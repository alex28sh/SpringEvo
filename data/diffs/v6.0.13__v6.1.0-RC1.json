{
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MethodInterceptor} implementation that allows for highly customizable\n * method-level tracing, using placeholders.\n *\n * <p>Trace messages are written on method entry, and if the method invocation succeeds\n * on method exit. If an invocation results in an exception, then an exception message\n * is written. The contents of these trace messages is fully customizable and special\n * placeholders are available to allow you to include runtime information in your log\n * messages. The placeholders available are:\n *\n * <p><ul>\n * <li>{@code $[methodName]} - replaced with the name of the method being invoked</li>\n * <li>{@code $[targetClassName]} - replaced with the name of the class that is\n * the target of the invocation</li>\n * <li>{@code $[targetClassShortName]} - replaced with the short name of the class\n * that is the target of the invocation</li>\n * <li>{@code $[returnValue]} - replaced with the value returned by the invocation</li>\n * <li>{@code $[argumentTypes]} - replaced with a comma-separated list of the\n * short class names of the method arguments</li>\n * <li>{@code $[arguments]} - replaced with a comma-separated list of the\n * {@code String} representation of the method arguments</li>\n * <li>{@code $[exception]} - replaced with the {@code String} representation\n * of any {@code Throwable} raised during the invocation</li>\n * <li>{@code $[invocationTime]} - replaced with the time, in milliseconds,\n * taken by the method invocation</li>\n * </ul>\n *\n * <p>There are restrictions on which placeholders can be used in which messages:\n * see the individual message properties for details on the valid placeholders.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.2\n * @see #setEnterMessage\n * @see #setExitMessage\n * @see #setExceptionMessage\n * @see SimpleTraceInterceptor\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "signature": "public class CustomizableTraceInterceptor",
    "source_code": "public class CustomizableTraceInterceptor extends AbstractTraceInterceptor {\n\n\t/**\n\t * The {@code $[methodName]} placeholder.\n\t * Replaced with the name of the method being invoked.\n\t */\n\tpublic static final String PLACEHOLDER_METHOD_NAME = \"$[methodName]\";\n\n\t/**\n\t * The {@code $[targetClassName]} placeholder.\n\t * Replaced with the fully-qualified name of the {@code Class}\n\t * of the method invocation target.\n\t */\n\tpublic static final String PLACEHOLDER_TARGET_CLASS_NAME = \"$[targetClassName]\";\n\n\t/**\n\t * The {@code $[targetClassShortName]} placeholder.\n\t * Replaced with the short name of the {@code Class} of the\n\t * method invocation target.\n\t */\n\tpublic static final String PLACEHOLDER_TARGET_CLASS_SHORT_NAME = \"$[targetClassShortName]\";\n\n\t/**\n\t * The {@code $[returnValue]} placeholder.\n\t * Replaced with the {@code String} representation of the value\n\t * returned by the method invocation.\n\t */\n\tpublic static final String PLACEHOLDER_RETURN_VALUE = \"$[returnValue]\";\n\n\t/**\n\t * The {@code $[argumentTypes]} placeholder.\n\t * Replaced with a comma-separated list of the argument types for the\n\t * method invocation. Argument types are written as short class names.\n\t */\n\tpublic static final String PLACEHOLDER_ARGUMENT_TYPES = \"$[argumentTypes]\";\n\n\t/**\n\t * The {@code $[arguments]} placeholder.\n\t * Replaced with a comma separated list of the argument values for the\n\t * method invocation. Relies on the {@code toString()} method of\n\t * each argument type.\n\t */\n\tpublic static final String PLACEHOLDER_ARGUMENTS = \"$[arguments]\";\n\n\t/**\n\t * The {@code $[exception]} placeholder.\n\t * Replaced with the {@code String} representation of any\n\t * {@code Throwable} raised during method invocation.\n\t */\n\tpublic static final String PLACEHOLDER_EXCEPTION = \"$[exception]\";\n\n\t/**\n\t * The {@code $[invocationTime]} placeholder.\n\t * Replaced with the time taken by the invocation (in milliseconds).\n\t */\n\tpublic static final String PLACEHOLDER_INVOCATION_TIME = \"$[invocationTime]\";\n\n\t/**\n\t * The default message used for writing method entry messages.\n\t */\n\tprivate static final String DEFAULT_ENTER_MESSAGE = \"Entering method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The default message used for writing method exit messages.\n\t */\n\tprivate static final String DEFAULT_EXIT_MESSAGE = \"Exiting method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The default message used for writing exception messages.\n\t */\n\tprivate static final String DEFAULT_EXCEPTION_MESSAGE = \"Exception thrown in method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The {@code Pattern} used to match placeholders.\n\t */\n\tprivate static final Pattern PATTERN = Pattern.compile(\"\\\\$\\\\[\\\\p{Alpha}+]\");\n\n\t/**\n\t * The {@code Set} of allowed placeholders.\n\t */\n\tstatic final Set<String> ALLOWED_PLACEHOLDERS = Set.of(\n\t\t\tPLACEHOLDER_METHOD_NAME,\n\t\t\tPLACEHOLDER_TARGET_CLASS_NAME,\n\t\t\tPLACEHOLDER_TARGET_CLASS_SHORT_NAME,\n\t\t\tPLACEHOLDER_RETURN_VALUE,\n\t\t\tPLACEHOLDER_ARGUMENT_TYPES,\n\t\t\tPLACEHOLDER_ARGUMENTS,\n\t\t\tPLACEHOLDER_EXCEPTION,\n\t\t\tPLACEHOLDER_INVOCATION_TIME);\n\n\n\t/**\n\t * The message for method entry.\n\t */\n\tprivate String enterMessage = DEFAULT_ENTER_MESSAGE;\n\n\t/**\n\t * The message for method exit.\n\t */\n\tprivate String exitMessage = DEFAULT_EXIT_MESSAGE;\n\n\t/**\n\t * The message for exceptions during method execution.\n\t */\n\tprivate String exceptionMessage = DEFAULT_EXCEPTION_MESSAGE;\n\n\n\t/**\n\t * Set the template used for method entry log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * </ul>\n\t */\n\tpublic void setEnterMessage(String enterMessage) throws IllegalArgumentException {\n\t\tAssert.hasText(enterMessage, \"enterMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(enterMessage);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_EXCEPTION);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_INVOCATION_TIME);\n\t\tthis.enterMessage = enterMessage;\n\t}\n\n\t/**\n\t * Set the template used for method exit log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[returnValue]}</li>\n\t * <li>{@code $[invocationTime]}</li>\n\t * </ul>\n\t */\n\tpublic void setExitMessage(String exitMessage) {\n\t\tAssert.hasText(exitMessage, \"exitMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exitMessage);\n\t\tAssert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"exitMessage cannot contain placeholder\" + PLACEHOLDER_EXCEPTION);\n\t\tthis.exitMessage = exitMessage;\n\t}\n\n\t/**\n\t * Set the template used for method exception log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[exception]}</li>\n\t * </ul>\n\t */\n\tpublic void setExceptionMessage(String exceptionMessage) {\n\t\tAssert.hasText(exceptionMessage, \"exceptionMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exceptionMessage);\n\t\tAssert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"exceptionMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tthis.exceptionMessage = exceptionMessage;\n\t}\n\n\n\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */\n\t@Override\n\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */\n\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {\n\n\t\tObject target = methodInvocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\tStringBuilder output = new StringBuilder();\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tswitch (match) {\n\t\t\t\tcase PLACEHOLDER_METHOD_NAME -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(methodInvocation.getMethod().getName()));\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_NAME -> {\n\t\t\t\t\tString className = getClassForLogging(target).getName();\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(className));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_SHORT_NAME -> {\n\t\t\t\t\tString shortName = ClassUtils.getShortName(getClassForLogging(target));\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(shortName));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_ARGUMENTS -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())));\n\t\t\t\tcase PLACEHOLDER_ARGUMENT_TYPES -> appendArgumentTypes(methodInvocation, matcher, output);\n\t\t\t\tcase PLACEHOLDER_RETURN_VALUE -> appendReturnValue(methodInvocation, matcher, output, returnValue);\n\t\t\t\tcase PLACEHOLDER_EXCEPTION -> {\n\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_INVOCATION_TIME -> matcher.appendReplacement(output, Long.toString(invocationTime));\n\t\t\t\tdefault -> {\n\t\t\t\t\t// Should not happen since placeholders are checked earlier.\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown placeholder [\" + match + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatcher.appendTail(output);\n\n\t\treturn output.toString();\n\t}\n\n\t/**\n\t * Adds the {@code String} representation of the method return value\n\t * to the supplied {@code StringBuilder}. Correctly handles\n\t * {@code null} and {@code void} results.\n\t * @param methodInvocation the {@code MethodInvocation} that returned the value\n\t * @param matcher the {@code Matcher} containing the matched placeholder\n\t * @param output the {@code StringBuilder} to write output to\n\t * @param returnValue the value returned by the method invocation.\n\t */\n\tprivate static void appendReturnValue(\n\t\t\tMethodInvocation methodInvocation, Matcher matcher, StringBuilder output, @Nullable Object returnValue) {\n\n\t\tif (methodInvocation.getMethod().getReturnType() == void.class) {\n\t\t\tmatcher.appendReplacement(output, \"void\");\n\t\t}\n\t\telse if (returnValue == null) {\n\t\t\tmatcher.appendReplacement(output, \"null\");\n\t\t}\n\t\telse {\n\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()));\n\t\t}\n\t}\n\n\t/**\n\t * Adds a comma-separated list of the short {@code Class} names of the\n\t * method argument types to the output. For example, if a method has signature\n\t * {@code put(java.lang.String, java.lang.Object)} then the value returned\n\t * will be {@code String, Object}.\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Arguments will be retrieved from the corresponding {@code Method}.\n\t * @param matcher the {@code Matcher} containing the state of the output\n\t * @param output the {@code StringBuilder} containing the output\n\t */\n\tprivate static void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuilder output) {\n\t\tClass<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes();\n\t\tString[] argumentTypeShortNames = new String[argumentTypes.length];\n\t\tfor (int i = 0; i < argumentTypeShortNames.length; i++) {\n\t\t\targumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i]);\n\t\t}\n\t\tmatcher.appendReplacement(output,\n\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)));\n\t}\n\n\t/**\n\t * Checks to see if the supplied {@code String} has any placeholders\n\t * that are not specified as constants on this class and throws an\n\t * {@code IllegalArgumentException} if so.\n\t */\n\tprivate static void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tif (!ALLOWED_PLACEHOLDERS.contains(match)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Placeholder [\" + match + \"] is not valid\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#invokeUnderTrace(invocation,logger)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "logger"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Object",
    "signature": "protected Object invokeUnderTrace(MethodInvocation invocation, Log logger)",
    "source_code": "\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#replacePlaceholders(message,methodInvocation,returnValue,throwable,invocationTime)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "methodInvocation",
      "returnValue",
      "throwable",
      "invocationTime"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "protected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime)",
    "source_code": "\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setEnterMessage(enterMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the template used for method entry log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enterMessage"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setEnterMessage(String enterMessage)",
    "source_code": "\tpublic void setEnterMessage(String enterMessage) throws IllegalArgumentException {\n\t\tAssert.hasText(enterMessage, \"enterMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(enterMessage);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_EXCEPTION);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_INVOCATION_TIME);\n\t\tthis.enterMessage = enterMessage;\n\t}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setExceptionMessage(exceptionMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the template used for method exception log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[exception]}</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionMessage"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void setExceptionMessage(String exceptionMessage)",
    "source_code": "\tpublic void setExceptionMessage(String exceptionMessage) {\n\t\tAssert.hasText(exceptionMessage, \"exceptionMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exceptionMessage);\n\t\tAssert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"exceptionMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tthis.exceptionMessage = exceptionMessage;\n\t}"
  },
  "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setExitMessage(exitMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the template used for method exit log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[returnValue]}</li>\n\t * <li>{@code $[invocationTime]}</li>\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exitMessage"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setExitMessage(String exitMessage)",
    "source_code": "\tpublic void setExitMessage(String exitMessage) {\n\t\tAssert.hasText(exitMessage, \"exitMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exitMessage);\n\t\tAssert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"exitMessage cannot contain placeholder\" + PLACEHOLDER_EXCEPTION);\n\t\tthis.exitMessage = exitMessage;\n\t}"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_ARGUMENTS": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[arguments]} placeholder.\n\t * Replaced with a comma separated list of the argument values for the\n\t * method invocation. Relies on the {@code toString()} method of\n\t * each argument type.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "signature": "public String PLACEHOLDER_ARGUMENTS",
    "source_code": "\tpublic static final String PLACEHOLDER_ARGUMENTS = \"$[arguments]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_ARGUMENT_TYPES": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[argumentTypes]} placeholder.\n\t * Replaced with a comma-separated list of the argument types for the\n\t * method invocation. Argument types are written as short class names.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "signature": "public String PLACEHOLDER_ARGUMENT_TYPES",
    "source_code": "\tpublic static final String PLACEHOLDER_ARGUMENT_TYPES = \"$[argumentTypes]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_EXCEPTION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[exception]} placeholder.\n\t * Replaced with the {@code String} representation of any\n\t * {@code Throwable} raised during method invocation.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "signature": "public String PLACEHOLDER_EXCEPTION",
    "source_code": "\tpublic static final String PLACEHOLDER_EXCEPTION = \"$[exception]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_INVOCATION_TIME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[invocationTime]} placeholder.\n\t * Replaced with the time taken by the invocation (in milliseconds).\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "signature": "public String PLACEHOLDER_INVOCATION_TIME",
    "source_code": "\tpublic static final String PLACEHOLDER_INVOCATION_TIME = \"$[invocationTime]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_METHOD_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[methodName]} placeholder.\n\t * Replaced with the name of the method being invoked.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String PLACEHOLDER_METHOD_NAME",
    "source_code": "\tpublic static final String PLACEHOLDER_METHOD_NAME = \"$[methodName]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_RETURN_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[returnValue]} placeholder.\n\t * Replaced with the {@code String} representation of the value\n\t * returned by the method invocation.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "signature": "public String PLACEHOLDER_RETURN_VALUE",
    "source_code": "\tpublic static final String PLACEHOLDER_RETURN_VALUE = \"$[returnValue]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_TARGET_CLASS_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[targetClassName]} placeholder.\n\t * Replaced with the fully-qualified name of the {@code Class}\n\t * of the method invocation target.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "signature": "public String PLACEHOLDER_TARGET_CLASS_NAME",
    "source_code": "\tpublic static final String PLACEHOLDER_TARGET_CLASS_NAME = \"$[targetClassName]\";",
    "type": "String"
  },
  "org.springframework.aop.interceptor.PLACEHOLDER_TARGET_CLASS_SHORT_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The {@code $[targetClassShortName]} placeholder.\n\t * Replaced with the short name of the {@code Class} of the\n\t * method invocation target.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "signature": "public String PLACEHOLDER_TARGET_CLASS_SHORT_NAME",
    "source_code": "\tpublic static final String PLACEHOLDER_TARGET_CLASS_SHORT_NAME = \"$[targetClassShortName]\";",
    "type": "String"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tExecutable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.aop.scope.<unknown>#getTarget(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean)",
    "source_code": "\t\tpublic ClassName getTarget(RegisteredBean registeredBean) {\n\t\t\treturn ClassName.get(this.targetBeanDefinition.getResolvableType().toClass());\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\t\tpublic ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\t\treturn ClassName.get(this.targetBeanDefinition.getResolvableType().toClass());\n\t\t}"
  },
  "org.springframework.aop.support.ClassFilters#negate(classFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a class filter that represents the logical negation of the specified\n\t * filter instance.\n\t * @param classFilter the {@link ClassFilter} to negate\n\t * @return a filter that represents the logical negation of the specified filter\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classFilter"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter negate(ClassFilter classFilter)",
    "source_code": "\tpublic static ClassFilter negate(ClassFilter classFilter) {\n\t\tAssert.notNull(classFilter, \"ClassFilter must not be null\");\n\t\treturn new NegateClassFilter(classFilter);\n\t}"
  },
  "org.springframework.aop.support.MethodMatchers#negate(methodMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a method matcher that represents the logical negation of the specified\n\t * matcher instance.\n\t * @param methodMatcher the {@link MethodMatcher} to negate\n\t * @return a matcher that represents the logical negation of the specified matcher\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodMatcher"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher negate(MethodMatcher methodMatcher)",
    "source_code": "\tpublic static MethodMatcher negate(MethodMatcher methodMatcher) {\n\t\tAssert.notNull(methodMatcher, \"MethodMatcher must not be null\");\n\t\treturn new NegateMethodMatcher(methodMatcher);\n\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getCollectionType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1052
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getCollectionType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asCollection().resolveGeneric());\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getMapKeyType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1044
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapKeyType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapKeyType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(0));\n\t\t}"
  },
  "org.springframework.beans.AbstractNestablePropertyAccessor#getMapValueType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1048
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapValueType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(1));\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getCollectionType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getCollectionType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getCollectionType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asCollection().getGeneric(),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}"
  },
  "org.springframework.beans.BeanWrapperImpl#getMapValueType(nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getMapValueType(int nestingLevel)",
    "source_code": "\t\tpublic TypeDescriptor getMapValueType(int nestingLevel) {\n\t\t\treturn new TypeDescriptor(\n\t\t\t\t\tthis.typeDescriptor.getResolvableType().getNested(nestingLevel).asMap().getGeneric(1),\n\t\t\t\t\tnull, this.typeDescriptor.getAnnotations());\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.beans.factory.aot.<unknown>#getTarget(registeredBean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean)",
    "source_code": "\tpublic ClassName getTarget(RegisteredBean registeredBean) {\n\t\tif (hasInstanceSupplier()) {\n\t\t\tthrow new IllegalStateException(\"Default code generation is not supported for bean definitions \"\n\t\t\t\t\t+ \"declaring an instance supplier callback: \" + registeredBean.getMergedBeanDefinition());\n\t\t}\n\t\tClass<?> target = extractDeclaringClass(registeredBean.getBeanType(), this.constructorOrFactoryMethod.get());\n\t\twhile (target.getName().startsWith(\"java.\") && registeredBean.isInnerBean()) {\n\t\t\tRegisteredBean parent = registeredBean.getParent();\n\t\t\tAssert.state(parent != null, \"No parent available for inner bean\");\n\t\t\ttarget = parent.getBeanClass();\n\t\t}\n\t\treturn ClassName.get(target);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean,\n\t\t\tExecutable constructorOrFactoryMethod)",
    "source_code": "\tpublic ClassName getTarget(RegisteredBean registeredBean,"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default code generator to create an {@link InstanceSupplier}, usually in\n * the form of a {@link BeanInstanceSupplier} that retains the executable\n * that is used to instantiate the bean. Takes care of registering the\n * necessary hints if reflection or a JDK proxy is required.\n *\n * <p>Generated code is usually a method reference that generates the\n * {@link BeanInstanceSupplier}, but some shortcut can be used as well such as:\n * <pre class=\"code\">\n * {@code InstanceSupplier.of(TheGeneratedClass::getMyBeanInstance);}\n * </pre>\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.0\n * @see BeanRegistrationCodeFragments\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "signature": "public class InstanceSupplierCodeGenerator",
    "source_code": "public class InstanceSupplierCodeGenerator {\n\n\tprivate static final String REGISTERED_BEAN_PARAMETER_NAME = \"registeredBean\";\n\n\tprivate static final String ARGS_PARAMETER_NAME = \"args\";\n\n\tprivate static final javax.lang.model.element.Modifier[] PRIVATE_STATIC = {\n\t\t\tjavax.lang.model.element.Modifier.PRIVATE,\n\t\t\tjavax.lang.model.element.Modifier.STATIC };\n\n\tprivate static final CodeBlock NO_ARGS = CodeBlock.of(\"\");\n\n\n\tprivate final GenerationContext generationContext;\n\n\tprivate final ClassName className;\n\n\tprivate final GeneratedMethods generatedMethods;\n\n\tprivate final boolean allowDirectSupplierShortcut;\n\n\n\t/**\n\t * Create a new instance.\n\t * @param generationContext the generation context\n\t * @param className the class name of the bean to instantiate\n\t * @param generatedMethods the generated methods\n\t * @param allowDirectSupplierShortcut whether a direct supplier may be used rather\n\t * than always needing an {@link InstanceSupplier}\n\t */\n\tpublic InstanceSupplierCodeGenerator(GenerationContext generationContext,\n\t\t\tClassName className, GeneratedMethods generatedMethods, boolean allowDirectSupplierShortcut) {\n\n\t\tthis.generationContext = generationContext;\n\t\tthis.className = className;\n\t\tthis.generatedMethods = generatedMethods;\n\t\tthis.allowDirectSupplierShortcut = allowDirectSupplierShortcut;\n\t}\n\n\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param constructorOrFactoryMethod the executable to use to create the bean\n\t * @return the generated code\n\t */\n\tpublic CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tregisterRuntimeHintsIfNecessary(registeredBean, constructorOrFactoryMethod);\n\t\tif (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\treturn generateCodeForConstructor(registeredBean, constructor);\n\t\t}\n\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\treturn generateCodeForFactoryMethod(registeredBean, method);\n\t\t}\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"No suitable executor found for \" + registeredBean.getBeanName());\n\t}\n\n\tprivate void registerRuntimeHintsIfNecessary(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tif (registeredBean.getBeanFactory() instanceof DefaultListableBeanFactory dlbf) {\n\t\t\tRuntimeHints runtimeHints = this.generationContext.getRuntimeHints();\n\t\t\tProxyRuntimeHintsRegistrar registrar = new ProxyRuntimeHintsRegistrar(dlbf.getAutowireCandidateResolver());\n\t\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\t\tregistrar.registerRuntimeHints(runtimeHints, method);\n\t\t\t}\n\t\t\telse if (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\t\tregistrar.registerRuntimeHints(runtimeHints, constructor);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate CodeBlock generateCodeForConstructor(RegisteredBean registeredBean, Constructor<?> constructor) {\n\t\tString beanName = registeredBean.getBeanName();\n\t\tClass<?> beanClass = registeredBean.getBeanClass();\n\t\tClass<?> declaringClass = constructor.getDeclaringClass();\n\t\tboolean dependsOnBean = ClassUtils.isInnerClass(declaringClass);\n\n\t\tVisibility accessVisibility = getAccessVisibility(registeredBean, constructor);\n\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDelegate.hasConstructorWithOptionalParameter(beanClass)) {\n\t\t\treturn generateCodeForInaccessibleConstructor(beanName, beanClass, constructor,\n\t\t\t\t\tdependsOnBean, hints -> hints.registerType(beanClass, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));\n\t\t}\n\t\telse if (accessVisibility != Visibility.PRIVATE) {\n\t\t\treturn generateCodeForAccessibleConstructor(beanName, beanClass, constructor,\n\t\t\t\t\tdependsOnBean, declaringClass);\n\t\t}\n\t\treturn generateCodeForInaccessibleConstructor(beanName, beanClass, constructor, dependsOnBean,\n\t\t\t\thints -> hints.registerConstructor(constructor, ExecutableMode.INVOKE));\n\t}\n\n\tprivate CodeBlock generateCodeForAccessibleConstructor(String beanName, Class<?> beanClass,\n\t\t\tConstructor<?> constructor, boolean dependsOnBean, Class<?> declaringClass) {\n\n\t\tthis.generationContext.getRuntimeHints().reflection().registerConstructor(\n\t\t\t\tconstructor, ExecutableMode.INTROSPECT);\n\n\t\tif (!dependsOnBean && constructor.getParameterCount() == 0) {\n\t\t\tif (!this.allowDirectSupplierShortcut) {\n\t\t\t\treturn CodeBlock.of(\"$T.using($T::new)\", InstanceSupplier.class, declaringClass);\n\t\t\t}\n\t\t\tif (!isThrowingCheckedException(constructor)) {\n\t\t\t\treturn CodeBlock.of(\"$T::new\", declaringClass);\n\t\t\t}\n\t\t\treturn CodeBlock.of(\"$T.of($T::new)\", ThrowingSupplier.class, declaringClass);\n\t\t}\n\n\t\tGeneratedMethod generatedMethod = generateGetInstanceSupplierMethod(method ->\n\t\t\t\tbuildGetInstanceMethodForConstructor(method, beanName, beanClass, constructor,\n\t\t\t\t\t\tdeclaringClass, dependsOnBean, PRIVATE_STATIC));\n\t\treturn generateReturnStatement(generatedMethod);\n\t}\n\n\tprivate CodeBlock generateCodeForInaccessibleConstructor(String beanName, Class<?> beanClass,\n\t\t\tConstructor<?> constructor, boolean dependsOnBean, Consumer<ReflectionHints> hints) {\n\n\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\tcodeWarnings.detectDeprecation(beanClass, constructor)\n\t\t\t\t.detectDeprecation(Arrays.stream(constructor.getParameters()).map(Parameter::getType));\n\t\thints.accept(this.generationContext.getRuntimeHints().reflection());\n\n\t\tGeneratedMethod generatedMethod = generateGetInstanceSupplierMethod(method -> {\n\t\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\t\tmethod.addModifiers(PRIVATE_STATIC);\n\t\t\tcodeWarnings.suppress(method);\n\t\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, beanClass));\n\t\t\tint parameterOffset = (!dependsOnBean) ? 0 : 1;\n\t\t\tmethod.addStatement(generateResolverForConstructor(beanClass, constructor, parameterOffset));\n\t\t});\n\n\t\treturn generateReturnStatement(generatedMethod);\n\t}\n\n\tprivate void buildGetInstanceMethodForConstructor(MethodSpec.Builder method,\n\t\t\tString beanName, Class<?> beanClass, Constructor<?> constructor, Class<?> declaringClass,\n\t\t\tboolean dependsOnBean, javax.lang.model.element.Modifier... modifiers) {\n\n\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\tcodeWarnings.detectDeprecation(beanClass, constructor, declaringClass)\n\t\t\t\t.detectDeprecation(Arrays.stream(constructor.getParameters()).map(Parameter::getType));\n\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\tmethod.addModifiers(modifiers);\n\t\tcodeWarnings.suppress(method);\n\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, beanClass));\n\n\t\tint parameterOffset = (!dependsOnBean) ? 0 : 1;\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.add(generateResolverForConstructor(beanClass, constructor, parameterOffset));\n\t\tboolean hasArguments = constructor.getParameterCount() > 0;\n\n\t\tCodeBlock arguments = hasArguments ?\n\t\t\t\tnew AutowiredArgumentsCodeGenerator(declaringClass, constructor)\n\t\t\t\t\t\t.generateCode(constructor.getParameterTypes(), parameterOffset)\n\t\t\t\t: NO_ARGS;\n\n\t\tCodeBlock newInstance = generateNewInstanceCodeForConstructor(dependsOnBean, declaringClass, arguments);\n\t\tcode.add(generateWithGeneratorCode(hasArguments, newInstance));\n\t\tmethod.addStatement(code.build());\n\t}\n\n\tprivate CodeBlock generateResolverForConstructor(Class<?> beanClass,\n\t\t\tConstructor<?> constructor, int parameterOffset) {\n\n\t\tCodeBlock parameterTypes = generateParameterTypesCode(constructor.getParameterTypes(), parameterOffset);\n\t\treturn CodeBlock.of(\"return $T.<$T>forConstructor($L)\", BeanInstanceSupplier.class, beanClass, parameterTypes);\n\t}\n\n\tprivate CodeBlock generateNewInstanceCodeForConstructor(boolean dependsOnBean,\n\t\t\tClass<?> declaringClass, CodeBlock args) {\n\n\t\tif (!dependsOnBean) {\n\t\t\treturn CodeBlock.of(\"new $T($L)\", declaringClass, args);\n\t\t}\n\n\t\treturn CodeBlock.of(\"$L.getBeanFactory().getBean($T.class).new $L($L)\",\n\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME, declaringClass.getEnclosingClass(),\n\t\t\t\tdeclaringClass.getSimpleName(), args);\n\t}\n\n\tprivate CodeBlock generateCodeForFactoryMethod(RegisteredBean registeredBean, Method factoryMethod) {\n\t\tString beanName = registeredBean.getBeanName();\n\t\tClass<?> declaringClass = ClassUtils.getUserClass(factoryMethod.getDeclaringClass());\n\t\tboolean dependsOnBean = !Modifier.isStatic(factoryMethod.getModifiers());\n\n\t\tVisibility accessVisibility = getAccessVisibility(registeredBean, factoryMethod);\n\t\tif (accessVisibility != Visibility.PRIVATE) {\n\t\t\treturn generateCodeForAccessibleFactoryMethod(\n\t\t\t\t\tbeanName, factoryMethod, declaringClass, dependsOnBean);\n\t\t}\n\t\treturn generateCodeForInaccessibleFactoryMethod(beanName, factoryMethod, declaringClass);\n\t}\n\n\tprivate CodeBlock generateCodeForAccessibleFactoryMethod(String beanName,\n\t\t\tMethod factoryMethod, Class<?> declaringClass, boolean dependsOnBean) {\n\n\t\tthis.generationContext.getRuntimeHints().reflection().registerMethod(\n\t\t\t\tfactoryMethod, ExecutableMode.INTROSPECT);\n\n\t\tif (!dependsOnBean && factoryMethod.getParameterCount() == 0) {\n\t\t\tClass<?> suppliedType = ClassUtils.resolvePrimitiveIfNecessary(factoryMethod.getReturnType());\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.<$T>forFactoryMethod($T.class, $S)\", BeanInstanceSupplier.class,\n\t\t\t\t\tsuppliedType, declaringClass, factoryMethod.getName());\n\t\t\tcode.add(\".withGenerator(($L) -> $T.$L())\", REGISTERED_BEAN_PARAMETER_NAME,\n\t\t\t\t\tdeclaringClass, factoryMethod.getName());\n\t\t\treturn code.build();\n\t\t}\n\n\t\tGeneratedMethod getInstanceMethod = generateGetInstanceSupplierMethod(method ->\n\t\t\t\tbuildGetInstanceMethodForFactoryMethod(method, beanName, factoryMethod,\n\t\t\t\t\t\tdeclaringClass, dependsOnBean, PRIVATE_STATIC));\n\t\treturn generateReturnStatement(getInstanceMethod);\n\t}\n\n\tprivate CodeBlock generateCodeForInaccessibleFactoryMethod(\n\t\t\tString beanName, Method factoryMethod, Class<?> declaringClass) {\n\n\t\tthis.generationContext.getRuntimeHints().reflection().registerMethod(factoryMethod, ExecutableMode.INVOKE);\n\t\tGeneratedMethod getInstanceMethod = generateGetInstanceSupplierMethod(method -> {\n\t\t\tClass<?> suppliedType = ClassUtils.resolvePrimitiveIfNecessary(factoryMethod.getReturnType());\n\t\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\t\tmethod.addModifiers(PRIVATE_STATIC);\n\t\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, suppliedType));\n\t\t\tmethod.addStatement(generateInstanceSupplierForFactoryMethod(\n\t\t\t\t\tfactoryMethod, suppliedType, declaringClass, factoryMethod.getName()));\n\t\t});\n\t\treturn generateReturnStatement(getInstanceMethod);\n\t}\n\n\tprivate void buildGetInstanceMethodForFactoryMethod(MethodSpec.Builder method,\n\t\t\tString beanName, Method factoryMethod, Class<?> declaringClass,\n\t\t\tboolean dependsOnBean, javax.lang.model.element.Modifier... modifiers) {\n\n\t\tString factoryMethodName = factoryMethod.getName();\n\t\tClass<?> suppliedType = ClassUtils.resolvePrimitiveIfNecessary(factoryMethod.getReturnType());\n\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\tcodeWarnings.detectDeprecation(declaringClass, factoryMethod, suppliedType)\n\t\t\t\t.detectDeprecation(Arrays.stream(factoryMethod.getParameters()).map(Parameter::getType));\n\n\t\tmethod.addJavadoc(\"Get the bean instance supplier for '$L'.\", beanName);\n\t\tmethod.addModifiers(modifiers);\n\t\tcodeWarnings.suppress(method);\n\t\tmethod.returns(ParameterizedTypeName.get(BeanInstanceSupplier.class, suppliedType));\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.add(generateInstanceSupplierForFactoryMethod(\n\t\t\t\tfactoryMethod, suppliedType, declaringClass, factoryMethodName));\n\n\t\tboolean hasArguments = factoryMethod.getParameterCount() > 0;\n\t\tCodeBlock arguments = hasArguments ?\n\t\t\t\tnew AutowiredArgumentsCodeGenerator(declaringClass, factoryMethod)\n\t\t\t\t\t\t.generateCode(factoryMethod.getParameterTypes())\n\t\t\t\t: NO_ARGS;\n\n\t\tCodeBlock newInstance = generateNewInstanceCodeForMethod(\n\t\t\t\tdependsOnBean, declaringClass, factoryMethodName, arguments);\n\t\tcode.add(generateWithGeneratorCode(hasArguments, newInstance));\n\t\tmethod.addStatement(code.build());\n\t}\n\n\tprivate CodeBlock generateInstanceSupplierForFactoryMethod(Method factoryMethod,\n\t\t\tClass<?> suppliedType, Class<?> declaringClass, String factoryMethodName) {\n\n\t\tif (factoryMethod.getParameterCount() == 0) {\n\t\t\treturn CodeBlock.of(\"return $T.<$T>forFactoryMethod($T.class, $S)\",\n\t\t\t\t\tBeanInstanceSupplier.class, suppliedType, declaringClass, factoryMethodName);\n\t\t}\n\n\t\tCodeBlock parameterTypes = generateParameterTypesCode(factoryMethod.getParameterTypes(), 0);\n\t\treturn CodeBlock.of(\"return $T.<$T>forFactoryMethod($T.class, $S, $L)\",\n\t\t\t\tBeanInstanceSupplier.class, suppliedType, declaringClass, factoryMethodName, parameterTypes);\n\t}\n\n\tprivate CodeBlock generateNewInstanceCodeForMethod(boolean dependsOnBean,\n\t\t\tClass<?> declaringClass, String factoryMethodName, CodeBlock args) {\n\n\t\tif (!dependsOnBean) {\n\t\t\treturn CodeBlock.of(\"$T.$L($L)\", declaringClass, factoryMethodName, args);\n\t\t}\n\t\treturn CodeBlock.of(\"$L.getBeanFactory().getBean($T.class).$L($L)\",\n\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME, declaringClass, factoryMethodName, args);\n\t}\n\n\tprivate CodeBlock generateReturnStatement(GeneratedMethod generatedMethod) {\n\t\treturn generatedMethod.toMethodReference().toInvokeCodeBlock(\n\t\t\t\tArgumentCodeGenerator.none(), this.className);\n\t}\n\n\tprivate CodeBlock generateWithGeneratorCode(boolean hasArguments, CodeBlock newInstance) {\n\t\tCodeBlock lambdaArguments = (hasArguments ?\n\t\t\t\tCodeBlock.of(\"($L, $L)\", REGISTERED_BEAN_PARAMETER_NAME, ARGS_PARAMETER_NAME) :\n\t\t\t\tCodeBlock.of(\"($L)\", REGISTERED_BEAN_PARAMETER_NAME));\n\t\tBuilder code = CodeBlock.builder();\n\t\tcode.add(\"\\n\");\n\t\tcode.indent().indent();\n\t\tcode.add(\".withGenerator($L -> $L)\", lambdaArguments, newInstance);\n\t\tcode.unindent().unindent();\n\t\treturn code.build();\n\t}\n\n\tprivate Visibility getAccessVisibility(RegisteredBean registeredBean, Member member) {\n\t\tAccessControl beanTypeAccessControl = AccessControl.forResolvableType(registeredBean.getBeanType());\n\t\tAccessControl memberAccessControl = AccessControl.forMember(member);\n\t\treturn AccessControl.lowest(beanTypeAccessControl, memberAccessControl).getVisibility();\n\t}\n\n\tprivate CodeBlock generateParameterTypesCode(Class<?>[] parameterTypes, int offset) {\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tfor (int i = offset; i < parameterTypes.length; i++) {\n\t\t\tcode.add(i != offset ? \", \" : \"\");\n\t\t\tcode.add(\"$T.class\", parameterTypes[i]);\n\t\t}\n\t\treturn code.build();\n\t}\n\n\tprivate GeneratedMethod generateGetInstanceSupplierMethod(Consumer<MethodSpec.Builder> method) {\n\t\treturn this.generatedMethods.add(\"getInstanceSupplier\", method);\n\t}\n\n\tprivate boolean isThrowingCheckedException(Executable executable) {\n\t\treturn Arrays.stream(executable.getGenericExceptionTypes())\n\t\t\t\t.map(ResolvableType::forType).map(ResolvableType::toClass)\n\t\t\t\t.anyMatch(Exception.class::isAssignableFrom);\n\t}\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tpublic static boolean hasConstructorWithOptionalParameter(Class<?> beanClass) {\n\t\t\tif (KotlinDetector.isKotlinType(beanClass)) {\n\t\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(beanClass);\n\t\t\t\tfor (KFunction<?> constructor : kClass.getConstructors()) {\n\t\t\t\t\tfor (KParameter parameter : constructor.getParameters()) {\n\t\t\t\t\t\tif (parameter.isOptional()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\n\tprivate static class ProxyRuntimeHintsRegistrar {\n\n\t\tprivate final AutowireCandidateResolver candidateResolver;\n\n\t\tpublic ProxyRuntimeHintsRegistrar(AutowireCandidateResolver candidateResolver) {\n\t\t\tthis.candidateResolver = candidateResolver;\n\t\t}\n\n\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}\n\n\t\tprivate void registerProxyIfNecessary(RuntimeHints runtimeHints, DependencyDescriptor dependencyDescriptor) {\n\t\t\tClass<?> proxyType = this.candidateResolver.getLazyResolutionProxyClass(dependencyDescriptor, null);\n\t\t\tif (proxyType != null && Proxy.isProxyClass(proxyType)) {\n\t\t\t\truntimeHints.proxies().registerJdkProxy(proxyType.getInterfaces());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#generateCode(registeredBean,constructorOrFactoryMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param constructorOrFactoryMethod the executable to use to create the bean\n\t * @return the generated code\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\tpublic CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tregisterRuntimeHintsIfNecessary(registeredBean, constructorOrFactoryMethod);\n\t\tif (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\treturn generateCodeForConstructor(registeredBean, constructor);\n\t\t}\n\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\treturn generateCodeForFactoryMethod(registeredBean, method);\n\t\t}\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"No suitable executor found for \" + registeredBean.getBeanName());\n\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#hasConstructorWithOptionalParameter(beanClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "boolean",
    "signature": "public boolean hasConstructorWithOptionalParameter(Class<?> beanClass)",
    "source_code": "\t\tpublic static boolean hasConstructorWithOptionalParameter(Class<?> beanClass) {\n\t\t\tif (KotlinDetector.isKotlinType(beanClass)) {\n\t\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(beanClass);\n\t\t\t\tfor (KFunction<?> constructor : kClass.getConstructors()) {\n\t\t\t\t\tfor (KParameter parameter : constructor.getParameters()) {\n\t\t\t\t\t\tif (parameter.isOptional()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.InstanceSupplierCodeGenerator#registerRuntimeHints(runtimeHints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.YamlProcessor#isGlobalTagAllowed(tag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "boolean",
    "signature": "public boolean isGlobalTagAllowed(Tag tag)",
    "source_code": "\t\tpublic boolean isGlobalTagAllowed(Tag tag) {\n\t\t\treturn supportedTypes.contains(tag.getClassName());\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#await(destroyMethod,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "boolean",
    "signature": "public boolean await(Method destroyMethod, Object returnValue)",
    "source_code": "\t\tpublic boolean await(Method destroyMethod, Object returnValue) throws InterruptedException {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnValue.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\t\tadapter.toPublisher(returnValue).subscribe(new DestroyMethodSubscriber(destroyMethod, latch));\n\t\t\t\tlatch.await();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodCompletion(this.destroyMethod, true);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.latch.countDown();\n\t\t\tlogDestroyMethodException(this.destroyMethod, t);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.beans.factory.support.DefaultListableBeanFactory#isBeanDefinitionOverridable(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code true} if bean definition overriding\n\t * is generally allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "boolean",
    "signature": "public boolean isBeanDefinitionOverridable(String beanName)",
    "source_code": "\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}"
  },
  "org.springframework.beans.factory.support.PREFERRED_CONSTRUCTORS_ATTRIBUTE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of an attribute that can be\n\t * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a\n\t * {@link org.springframework.beans.factory.config.BeanDefinition} so that\n\t * bean definitions can indicate one or more preferred constructors. This is\n\t * analogous to {@code @Autowired} annotated constructors on the bean class.\n\t * <p>The attribute value may be a single {@link java.lang.reflect.Constructor}\n\t * reference or an array thereof.\n\t * @since 6.1\n\t * @see org.springframework.beans.factory.annotation.Autowired\n\t * @see org.springframework.beans.factory.support.RootBeanDefinition#getPreferredConstructors()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "signature": "public String PREFERRED_CONSTRUCTORS_ATTRIBUTE",
    "source_code": "\tpublic static final String PREFERRED_CONSTRUCTORS_ATTRIBUTE = \"preferredConstructors\";",
    "type": "String"
  },
  "org.springframework.cache.caffeine.CaffeineCache#getAsyncCache()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the internal Caffeine AsyncCache.\n\t * @throws IllegalStateException if no AsyncCache is available\n\t * @since 6.1\n\t * @see #CaffeineCache(String, AsyncCache, boolean)\n\t * @see CaffeineCacheManager#setAsyncCacheMode\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object>",
    "signature": "public Object> getAsyncCache()",
    "source_code": "\tpublic final AsyncCache<Object, Object> getAsyncCache() {\n\t\tAssert.state(this.asyncCache != null,\n\t\t\t\t\"No Caffeine AsyncCache available: set CaffeineCacheManager.setAsyncCacheMode(true)\");\n\t\treturn this.asyncCache;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCache#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn (CompletableFuture<T>) getAsyncCache().get(key, (k, e) -> valueLoader.get());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link CacheManager} implementation that lazily builds {@link CaffeineCache}\n * instances for each {@link #getCache} request. Also supports a 'static' mode\n * where the set of cache names is pre-defined through {@link #setCacheNames},\n * with no dynamic creation of further cache regions at runtime.\n *\n * <p>The configuration of the underlying cache can be fine-tuned through a\n * {@link Caffeine} builder or {@link CaffeineSpec}, passed into this\n * CacheManager through {@link #setCaffeine}/{@link #setCaffeineSpec}.\n * A {@link CaffeineSpec}-compliant expression value can also be applied\n * via the {@link #setCacheSpecification \"cacheSpecification\"} bean property.\n *\n * <p>Supports the {@link Cache#retrieve(Object)} and\n * {@link Cache#retrieve(Object, Supplier)} operations through Caffeine's\n * {@link AsyncCache}, when configured via {@link #setAsyncCacheMode}.\n *\n * <p>Requires Caffeine 3.0 or higher, as of Spring Framework 6.1.\n *\n * @author Ben Manes\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 4.3\n * @see CaffeineCache\n * @see #setCaffeineSpec\n * @see #setCacheSpecification\n * @see #setAsyncCacheMode\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "signature": "public class CaffeineCacheManager",
    "source_code": "public class CaffeineCacheManager implements CacheManager {\n\n\tprivate Caffeine<Object, Object> cacheBuilder = Caffeine.newBuilder();\n\n\t@Nullable\n\tprivate AsyncCacheLoader<Object, Object> cacheLoader;\n\n\tprivate boolean asyncCacheMode = false;\n\n\tprivate boolean allowNullValues = true;\n\n\tprivate boolean dynamic = true;\n\n\tprivate final Map<String, Cache> cacheMap = new ConcurrentHashMap<>(16);\n\n\tprivate final Collection<String> customCacheNames = new CopyOnWriteArrayList<>();\n\n\n\t/**\n\t * Construct a dynamic CaffeineCacheManager,\n\t * lazily creating cache instances as they are being requested.\n\t */\n\tpublic CaffeineCacheManager() {\n\t}\n\n\t/**\n\t * Construct a static CaffeineCacheManager,\n\t * managing caches for the specified cache names only.\n\t */\n\tpublic CaffeineCacheManager(String... cacheNames) {\n\t\tsetCacheNames(Arrays.asList(cacheNames));\n\t}\n\n\n\t/**\n\t * Specify the set of cache names for this CacheManager's 'static' mode.\n\t * <p>The number of caches and their names will be fixed after a call to this method,\n\t * with no creation of further cache regions at runtime.\n\t * <p>Calling this with a {@code null} collection argument resets the\n\t * mode to 'dynamic', allowing for further creation of caches again.\n\t */\n\tpublic void setCacheNames(@Nullable Collection<String> cacheNames) {\n\t\tif (cacheNames != null) {\n\t\t\tfor (String name : cacheNames) {\n\t\t\t\tthis.cacheMap.put(name, createCaffeineCache(name));\n\t\t\t}\n\t\t\tthis.dynamic = false;\n\t\t}\n\t\telse {\n\t\t\tthis.dynamic = true;\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */\n\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}\n\n\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */\n\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}\n\n\t/**\n\t * Set the Caffeine cache specification String to use for building each\n\t * individual {@link CaffeineCache} instance. The given value needs to\n\t * comply with Caffeine's {@link CaffeineSpec} (see its javadoc).\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(String)\n\t */\n\tpublic void setCacheSpecification(String cacheSpecification) {\n\t\tdoSetCaffeine(Caffeine.from(cacheSpecification));\n\t}\n\n\tprivate void doSetCaffeine(Caffeine<Object, Object> cacheBuilder) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheBuilder, cacheBuilder)) {\n\t\t\tthis.cacheBuilder = cacheBuilder;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */\n\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */\n\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Set the common cache type that this cache manager builds to async.\n\t * This applies to {@link #setCacheNames} as well as on-demand caches.\n\t * <p>Individual cache registrations (such as {@link #registerCustomCache(String, AsyncCache)}\n\t * and {@link #registerCustomCache(String, com.github.benmanes.caffeine.cache.Cache)}\n\t * are not dependent on this setting.\n\t * <p>By default, this cache manager builds regular native Caffeine caches.\n\t * To switch to async caches which can also be used through the synchronous API\n\t * but come with support for {@code Cache#retrieve}, set this flag to {@code true}.\n\t * @since 6.1\n\t * @see Caffeine#buildAsync()\n\t * @see Cache#retrieve(Object)\n\t * @see Cache#retrieve(Object, Supplier)\n\t */\n\tpublic void setAsyncCacheMode(boolean asyncCacheMode) {\n\t\tif (this.asyncCacheMode != asyncCacheMode) {\n\t\t\tthis.asyncCacheMode = asyncCacheMode;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Specify whether to accept and convert {@code null} values for all caches\n\t * in this cache manager.\n\t * <p>Default is \"true\", despite Caffeine itself not supporting {@code null} values.\n\t * An internal holder object will be used to store user-level {@code null}s.\n\t */\n\tpublic void setAllowNullValues(boolean allowNullValues) {\n\t\tif (this.allowNullValues != allowNullValues) {\n\t\t\tthis.allowNullValues = allowNullValues;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}\n\n\t/**\n\t * Return whether this cache manager accepts and converts {@code null} values\n\t * for all of its caches.\n\t */\n\tpublic boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}\n\n\n\t@Override\n\tpublic Collection<String> getCacheNames() {\n\t\treturn Collections.unmodifiableSet(this.cacheMap.keySet());\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Cache getCache(String name) {\n\t\tCache cache = this.cacheMap.get(name);\n\t\tif (cache == null && this.dynamic) {\n\t\t\tcache = this.cacheMap.computeIfAbsent(name, this::createCaffeineCache);\n\t\t}\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */\n\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}\n\n\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */\n\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}\n\n\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */\n\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}\n\n\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */\n\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}\n\n\t/**\n\t * Build a common {@link CaffeineCache} instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * <p>Delegates to {@link #adaptCaffeineCache} as the adaptation method to\n\t * Spring's cache abstraction (allowing for centralized decoration etc),\n\t * passing in a freshly built native Caffeine Cache instance.\n\t * @param name the name of the cache\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @see #adaptCaffeineCache\n\t * @see #createNativeCaffeineCache\n\t */\n\tprotected Cache createCaffeineCache(String name) {\n\t\treturn (this.asyncCacheMode ? adaptCaffeineCache(name, createAsyncCaffeineCache(name)) :\n\t\t\t\tadaptCaffeineCache(name, createNativeCaffeineCache(name)));\n\t}\n\n\t/**\n\t * Build a common Caffeine Cache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the native Caffeine Cache instance\n\t * @see #createCaffeineCache\n\t */\n\tprotected com.github.benmanes.caffeine.cache.Cache<Object, Object> createNativeCaffeineCache(String name) {\n\t\tif (this.cacheLoader != null) {\n\t\t\tif (this.cacheLoader instanceof CacheLoader<Object, Object> regularCacheLoader) {\n\t\t\t\treturn this.cacheBuilder.build(regularCacheLoader);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot create regular Caffeine Cache with async-only cache loader: \" + this.cacheLoader);\n\t\t\t}\n\t\t}\n\t\treturn this.cacheBuilder.build();\n\t}\n\n\t/**\n\t * Build a common Caffeine AsyncCache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the Caffeine AsyncCache instance\n\t * @since 6.1\n\t * @see #createCaffeineCache\n\t */\n\tprotected AsyncCache<Object, Object> createAsyncCaffeineCache(String name) {\n\t\treturn (this.cacheLoader != null ? this.cacheBuilder.buildAsync(this.cacheLoader) :\n\t\t\t\tthis.cacheBuilder.buildAsync());\n\t}\n\n\t/**\n\t * Recreate the common caches with the current state of this manager.\n\t */\n\tprivate void refreshCommonCaches() {\n\t\tfor (Map.Entry<String, Cache> entry : this.cacheMap.entrySet()) {\n\t\t\tif (!this.customCacheNames.contains(entry.getKey())) {\n\t\t\t\tentry.setValue(createCaffeineCache(entry.getKey()));\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#adaptCaffeineCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#adaptCaffeineCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#createAsyncCaffeineCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a common Caffeine AsyncCache instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * @param name the name of the cache\n\t * @return the Caffeine AsyncCache instance\n\t * @since 6.1\n\t * @see #createCaffeineCache\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "Object>",
    "signature": "protected Object> createAsyncCaffeineCache(String name)",
    "source_code": "\tprotected AsyncCache<Object, Object> createAsyncCaffeineCache(String name) {\n\t\treturn (this.cacheLoader != null ? this.cacheBuilder.buildAsync(this.cacheLoader) :\n\t\t\t\tthis.cacheBuilder.buildAsync());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#createCaffeineCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a common {@link CaffeineCache} instance for the specified cache name,\n\t * using the common Caffeine configuration specified on this cache manager.\n\t * <p>Delegates to {@link #adaptCaffeineCache} as the adaptation method to\n\t * Spring's cache abstraction (allowing for centralized decoration etc),\n\t * passing in a freshly built native Caffeine Cache instance.\n\t * @param name the name of the cache\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @see #adaptCaffeineCache\n\t * @see #createNativeCaffeineCache\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "Cache",
    "signature": "protected Cache createCaffeineCache(String name)",
    "source_code": "\tprotected Cache createCaffeineCache(String name) {\n\t\treturn (this.asyncCacheMode ? adaptCaffeineCache(name, createAsyncCaffeineCache(name)) :\n\t\t\t\tadaptCaffeineCache(name, createNativeCaffeineCache(name)));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#getCache(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Cache",
    "signature": "public Cache getCache(String name)",
    "source_code": "\tpublic Cache getCache(String name) {\n\t\tCache cache = this.cacheMap.get(name);\n\t\tif (cache == null && this.dynamic) {\n\t\t\tcache = this.cacheMap.computeIfAbsent(name, this::createCaffeineCache);\n\t\t}\n\t\treturn cache;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#getCacheNames()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "Collection<String>",
    "signature": "public Collection<String> getCacheNames()",
    "source_code": "\tpublic Collection<String> getCacheNames() {\n\t\treturn Collections.unmodifiableSet(this.cacheMap.keySet());\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#isAllowNullValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this cache manager accepts and converts {@code null} values\n\t * for all of its caches.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "boolean",
    "signature": "public boolean isAllowNullValues()",
    "source_code": "\tpublic boolean isAllowNullValues() {\n\t\treturn this.allowNullValues;\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#registerCustomCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#registerCustomCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAllowNullValues(allowNullValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify whether to accept and convert {@code null} values for all caches\n\t * in this cache manager.\n\t * <p>Default is \"true\", despite Caffeine itself not supporting {@code null} values.\n\t * An internal holder object will be used to store user-level {@code null}s.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "allowNullValues"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void setAllowNullValues(boolean allowNullValues)",
    "source_code": "\tpublic void setAllowNullValues(boolean allowNullValues) {\n\t\tif (this.allowNullValues != allowNullValues) {\n\t\t\tthis.allowNullValues = allowNullValues;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAsyncCacheLoader(AsyncCacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AsyncCacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setAsyncCacheMode(asyncCacheMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the common cache type that this cache manager builds to async.\n\t * This applies to {@link #setCacheNames} as well as on-demand caches.\n\t * <p>Individual cache registrations (such as {@link #registerCustomCache(String, AsyncCache)}\n\t * and {@link #registerCustomCache(String, com.github.benmanes.caffeine.cache.Cache)}\n\t * are not dependent on this setting.\n\t * <p>By default, this cache manager builds regular native Caffeine caches.\n\t * To switch to async caches which can also be used through the synchronous API\n\t * but come with support for {@code Cache#retrieve}, set this flag to {@code true}.\n\t * @since 6.1\n\t * @see Caffeine#buildAsync()\n\t * @see Cache#retrieve(Object)\n\t * @see Cache#retrieve(Object, Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "asyncCacheMode"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setAsyncCacheMode(boolean asyncCacheMode)",
    "source_code": "\tpublic void setAsyncCacheMode(boolean asyncCacheMode) {\n\t\tif (this.asyncCacheMode != asyncCacheMode) {\n\t\t\tthis.asyncCacheMode = asyncCacheMode;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheLoader(CacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "CacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setCacheLoader(CacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheNames(cacheNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the set of cache names for this CacheManager's 'static' mode.\n\t * <p>The number of caches and their names will be fixed after a call to this method,\n\t * with no creation of further cache regions at runtime.\n\t * <p>Calling this with a {@code null} collection argument resets the\n\t * mode to 'dynamic', allowing for further creation of caches again.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheNames"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void setCacheNames(@Nullable Collection<String> cacheNames)",
    "source_code": "\tpublic void setCacheNames(@Nullable Collection<String> cacheNames) {\n\t\tif (cacheNames != null) {\n\t\t\tfor (String name : cacheNames) {\n\t\t\t\tthis.cacheMap.put(name, createCaffeineCache(name));\n\t\t\t}\n\t\t\tthis.dynamic = false;\n\t\t}\n\t\telse {\n\t\t\tthis.dynamic = true;\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCacheSpecification(cacheSpecification)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine cache specification String to use for building each\n\t * individual {@link CaffeineCache} instance. The given value needs to\n\t * comply with Caffeine's {@link CaffeineSpec} (see its javadoc).\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheSpecification"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setCacheSpecification(String cacheSpecification)",
    "source_code": "\tpublic void setCacheSpecification(String cacheSpecification) {\n\t\tdoSetCaffeine(Caffeine.from(cacheSpecification));\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeine(Caffeine<Object,caffeine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Caffeine<Object",
      "caffeine"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setCaffeine(Caffeine<Object, Object> caffeine)",
    "source_code": "\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}"
  },
  "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeineSpec(caffeineSpec)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "caffeineSpec"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void setCaffeineSpec(CaffeineSpec caffeineSpec)",
    "source_code": "\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#apply(result)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "Object",
    "signature": "public Object apply(@Nullable Object result)",
    "source_code": "\t\tpublic Object apply(@Nullable Object result) {\n\t\t\tif (result instanceof CompletableFuture<?> future) {\n\t\t\t\treturn future.whenComplete((value, ex) -> {\n\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\tperformEvict(ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tperformPut(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (reactiveCachingHandler != null) {\n\t\t\t\tObject returnValue = reactiveCachingHandler.processPutRequest(this, result);\n\t\t\t\tif (returnValue != ReactiveCachingHandler.NOT_HANDLED) {\n\t\t\t\t\treturn returnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperformPut(result);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#executeSynchronized(invoker,method,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invoker",
      "method",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1010
    },
    "return": "Object",
    "signature": "public Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key)",
    "source_code": "\t\tpublic Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(method.getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\t// Flux or similar\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Flux.from(adapter.toPublisher(invokeOperation(invoker))).collectList().toFuture())))\n\t\t\t\t\t\t\t.flatMap(Flux::fromIterable));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mono or similar\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Mono.from(adapter.toPublisher(invokeOperation(invoker))).toFuture())));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#findInCaches(context,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1041
    },
    "return": "Object",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key)",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(context.getMethod().getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tCompletableFuture<?> cachedFuture = cache.retrieve(key);\n\t\t\t\tif (cachedFuture == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(cachedFuture))\n\t\t\t\t\t\t\t.flatMap(v -> (v instanceof Iterable<?> iv ? Flux.fromIterable(iv) : Flux.just(v))));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(cachedFuture));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 994
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.request.performPut(this.cacheValue);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onError(t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t"
    ],
    "position": {
      "column": 1,
      "line": 990
    },
    "return": "void",
    "signature": "public void onError(Throwable t)",
    "source_code": "\t\tpublic void onError(Throwable t) {\n\t\t\tthis.request.performEvict(t);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onNext(o)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o"
    ],
    "position": {
      "column": 1,
      "line": 986
    },
    "return": "void",
    "signature": "public void onNext(Object o)",
    "source_code": "\t\tpublic void onNext(Object o) {\n\t\t\tthis.cacheValue.add(o);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#onSubscribe(s)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s"
    ],
    "position": {
      "column": 1,
      "line": 982
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription s)",
    "source_code": "\t\tpublic void onSubscribe(Subscription s) {\n\t\t\ts.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(contexts,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contexts",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1031
    },
    "return": "Object",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, result)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.CacheAspectSupport#processPutRequest(request,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "Object",
    "signature": "public Object processPutRequest(CachePutRequest request, @Nullable Object result)",
    "source_code": "\t\tpublic Object processPutRequest(CachePutRequest request, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\tFlux<?> source = Flux.from(adapter.toPublisher(result));\n\t\t\t\t\tsource.subscribe(new CachePutListSubscriber(request));\n\t\t\t\t\treturn adapter.fromPublisher(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.doOnSuccess(request::performPut).doOnError(request::performEvict));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.NOT_HANDLED": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1005
    },
    "signature": "public Object NOT_HANDLED",
    "source_code": "\t\tpublic static final Object NOT_HANDLED = new Object();",
    "type": "Object"
  },
  "org.springframework.context.annotation.ConfigurationClassPostProcessor#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 775
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.context.annotation.ConfigurationClassPostProcessor#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 771
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, Executable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,"
  },
  "org.springframework.context.event.ApplicationListenerMethodAdapter#shouldHandle(event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the listener method would actually handle the given\n\t * event, checking if the condition matches.\n\t * @param event the event to process through the listener method\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "boolean",
    "signature": "public boolean shouldHandle(ApplicationEvent event)",
    "source_code": "\tpublic boolean shouldHandle(ApplicationEvent event) {\n\t\treturn shouldHandle(event, resolveArguments(event));\n\t}"
  },
  "org.springframework.context.support.CHECKPOINT_ON_REFRESH_VALUE": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recognized value for the context checkpoint property: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_PROPERTY_NAME\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public String CHECKPOINT_ON_REFRESH_VALUE",
    "source_code": "\tpublic static final String CHECKPOINT_ON_REFRESH_VALUE = \"onRefresh\";",
    "type": "String"
  },
  "org.springframework.context.support.CHECKPOINT_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Property name for a common context checkpoint: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_ON_REFRESH_VALUE\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "signature": "public String CHECKPOINT_PROPERTY_NAME",
    "source_code": "\tpublic static final String CHECKPOINT_PROPERTY_NAME = \"spring.context.checkpoint\";",
    "type": "String"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#afterRestore(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void afterRestore(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void afterRestore(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\tlong restartTime = System.nanoTime();\n\t\t\tlogger.info(\"Restarting Spring-managed lifecycle beans after JVM restore\");\n\t\t\trestartAfterStop();\n\n\t\t\t// Barrier for prevent-shutdown thread not needed anymore\n\t\t\tthis.barrier = null;\n\n\t\t\tlong timeTakenToRestart = Duration.ofNanos(System.nanoTime() - restartTime).toMillis();\n\t\t\tlong timeTakenToRestoreJvm = CRaCMXBean.getCRaCMXBean().getUptimeSinceRestore();\n\t\t\tlogger.info(\"Spring-managed lifecycle restart completed in \" + timeTakenToRestart\n\t\t\t\t\t+ \" ms (restored JVM running for \" + timeTakenToRestoreJvm + \" ms)\");\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#beforeCheckpoint(context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "public void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context)",
    "source_code": "\t\tpublic void beforeCheckpoint(org.crac.Context<? extends org.crac.Resource> context) {\n\t\t\t// A non-daemon thread for preventing an accidental JVM shutdown before the checkpoint\n\t\t\tthis.barrier = new CyclicBarrier(2);\n\n\t\t\tThread thread = new Thread(() -> {\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t\t// Checkpoint happens here\n\t\t\t\tawaitPreventShutdownBarrier();\n\t\t\t}, \"prevent-shutdown\");\n\n\t\t\tthread.setDaemon(false);\n\t\t\tthread.start();\n\t\t\tawaitPreventShutdownBarrier();\n\n\t\t\tlogger.debug(\"Stopping Spring-managed lifecycle beans before JVM checkpoint\");\n\t\t\tstopForRestart();\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#checkpointRestore()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "void",
    "signature": "public void checkpointRestore()",
    "source_code": "\t\tpublic void checkpointRestore() {\n\t\t\tlogger.info(\"Triggering JVM checkpoint/restore\");\n\t\t\ttry {\n\t\t\t\tCore.checkpointRestore();\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"CRaC checkpoint not supported on current JVM\", ex);\n\t\t\t}\n\t\t\tcatch (CheckpointException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to take CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t\tcatch (RestoreException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Failed to restore CRaC checkpoint on refresh\", ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#compareTo(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "int",
    "signature": "public int compareTo(LifecycleGroupMember other)",
    "source_code": "\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}"
  },
  "org.springframework.context.support.DefaultLifecycleProcessor#registerResource()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "Object",
    "signature": "public Object registerResource()",
    "source_code": "\t\tpublic Object registerResource() {\n\t\t\tlogger.debug(\"Registering JVM checkpoint/restore callback for Spring-managed lifecycle beans\");\n\t\t\tCracResourceAdapter resourceAdapter = new CracResourceAdapter();\n\t\t\torg.crac.Core.getGlobalContext().register(resourceAdapter);\n\t\t\treturn resourceAdapter;\n\t\t}"
  },
  "org.springframework.context.support.GenericApplicationContext#isBeanDefinitionOverridable(beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "boolean",
    "signature": "public boolean isBeanDefinitionOverridable(String beanName)",
    "source_code": "\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn this.beanFactory.isBeanDefinitionOverridable(beanName);\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#resolveResource(filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bundle {@code filename} into a concrete {@link Resource},\n\t * potentially checking multiple sources or file extensions.\n\t * <p>If no suitable concrete {@code Resource} can be resolved, this method\n\t * returns a {@code Resource} for which {@link Resource#exists()} returns\n\t * {@code false}, which gets subsequently ignored.\n\t * <p>This can be leveraged to check the last modification timestamp or to load\n\t * properties from alternative sources &mdash; for example, from an XML BLOB\n\t * in a database, or from properties serialized using a custom format such as\n\t * JSON.\n\t * <p>The default implementation delegates to the configured\n\t * {@link #setResourceLoader(ResourceLoader) ResourceLoader} to resolve\n\t * resources, checking in order for existing {@code Resource} with extensions defined\n\t * by {@link #setFileExtensions(List)} ({@code .properties} and {@code .xml}\n\t * by default).\n\t * <p>When overriding this method, {@link #loadProperties(Resource, String)}\n\t * <strong>must</strong> be capable of loading properties from any type of\n\t * {@code Resource} returned by this method. As a consequence, implementors\n\t * are strongly encouraged to also override {@code loadProperties()}.\n\t * <p>As an alternative to overriding this method, you can configure a\n\t * {@link #setPropertiesPersister(PropertiesPersister) PropertiesPersister}\n\t * that is capable of dealing with all resources returned by this method.\n\t * Please note, however, that the default {@code loadProperties()} implementation\n\t * uses {@link PropertiesPersister#loadFromXml(Properties, InputStream) loadFromXml}\n\t * for XML resources and otherwise uses the two\n\t * {@link PropertiesPersister#load(Properties, InputStream) load} methods\n\t * for other types of resources.\n\t * @param filename the bundle filename (basename + Locale)\n\t * @return the {@code Resource} to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "Resource",
    "signature": "protected Resource resolveResource(String filename)",
    "source_code": "\tprotected Resource resolveResource(String filename) {\n\t\tResource resource = null;\n\t\tfor (String fileExtension : this.fileExtensions) {\n\t\t\tresource = this.resourceLoader.getResource(filename + fileExtension);\n\t\t\tif (resource.exists()) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\t\treturn Objects.requireNonNull(resource);\n\t}"
  },
  "org.springframework.context.support.ReloadableResourceBundleMessageSource#setFileExtensions(fileExtensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of supported file extensions.\n\t * <p>The default is a list containing {@code .properties} and {@code .xml}.\n\t * @param fileExtensions the file extensions (starts with a dot)\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fileExtensions"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void setFileExtensions(List<String> fileExtensions)",
    "source_code": "\tpublic void setFileExtensions(List<String> fileExtensions) {\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(fileExtensions), \"At least one file extension is required\");\n\t\tfor (String extension : fileExtensions) {\n\t\t\tif (!extension.startsWith(\".\")) {\n\t\t\t\tthrow new IllegalArgumentException(\"File extension '\" + extension + \"' should start with '.'\");\n\t\t\t}\n\t\t}\n\t\tthis.fileExtensions = Collections.unmodifiableList(fileExtensions);\n\t}"
  },
  "org.springframework.core.MethodParameter#forFieldAwareConstructor(ctor,parameterIndex,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * e.g. on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "parameterIndex",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName)",
    "source_code": "\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#cancel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "public void cancel()",
    "source_code": "\t\t\tpublic void cancel() {\n\t\t\t}"
  },
  "org.springframework.core.ReactiveAdapterRegistry#request(n)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "n"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "public void request(long n)",
    "source_code": "\t\t\tpublic void request(long n) {\n\t\t\t}"
  },
  "org.springframework.core.ResolvableType#equalsType(otherType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for type-level equality with another {@code ResolvableType}.\n\t * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\n\t * this works between different sources as well, e.g. method parameters and return types.\n\t * @param otherType the {@code ResolvableType} to match against\n\t * @return whether the declared type and type variables match\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "otherType"
    ],
    "position": {
      "column": 1,
      "line": 952
    },
    "return": "boolean",
    "signature": "public boolean equalsType(ResolvableType otherType)",
    "source_code": "\tpublic boolean equalsType(ResolvableType otherType) {\n\t\treturn (ObjectUtils.nullSafeEquals(this.type, otherType.type) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.componentType, otherType.componentType));\n\t}"
  },
  "org.springframework.core.convert.support.GenericConversionService#convert(source,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "T",
    "signature": "public T convert(@Nullable Object source, Class<T> targetType)",
    "source_code": "\tpublic <T> T convert(@Nullable Object source, Class<T> targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));\n\t}"
  },
  "org.springframework.core.io.ModuleResource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link Resource} implementation for {@link java.lang.Module} resolution,\n * performing {@link #getInputStream()} access via {@link Module#getResourceAsStream}.\n *\n * <p>Alternatively, consider accessing resources in a module path layout via\n * {@link ClassPathResource} for exported resources, or specifically relative to\n * a {@code Class} via {@link ClassPathResource#ClassPathResource(String, Class)}\n * for local resolution within the containing module of that specific class.\n * In common scenarios, module resources will simply be transparently visible as\n * classpath resources and therefore do not need any special treatment at all.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @see Module#getResourceAsStream\n * @see ClassPathResource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class ModuleResource",
    "source_code": "public class ModuleResource extends AbstractResource {\n\n\tprivate final Module module;\n\n\tprivate final String path;\n\n\n\t/**\n\t * Create a new {@code ModuleResource} for the given {@link Module}\n\t * and the given resource path.\n\t * @param module the runtime module to search within\n\t * @param path the resource path within the module\n\t */\n\tpublic ModuleResource(Module module, String path) {\n\t\tAssert.notNull(module, \"Module must not be null\");\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tthis.module = module;\n\t\tthis.path = path;\n\t}\n\n\n\t/**\n\t * Return the {@link Module} for this resource.\n\t */\n\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}\n\n\t/**\n\t * Return the path for this resource.\n\t */\n\tpublic final String getPath() {\n\t\treturn this.path;\n\t}\n\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}\n\n\t@Override\n\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}\n\n}"
  },
  "org.springframework.core.io.ModuleResource#createRelative(relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "Resource",
    "signature": "public Resource createRelative(String relativePath)",
    "source_code": "\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}"
  },
  "org.springframework.core.io.ModuleResource#equals(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object obj)",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "String",
    "signature": "public String getDescription()",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getFilename()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "String",
    "signature": "public String getFilename()",
    "source_code": "\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getInputStream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "InputStream",
    "signature": "public InputStream getInputStream()",
    "source_code": "\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getModule()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Module} for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Module",
    "signature": "public Module getModule()",
    "source_code": "\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#getPath()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the path for this resource.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "String",
    "signature": "public String getPath()",
    "source_code": "\tpublic final String getPath() {\n\t\treturn this.path;\n\t}"
  },
  "org.springframework.core.io.ModuleResource#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}"
  },
  "org.springframework.core.io.UrlResource#customizeConnection(con)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "protected void customizeConnection(URLConnection con)",
    "source_code": "\tprotected void customizeConnection(URLConnection con) throws IOException {\n\t\tsuper.customizeConnection(con);\n\t\tString userInfo = this.url.getUserInfo();\n\t\tif (userInfo != null) {\n\t\t\tString encodedCredentials = Base64.getUrlEncoder().encodeToString(userInfo.getBytes());\n\t\t\tcon.setRequestProperty(AUTHORIZATION, \"Basic \" + encodedCredentials);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,"
  },
  "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor,chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamHandler} are buffered until they\n\t * reach or exceed {@code chunkSize}, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,"
  },
  "org.springframework.core.task.TaskRejectedException": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Exception thrown when a {@link TaskExecutor} rejects to accept\n * a given task for execution.\n *\n * @author Juergen Hoeller\n * @since 2.0.1\n * @see TaskExecutor#execute(Runnable)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "signature": "public class TaskRejectedException",
    "source_code": "public class TaskRejectedException extends RejectedExecutionException {\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with the specified detail message and no root cause.\n\t * @param msg the detail message\n\t */\n\tpublic TaskRejectedException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with the specified detail message and the given root cause.\n\t * @param msg the detail message\n\t * @param cause the root cause (usually from using an underlying\n\t * API such as the {@code java.util.concurrent} package)\n\t * @see java.util.concurrent.RejectedExecutionException\n\t */\n\tpublic TaskRejectedException(String msg, Throwable cause) {\n\t\tsuper(msg, cause);\n\t}\n\n\t/**\n\t * Create a new {@code TaskRejectedException}\n\t * with a default message for the given executor and task.\n\t * @param executor the {@code Executor} that rejected the task\n\t * @param task the task object that got rejected\n\t * @param cause the original {@link RejectedExecutionException}\n\t * @since 6.1\n\t * @see ExecutorService#isShutdown()\n\t * @see java.util.concurrent.RejectedExecutionException\n\t */\n\tpublic TaskRejectedException(Executor executor, Object task, RejectedExecutionException cause) {\n\t\tsuper(executorDescription(executor) + \" did not accept task: \" + task, cause);\n\t}\n\n\n\tprivate static String executorDescription(Executor executor) {\n\t\tif (executor instanceof ExecutorService executorService) {\n\t\t\treturn \"ExecutorService in \" + (executorService.isShutdown() ? \"shutdown\" : \"active\") + \" state\";\n\t\t}\n\t\treturn executor.toString();\n\t}\n\n}"
  },
  "org.springframework.core.task.support.TaskExecutorAdapter#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.dao.support.DataAccessUtils#optionalResult(results)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single result object from the given Iterator.\n\t * <p>Returns {@code Optional.empty()} if 0 result objects found;\n\t * throws an exception if more than 1 element found.\n\t * @param results the result Iterator (can be {@code null})\n\t * @return the single optional result object, or {@code Optional.empty()} if none\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * element has been found in the given Iterator\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> optionalResult(@Nullable Iterator<T> results)",
    "source_code": "\tpublic static <T> Optional<T> optionalResult(@Nullable Iterator<T> results) throws IncorrectResultSizeDataAccessException {\n\t\treturn Optional.ofNullable(singleResult(results));\n\t}"
  },
  "org.springframework.expression.spel.ast.OpMinus#isNegativeNumberLiteral()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this operator is a unary minus and its child is a\n\t * {@linkplain Literal#isNumberLiteral() number literal}.\n\t * @return {@code true} if it is a negative number literal\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean isNegativeNumberLiteral()",
    "source_code": "\tpublic boolean isNegativeNumberLiteral() {\n\t\treturn (this.children.length == 1 && this.children[0] instanceof Literal literal &&\n\t\t\t\tliteral.isNumberLiteral());\n\t}"
  },
  "org.springframework.expression.spel.support.ReflectivePropertyAccessor#isKotlinProperty(method,methodSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "methodSuffix"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "boolean",
    "signature": "public boolean isKotlinProperty(Method method, String methodSuffix)",
    "source_code": "\t\tpublic static boolean isKotlinProperty(Method method, String methodSuffix) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(method.getDeclaringClass());\n\t\t\tfor (KProperty<?> property : KClasses.getMemberProperties(kClass)) {\n\t\t\t\tif (methodSuffix.equalsIgnoreCase(property.getName()) &&\n\t\t\t\t\t\t(method.equals(ReflectJvmMapping.getJavaGetter(property)) ||\n\t\t\t\t\t\t\t\tproperty instanceof KMutableProperty<?> mutableProperty &&\n\t\t\t\t\t\t\t\t\t\tmethod.equals(ReflectJvmMapping.getJavaSetter(mutableProperty)))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.http.HttpMethod#resolve(method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given method value to an {@code HttpMethod}.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code HttpMethod}, or {@code null} if not found\n\t * @since 4.2.4\n\t * @deprecated in favor of {@link #valueOf(String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "HttpMethod",
    "signature": "public HttpMethod resolve(@Nullable String method)",
    "source_code": "\tpublic static HttpMethod resolve(@Nullable String method) {\n\t\treturn (method != null ? valueOf(method) : null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tStreamUtils.drain(this.body);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.body.close();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignored) {\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\tif (!headers.isEmpty()) {\n\t\t\tthis.request.headers(httpFields -> {\n\t\t\t\theaders.forEach((headerName, headerValues) -> {\n\t\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\t\thttpFields.add(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tString contentType = null;\n\t\tif (headers.getContentType() != null) {\n\t\t\tcontentType = headers.getContentType().toString();\n\t\t}\n\t\ttry {\n\t\t\tInputStreamResponseListener responseListener = new InputStreamResponseListener();\n\t\t\tif (body != null) {\n\t\t\t\tOutputStreamRequestContent requestContent = new OutputStreamRequestContent(contentType);\n\t\t\t\tthis.request.body(requestContent)\n\t\t\t\t\t\t.send(responseListener);\n\t\t\t\ttry (OutputStream outputStream = requestContent.getOutputStream()) {\n\t\t\t\t\tbody.writeTo(StreamUtils.nonClosing(outputStream));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.request.send(responseListener);\n\t\t\t}\n\t\t\tResponse response = responseListener.get(this.readTimeout, TimeUnit.MILLISECONDS);\n\t\t\treturn new JettyClientHttpResponse(response, responseListener.getInputStream());\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\tthrow new IOException(\"Request was interrupted: \" + ex.getMessage(), ex);\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\tif (cause instanceof RuntimeException rtEx) {\n\t\t\t\tthrow rtEx;\n\t\t\t}\n\t\t\telse if (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(cause.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (TimeoutException ex) {\n\t\t\tthrow new IOException(\"Request timed out: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#getBody()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "InputStream",
    "signature": "public InputStream getBody()",
    "source_code": "\tpublic InputStream getBody() throws IOException {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.http.client.<unknown>#getHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHeaders()",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.http.client.<unknown>#getStatusCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatusCode.valueOf(this.response.statusCode());\n\t}"
  },
  "org.springframework.http.client.<unknown>#getStatusText()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "String",
    "signature": "public String getStatusText()",
    "source_code": "\tpublic String getStatusText() {\n\t\t// HttpResponse does not expose status text\n\t\tif (getStatusCode() instanceof HttpStatus status) {\n\t\t\treturn status.getReasonPhrase();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(int b)",
    "source_code": "\t\tpublic ByteBuf map(int b) {\n\t\t\tByteBuf byteBuf = this.allocator.buffer(1);\n\t\t\tbyteBuf.writeByte(b);\n\t\t\treturn byteBuf;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuf map(byte[] b, int off, int len) {\n\t\t\tByteBuf byteBuf = this.allocator.buffer(len);\n\t\t\tbyteBuf.writeBytes(b, off, len);\n\t\t\treturn byteBuf;\n\t\t}"
  },
  "org.springframework.http.client.HttpComponentsClientHttpRequestFactory#setReadTimeout(timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * As of version 6.0, setting this property has no effect.\n\t * <p>To change the socket read timeout, use {@link SocketConfig.Builder#setSoTimeout(Timeout)},\n\t * supply the resulting {@link SocketConfig} to\n\t * {@link org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder#setDefaultSocketConfig(SocketConfig)},\n\t * use the resulting connection manager for\n\t * {@link org.apache.hc.client5.http.impl.classic.HttpClientBuilder#setConnectionManager(HttpClientConnectionManager)},\n\t * and supply the built {@link HttpClient} to {@link #HttpComponentsClientHttpRequestFactory(HttpClient)}.\n\t * @deprecated as of 6.0, in favor of {@link SocketConfig.Builder#setSoTimeout(Timeout)}, see above.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void setReadTimeout(int timeout)",
    "source_code": "\tpublic void setReadTimeout(int timeout) {\n\t\tlogger.warn(\"HttpComponentsClientHttpRequestFactory.setReadTimeout has no effect\");\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#add(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#clear()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#containsKey(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#containsValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#entrySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#get(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getFirst(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getKey()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#getValue()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#hasNext()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#isEmpty()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#iterator()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#keySet()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#next()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#remove()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#remove(key)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#set(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setAll(Map<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setValue(value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#size()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toSingleValueMap()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#values()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ClientHttpConnector} for the Jetty Reactive Streams HttpClient.\n *\n * @author Sebastien Deleuze\n * @since 5.1\n * @see <a href=\"https://github.com/jetty-project/jetty-reactive-httpclient\">Jetty ReactiveStreams HttpClient</a>\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "signature": "public class JettyClientHttpConnector",
    "source_code": "public class JettyClientHttpConnector implements ClientHttpConnector {\n\n\tprivate final HttpClient httpClient;\n\n\tprivate DataBufferFactory bufferFactory = DefaultDataBufferFactory.sharedInstance;\n\n\n\t/**\n\t * Default constructor that creates a new instance of {@link HttpClient}.\n\t */\n\tpublic JettyClientHttpConnector() {\n\t\tthis(new HttpClient());\n\t}\n\n\t/**\n\t * Constructor with an initialized {@link HttpClient}.\n\t */\n\tpublic JettyClientHttpConnector(HttpClient httpClient) {\n\t\tthis(httpClient, null);\n\t}\n\n\t/**\n\t * Constructor with an initialized {@link HttpClient} and configures it\n\t * with the given {@link JettyResourceFactory}.\n\t * @param httpClient the {@link HttpClient} to use\n\t * @param resourceFactory the {@link JettyResourceFactory} to use\n\t * @since 5.2\n\t */\n\tpublic JettyClientHttpConnector(HttpClient httpClient, @Nullable JettyResourceFactory resourceFactory) {\n\t\tAssert.notNull(httpClient, \"HttpClient is required\");\n\t\tif (resourceFactory != null) {\n\t\t\thttpClient.setExecutor(resourceFactory.getExecutor());\n\t\t\thttpClient.setByteBufferPool(resourceFactory.getByteBufferPool());\n\t\t\thttpClient.setScheduler(resourceFactory.getScheduler());\n\t\t}\n\t\tthis.httpClient = httpClient;\n\t}\n\n\t/**\n\t * Constructor with an {@link JettyResourceFactory} that will manage shared resources.\n\t * @param resourceFactory the {@link JettyResourceFactory} to use\n\t * @param customizer the lambda used to customize the {@link HttpClient}\n\t * @deprecated as of 5.2, in favor of\n\t * {@link JettyClientHttpConnector#JettyClientHttpConnector(HttpClient, JettyResourceFactory)}\n\t */\n\t@Deprecated\n\tpublic JettyClientHttpConnector(JettyResourceFactory resourceFactory, @Nullable Consumer<HttpClient> customizer) {\n\t\tthis(new HttpClient(), resourceFactory);\n\t\tif (customizer != null) {\n\t\t\tcustomizer.accept(this.httpClient);\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the buffer factory to use.\n\t */\n\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.bufferFactory = bufferFactory;\n\t}\n\n\n\t@Override\n\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tif (!uri.isAbsolute()) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n\t\t}\n\n\t\tif (!this.httpClient.isStarted()) {\n\t\t\ttry {\n\t\t\t\tthis.httpClient.start();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tRequest jettyRequest = this.httpClient.newRequest(uri).method(method.toString());\n\t\tJettyClientHttpRequest request = new JettyClientHttpRequest(jettyRequest, this.bufferFactory);\n\n\t\treturn requestCallback.apply(request).then(execute(request));\n\t}\n\n\tprivate Mono<ClientHttpResponse> execute(JettyClientHttpRequest request) {\n\t\treturn Mono.fromDirect(request.toReactiveRequest()\n\t\t\t\t.response((reactiveResponse, chunkPublisher) -> {\n\t\t\t\t\tFlux<DataBuffer> content = Flux.from(chunkPublisher).map(this::toDataBuffer);\n\t\t\t\t\treturn Mono.just(new JettyClientHttpResponse(reactiveResponse, content));\n\t\t\t\t}));\n\t}\n\n\tprivate DataBuffer toDataBuffer(Content.Chunk chunk) {\n\t\tDataBuffer delegate = this.bufferFactory.wrap(chunk.getByteBuffer());\n\t\treturn new JettyDataBuffer(delegate, chunk);\n\t}\n\n\n\tprivate static final class JettyDataBuffer implements PooledDataBuffer {\n\n\t\tprivate final DataBuffer delegate;\n\n\t\tprivate final Content.Chunk chunk;\n\n\t\tprivate final AtomicInteger refCount = new AtomicInteger(1);\n\n\n\t\tpublic JettyDataBuffer(DataBuffer delegate, Content.Chunk chunk) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.chunk = chunk;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isAllocated() {\n\t\t\treturn this.refCount.get() > 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic PooledDataBuffer retain() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.retain();\n\t\t\t}\n\t\t\tthis.chunk.retain();\n\t\t\tthis.refCount.getAndUpdate(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic PooledDataBuffer touch(Object hint) {\n\t\t\tif (this.delegate instanceof TouchableDataBuffer touchableDelegate) {\n\t\t\t\ttouchableDelegate.touch(hint);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// delegation\n\n\t\t@Override\n\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}\n\n\t\t@Override\n\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(DataBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}\n\n\n\t\tprivate static final class JettyByteBufferIterator implements ByteBufferIterator {\n\n\t\t\tprivate final ByteBufferIterator delegate;\n\n\t\t\tprivate final Content.Chunk chunk;\n\n\n\t\t\tpublic JettyByteBufferIterator(ByteBufferIterator delegate, Content.Chunk chunk) {\n\t\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\t\tAssert.notNull(chunk, \"Chunk must not be null\");\n\n\t\t\t\tthis.delegate = delegate;\n\t\t\t\tthis.chunk = chunk;\n\t\t\t\tthis.chunk.retain();\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#asByteBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer capacity(int capacity)",
    "source_code": "\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#ensureWritable(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#factory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory factory()",
    "source_code": "\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#getByte(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#isAllocated()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean isAllocated()",
    "source_code": "\t\tpublic boolean isAllocated() {\n\t\t\treturn this.refCount.get() > 0;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readPosition(readPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer readPosition(int readPosition)",
    "source_code": "\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#readableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#release()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "boolean",
    "signature": "public boolean release()",
    "source_code": "\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#retain()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer retain()",
    "source_code": "\t\tpublic PooledDataBuffer retain() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.retain();\n\t\t\t}\n\t\t\tthis.chunk.retain();\n\t\t\tthis.refCount.getAndUpdate(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#setBufferFactory(bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the buffer factory to use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setBufferFactory(DataBufferFactory bufferFactory)",
    "source_code": "\tpublic void setBufferFactory(DataBufferFactory bufferFactory) {\n\t\tthis.bufferFactory = bufferFactory;\n\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#split(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#touch(hint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "PooledDataBuffer",
    "signature": "public PooledDataBuffer touch(Object hint)",
    "source_code": "\t\tpublic PooledDataBuffer touch(Object hint) {\n\t\t\tif (this.delegate instanceof TouchableDataBuffer touchableDelegate) {\n\t\t\t\ttouchableDelegate.touch(hint);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte b)",
    "source_code": "\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(buffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(ByteBuffer... buffers)",
    "source_code": "\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writePosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}"
  },
  "org.springframework.http.client.reactive.JettyClientHttpConnector#writePosition(writePosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "source_code": "\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.ResourceHttpMessageWriter#addDefaultHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\treturn Mono.defer(() -> {\n\t\t\tHttpHeaders headers = message.getHeaders();\n\t\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\t\theaders.setContentType(resourceMediaType);\n\t\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t\t// server side\n\t\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t}\n\n\t\t\tif (headers.getContentLength() < 0) {\n\t\t\t\treturn lengthOf(resource)\n\t\t\t\t\t\t.flatMap(contentLength -> {\n\t\t\t\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t\t\t\t\treturn Mono.empty();\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Encode from single value to a byte stream containing XML elements.\n *\n * <p>{@link jakarta.xml.bind.annotation.XmlElements @XmlElements} and\n * {@link jakarta.xml.bind.annotation.XmlElement @XmlElement} can be used\n * to specify how collections should be marshalled.\n *\n * @author Sebastien Deleuze\n * @author Arjen Poutsma\n * @since 5.0\n * @see Jaxb2XmlDecoder\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class Jaxb2XmlEncoder",
    "source_code": "public class Jaxb2XmlEncoder extends AbstractSingleValueEncoder<Object> {\n\n\tprivate final JaxbContextContainer jaxbContexts = new JaxbContextContainer();\n\n\tprivate Function<Marshaller, Marshaller> marshallerProcessor = Function.identity();\n\n\n\tpublic Jaxb2XmlEncoder() {\n\t\tsuper(MimeTypeUtils.APPLICATION_XML, MimeTypeUtils.TEXT_XML, new MediaType(\"application\", \"*+xml\"));\n\t}\n\n\n\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */\n\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}\n\n\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */\n\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}\n\n\n\t@Override\n\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\t// we're relying on doOnDiscard in base class\n\t\treturn Mono.fromCallable(() -> encodeValue(value, bufferFactory, valueType, mimeType, hints)).flux();\n\t}\n\n\t@Override\n\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Encoding [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\n\t\tboolean release = true;\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(1024);\n\t\ttry {\n\t\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = initMarshaller(clazz);\n\t\t\tmarshaller.marshal(value, outputStream);\n\t\t\trelease = false;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow new EncodingException(\"Could not marshal \" + value.getClass() + \" to XML\", ex);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new CodecException(\"Invalid JAXB configuration\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (release) {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Class<?> getMarshallerType(Object value) {\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\treturn jaxbElement.getDeclaredType();\n\t\t}\n\t\telse {\n\t\t\treturn ClassUtils.getUserClass(value);\n\t\t}\n\t}\n\n\tprivate Marshaller initMarshaller(Class<?> clazz) throws CodecException, JAXBException {\n\t\tMarshaller marshaller = this.jaxbContexts.createMarshaller(clazz);\n\t\tmarshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.name());\n\t\tmarshaller = this.marshallerProcessor.apply(marshaller);\n\t\treturn marshaller;\n\t}\n\n}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#getMarshallerProcessor()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Marshaller>",
    "signature": "public Marshaller> getMarshallerProcessor()",
    "source_code": "\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}"
  },
  "org.springframework.http.codec.xml.Jaxb2XmlEncoder#setMarshallerProcessor(Function<Marshaller,processor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Marshaller",
      "processor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setMarshallerProcessor(Function<Marshaller, Marshaller> processor)",
    "source_code": "\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\tpublic void close() {\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#flush()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 677
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t}"
  },
  "org.springframework.http.converter.FormHttpMessageConverter#write(b,off,let)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "let"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int let)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int let) throws IOException {\n\t\t\tthis.out.write(b, off, let);\n\t\t}"
  },
  "org.springframework.http.server.ServletServerHttpRequest#initURI(servletRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a URI from the given Servlet request.\n\t * @param servletRequest the request\n\t * @return the initialized URI\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "URI",
    "signature": "public URI initURI(HttpServletRequest servletRequest)",
    "source_code": "\tpublic static URI initURI(HttpServletRequest servletRequest) {\n\t\tString urlString = null;\n\t\tboolean hasQuery = false;\n\t\ttry {\n\t\t\tStringBuffer url = servletRequest.getRequestURL();\n\t\t\tString query = servletRequest.getQueryString();\n\t\t\thasQuery = StringUtils.hasText(query);\n\t\t\tif (hasQuery) {\n\t\t\t\turl.append('?').append(query);\n\t\t\t}\n\t\t\turlString = url.toString();\n\t\t\treturn new URI(urlString);\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tif (!hasQuery) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not resolve HttpServletRequest as URI: \" + urlString, ex);\n\t\t\t}\n\t\t\t// Maybe a malformed query string... try plain request URL\n\t\t\ttry {\n\t\t\t\turlString = servletRequest.getRequestURL().toString();\n\t\t\t\treturn new URI(urlString);\n\t\t\t}\n\t\t\tcatch (URISyntaxException ex2) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not resolve HttpServletRequest as URI: \" + urlString, ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter#applyHeaders()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "protected void applyHeaders()",
    "source_code": "\t\tprotected void applyHeaders() {\n\t\t\tadaptHeaders(false);\n\t\t}"
  },
  "org.springframework.http.server.reactive.JettyHttpHandlerAdapter#createRequest(request,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Apache HttpComponents\n * HttpClient headers.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "signature": "public class HttpComponentsHeadersAdapter",
    "source_code": "public final class HttpComponentsHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpMessage message;\n\n\n\t/**\n\t * Create a new {@code HttpComponentsHeadersAdapter} based on the given\n\t * {@code HttpMessage}.\n\t */\n\tpublic HttpComponentsHeadersAdapter(HttpMessage message) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tthis.message = message;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\tHeader header = this.message.getFirstHeader(key);\n\t\treturn (header != null ? header.getValue() : null);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tthis.message.addHeader(key, value);\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tthis.message.setHeader(key, value);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> map = CollectionUtils.newLinkedHashMap(size());\n\t\tthis.message.headerIterator().forEachRemaining(h -> map.putIfAbsent(h.getName(), h.getValue()));\n\t\treturn map;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.message.getHeaders().length;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.message.getHeaders().length == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.message.containsHeader(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tArrays.stream(this.message.getHeaders()).anyMatch(h -> h.getValue().equals(value)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tList<String> values = null;\n\t\tif (containsKey(key)) {\n\t\t\tHeader[] headers = this.message.getHeaders((String) key);\n\t\t\tvalues = new ArrayList<>(headers.length);\n\t\t\tfor (Header header : headers) {\n\t\t\t\tvalues.add(header.getValue());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tthis.message.removeHeaders(headerName);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.message.setHeaders();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\tSet<String> keys = new LinkedHashSet<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tkeys.add(header.getName());\n\t\t}\n\t\treturn keys;\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\tCollection<List<String>> values = new ArrayList<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tvalues.add(get(header.getName()));\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<Header> iterator = message.headerIterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = HttpComponentsHeadersAdapter.this.get(this.key);\n\t\t\treturn values != null ? values : Collections.emptyList();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\tHttpComponentsHeadersAdapter.this.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tthis.message.addHeader(key, value);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.message.setHeaders();\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.message.containsHeader(headerName));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tArrays.stream(this.message.getHeaders()).anyMatch(h -> h.getValue().equals(value)));\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tList<String> values = null;\n\t\tif (containsKey(key)) {\n\t\t\tHeader[] headers = this.message.getHeaders((String) key);\n\t\t\tvalues = new ArrayList<>(headers.length);\n\t\t\tfor (Header header : headers) {\n\t\t\t\tvalues.add(header.getValue());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\tHeader header = this.message.getFirstHeader(key);\n\t\treturn (header != null ? header.getValue() : null);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = HttpComponentsHeadersAdapter.this.get(this.key);\n\t\t\treturn values != null ? values : Collections.emptyList();\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.message.getHeaders().length == 0);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> iterator()",
    "source_code": "\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\tSet<String> keys = new LinkedHashSet<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tkeys.add(header.getName());\n\t\t}\n\t\treturn keys;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "List<String>>",
    "signature": "public List<String>> next()",
    "source_code": "\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#put(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tthis.message.removeHeaders(headerName);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tthis.message.setHeader(key, value);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\tHttpComponentsHeadersAdapter.this.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> map = CollectionUtils.newLinkedHashMap(size());\n\t\tthis.message.headerIterator().forEachRemaining(h -> map.putIfAbsent(h.getName(), h.getValue()));\n\t\treturn map;\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.HttpComponentsHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tCollection<List<String>> values = new ArrayList<>(size());\n\t\tfor (Header header : this.message.getHeaders()) {\n\t\t\tvalues.add(get(header.getName()));\n\t\t}\n\t\treturn values;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Jetty HTTP headers.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "signature": "public class JettyHeadersAdapter",
    "source_code": "public final class JettyHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpFields headers;\n\n\n\t/**\n\t * Creates a new {@code JettyHeadersAdapter} based on the given\n\t * {@code HttpFields} instance.\n\t * @param headers the {@code HttpFields} to base this adapter on\n\t */\n\tpublic JettyHeadersAdapter(HttpFields headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tmutableHttpFields.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.getFieldNamesCollection().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tmutableHttpFields.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate HttpFields.Mutable mutableFields() {\n\t\tif (this.headers instanceof HttpFields.Mutable mutableHttpFields) {\n\t\t\treturn mutableHttpFields;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t}\n\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.getFieldNamesCollection().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}\n\t}\n\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tmutableHttpFields.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tmutableHttpFields.clear();\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.JettyHeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Netty 4 HTTP headers.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 40
    },
    "signature": "public class Netty4HeadersAdapter",
    "source_code": "public final class Netty4HeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpHeaders headers;\n\n\n\t/**\n\t * Creates a new {@code Netty4HeadersAdapter} based on the given\n\t * {@code HttpHeaders}.\n\t */\n\tpublic Netty4HeadersAdapter(HttpHeaders headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.entries()\n\t\t\t\t.forEach(entry -> {\n\t\t\t\t\tif (!singleValueMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tsingleValueMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.names().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tthis.headers.entries().stream()\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getAll((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = this.headers.getAll(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.names().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getAll(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = headers.getAll(this.key);\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}\n\t}\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tthis.headers.entries().stream()\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getAll((String) key);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getAll(this.key);\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = this.headers.getAll(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = headers.getAll(this.key);\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.entries()\n\t\t\t\t.forEach(entry -> {\n\t\t\t\t\tif (!singleValueMap.containsKey(entry.getKey())) {\n\t\t\t\t\t\tsingleValueMap.put(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.Netty4HeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MultiValueMap} implementation for wrapping Netty HTTP headers.\n *\n * @author Violeta Georgieva\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public class Netty5HeadersAdapter",
    "source_code": "public final class Netty5HeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpHeaders headers;\n\n\n\t/**\n\t * Create a new {@code Netty5HeadersAdapter} based on the given\n\t * {@code HttpHeaders}.\n\t */\n\tpublic Netty5HeadersAdapter(HttpHeaders headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\t@Nullable\n\tpublic String getFirst(String key) {\n\t\tCharSequence value = this.headers.get(key);\n\t\treturn (value != null ? value.toString() : null);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach(entry -> singleValueMap.putIfAbsent(\n\t\t\t\tentry.getKey().toString(), entry.getValue().toString()));\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.names().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tStreamSupport.stream(this.headers.spliterator(), false)\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic List<String> get(Object key) {\n\t\tIterator<CharSequence> iterator = this.headers.valuesIterator((CharSequence) key);\n\t\tif (iterator.hasNext()) {\n\t\t\tList<String> result = new ArrayList<>();\n\t\t\titerator.forEachRemaining(value -> result.add(value.toString()));\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = get(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<CharSequence> names = headers.names().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final CharSequence key;\n\n\t\tHeaderEntry(CharSequence key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = get(this.key);\n\t\t\treturn (values != null ? values : Collections.emptyList());\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}\n\t}\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<CharSequence> iterator;\n\n\t\t@Nullable\n\t\tprivate CharSequence currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<CharSequence> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this.headers::add);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.add(key, values);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#clear()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void clear()",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#containsKey(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean containsKey(Object key)",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#containsValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "boolean",
    "signature": "public boolean containsValue(Object value)",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String &&\n\t\t\t\tStreamSupport.stream(this.headers.spliterator(), false)\n\t\t\t\t\t\t.anyMatch(entry -> value.equals(entry.getValue())));\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#entrySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "List<String>>>",
    "signature": "public List<String>>> entrySet()",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#get(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "List<String>",
    "signature": "public List<String> get(Object key)",
    "source_code": "\tpublic List<String> get(Object key) {\n\t\tIterator<CharSequence> iterator = this.headers.valuesIterator((CharSequence) key);\n\t\tif (iterator.hasNext()) {\n\t\t\tList<String> result = new ArrayList<>();\n\t\t\titerator.forEachRemaining(value -> result.add(value.toString()));\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getFirst(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "String",
    "signature": "public String getFirst(String key)",
    "source_code": "\tpublic String getFirst(String key) {\n\t\tCharSequence value = this.headers.get(key);\n\t\treturn (value != null ? value.toString() : null);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getKey()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String",
    "signature": "public String getKey()",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key.toString();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#getValue()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "List<String>",
    "signature": "public List<String> getValue()",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\tList<String> values = get(this.key);\n\t\t\treturn (values != null ? values : Collections.emptyList());\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#isEmpty()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "public boolean isEmpty()",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.headers.isEmpty();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#iterator()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Iterator<String>",
    "signature": "public Iterator<String> iterator()",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names().iterator());\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#keySet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Set<String>",
    "signature": "public Set<String> keySet()",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "String",
    "signature": "public String next()",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName.toString();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#remove()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "void",
    "signature": "public void remove()",
    "source_code": "\t\tpublic void remove() {\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\theaders.remove(this.currentName);\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#remove(key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<String>",
    "signature": "public List<String> remove(Object key)",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = get(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tthis.headers.set(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this.headers::set);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#setValue(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "List<String>",
    "signature": "public List<String> setValue(List<String> value)",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#size()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int size()",
    "source_code": "\t\tpublic int size() {\n\t\t\treturn headers.names().size();\n\t\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#toSingleValueMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String>",
    "signature": "public String> toSingleValueMap()",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tthis.headers.forEach(entry -> singleValueMap.putIfAbsent(\n\t\t\t\tentry.getKey().toString(), entry.getValue().toString()));\n\t\treturn singleValueMap;\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn org.springframework.http.HttpHeaders.formatHeaders(this);\n\t}"
  },
  "org.springframework.http.support.Netty5HeadersAdapter#values()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Collection<List<String>>",
    "signature": "public Collection<List<String>> values()",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.JdbcTemplate#batchUpdate(psc,pss,generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 1024
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,\n\t\t\tfinal KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,"
  },
  "org.springframework.jdbc.core.SimplePropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link RowMapper} implementation that converts a row into a new instance\n * of the specified mapped target class. The mapped target class must be a\n * top-level class or {@code static} nested class, and it may expose either a\n * <em>data class</em> constructor with named parameters corresponding to column\n * names or classic bean property setter methods with property names corresponding\n * to column names or fields with corresponding field names.\n *\n * <p>When combining a data class constructor with setter methods, any property\n * mapped successfully via a constructor argument will not be mapped additionally\n * via a corresponding setter method or field mapping. This means that constructor\n * arguments take precedence over property setter methods which in turn take\n * precedence over direct field mappings.\n *\n * <p>To facilitate mapping between columns and properties that don't have matching\n * names, try using underscore-separated column aliases in the SQL statement like\n * {@code \"select fname as first_name from customer\"}, where {@code first_name}\n * can be mapped to a {@code setFirstName(String)} method in the target class.\n *\n * <p>This is a flexible alternative to {@link DataClassRowMapper} and\n * {@link BeanPropertyRowMapper} for scenarios where no specific customization\n * and no pre-defined property mappings are needed.\n *\n * <p>In terms of its fallback property discovery algorithm, this class is similar to\n * {@link org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource}\n * and is similarly used for {@link org.springframework.jdbc.core.simple.JdbcClient}.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @param <T> the result type\n * @see DataClassRowMapper\n * @see BeanPropertyRowMapper\n * @see org.springframework.jdbc.core.simple.JdbcClient.StatementSpec#query(Class)\n * @see org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "signature": "public class SimplePropertyRowMapper",
    "source_code": "public class SimplePropertyRowMapper<T> implements RowMapper<T> {\n\n\tprivate static final Object NO_DESCRIPTOR = new Object();\n\n\tprivate final Class<T> mappedClass;\n\n\tprivate final ConversionService conversionService;\n\n\tprivate final Constructor<T> mappedConstructor;\n\n\tprivate final String[] constructorParameterNames;\n\n\tprivate final TypeDescriptor[] constructorParameterTypes;\n\n\tprivate final Map<String, Object> propertyDescriptors = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new {@code SimplePropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic SimplePropertyRowMapper(Class<T> mappedClass) {\n\t\tthis(mappedClass, DefaultConversionService.getSharedInstance());\n\t}\n\n\t/**\n\t * Create a new {@code SimplePropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService a {@link ConversionService} for binding\n\t * JDBC values to bean properties\n\t */\n\tpublic SimplePropertyRowMapper(Class<T> mappedClass, ConversionService conversionService) {\n\t\tAssert.notNull(mappedClass, \"Mapped Class must not be null\");\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.conversionService = conversionService;\n\n\t\tthis.mappedConstructor = BeanUtils.getResolvableConstructor(mappedClass);\n\t\tint paramCount = this.mappedConstructor.getParameterCount();\n\t\tthis.constructorParameterNames = (paramCount > 0 ?\n\t\t\t\tBeanUtils.getParameterNames(this.mappedConstructor) : new String[0]);\n\t\tthis.constructorParameterTypes = new TypeDescriptor[paramCount];\n\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\tthis.constructorParameterTypes[i] = new TypeDescriptor(new MethodParameter(this.mappedConstructor, i));\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\tprivate Object getDescriptor(String column) {\n\t\treturn this.propertyDescriptors.computeIfAbsent(column, name -> {\n\n\t\t\t// Try direct match first\n\t\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.mappedClass, name);\n\t\t\tif (pd != null && pd.getWriteMethod() != null) {\n\t\t\t\treturn BeanUtils.getWriteMethodParameter(pd);\n\t\t\t}\n\t\t\tField field = ReflectionUtils.findField(this.mappedClass, name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\n\t\t\t// Try de-underscored match instead\n\t\t\tString adaptedName = JdbcUtils.convertUnderscoreNameToPropertyName(name);\n\t\t\tif (!adaptedName.equals(name)) {\n\t\t\t\tpd = BeanUtils.getPropertyDescriptor(this.mappedClass, adaptedName);\n\t\t\t\tif (pd != null && pd.getWriteMethod() != null) {\n\t\t\t\t\treturn BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t}\n\t\t\t\tfield = ReflectionUtils.findField(this.mappedClass, adaptedName);\n\t\t\t\tif (field != null) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fallback: case-insensitive match\n\t\t\tPropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(this.mappedClass);\n\t\t\tfor (PropertyDescriptor candidate : pds) {\n\t\t\t\tif (name.equalsIgnoreCase(candidate.getName())) {\n\t\t\t\t\treturn BeanUtils.getWriteMethodParameter(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield = ReflectionUtils.findFieldIgnoreCase(this.mappedClass, name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\n\t\t\treturn NO_DESCRIPTOR;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.SimplePropertyRowMapper#mapRow(rs,rowNumber)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Factory used to create a {@link CallMetaDataProvider} implementation\n * based on the type of database being used.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class CallMetaDataProviderFactory",
    "source_code": "public final class CallMetaDataProviderFactory {\n\n\tprivate static final String DB2 = \"DB2\";\n\tprivate static final String DERBY = \"Apache Derby\";\n\tprivate static final String HANA = \"HDB\";\n\tprivate static final String INFORMIX = \"Informix Dynamic Server\";\n\tprivate static final String MARIA = \"MariaDB\";\n\tprivate static final String MS_SQL_SERVER = \"Microsoft SQL Server\";\n\tprivate static final String MYSQL = \"MySQL\";\n\tprivate static final String ORACLE = \"Oracle\";\n\tprivate static final String POSTGRES = \"PostgreSQL\";\n\tprivate static final String SYBASE = \"Sybase\";\n\n\t/** List of supported database products for procedure calls. */\n\tpublic static final List<String> supportedDatabaseProductsForProcedures = List.of(\n\t\t\tDERBY,\n\t\t\tDB2,\n\t\t\tINFORMIX,\n\t\t\tMARIA,\n\t\t\tMS_SQL_SERVER,\n\t\t\tMYSQL,\n\t\t\tORACLE,\n\t\t\tPOSTGRES,\n\t\t\tSYBASE\n\t\t);\n\n\t/** List of supported database products for function calls. */\n\tpublic static final List<String> supportedDatabaseProductsForFunctions = List.of(\n\t\t\tMARIA,\n\t\t\tMS_SQL_SERVER,\n\t\t\tMYSQL,\n\t\t\tORACLE,\n\t\t\tPOSTGRES\n\t\t);\n\n\tprivate static final Log logger = LogFactory.getLog(CallMetaDataProviderFactory.class);\n\n\n\tprivate CallMetaDataProviderFactory() {\n\t}\n\n\n\t/**\n\t * Create a {@link CallMetaDataProvider} based on the database meta-data.\n\t * @param dataSource the JDBC DataSource to use for retrieving meta-data\n\t * @param context the class that holds configuration and meta-data\n\t * @return instance of the CallMetaDataProvider implementation to be used\n\t */\n\tpublic static CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context) {\n\t\ttry {\n\t\t\treturn JdbcUtils.extractDatabaseMetaData(dataSource, databaseMetaData -> {\n\t\t\t\tString databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\n\t\t\t\tboolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\n\t\t\t\tif (context.isFunction()) {\n\t\t\t\t\tif (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for function calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForFunctions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for procedure calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForProcedures);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCallMetaDataProvider provider = switch (databaseProductName) {\n\t\t\t\t\tcase ORACLE -> new OracleCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase POSTGRES -> new PostgresCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DERBY -> new DerbyCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DB2 -> new Db2CallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase HANA -> new HanaCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase MS_SQL_SERVER -> new SqlServerCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase SYBASE -> new SybaseCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tdefault -> new GenericCallMetaDataProvider(databaseMetaData);\n\t\t\t\t};\n\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using \" + provider.getClass().getName());\n\t\t\t\t}\n\t\t\t\tprovider.initializeWithMetaData(databaseMetaData);\n\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\tprovider.initializeWithProcedureColumnMetaData(databaseMetaData,\n\t\t\t\t\t\t\tcontext.getCatalogName(), context.getSchemaName(), context.getProcedureName());\n\t\t\t\t}\n\t\t\t\treturn provider;\n\t\t\t});\n\t\t}\n\t\tcatch (MetaDataAccessException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Error retrieving database meta-data\", ex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory#createMetaDataProvider(dataSource,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CallMetaDataProvider} based on the database meta-data.\n\t * @param dataSource the JDBC DataSource to use for retrieving meta-data\n\t * @param context the class that holds configuration and meta-data\n\t * @return instance of the CallMetaDataProvider implementation to be used\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "CallMetaDataProvider",
    "signature": "public CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context)",
    "source_code": "\tpublic static CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context) {\n\t\ttry {\n\t\t\treturn JdbcUtils.extractDatabaseMetaData(dataSource, databaseMetaData -> {\n\t\t\t\tString databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\n\t\t\t\tboolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\n\t\t\t\tif (context.isFunction()) {\n\t\t\t\t\tif (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for function calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForFunctions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for procedure calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForProcedures);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCallMetaDataProvider provider = switch (databaseProductName) {\n\t\t\t\t\tcase ORACLE -> new OracleCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase POSTGRES -> new PostgresCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DERBY -> new DerbyCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DB2 -> new Db2CallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase HANA -> new HanaCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase MS_SQL_SERVER -> new SqlServerCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase SYBASE -> new SybaseCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tdefault -> new GenericCallMetaDataProvider(databaseMetaData);\n\t\t\t\t};\n\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using \" + provider.getClass().getName());\n\t\t\t\t}\n\t\t\t\tprovider.initializeWithMetaData(databaseMetaData);\n\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\tprovider.initializeWithProcedureColumnMetaData(databaseMetaData,\n\t\t\t\t\t\t\tcontext.getCatalogName(), context.getSchemaName(), context.getProcedureName());\n\t\t\t\t}\n\t\t\t\treturn provider;\n\t\t\t});\n\t\t}\n\t\tcatch (MetaDataAccessException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Error retrieving database meta-data\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.supportedDatabaseProductsForFunctions": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** List of supported database products for function calls. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "signature": "public List<String> supportedDatabaseProductsForFunctions",
    "source_code": "\tpublic static final List<String> supportedDatabaseProductsForFunctions = List.of(",
    "type": "List<String>"
  },
  "org.springframework.jdbc.core.metadata.supportedDatabaseProductsForProcedures": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** List of supported database products for procedure calls. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public List<String> supportedDatabaseProductsForProcedures",
    "source_code": "\tpublic static final List<String> supportedDatabaseProductsForProcedures = List.of(",
    "type": "List<String>"
  },
  "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#hasValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether this parameter source has been configured with any values.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "public boolean hasValues()",
    "source_code": "\tpublic boolean hasValues() {\n\t\treturn !this.values.isEmpty();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link SqlParameterSource} implementation that obtains parameter values\n * from bean properties of a given JavaBean object, from component accessors\n * of a record class, or from raw field access.\n *\n * <p>This is a more flexible variant of {@link BeanPropertySqlParameterSource},\n * with the limitation that it is not able to enumerate its\n * {@link #getParameterNames() parameter names}.\n *\n * <p>In terms of its fallback property discovery algorithm, this class is\n * similar to {@link org.springframework.validation.SimpleErrors} which is\n * also just used for property retrieval purposes (rather than binding).\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see NamedParameterJdbcTemplate\n * @see BeanPropertySqlParameterSource\n * @see org.springframework.jdbc.core.simple.JdbcClient.StatementSpec#paramSource(Object)\n * @see org.springframework.jdbc.core.SimplePropertyRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class SimplePropertySqlParameterSource",
    "source_code": "public class SimplePropertySqlParameterSource extends AbstractSqlParameterSource {\n\n\tprivate static final Object NO_DESCRIPTOR = new Object();\n\n\tprivate final Object paramObject;\n\n\tprivate final Map<String, Object> propertyDescriptors = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new SqlParameterSource for the given bean, record or field holder.\n\t * @param paramObject the bean, record or field holder instance to wrap\n\t */\n\tpublic SimplePropertySqlParameterSource(Object paramObject) {\n\t\tAssert.notNull(paramObject, \"Parameter object must not be null\");\n\t\tthis.paramObject = paramObject;\n\t}\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn (getDescriptor(paramName) != NO_DESCRIPTOR);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}\n\n\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see StatementCreatorUtils#javaTypeToSqlParameterType\n\t */\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(pd.getPropertyType());\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(field.getType());\n\t\t}\n\t\treturn TYPE_UNKNOWN;\n\t}\n\n\tprivate Object getDescriptor(String paramName) {\n\t\treturn this.propertyDescriptors.computeIfAbsent(paramName, name -> {\n\t\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.paramObject.getClass(), name);\n\t\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t\tField field = ReflectionUtils.findField(this.paramObject.getClass(), name);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t\treturn NO_DESCRIPTOR;\n\t\t});\n\t}\n\n}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getSqlType(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see StatementCreatorUtils#javaTypeToSqlParameterType\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getSqlType(String paramName)",
    "source_code": "\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(pd.getPropertyType());\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(field.getType());\n\t\t}\n\t\treturn TYPE_UNKNOWN;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object getValue(String paramName)",
    "source_code": "\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#hasValue(paramName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean hasValue(String paramName)",
    "source_code": "\tpublic boolean hasValue(String paramName) {\n\t\treturn (getDescriptor(paramName) != NO_DESCRIPTOR);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#list()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "List<T>",
    "signature": "public List<T> list()",
    "source_code": "\t\t\tpublic List<T> list() {\n\t\t\t\treturn namedParamOps.query(sql, namedParamSource, this.rowMapper);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#listOfRows()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Object>>",
    "signature": "public Object>> listOfRows()",
    "source_code": "\t\t\tpublic List<Map<String, Object>> listOfRows() {\n\t\t\t\treturn namedParamOps.queryForList(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value) {\n\t\t\tif (jdbcIndex < 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid JDBC index: needs to start at 1\");\n\t\t\t}\n\t\t\tvalidateIndexedParamValue(value);\n\t\t\tint index = jdbcIndex - 1;\n\t\t\tint size = this.indexedParams.size();\n\t\t\tif (index < size) {\n\t\t\t\tthis.indexedParams.set(index, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = size; i < index; i++) {\n\t\t\t\t\tthis.indexedParams.add(null);\n\t\t\t\t}\n\t\t\t\tthis.indexedParams.add(value);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType) {\n\t\t\treturn param(jdbcIndex, new SqlParameterValue(sqlType, value));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value) {\n\t\t\tthis.namedParams.addValue(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value, int sqlType) {\n\t\t\tthis.namedParams.addValue(name, value, sqlType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(@Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(@Nullable Object value) {\n\t\t\tvalidateIndexedParamValue(value);\n\t\t\tthis.indexedParams.add(value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedParamObject"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec paramSource(Object namedParamObject)",
    "source_code": "\t\tpublic StatementSpec paramSource(Object namedParamObject) {\n\t\t\tthis.namedParamSource = (namedParamObject instanceof Map map ?\n\t\t\t\t\tnew MapSqlParameterSource(map) :\n\t\t\t\t\tnew SimplePropertySqlParameterSource(namedParamObject));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namedParamSource"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec paramSource(SqlParameterSource namedParamSource)",
    "source_code": "\t\tpublic StatementSpec paramSource(SqlParameterSource namedParamSource) {\n\t\t\tthis.namedParamSource = namedParamSource;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(Map<String, ?> paramMap)",
    "source_code": "\t\tpublic StatementSpec params(Map<String, ?> paramMap) {\n\t\t\tthis.namedParams.addValues(paramMap);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(List<?> values)",
    "source_code": "\t\tpublic StatementSpec params(List<?> values) {\n\t\t\tthis.indexedParams.addAll(values);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ResultQuerySpec",
    "signature": "public ResultQuerySpec query()",
    "source_code": "\t\tpublic ResultQuerySpec query() {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnew NamedParamResultQuerySpec() :\n\t\t\t\t\tnew IndexedParamResultQuerySpec());\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "MappedQuerySpec<T>",
    "signature": "public MappedQuerySpec<T> query(Class<T> mappedClass)",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(Class<T> mappedClass) {\n\t\t\tRowMapper<?> rowMapper = rowMapperCache.computeIfAbsent(mappedClass, key ->\n\t\t\t\t\tBeanUtils.isSimpleProperty(mappedClass) ? new SingleColumnRowMapper<>(mappedClass) :\n\t\t\t\t\t\t\tnew SimplePropertyRowMapper<>(mappedClass));\n\t\t\treturn query((RowMapper<T>) rowMapper);\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void query(RowCallbackHandler rch)",
    "source_code": "\t\tpublic void query(RowCallbackHandler rch) {\n\t\t\tif (useNamedParams()) {\n\t\t\t\tnamedParamOps.query(this.sql, this.namedParamSource, rch);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclassicOps.query(getPreparedStatementCreatorForIndexedParams(), rch);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "MappedQuerySpec<T>",
    "signature": "public MappedQuerySpec<T> query(RowMapper<T> rowMapper)",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(RowMapper<T> rowMapper) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnew NamedParamMappedQuerySpec<>(rowMapper) :\n\t\t\t\t\tnew IndexedParamMappedQuerySpec<>(rowMapper));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#query(rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "T",
    "signature": "public T query(ResultSetExtractor<T> rse)",
    "source_code": "\t\tpublic <T> T query(ResultSetExtractor<T> rse) {\n\t\t\tT result = (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.query(this.sql, this.namedParamSource, rse) :\n\t\t\t\t\tclassicOps.query(getPreparedStatementCreatorForIndexedParams(), rse));\n\t\t\tAssert.state(result != null, \"No result from ResultSetExtractor\");\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#rowSet()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet rowSet()",
    "source_code": "\t\t\tpublic SqlRowSet rowSet() {\n\t\t\t\treturn namedParamOps.queryForRowSet(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#singleColumn()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "List<Object>",
    "signature": "public List<Object> singleColumn()",
    "source_code": "\t\t\tpublic List<Object> singleColumn() {\n\t\t\t\treturn namedParamOps.queryForList(sql, namedParamSource, Object.class);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#singleRow()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object>",
    "signature": "public Object> singleRow()",
    "source_code": "\t\t\tpublic Map<String, Object> singleRow() {\n\t\t\t\treturn namedParamOps.queryForMap(sql, namedParamSource);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#sql(sql)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec sql(String sql)",
    "source_code": "\tpublic StatementSpec sql(String sql) {\n\t\treturn new DefaultStatementSpec(sql);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#stream()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> stream()",
    "source_code": "\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn namedParamOps.queryForStream(sql, namedParamSource, this.rowMapper);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "int",
    "signature": "public int update()",
    "source_code": "\t\tpublic int update() {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource) :\n\t\t\t\t\tclassicOps.update(getPreparedStatementCreatorForIndexedParams()));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update(generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "int",
    "signature": "public int update(KeyHolder generatedKeyHolder)",
    "source_code": "\t\tpublic int update(KeyHolder generatedKeyHolder) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource, generatedKeyHolder) :\n\t\t\t\t\tclassicOps.update(getPreparedStatementCreatorForIndexedParams(true), generatedKeyHolder));\n\t\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,"
  },
  "org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(script,separator,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the internal state of this {@code AbstractRoutingDataSource}\n\t * by resolving the configured target DataSources.\n\t * @throws IllegalArgumentException if the target DataSources have not been configured\n\t * @since 6.1\n\t * @see #setTargetDataSources(Map)\n\t * @see #setDefaultTargetDataSource(Object)\n\t * @see #getResolvedDataSources()\n\t * @see #getResolvedDefaultDataSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\tif (this.targetDataSources == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'targetDataSources' is required\");\n\t\t}\n\t\tthis.resolvedDataSources = CollectionUtils.newHashMap(this.targetDataSources.size());\n\t\tthis.targetDataSources.forEach((key, value) -> {\n\t\t\tObject lookupKey = resolveSpecifiedLookupKey(key);\n\t\t\tDataSource dataSource = resolveSpecifiedDataSource(value);\n\t\t\tthis.resolvedDataSources.put(lookupKey, dataSource);\n\t\t});\n\t\tif (this.defaultTargetDataSource != null) {\n\t\t\tthis.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.JdbcUtils#convertPropertyNameToUnderscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a property name using \"camelCase\" to a corresponding column name with underscores.\n\t * A name like \"customerNumber\" would match a \"customer_number\" column name.\n\t * @param name the property name to be converted\n\t * @return the column name using underscores\n\t * @since 6.1\n\t * @see #convertUnderscoreNameToPropertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "String",
    "signature": "public String convertPropertyNameToUnderscoreName(@Nullable String name)",
    "source_code": "\tpublic static String convertPropertyNameToUnderscoreName(@Nullable String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.jms.connection.ConnectionFactoryUtils#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "void",
    "signature": "public void afterCompletion(int status)",
    "source_code": "\t\tpublic void afterCompletion(int status) {\n\t\t\tif (status == STATUS_COMMITTED && this.transacted && !this.commitProcessed) {\n\t\t\t\t// JmsResourceSynchronization registered in afterCommit phase of other synchronization\n\t\t\t\t// -> late local JMS transaction commit here, otherwise it would silently get dropped.\n\t\t\t\tafterCommit();\n\t\t\t}\n\t\t\tsuper.afterCompletion(status);\n\t\t}"
  },
  "org.springframework.jms.connection.JmsTransactionManager#flush()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "void",
    "signature": "public void flush()",
    "source_code": "\t\tpublic void flush() {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether there is currently an underlying connection.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\tsynchronized (this.connectionMonitor) {\n\t\t\treturn (this.connection != null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the underlying shared connection on start.\n\t * @since 6.1\n\t * @see #initConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\ttry {\n\t\t\tinitConnection();\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tlogger.info(\"Start attempt failed for shared JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.SingleConnectionFactory#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the underlying shared connection on stop.\n\t * @since 6.1\n\t * @see #resetConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tresetConnection();\n\t}"
  },
  "org.springframework.jms.core.JmsTemplate#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObservationRegistry} to use for recording JMS observations.\n\t * @param observationRegistry the observation registry to use.\n\t * @since 6.1\n\t * @see io.micrometer.jakarta9.instrument.jms.JmsInstrumentation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "void",
    "signature": "public void setObservationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ObservationRegistry} used for recording\n\t * {@link JmsObservationDocumentation#JMS_MESSAGE_PROCESS JMS message processing observations}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.jms.listener.AbstractMessageListenerContainer#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link ObservationRegistry} to be used for recording\n\t * {@link JmsObservationDocumentation#JMS_MESSAGE_PROCESS JMS message processing observations}.\n\t * Defaults to no-op observations if the registry is not set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 594
    },
    "return": "void",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerMethod return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new HandlerMethodParameter(-1);\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn Void.TYPE.equals(getReturnType().getParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethod#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}"
  },
  "org.springframework.messaging.handler.HandlerMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with HandlerMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "signature": "protected class HandlerMethodParameter",
    "source_code": "\tprotected class HandlerMethodParameter extends SynthesizingMethodParameter {\n\n\t\tpublic HandlerMethodParameter(int index) {\n\t\t\tsuper(HandlerMethod.this.bridgedMethod, index);\n\t\t}\n\n\t\tprotected HandlerMethodParameter(HandlerMethodParameter original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn HandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic HandlerMethodParameter clone() {\n\t\t\treturn new HandlerMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.OrderedMessageChannelDecorator#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.handledCount == null || this.handledCount.addAndGet(1) == subscriberCount) {\n\t\t\t\tif (OrderedMessageChannelDecorator.this.removeMessage(this.message)) {\n\t\t\t\t\tsendNextMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.OrderedMessageChannelDecorator#supportsOrderedMessages(channel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the channel has been {@link #configureInterceptor configured}\n\t * with an interceptor for sequential handling.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean supportsOrderedMessages(MessageChannel channel)",
    "source_code": "\tpublic static boolean supportsOrderedMessages(MessageChannel channel) {\n\t\treturn (channel instanceof ExecutorSubscribableChannel ch &&\n\t\t\t\tch.getInterceptors().stream().anyMatch(CallbackTaskInterceptor.class::isInstance));\n\t}"
  },
  "org.springframework.mock.http.client.MockClientHttpResponse#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}"
  },
  "org.springframework.orm.jpa.vendor.HibernateJpaDialect#setJdbcExceptionTranslator(exceptionTranslator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JDBC exception translator for Hibernate exception translation purposes.\n\t * <p>Applied to any detected {@link java.sql.SQLException} root cause of a Hibernate\n\t * {@link JDBCException}, overriding Hibernate's own {@code SQLException} translation\n\t * (which is based on a Hibernate Dialect for a specific target database).\n\t * <p>As of 6.1, also applied to {@link org.hibernate.TransactionException} translation\n\t * with a {@link SQLException} root cause (where Hibernate does not translate itself\n\t * at all), overriding Spring's default {@link SQLExceptionSubclassTranslator} there.\n\t * @param exceptionTranslator the {@link SQLExceptionTranslator} to delegate to, or\n\t * {@code null} for none. By default, a {@link SQLExceptionSubclassTranslator} will\n\t * be used for {@link org.hibernate.TransactionException} translation as of 6.1;\n\t * this can be reverted to pre-6.1 behavior through setting {@code null} here.\n\t * @since 5.1\n\t * @see java.sql.SQLException\n\t * @see org.hibernate.JDBCException\n\t * @see org.springframework.jdbc.support.SQLExceptionSubclassTranslator\n\t * @see org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionTranslator"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setJdbcExceptionTranslator(@Nullable SQLExceptionTranslator exceptionTranslator)",
    "source_code": "\tpublic void setJdbcExceptionTranslator(@Nullable SQLExceptionTranslator exceptionTranslator) {\n\t\tthis.jdbcExceptionTranslator = exceptionTranslator;\n\t\tthis.transactionExceptionTranslator = exceptionTranslator;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.HibernateJpaDialect#setJdbcExceptionTranslator(jdbcExceptionTranslator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JDBC exception translator for Hibernate exception translation purposes.\n\t * <p>Applied to any detected {@link java.sql.SQLException} root cause of a Hibernate\n\t * {@link JDBCException}, overriding Hibernate's own {@code SQLException} translation\n\t * (which is based on a Hibernate Dialect for a specific target database).\n\t * @since 5.1\n\t * @see java.sql.SQLException\n\t * @see org.hibernate.JDBCException\n\t * @see org.springframework.jdbc.support.SQLExceptionSubclassTranslator\n\t * @see org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcExceptionTranslator"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setJdbcExceptionTranslator(SQLExceptionTranslator jdbcExceptionTranslator)",
    "source_code": "\tpublic void setJdbcExceptionTranslator(SQLExceptionTranslator jdbcExceptionTranslator) {\n\t\tthis.jdbcExceptionTranslator = jdbcExceptionTranslator;\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.AbstractRoutingConnectionFactory#initialize()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the internal state of this {@code AbstractRoutingConnectionFactory}\n\t * by resolving the configured target ConnectionFactories.\n\t * @throws IllegalArgumentException if the target ConnectionFactories have not\n\t * been configured\n\t * @since 6.1\n\t * @see #setTargetConnectionFactories(Map)\n\t * @see #setDefaultTargetConnectionFactory(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void initialize()",
    "source_code": "\tpublic void initialize() {\n\t\tAssert.notNull(this.targetConnectionFactories, \"Property 'targetConnectionFactories' must not be null\");\n\n\t\tthis.resolvedConnectionFactories = CollectionUtils.newHashMap(this.targetConnectionFactories.size());\n\t\tthis.targetConnectionFactories.forEach((key, value) -> {\n\t\t\tObject lookupKey = resolveSpecifiedLookupKey(key);\n\t\t\tConnectionFactory connectionFactory = resolveSpecifiedConnectionFactory(value);\n\t\t\tthis.resolvedConnectionFactories.put(lookupKey, connectionFactory);\n\t\t});\n\n\t\tif (this.defaultTargetConnectionFactory != null) {\n\t\t\tthis.resolvedDefaultConnectionFactory = resolveSpecifiedConnectionFactory(this.defaultTargetConnectionFactory);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindProperties(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bindProperties(Object source)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bindProperties(Object source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(source.getClass())) {\n\t\t\t\tif (pd.getReadMethod() != null && pd.getReadMethod().getDeclaringClass() != Object.class) {\n\t\t\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\t\t\tObject value = ReflectionUtils.invokeMethod(pd.getReadMethod(), source);\n\t\t\t\t\tbyName.put(pd.getName(), (value != null ? Parameters.in(value) : Parameters.in(pd.getPropertyType())));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindValues(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "GenericExecuteSpec",
    "signature": "public GenericExecuteSpec bindValues(Map<String, ?> source)",
    "source_code": "\t\tpublic GenericExecuteSpec bindValues(Map<String, ?> source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> target = new LinkedHashMap<>(this.byName);\n\t\t\tsource.forEach((name, value) -> target.put(name, resolveParameter(value)));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, target, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#mapProperties(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> mapProperties(Class<R> mappedClass)",
    "source_code": "\t\tpublic <R> FetchSpec<R> mapProperties(Class<R> mappedClass) {\n\t\t\tAssert.notNull(mappedClass, \"Mapped class must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(new DataClassRowMapper<R>(mappedClass)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#mapValue(mappedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "RowsFetchSpec<R>",
    "signature": "public RowsFetchSpec<R> mapValue(Class<R> mappedClass)",
    "source_code": "\t\tpublic <R> RowsFetchSpec<R> mapValue(Class<R> mappedClass) {\n\t\t\tAssert.notNull(mappedClass, \"Mapped class must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(row -> row.get(0, mappedClass)));\n\t\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Mapping {@code Function} implementation that converts an R2DBC {@link Readable}\n * (a {@link Row} or {@link OutParameters}) into a new instance of the specified mapped\n * target class. The mapped target class must be a top-level class or {@code static}\n * nested class, and it must have a default or no-arg constructor.\n *\n * <p>{@code Readable} component values are mapped based on matching the column\n * name (as obtained from R2DBC meta-data) to public setters in the target class\n * for the corresponding properties. The names are matched either directly or by\n * transforming a name separating the parts with underscores to the same name using\n * \"camel\" case.\n *\n * <p>Mapping is provided for properties in the target class for many common types &mdash;\n * for example: String, boolean, Boolean, byte, Byte, short, Short, int, Integer,\n * long, Long, float, Float, double, Double, BigDecimal, {@code java.util.Date}, etc.\n *\n * <p>To facilitate mapping between columns and properties that don't have matching\n * names, try using column aliases in the SQL statement like\n * {@code \"select fname as first_name from customer\"}, where {@code first_name}\n * can be mapped to a {@code setFirstName(String)} method in the target class.\n *\n * <p>If you need to map to a target class which has a <em>data class</em> constructor\n * &mdash; for example, a Java {@code record} or a Kotlin {@code data} class &mdash;\n * use {@link DataClassRowMapper} instead.\n *\n * <p>Please note that this class is designed to provide convenience rather than\n * high performance. For best performance, consider using a custom mapping function\n * implementation.\n *\n * @author Simon Basl\u00e9\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @param <T> the result type\n * @see DataClassRowMapper\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public class BeanPropertyRowMapper",
    "source_code": "public class BeanPropertyRowMapper<T> implements Function<Readable, T> {\n\n\t/** The class we are mapping to. */\n\tprivate final Class<T> mappedClass;\n\n\t/** ConversionService for binding result values to bean properties. */\n\tprivate final ConversionService conversionService;\n\n\t/** Map of the properties we provide mapping for. */\n\tprivate final Map<String, PropertyDescriptor> mappedProperties;\n\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass) {\n\t\tthis(mappedClass, DefaultConversionService.getSharedInstance());\n\t}\n\n\t/**\n\t * Create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService a {@link ConversionService} for binding\n\t * result values to bean properties\n\t */\n\tpublic BeanPropertyRowMapper(Class<T> mappedClass, ConversionService conversionService) {\n\t\tAssert.notNull(mappedClass, \"Mapped Class must not be null\");\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tthis.mappedClass = mappedClass;\n\t\tthis.conversionService = conversionService;\n\t\tthis.mappedProperties = new HashMap<>();\n\n\t\tfor (PropertyDescriptor pd : BeanUtils.getPropertyDescriptors(mappedClass)) {\n\t\t\tif (pd.getWriteMethod() != null) {\n\t\t\t\tString lowerCaseName = lowerCaseName(pd.getName());\n\t\t\t\tthis.mappedProperties.put(lowerCaseName, pd);\n\t\t\t\tString underscoreName = underscoreName(pd.getName());\n\t\t\t\tif (!lowerCaseName.equals(underscoreName)) {\n\t\t\t\t\tthis.mappedProperties.put(underscoreName, pd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */\n\tprotected void suppressProperty(String propertyName) {\n\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t}\n\n\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */\n\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}\n\n\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */\n\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */\n\t@Override\n\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}\n\n\tprivate <R extends Readable> T mapForReadable(R readable, List<? extends ReadableMetadata> readableMetadatas) {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tbw.setConversionService(this.conversionService);\n\t\tT mappedObject = constructMappedInstance(readable, readableMetadatas, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tint readableItemCount = readableMetadatas.size();\n\t\tfor (int itemIndex = 0; itemIndex < readableItemCount; itemIndex++) {\n\t\t\tReadableMetadata itemMetadata = readableMetadatas.get(itemIndex);\n\t\t\tString itemName = itemMetadata.getName();\n\t\t\tString property = lowerCaseName(StringUtils.delete(itemName, \" \"));\n\t\t\tPropertyDescriptor pd = this.mappedProperties.get(property);\n\t\t\tif (pd != null) {\n\t\t\t\tObject value = getItemValue(readable, itemIndex, pd.getPropertyType());\n\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}\n\n\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */\n\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}\n\n\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */\n\t@Nullable\n\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#apply(readable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readable"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "T",
    "signature": "public T apply(Readable readable)",
    "source_code": "\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#constructMappedInstance(readable,itemMetadatas,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemMetadatas",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#getItemValue(readable,itemIndex,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#lowerCaseName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given name to lower case.\n\t * <p>By default, conversions will happen within the US locale.\n\t * @param name the original name\n\t * @return the converted name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "String",
    "signature": "protected String lowerCaseName(String name)",
    "source_code": "\tprotected String lowerCaseName(String name) {\n\t\treturn name.toLowerCase(Locale.US);\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#suppressProperty(propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the specified property from the mapped properties.\n\t * @param propertyName the property name (as used by property descriptors)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "protected void suppressProperty(String propertyName)",
    "source_code": "\tprotected void suppressProperty(String propertyName) {\n\t\tthis.mappedProperties.remove(lowerCaseName(propertyName));\n\t\tthis.mappedProperties.remove(underscoreName(propertyName));\n\t}"
  },
  "org.springframework.r2dbc.core.BeanPropertyRowMapper#underscoreName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a name in camelCase to an underscored name in lower case.\n\t * <p>Any upper case letters are converted to lower case with a preceding underscore.\n\t * @param name the original name\n\t * @return the converted name\n\t * @see #lowerCaseName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "protected String underscoreName(String name)",
    "source_code": "\tprotected String underscoreName(String name) {\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(Character.toLowerCase(name.charAt(0)));\n\t\tfor (int i = 1; i < name.length(); i++) {\n\t\t\tchar c = name.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tresult.append('_').append(Character.toLowerCase(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createSubscriptionRunnable(method,targetBean,scheduled,observationRegistrySupplier,subscriptionTrackerRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the Scheduled infrastructure, allowing for scheduled\n\t * subscription to the publisher produced by a reactive method.\n\t * <p>Note that the reactive method is invoked once, but the resulting {@code Publisher}\n\t * is subscribed to repeatedly, once per each invocation of the {@code Runnable}.\n\t * <p>In the case of a fixed-delay configuration, the subscription inside the\n\t * {@link Runnable} is turned into a blocking call in order to maintain fixed-delay\n\t * semantics (i.e. the task blocks until completion of the Publisher, and the\n\t * delay is applied until the next iteration).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetBean",
      "scheduled",
      "observationRegistrySupplier",
      "subscriptionTrackerRegistry"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Runnable",
    "signature": "public Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry)",
    "source_code": "\tpublic static Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,"
  },
  "org.springframework.scheduling.annotation.<unknown>#getQualifier()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getQualifier()",
    "source_code": "\t\tpublic String getQualifier() {\n\t\t\treturn this.qualifier;\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#isReactive(method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks that if the method is reactive, it can be scheduled. Methods are considered\n\t * eligible for reactive scheduling if they either return an instance of a type that\n\t * can be converted to {@code Publisher} or are a Kotlin suspending function.\n\t * If the method doesn't match these criteria, this check returns {@code false}.\n\t * <p>For scheduling of Kotlin suspending functions, the Coroutine-Reactor bridge\n\t * {@code kotlinx.coroutines.reactor} must be present at runtime (in order to invoke\n\t * suspending functions as a {@code Publisher}). Provided that is the case, this\n\t * method returns {@code true}. Otherwise, it throws an {@code IllegalStateException}.\n\t * @throws IllegalStateException if the method is reactive but Reactor and/or the\n\t * Kotlin coroutines bridge are not present at runtime\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean isReactive(Method method)",
    "source_code": "\tpublic static boolean isReactive(Method method) {\n\t\tif (KotlinDetector.isKotlinPresent() && KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t// Note that suspending functions declared without args have a single Continuation\n\t\t\t// parameter in reflective inspection\n\t\t\tAssert.isTrue(method.getParameterCount() == 1,\n\t\t\t\t\t\"Kotlin suspending functions may only be annotated with @Scheduled if declared without arguments\");\n\t\t\tAssert.isTrue(coroutinesReactorPresent, \"Kotlin suspending functions may only be annotated with \" +\n\t\t\t\t\t\"@Scheduled if the Coroutine-Reactor bridge (kotlinx.coroutines.reactor) is present at runtime\");\n\t\t\treturn true;\n\t\t}\n\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\tif (!registry.hasAdapters()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> returnType = method.getReturnType();\n\t\tReactiveAdapter candidateAdapter = registry.getAdapter(returnType);\n\t\tif (candidateAdapter == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0,\n\t\t\t\t\"Reactive methods may only be annotated with @Scheduled if declared without arguments\");\n\t\tAssert.isTrue(candidateAdapter.getDescriptor().isDeferred(),\n\t\t\t\t\"Reactive methods may only be annotated with @Scheduled if the return type supports deferred execution\");\n\t\treturn true;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onComplete()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "void",
    "signature": "public void onComplete()",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.subscriptionTrackerRegistry.remove(this);\n\t\t\tif (this.observation.getContext() instanceof ScheduledTaskObservationContext context) {\n\t\t\t\tcontext.setComplete(true);\n\t\t\t}\n\t\t\tthis.observation.stop();\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onError(ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "public void onError(Throwable ex)",
    "source_code": "\t\tpublic void onError(Throwable ex) {\n\t\t\tthis.subscriptionTrackerRegistry.remove(this);\n\t\t\tlogger.warn(\"Unexpected error occurred in scheduled reactive task\", ex);\n\t\t\tthis.observation.error(ex);\n\t\t\tthis.observation.stop();\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onNext(obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void onNext(Object obj)",
    "source_code": "\t\tpublic void onNext(Object obj) {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#onSubscribe(subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void onSubscribe(Subscription subscription)",
    "source_code": "\t\tpublic void onSubscribe(Subscription subscription) {\n\t\t\tthis.subscription = subscription;\n\t\t\tthis.observation.start();\n\t\t\tsubscription.request(Integer.MAX_VALUE);\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#run()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void run()",
    "source_code": "\t\tpublic void run() {\n\t\t\tif (this.subscription != null) {\n\t\t\t\tthis.subscription.cancel();\n\t\t\t\tthis.observation.stop();\n\t\t\t}\n\t\t\tif (this.blockingLatch != null) {\n\t\t\t\tthis.blockingLatch.countDown();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#createRunnable(target,method,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method, @Nullable String qualifier)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method, @Nullable String qualifier) {\n\t\tRunnable runnable = createRunnable(target, method);\n\t\tif (runnable != null) {\n\t\t\treturn runnable;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod, qualifier, this.registrar::getObservationRegistry);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An after-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param task the task that has been executed\n\t * @param ex the exception thrown during execution, if any\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#afterExecute(Runnable, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, @Nullable Throwable ex)",
    "source_code": "\tprotected void afterExecute(Runnable task, @Nullable Throwable ex) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.afterExecute();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A before-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param thread the thread to run the task\n\t * @param task the task to be executed\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#beforeExecute(Thread, Runnable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.beforeExecute(thread);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the lifecycle phase for pausing and resuming this executor.\n\t * @since 6.1\n\t * @see #setPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initiateShutdown()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initiate a shutdown on the underlying ExecutorService,\n\t * rejecting further task submissions.\n\t * <p>The executor will not accept further tasks and will prevent further\n\t * scheduling of periodic tasks, letting existing tasks complete still.\n\t * This step is non-blocking and can be applied as an early shutdown signal\n\t * before following up with a full {@link #shutdown()} call later on.\n\t * @since 6.1\n\t * @see #shutdown()\n\t * @see java.util.concurrent.ExecutorService#shutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void initiateShutdown()",
    "source_code": "\tpublic void initiateShutdown() {\n\t\tif (this.executor != null) {\n\t\t\tthis.executor.shutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this executor is not paused and has not been shut down either.\n\t * @since 6.1\n\t * @see #start()\n\t * @see #stop()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn (this.lifecycleDelegate != null && this.lifecycleDelegate.isRunning());\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@link ContextClosedEvent} handler for initiating an early shutdown.\n\t * @since 6.1\n\t * @see #initiateShutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextClosedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext && !this.acceptTasksAfterContextClose) {\n\t\t\t// Early shutdown signal: accept no further tasks, let existing tasks complete\n\t\t\t// before hitting the actual destruction step in the shutdown() method above.\n\t\t\tinitiateShutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAcceptTasksAfterContextClose(acceptTasksAfterContextClose)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to accept further tasks after the application context close phase\n\t * has begun.\n\t * <p>Default is {@code false} as of 6.1, triggering an early soft shutdown of\n\t * the executor and therefore rejecting any further task submissions. Switch this\n\t * to {@code true} in order to let other components submit tasks even during their\n\t * own destruction callbacks, at the expense of a longer shutdown phase.\n\t * This will usually go along with\n\t * {@link #setWaitForTasksToCompleteOnShutdown \"waitForTasksToCompleteOnShutdown\"}.\n\t * <p>This flag will only have effect when the executor is running in a Spring\n\t * application context and able to receive the {@link ContextClosedEvent}.\n\t * @since 6.1\n\t * @see org.springframework.context.ConfigurableApplicationContext#close()\n\t * @see DisposableBean#destroy()\n\t * @see #shutdown()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptTasksAfterContextClose"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose)",
    "source_code": "\tpublic void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose) {\n\t\tthis.acceptTasksAfterContextClose = acceptTasksAfterContextClose;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @since 6.1\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#start()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resume this executor if paused before (otherwise a no-op).\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.start();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Pause this executor, not waiting for tasks to complete.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.stop();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Pause this executor, triggering the given callback\n\t * once all currently executing tasks have completed.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.stop(callback);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tScheduledExecutorFactoryBean.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tScheduledExecutorFactoryBean.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple implementation of Spring's {@link TaskScheduler} interface, using\n * a single scheduler thread and executing every scheduled task in an individual\n * separate thread. This is an attractive choice with virtual threads on JDK 21,\n * expecting common usage with {@link #setVirtualThreads setVirtualThreads(true)}.\n *\n * <p><b>NOTE: Scheduling with a fixed delay enforces execution on the single\n * scheduler thread, in order to provide traditional fixed-delay semantics!</b>\n * Prefer the use of fixed rates or cron triggers instead which are a better fit\n * with this thread-per-task scheduler variant.\n *\n * <p>Supports a graceful shutdown through {@link #setTaskTerminationTimeout},\n * at the expense of task tracking overhead per execution thread at runtime.\n * Supports limiting concurrent threads through {@link #setConcurrencyLimit}.\n * By default, the number of concurrent task executions is unlimited.\n * This allows for dynamic concurrency of scheduled task executions, in contrast\n * to {@link ThreadPoolTaskScheduler} which requires a fixed pool size.\n *\n * <p><b>NOTE: This implementation does not reuse threads!</b> Consider a\n * thread-pooling TaskScheduler implementation instead, in particular for\n * scheduling a large number of short-lived tasks. Alternatively, on JDK 21,\n * consider setting {@link #setVirtualThreads} to {@code true}.\n *\n * <p>Extends {@link SimpleAsyncTaskExecutor} and can serve as a fully capable\n * replacement for it, e.g. as a single shared instance serving as a\n * {@link org.springframework.core.task.TaskExecutor} as well as a {@link TaskScheduler}.\n * This is generally not the case with other executor/scheduler implementations\n * which tend to have specific constraints for the scheduler thread pool,\n * requiring a separate thread pool for general executor purposes in practice.\n *\n * <p>As an alternative to the built-in thread-per-task capability, this scheduler\n * can also be configured with a separate target executor for scheduled task\n * execution through {@link #setTargetTaskExecutor}: e.g. pointing to a shared\n * {@link ThreadPoolTaskExecutor} bean. This is still rather different from a\n * {@link ThreadPoolTaskScheduler} setup since it always uses a single scheduler\n * thread while dynamically dispatching to the target thread pool which may have\n * a dynamic core/max pool size range, participating in a shared concurrency limit.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #setVirtualThreads\n * @see #setTaskTerminationTimeout\n * @see #setConcurrencyLimit\n * @see SimpleAsyncTaskExecutor\n * @see ThreadPoolTaskScheduler\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public class SimpleAsyncTaskScheduler",
    "source_code": "public class SimpleAsyncTaskScheduler extends SimpleAsyncTaskExecutor implements TaskScheduler,"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tlifecycleDelegate.afterExecute();\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tlifecycleDelegate.beforeExecute(thread);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\tpublic void close() {\n\t\tfor (Runnable remainingTask : this.scheduledExecutor.shutdownNow()) {\n\t\t\tif (remainingTask instanceof Future<?> future) {\n\t\t\t\tfuture.cancel(true);\n\t\t\t}\n\t\t}\n\t\tsuper.close();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#doExecute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "protected void doExecute(Runnable task)",
    "source_code": "\tprotected void doExecute(Runnable task) {\n\t\tif (this.targetTaskExecutor != null) {\n\t\t\tthis.targetTaskExecutor.execute(task);\n\t\t}\n\t\telse {\n\t\t\tsuper.doExecute(task);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#getClock()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Clock",
    "signature": "public Clock getClock()",
    "source_code": "\tpublic Clock getClock() {\n\t\treturn this.clock;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#getPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the lifecycle phase for pausing and resuming this executor.\n\t * @see #setPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "int",
    "signature": "public int getPhase()",
    "source_code": "\tpublic int getPhase() {\n\t\treturn this.phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#isRunning()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "boolean",
    "signature": "public boolean isRunning()",
    "source_code": "\tpublic boolean isRunning() {\n\t\treturn this.lifecycleDelegate.isRunning();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#onApplicationEvent(event)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "void",
    "signature": "public void onApplicationEvent(ContextClosedEvent event)",
    "source_code": "\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tthis.scheduledExecutor.shutdown();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setApplicationContext(applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setClock(clock)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the clock to use for scheduling purposes.\n\t * <p>The default clock is the system clock for the default time zone.\n\t * @since 5.3\n\t * @see Clock#systemDefaultZone()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clock"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void setClock(Clock clock)",
    "source_code": "\tpublic void setClock(Clock clock) {\n\t\tthis.clock = clock;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setPhase(phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setPhase(int phase)",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setTargetTaskExecutor(targetTaskExecutor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify a custom target {@link Executor} to delegate to for\n\t * the individual execution of scheduled tasks. This can for example\n\t * be set to a separate thread pool for executing scheduled tasks,\n\t * whereas this scheduler keeps using its single scheduler thread.\n\t * <p>If not set, the regular {@link SimpleAsyncTaskExecutor}\n\t * arrangements kicks in with a new thread per task.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetTaskExecutor"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void setTargetTaskExecutor(Executor targetTaskExecutor)",
    "source_code": "\tpublic void setTargetTaskExecutor(Executor targetTaskExecutor) {\n\t\tthis.targetTaskExecutor = (targetTaskExecutor == this ? null : targetTaskExecutor);\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#start()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "void",
    "signature": "public void start()",
    "source_code": "\tpublic void start() {\n\t\tthis.lifecycleDelegate.start();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#stop()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "public void stop()",
    "source_code": "\tpublic void stop() {\n\t\tthis.lifecycleDelegate.stop();\n\t}"
  },
  "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#stop(callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "void",
    "signature": "public void stop(Runnable callback)",
    "source_code": "\tpublic void stop(Runnable callback) {\n\t\tthis.lifecycleDelegate.stop(callback);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskExecutor.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskExecutor.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskScheduler.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskScheduler.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.config.DEFAULT_TASK_SCHEDULER_BEAN_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "signature": "public String DEFAULT_TASK_SCHEDULER_BEAN_NAME",
    "source_code": "\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";",
    "type": "String"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addFixedDelayTask(task,delay)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "delay"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration delay)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration delay) {\n\t\taddFixedDelayTask(new IntervalTask(task, delay));\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addFixedDelayTask(task,interval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration interval)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration interval) {\n\t\taddFixedDelayTask(new IntervalTask(task, interval));\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addOneTimeTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a one-time {@link DelayedTask}.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t * @see OneTimeTask\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "public void addOneTimeTask(DelayedTask task)",
    "source_code": "\tpublic void addOneTimeTask(DelayedTask task) {\n\t\tif (this.oneTimeTasks == null) {\n\t\t\tthis.oneTimeTasks = new ArrayList<>();\n\t\t}\n\t\tthis.oneTimeTasks.add(task);\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#addOneTimeTask(task,initialDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered once after the given initial delay.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "initialDelay"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void addOneTimeTask(Runnable task, Duration initialDelay)",
    "source_code": "\tpublic void addOneTimeTask(Runnable task, Duration initialDelay) {\n\t\taddOneTimeTask(new OneTimeTask(task, initialDelay));\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link ObservationRegistry} for this registrar.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#scheduleOneTimeTask(task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Schedule the specified one-time task, either right away if possible\n\t * or on initialization of the scheduler.\n\t * @return a handle to the scheduled task, allowing to cancel it\n\t * (or {@code null} if processing a previously registered task)\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 607
    },
    "return": "ScheduledTask",
    "signature": "public ScheduledTask scheduleOneTimeTask(OneTimeTask task)",
    "source_code": "\tpublic ScheduledTask scheduleOneTimeTask(OneTimeTask task) {\n\t\tScheduledTask scheduledTask = this.unresolvedTasks.remove(task);\n\t\tboolean newTask = false;\n\t\tif (scheduledTask == null) {\n\t\t\tscheduledTask = new ScheduledTask(task);\n\t\t\tnewTask = true;\n\t\t}\n\t\tif (this.taskScheduler != null) {\n\t\t\tInstant startTime = this.taskScheduler.getClock().instant().plus(task.getInitialDelayDuration());\n\t\t\tscheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), startTime);\n\t\t}\n\t\telse {\n\t\t\taddOneTimeTask(task);\n\t\t\tthis.unresolvedTasks.put(task, scheduledTask);\n\t\t}\n\t\treturn (newTask ? scheduledTask : null);\n\t}"
  },
  "org.springframework.scheduling.config.ScheduledTaskRegistrar#setObservationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} to record observations for scheduled tasks.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A routing implementation of the {@link TaskScheduler} interface,\n * delegating to a target scheduler based on an identified qualifier\n * or using a default scheduler otherwise.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see SchedulingAwareRunnable#getQualifier()\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "signature": "public class TaskSchedulerRouter",
    "source_code": "public class TaskSchedulerRouter implements TaskScheduler, BeanNameAware, BeanFactoryAware, DisposableBean {\n\n\t/**\n\t * The default name of the {@link TaskScheduler} bean to pick up: {@value}.\n\t * <p>Note that the initial lookup happens by type; this is just the fallback\n\t * in case of multiple scheduler beans found in the context.\n\t */\n\tpublic static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \"taskScheduler\";\n\n\n\tprotected static final Log logger = LogFactory.getLog(TaskSchedulerRouter.class);\n\n\t@Nullable\n\tprivate String beanName;\n\n\t@Nullable\n\tprivate BeanFactory beanFactory;\n\n\t@Nullable\n\tprivate StringValueResolver embeddedValueResolver;\n\n\tprivate final Supplier<TaskScheduler> defaultScheduler = SingletonSupplier.of(this::determineDefaultScheduler);\n\n\t@Nullable\n\tprivate volatile ScheduledExecutorService localExecutor;\n\n\n\t/**\n\t * The bean name for this router, or the bean name of the containing\n\t * bean if the router instance is internally held.\n\t */\n\t@Override\n\tpublic void setBeanName(@Nullable String name) {\n\t\tthis.beanName = name;\n\t}\n\n\t/**\n\t * The bean factory for scheduler lookups.\n\t */\n\t@Override\n\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {\n\t\treturn determineTargetScheduler(task).schedule(task, trigger);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Instant startTime) {\n\t\treturn determineTargetScheduler(task).schedule(task, startTime);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Instant startTime, Duration period) {\n\t\treturn determineTargetScheduler(task).scheduleAtFixedRate(task, startTime, period);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleAtFixedRate(Runnable task, Duration period) {\n\t\treturn determineTargetScheduler(task).scheduleAtFixedRate(task, period);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay) {\n\t\treturn determineTargetScheduler(task).scheduleWithFixedDelay(task, startTime, delay);\n\t}\n\n\t@Override\n\tpublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, Duration delay) {\n\t\treturn determineTargetScheduler(task).scheduleWithFixedDelay(task, delay);\n\t}\n\n\n\tprotected TaskScheduler determineTargetScheduler(Runnable task) {\n\t\tString qualifier = determineQualifier(task);\n\t\tif (this.embeddedValueResolver != null && StringUtils.hasLength(qualifier)) {\n\t\t\tqualifier = this.embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\treturn determineQualifiedScheduler(qualifier);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultScheduler.get();\n\t\t}\n\t}\n\n\t@Nullable\n\tprotected String determineQualifier(Runnable task) {\n\t\treturn (task instanceof SchedulingAwareRunnable sar ? sar.getQualifier() : null);\n\t}\n\n\tprotected TaskScheduler determineQualifiedScheduler(String qualifier) {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find qualified scheduler\");\n\t\ttry {\n\t\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, TaskScheduler.class, qualifier);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException | BeanNotOfRequiredTypeException ex) {\n\t\t\treturn new ConcurrentTaskScheduler(BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tthis.beanFactory, ScheduledExecutorService.class, qualifier));\n\t\t}\n\t}\n\n\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}\n\n\tprivate <T> T resolveSchedulerBean(BeanFactory beanFactory, Class<T> schedulerType, boolean byName) {\n\t\tif (byName) {\n\t\t\tT scheduler = beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType);\n\t\t\tif (this.beanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tcbf.registerDependentBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName);\n\t\t\t}\n\t\t\treturn scheduler;\n\t\t}\n\t\telse if (beanFactory instanceof AutowireCapableBeanFactory acbf) {\n\t\t\tNamedBeanHolder<T> holder = acbf.resolveNamedBean(schedulerType);\n\t\t\tif (this.beanName != null && beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\tcbf.registerDependentBean(holder.getBeanName(), this.beanName);\n\t\t\t}\n\t\t\treturn holder.getBeanInstance();\n\t\t}\n\t\telse {\n\t\t\treturn beanFactory.getBean(schedulerType);\n\t\t}\n\t}\n\n\n\t/**\n\t * Destroy the local default executor, if any.\n\t */\n\t@Override\n\tpublic void destroy() {\n\t\tScheduledExecutorService localExecutor = this.localExecutor;\n\t\tif (localExecutor != null) {\n\t\t\tlocalExecutor.shutdownNow();\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#destroy()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the local default executor, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void destroy()",
    "source_code": "\tpublic void destroy() {\n\t\tScheduledExecutorService localExecutor = this.localExecutor;\n\t\tif (localExecutor != null) {\n\t\t\tlocalExecutor.shutdownNow();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineDefaultScheduler()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineDefaultScheduler()",
    "source_code": "\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineQualifiedScheduler(qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineQualifiedScheduler(String qualifier)",
    "source_code": "\tprotected TaskScheduler determineQualifiedScheduler(String qualifier) {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find qualified scheduler\");\n\t\ttry {\n\t\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, TaskScheduler.class, qualifier);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException | BeanNotOfRequiredTypeException ex) {\n\t\t\treturn new ConcurrentTaskScheduler(BeanFactoryAnnotationUtils.qualifiedBeanOfType(\n\t\t\t\t\tthis.beanFactory, ScheduledExecutorService.class, qualifier));\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineQualifier(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "String",
    "signature": "protected String determineQualifier(Runnable task)",
    "source_code": "\tprotected String determineQualifier(Runnable task) {\n\t\treturn (task instanceof SchedulingAwareRunnable sar ? sar.getQualifier() : null);\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#determineTargetScheduler(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "TaskScheduler",
    "signature": "protected TaskScheduler determineTargetScheduler(Runnable task)",
    "source_code": "\tprotected TaskScheduler determineTargetScheduler(Runnable task) {\n\t\tString qualifier = determineQualifier(task);\n\t\tif (this.embeddedValueResolver != null && StringUtils.hasLength(qualifier)) {\n\t\t\tqualifier = this.embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\tif (StringUtils.hasLength(qualifier)) {\n\t\t\treturn determineQualifiedScheduler(qualifier);\n\t\t}\n\t\telse {\n\t\t\treturn this.defaultScheduler.get();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanFactory(beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean factory for scheduler lookups.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The bean name for this router, or the bean name of the containing\n\t * bean if the router instance is internally held.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void setBeanName(@Nullable String name)",
    "source_code": "\tpublic void setBeanName(@Nullable String name) {\n\t\tthis.beanName = name;\n\t}"
  },
  "org.springframework.scheduling.config.logger": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected static final Log logger = LogFactory.getLog(TaskSchedulerRouter.class);",
    "type": "Log"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Date sequence generator for a\n * <a href=\"https://www.manpagez.com/man/5/crontab/\">Crontab pattern</a>,\n * allowing clients to specify a pattern that the sequence matches.\n *\n * <p>The pattern is a list of six single space-separated fields: representing\n * second, minute, hour, day, month, weekday. Month and weekday names can be\n * given as the first three letters of the English names.\n *\n * <p>Example patterns:\n * <ul>\n * <li>\"0 0 * * * *\" = the top of every hour of every day.</li>\n * <li>\"*&#47;10 * * * * *\" = every ten seconds.</li>\n * <li>\"0 0 8-10 * * *\" = 8, 9 and 10 o'clock of every day.</li>\n * <li>\"0 0 6,19 * * *\" = 6:00 AM and 7:00 PM every day.</li>\n * <li>\"0 0/30 8-10 * * *\" = 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day.</li>\n * <li>\"0 0 9-17 * * MON-FRI\" = on the hour nine-to-five weekdays</li>\n * <li>\"0 0 0 25 12 ?\" = every Christmas Day at midnight</li>\n * </ul>\n *\n * @author Dave Syer\n * @author Juergen Hoeller\n * @author Ruslan Sibgatullin\n * @since 3.0\n * @see CronTrigger\n * @deprecated as of 5.3, in favor of {@link CronExpression}\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "signature": "public class CronSequenceGenerator",
    "source_code": "public class CronSequenceGenerator {\n\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final TimeZone timeZone;\n\n\tprivate final BitSet months = new BitSet(12);\n\n\tprivate final BitSet daysOfMonth = new BitSet(31);\n\n\tprivate final BitSet daysOfWeek = new BitSet(7);\n\n\tprivate final BitSet hours = new BitSet(24);\n\n\tprivate final BitSet minutes = new BitSet(60);\n\n\tprivate final BitSet seconds = new BitSet(60);\n\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the default {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @see java.util.TimeZone#getDefault()\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated(since = \"5.3\", forRemoval = true)\n\tpublic CronSequenceGenerator(String expression) {\n\t\tthis(expression, TimeZone.getDefault());\n\t}\n\n\t/**\n\t * Construct a {@code CronSequenceGenerator} from the pattern provided,\n\t * using the specified {@link TimeZone}.\n\t * @param expression a space-separated list of time fields\n\t * @param timeZone the TimeZone to use for generated trigger times\n\t * @throws IllegalArgumentException if the pattern cannot be parsed\n\t * @deprecated as of 5.3, in favor of {@link CronExpression#parse(String)}\n\t */\n\t@Deprecated\n\tpublic CronSequenceGenerator(String expression, TimeZone timeZone) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = timeZone;\n\t\tparse(expression);\n\t}\n\n\tprivate CronSequenceGenerator(String expression, String[] fields) {\n\t\tthis.expression = expression;\n\t\tthis.timeZone = null;\n\t\tdoParse(fields);\n\t}\n\n\n\t/**\n\t * Return the cron pattern that this sequence generator has been built for.\n\t */\n\tString getExpression() {\n\t\treturn this.expression;\n\t}\n\n\n\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */\n\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}\n\n\tprivate void doNext(Calendar calendar, int dot) {\n\t\tList<Integer> resets = new ArrayList<>();\n\n\t\tint second = calendar.get(Calendar.SECOND);\n\t\tList<Integer> emptyList = Collections.emptyList();\n\t\tint updateSecond = findNext(this.seconds, second, calendar, Calendar.SECOND, Calendar.MINUTE, emptyList);\n\t\tif (second == updateSecond) {\n\t\t\tresets.add(Calendar.SECOND);\n\t\t}\n\n\t\tint minute = calendar.get(Calendar.MINUTE);\n\t\tint updateMinute = findNext(this.minutes, minute, calendar, Calendar.MINUTE, Calendar.HOUR_OF_DAY, resets);\n\t\tif (minute == updateMinute) {\n\t\t\tresets.add(Calendar.MINUTE);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint hour = calendar.get(Calendar.HOUR_OF_DAY);\n\t\tint updateHour = findNext(this.hours, hour, calendar, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_WEEK, resets);\n\t\tif (hour == updateHour) {\n\t\t\tresets.add(Calendar.HOUR_OF_DAY);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\tint dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\tint updateDayOfMonth = findNextDay(calendar, this.daysOfMonth, dayOfMonth, this.daysOfWeek, dayOfWeek, resets);\n\t\tif (dayOfMonth == updateDayOfMonth) {\n\t\t\tresets.add(Calendar.DAY_OF_MONTH);\n\t\t}\n\t\telse {\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t\tint month = calendar.get(Calendar.MONTH);\n\t\tint updateMonth = findNext(this.months, month, calendar, Calendar.MONTH, Calendar.YEAR, resets);\n\t\tif (month != updateMonth) {\n\t\t\tif (calendar.get(Calendar.YEAR) - dot > 4) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid cron expression \\\"\" + this.expression +\n\t\t\t\t\t\t\"\\\" led to runaway search for next trigger\");\n\t\t\t}\n\t\t\tdoNext(calendar, dot);\n\t\t}\n\n\t}\n\n\tprivate int findNextDay(Calendar calendar, BitSet daysOfMonth, int dayOfMonth, BitSet daysOfWeek, int dayOfWeek,\n\t\t\tList<Integer> resets) {\n\n\t\tint count = 0;\n\t\tint max = 366;\n\t\t// the DAY_OF_WEEK values in java.util.Calendar start with 1 (Sunday),\n\t\t// but in the cron pattern, they start with 0, so we subtract 1 here\n\t\twhile ((!daysOfMonth.get(dayOfMonth) || !daysOfWeek.get(dayOfWeek - 1)) && count++ < max) {\n\t\t\tcalendar.add(Calendar.DAY_OF_MONTH, 1);\n\t\t\tdayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);\n\t\t\tdayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);\n\t\t\treset(calendar, resets);\n\t\t}\n\t\tif (count >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Overflow in day for expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn dayOfMonth;\n\t}\n\n\t/**\n\t * Search the bits provided for the next set bit after the value provided,\n\t * and reset the calendar.\n\t * @param bits a {@link BitSet} representing the allowed values of the field\n\t * @param value the current value of the field\n\t * @param calendar the calendar to increment as we move through the bits\n\t * @param field the field to increment in the calendar (@see\n\t * {@link Calendar} for the static constants defining valid fields)\n\t * @param lowerOrders the Calendar field ids that should be reset (i.e. the\n\t * ones of lower significance than the field of interest)\n\t * @return the value of the calendar field that is next in the sequence\n\t */\n\tprivate int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {\n\t\tint nextValue = bits.nextSetBit(value);\n\t\t// roll over if needed\n\t\tif (nextValue == -1) {\n\t\t\tcalendar.add(nextField, 1);\n\t\t\treset(calendar, Collections.singletonList(field));\n\t\t\tnextValue = bits.nextSetBit(0);\n\t\t}\n\t\tif (nextValue != value) {\n\t\t\tcalendar.set(field, nextValue);\n\t\t\treset(calendar, lowerOrders);\n\t\t}\n\t\treturn nextValue;\n\t}\n\n\t/**\n\t * Reset the calendar setting all the fields provided to zero.\n\t */\n\tprivate void reset(Calendar calendar, List<Integer> fields) {\n\t\tfor (int field : fields) {\n\t\t\tcalendar.set(field, field == Calendar.DAY_OF_MONTH ? 1 : 0);\n\t\t}\n\t}\n\n\n\t// Parsing logic invoked by the constructor\n\n\t/**\n\t * Parse the given pattern expression.\n\t */\n\tprivate void parse(String expression) throws IllegalArgumentException {\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Cron expression must consist of 6 fields (found %d in \\\"%s\\\")\", fields.length, expression));\n\t\t}\n\t\tdoParse(fields);\n\t}\n\n\tprivate void doParse(String[] fields) {\n\t\tsetNumberHits(this.seconds, fields[0], 0, 60);\n\t\tsetNumberHits(this.minutes, fields[1], 0, 60);\n\t\tsetNumberHits(this.hours, fields[2], 0, 24);\n\t\tsetDaysOfMonth(this.daysOfMonth, fields[3]);\n\t\tsetMonths(this.months, fields[4]);\n\t\tsetDays(this.daysOfWeek, replaceOrdinals(fields[5], \"SUN,MON,TUE,WED,THU,FRI,SAT\"), 8);\n\n\t\tif (this.daysOfWeek.get(7)) {\n\t\t\t// Sunday can be represented as 0 or 7\n\t\t\tthis.daysOfWeek.set(0);\n\t\t\tthis.daysOfWeek.clear(7);\n\t\t}\n\t}\n\n\t/**\n\t * Replace the values in the comma-separated list (case-insensitive)\n\t * with their index in the list.\n\t * @return a new String with the values from the list replaced\n\t */\n\tprivate String replaceOrdinals(String value, String commaSeparatedList) {\n\t\tString[] list = StringUtils.commaDelimitedListToStringArray(commaSeparatedList);\n\t\tfor (int i = 0; i < list.length; i++) {\n\t\t\tString item = list[i].toUpperCase();\n\t\t\tvalue = StringUtils.replace(value.toUpperCase(), item, \"\" + i);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate void setDaysOfMonth(BitSet bits, String field) {\n\t\tint max = 31;\n\t\t// Days of month start with 1 (in Cron and Calendar) so add one\n\t\tsetDays(bits, field, max + 1);\n\t\t// ... and remove it from the front\n\t\tbits.clear(0);\n\t}\n\n\tprivate void setDays(BitSet bits, String field, int max) {\n\t\tif (field.contains(\"?\")) {\n\t\t\tfield = \"*\";\n\t\t}\n\t\tsetNumberHits(bits, field, 0, max);\n\t}\n\n\tprivate void setMonths(BitSet bits, String value) {\n\t\tint max = 12;\n\t\tvalue = replaceOrdinals(value, \"FOO,JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC\");\n\t\tBitSet months = new BitSet(13);\n\t\t// Months start with 1 in Cron and 0 in Calendar, so push the values first into a longer bit set\n\t\tsetNumberHits(months, value, 1, max + 1);\n\t\t// ... and then rotate it to the front of the months\n\t\tfor (int i = 1; i <= max; i++) {\n\t\t\tif (months.get(i)) {\n\t\t\t\tbits.set(i - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setNumberHits(BitSet bits, String value, int min, int max) {\n\t\tString[] fields = StringUtils.delimitedListToStringArray(value, \",\");\n\t\tfor (String field : fields) {\n\t\t\tif (!field.contains(\"/\")) {\n\t\t\t\t// Not an incrementer so it must be a range (possibly empty)\n\t\t\t\tint[] range = getRange(field, min, max);\n\t\t\t\tbits.set(range[0], range[1] + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"/\");\n\t\t\t\tif (split.length > 2) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer has more than two fields: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tint[] range = getRange(split[0], min, max);\n\t\t\t\tif (!split[0].contains(\"-\")) {\n\t\t\t\t\trange[1] = max - 1;\n\t\t\t\t}\n\t\t\t\tint delta = Integer.parseInt(split[1]);\n\t\t\t\tif (delta <= 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Incrementer delta must be 1 or higher: '\" +\n\t\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tfor (int i = range[0]; i <= range[1]; i += delta) {\n\t\t\t\t\tbits.set(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int[] getRange(String field, int min, int max) {\n\t\tint[] result = new int[2];\n\t\tif (field.contains(\"*\")) {\n\t\t\tresult[0] = min;\n\t\t\tresult[1] = max - 1;\n\t\t\treturn result;\n\t\t}\n\t\tif (!field.contains(\"-\")) {\n\t\t\tresult[0] = result[1] = Integer.parseInt(field);\n\t\t}\n\t\telse {\n\t\t\tString[] split = StringUtils.delimitedListToStringArray(field, \"-\");\n\t\t\tif (split.length > 2) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range has more than two fields: '\" +\n\t\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tresult[0] = Integer.parseInt(split[0]);\n\t\t\tresult[1] = Integer.parseInt(split[1]);\n\t\t}\n\t\tif (result[0] >= max || result[1] >= max) {\n\t\t\tthrow new IllegalArgumentException(\"Range exceeds maximum (\" + max + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] < min || result[1] < min) {\n\t\t\tthrow new IllegalArgumentException(\"Range less than minimum (\" + min + \"): '\" +\n\t\t\t\t\tfield + \"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\tif (result[0] > result[1]) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid inverted range: '\" + field +\n\t\t\t\t\t\"' in expression \\\"\" + this.expression + \"\\\"\");\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */\n\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static boolean areValidCronFields(@Nullable String[] fields) {\n\t\treturn (fields != null && fields.length == 6);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof CronSequenceGenerator that &&\n\t\t\t\tthis.months.equals(that.months) && this.daysOfMonth.equals(that.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(that.daysOfWeek) && this.hours.equals(that.hours) &&\n\t\t\t\tthis.minutes.equals(that.minutes) && this.seconds.equals(that.seconds)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}\n\n}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#equals(other)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof CronSequenceGenerator that &&\n\t\t\t\tthis.months.equals(that.months) && this.daysOfMonth.equals(that.daysOfMonth) &&\n\t\t\t\tthis.daysOfWeek.equals(that.daysOfWeek) && this.hours.equals(that.hours) &&\n\t\t\t\tthis.minutes.equals(that.minutes) && this.seconds.equals(that.seconds)));\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#hashCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (17 * this.months.hashCode() + 29 * this.daysOfMonth.hashCode() + 37 * this.daysOfWeek.hashCode() +\n\t\t\t\t41 * this.hours.hashCode() + 53 * this.minutes.hashCode() + 61 * this.seconds.hashCode());\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#isValidExpression(expression)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified expression represents a valid cron pattern.\n\t * @param expression the expression to evaluate\n\t * @return {@code true} if the given expression is a valid cron expression\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean isValidExpression(@Nullable String expression)",
    "source_code": "\tpublic static boolean isValidExpression(@Nullable String expression) {\n\t\tif (expression == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString[] fields = StringUtils.tokenizeToStringArray(expression, \" \");\n\t\tif (!areValidCronFields(fields)) {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\tnew CronSequenceGenerator(expression, fields);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#next(date)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Date",
    "signature": "public Date next(Date date)",
    "source_code": "\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}"
  },
  "org.springframework.scheduling.support.CronSequenceGenerator#toString()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \": \" + this.expression;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code MergedContextConfiguration} encapsulates the <em>merged</em> context\n * configuration declared on a test class and all of its superclasses and\n * enclosing classes via {@link ContextConfiguration @ContextConfiguration},\n * {@link ActiveProfiles @ActiveProfiles}, and\n * {@link TestPropertySource @TestPropertySource}.\n *\n * <p>Merged context resource locations, annotated classes, active profiles,\n * property resource locations, and in-lined properties represent all declared\n * values in the test class hierarchy and enclosing class hierarchy taking into\n * consideration the semantics of the {@link ContextConfiguration#inheritLocations},\n * {@link ActiveProfiles#inheritProfiles},\n * {@link TestPropertySource#inheritLocations}, and\n * {@link TestPropertySource#inheritProperties} flags.\n *\n * <p>A {@link SmartContextLoader} uses {@code MergedContextConfiguration}\n * to load an {@link org.springframework.context.ApplicationContext ApplicationContext}.\n *\n * <p>{@code MergedContextConfiguration} is also used by the\n * {@link org.springframework.test.context.cache.ContextCache ContextCache}\n * as the key for caching an\n * {@link org.springframework.context.ApplicationContext ApplicationContext}\n * that was loaded using properties of this {@code MergedContextConfiguration}.\n *\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 3.1\n * @see ContextConfiguration\n * @see ContextHierarchy\n * @see ActiveProfiles\n * @see TestPropertySource\n * @see ContextConfigurationAttributes\n * @see SmartContextLoader#loadContext(MergedContextConfiguration)\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class MergedContextConfiguration",
    "source_code": "public class MergedContextConfiguration implements Serializable {\n\n\tprivate static final long serialVersionUID = -3290560718464957422L;\n\n\tprivate static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n\tprivate static final Set<Class<? extends ApplicationContextInitializer<?>>> EMPTY_INITIALIZER_CLASSES =\n\t\t\tCollections.emptySet();\n\n\tprivate static final Set<ContextCustomizer> EMPTY_CONTEXT_CUSTOMIZERS = Collections.emptySet();\n\n\n\tprivate final Class<?> testClass;\n\n\tprivate final String[] locations;\n\n\tprivate final Class<?>[] classes;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses;\n\n\tprivate final String[] activeProfiles;\n\n\tprivate final List<PropertySourceDescriptor> propertySourceDescriptors;\n\n\tprivate final String[] propertySourceLocations;\n\n\tprivate final String[] propertySourceProperties;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final Set<ContextCustomizer> contextCustomizers;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final ContextLoader contextLoader;\n\n\t@Nullable\n\t@SuppressWarnings(\"serial\")\n\tprivate final CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate;\n\n\t@Nullable\n\tprivate final MergedContextConfiguration parent;\n\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader) {\n\n\t\tthis(testClass, locations, classes, null, activeProfiles, contextLoader);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, contextLoader, null, null);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, ContextLoader contextLoader,\n\t\t\t@Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles, null, null,\n\t\t\t\tcontextLoader, cacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance by copying\n\t * all fields from the supplied {@code MergedContextConfiguration}.\n\t * @since 4.1\n\t */\n\tpublic MergedContextConfiguration(MergedContextConfiguration mergedConfig) {\n\t\tthis(mergedConfig.testClass, mergedConfig.locations, mergedConfig.classes,\n\t\t\t\tmergedConfig.contextInitializerClasses, mergedConfig.activeProfiles,\n\t\t\t\tmergedConfig.propertySourceDescriptors, mergedConfig.propertySourceProperties,\n\t\t\t\tmergedConfig.contextCustomizers, mergedConfig.contextLoader,\n\t\t\t\tmergedConfig.cacheAwareContextLoaderDelegate, mergedConfig.parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for the\n\t * {@code contextInitializerClasses} an empty set will be stored instead.\n\t * Furthermore, active profiles will be sorted, and duplicate profiles\n\t * will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.1\n\t * @deprecated since 6.1 in favor of\n\t * {@link #MergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations,\n\t\t\t@Nullable String[] propertySourceProperties, ContextLoader contextLoader,\n\t\t\t@Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\t\tpropertySourceLocations, propertySourceProperties,\n\t\t\t\tEMPTY_CONTEXT_CUSTOMIZERS, contextLoader,\n\t\t\t\tcacheAwareContextLoaderDelegate, parent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the\n\t * supplied parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations},\n\t * {@code classes}, {@code activeProfiles}, {@code propertySourceLocations},\n\t * or {@code propertySourceProperties} an empty array will be stored instead.\n\t * If a {@code null} value is supplied for {@code contextInitializerClasses}\n\t * or {@code contextCustomizers}, an empty set will be stored instead.\n\t * Furthermore, active profiles will be sorted, and duplicate profiles\n\t * will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceLocations the merged {@code PropertySource} locations\n\t * @param propertySourceProperties the merged {@code PropertySource} properties\n\t * @param contextCustomizers the context customizers\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 4.3\n\t * @deprecated since 6.1 in favor of\n\t * {@link #MergedContextConfiguration(Class, String[], Class[], Set, String[], List, String[], Set, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, @Nullable String[] propertySourceLocations,\n\t\t\t@Nullable String[] propertySourceProperties, @Nullable Set<ContextCustomizer> contextCustomizers,\n\t\t\tContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis(testClass, locations, classes, contextInitializerClasses, activeProfiles,\n\t\t\tList.of(new PropertySourceDescriptor(processStrings(propertySourceLocations))),\n\t\t\tpropertySourceProperties, contextCustomizers, contextLoader, cacheAwareContextLoaderDelegate,\n\t\t\tparent);\n\t}\n\n\t/**\n\t * Create a new {@code MergedContextConfiguration} instance for the supplied\n\t * parameters.\n\t * <p>If a {@code null} value is supplied for {@code locations}, {@code classes},\n\t * {@code activeProfiles}, or {@code propertySourceProperties} an empty array\n\t * will be stored instead. If a {@code null} value is supplied for\n\t * {@code contextInitializerClasses} or {@code contextCustomizers}, an empty\n\t * set will be stored instead. Furthermore, active profiles will be sorted,\n\t * and duplicate profiles will be removed.\n\t * @param testClass the test class for which the configuration was merged\n\t * @param locations the merged context resource locations\n\t * @param classes the merged annotated classes\n\t * @param contextInitializerClasses the merged context initializer classes\n\t * @param activeProfiles the merged active bean definition profiles\n\t * @param propertySourceDescriptors the merged property source descriptors\n\t * @param propertySourceProperties the merged inlined properties\n\t * @param contextCustomizers the context customizers\n\t * @param contextLoader the resolved {@code ContextLoader}\n\t * @param cacheAwareContextLoaderDelegate a cache-aware context loader\n\t * delegate with which to retrieve the parent {@code ApplicationContext}\n\t * @param parent the parent configuration or {@code null} if there is no parent\n\t * @since 6.1\n\t */\n\tpublic MergedContextConfiguration(Class<?> testClass, @Nullable String[] locations, @Nullable Class<?>[] classes,\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses,\n\t\t\t@Nullable String[] activeProfiles, List<PropertySourceDescriptor> propertySourceDescriptors,\n\t\t\t@Nullable String[] propertySourceProperties, @Nullable Set<ContextCustomizer> contextCustomizers,\n\t\t\tContextLoader contextLoader, @Nullable CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n\t\t\t@Nullable MergedContextConfiguration parent) {\n\n\t\tthis.testClass = testClass;\n\t\tthis.locations = processStrings(locations);\n\t\tthis.classes = processClasses(classes);\n\t\tthis.contextInitializerClasses = processContextInitializerClasses(contextInitializerClasses);\n\t\tthis.activeProfiles = processActiveProfiles(activeProfiles);\n\t\tthis.propertySourceDescriptors = Collections.unmodifiableList(propertySourceDescriptors);\n\t\tthis.propertySourceLocations = this.propertySourceDescriptors.stream()\n\t\t\t\t.map(PropertySourceDescriptor::locations)\n\t\t\t\t.flatMap(List::stream)\n\t\t\t\t.toArray(String[]::new);\n\t\tthis.propertySourceProperties = processStrings(propertySourceProperties);\n\t\tthis.contextCustomizers = processContextCustomizers(contextCustomizers);\n\t\tthis.contextLoader = contextLoader;\n\t\tthis.cacheAwareContextLoaderDelegate = cacheAwareContextLoaderDelegate;\n\t\tthis.parent = parent;\n\t}\n\n\n\t/**\n\t * Get the {@linkplain Class test class} associated with this\n\t * {@code MergedContextConfiguration}.\n\t */\n\tpublic Class<?> getTestClass() {\n\t\treturn this.testClass;\n\t}\n\n\t/**\n\t * Get the merged resource locations for {@code ApplicationContext}\n\t * configuration files for the {@linkplain #getTestClass() test class}.\n\t * <p>Context resource locations typically represent XML configuration\n\t * files or Groovy scripts.\n\t */\n\tpublic String[] getLocations() {\n\t\treturn this.locations;\n\t}\n\n\t/**\n\t * Get the merged annotated classes for the {@linkplain #getTestClass() test class}.\n\t */\n\tpublic Class<?>[] getClasses() {\n\t\treturn this.classes;\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * path-based context resource locations.\n\t * @return {@code true} if the {@link #getLocations() locations} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasClasses()\n\t */\n\tpublic boolean hasLocations() {\n\t\treturn !ObjectUtils.isEmpty(getLocations());\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * class-based resources.\n\t * @return {@code true} if the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasLocations()\n\t */\n\tpublic boolean hasClasses() {\n\t\treturn !ObjectUtils.isEmpty(getClasses());\n\t}\n\n\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * either path-based context resource locations or class-based resources.\n\t * @return {@code true} if either the {@link #getLocations() locations}\n\t * or the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasLocations()\n\t * @see #hasClasses()\n\t */\n\tpublic boolean hasResources() {\n\t\treturn (hasLocations() || hasClasses());\n\t}\n\n\t/**\n\t * Get the merged {@code ApplicationContextInitializer} classes for the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\tpublic Set<Class<? extends ApplicationContextInitializer<?>>> getContextInitializerClasses() {\n\t\treturn this.contextInitializerClasses;\n\t}\n\n\t/**\n\t * Get the merged active bean definition profiles for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see ActiveProfiles\n\t */\n\tpublic String[] getActiveProfiles() {\n\t\treturn this.activeProfiles;\n\t}\n\n\t/**\n\t * Get the merged descriptors for resource locations for test {@code PropertySources}\n\t * for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t */\n\tpublic List<PropertySourceDescriptor> getPropertySourceDescriptors() {\n\t\treturn this.propertySourceDescriptors;\n\t}\n\n\t/**\n\t * Get the merged resource locations of properties files for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see TestPropertySource#locations\n\t * @see java.util.Properties\n\t * @deprecated since 6.1 in favor of {@link #getPropertySourceDescriptors()}\n\t */\n\t@Deprecated(since = \"6.1\")\n\tpublic String[] getPropertySourceLocations() {\n\t\treturn this.propertySourceLocations;\n\t}\n\n\t/**\n\t * Get the merged inlined properties for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @see TestPropertySource#properties\n\t * @see java.util.Properties\n\t */\n\tpublic String[] getPropertySourceProperties() {\n\t\treturn this.propertySourceProperties;\n\t}\n\n\t/**\n\t * Get the merged {@link ContextCustomizer ContextCustomizers} that will be applied\n\t * when the application context is loaded.\n\t */\n\tpublic Set<ContextCustomizer> getContextCustomizers() {\n\t\treturn this.contextCustomizers;\n\t}\n\n\t/**\n\t * Get the resolved {@link ContextLoader} for the {@linkplain #getTestClass() test class}.\n\t */\n\tpublic ContextLoader getContextLoader() {\n\t\treturn this.contextLoader;\n\t}\n\n\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */\n\t@Nullable\n\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}\n\n\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */\n\t@Nullable\n\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}\n\n\n\t/**\n\t * Determine if the supplied object is equal to this {@code MergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMergedContextConfiguration otherConfig = (MergedContextConfiguration) other;\n\t\tif (!Arrays.equals(this.locations, otherConfig.locations)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.classes, otherConfig.classes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.activeProfiles, otherConfig.activeProfiles)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.propertySourceDescriptors.equals(otherConfig.propertySourceDescriptors)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.propertySourceProperties, otherConfig.propertySourceProperties)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextCustomizers.equals(otherConfig.contextCustomizers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.parent == null) {\n\t\t\tif (otherConfig.parent != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.parent.equals(otherConfig.parent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!nullSafeClassName(this.contextLoader).equals(nullSafeClassName(otherConfig.contextLoader))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code MergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = Arrays.hashCode(this.locations);\n\t\tresult = 31 * result + Arrays.hashCode(this.classes);\n\t\tresult = 31 * result + this.contextInitializerClasses.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.activeProfiles);\n\t\tresult = 31 * result + this.propertySourceDescriptors.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n\t\tresult = 31 * result + this.contextCustomizers.hashCode();\n\t\tresult = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n\t\tresult = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n\t\treturn result;\n\t}\n\n\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * the name of the {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", this.testClass)\n\t\t\t\t.append(\"locations\", this.locations)\n\t\t\t\t.append(\"classes\", this.classes)\n\t\t\t\t.append(\"contextInitializerClasses\", this.contextInitializerClasses)\n\t\t\t\t.append(\"activeProfiles\", this.activeProfiles)\n\t\t\t\t.append(\"propertySourceDescriptors\", this.propertySourceDescriptors)\n\t\t\t\t.append(\"propertySourceProperties\", this.propertySourceProperties)\n\t\t\t\t.append(\"contextCustomizers\", this.contextCustomizers)\n\t\t\t\t.append(\"contextLoader\", (this.contextLoader != null ? this.contextLoader.getClass() : null))\n\t\t\t\t.append(\"parent\", this.parent)\n\t\t\t\t.toString();\n\t}\n\n\n\tprotected static String[] processStrings(@Nullable String[] array) {\n\t\treturn (array != null ? array : EMPTY_STRING_ARRAY);\n\t}\n\n\tprivate static Class<?>[] processClasses(@Nullable Class<?>[] classes) {\n\t\treturn (classes != null ? classes : EMPTY_CLASS_ARRAY);\n\t}\n\n\tprivate static Set<Class<? extends ApplicationContextInitializer<?>>> processContextInitializerClasses(\n\t\t\t@Nullable Set<Class<? extends ApplicationContextInitializer<?>>> contextInitializerClasses) {\n\n\t\treturn (contextInitializerClasses != null ?\n\t\t\t\tCollections.unmodifiableSet(contextInitializerClasses) : EMPTY_INITIALIZER_CLASSES);\n\t}\n\n\tprivate static Set<ContextCustomizer> processContextCustomizers(\n\t\t\t@Nullable Set<ContextCustomizer> contextCustomizers) {\n\n\t\treturn (contextCustomizers != null ?\n\t\t\t\tCollections.unmodifiableSet(contextCustomizers) : EMPTY_CONTEXT_CUSTOMIZERS);\n\t}\n\n\tprivate static String[] processActiveProfiles(@Nullable String[] activeProfiles) {\n\t\tif (activeProfiles == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\t// Active profiles must be unique\n\t\tSet<String> profilesSet = new LinkedHashSet<>(Arrays.asList(activeProfiles));\n\t\treturn StringUtils.toStringArray(profilesSet);\n\t}\n\n\t/**\n\t * Generate a null-safe {@link String} representation of the supplied\n\t * {@link ContextLoader} based solely on the fully qualified name of the\n\t * loader or &quot;null&quot; if the supplied loader is {@code null}.\n\t */\n\tprotected static String nullSafeClassName(@Nullable ContextLoader contextLoader) {\n\t\treturn (contextLoader != null ? contextLoader.getClass().getName() : \"null\");\n\t}\n\n}"
  },
  "org.springframework.test.context.MergedContextConfiguration#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied object is equal to this {@code MergedContextConfiguration}\n\t * instance by comparing both objects' {@linkplain #getLocations() locations},\n\t * {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getParent() parents}, and the fully qualified names of their\n\t * {@link #getContextLoader() ContextLoaders}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMergedContextConfiguration otherConfig = (MergedContextConfiguration) other;\n\t\tif (!Arrays.equals(this.locations, otherConfig.locations)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.classes, otherConfig.classes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextInitializerClasses.equals(otherConfig.contextInitializerClasses)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.activeProfiles, otherConfig.activeProfiles)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.propertySourceDescriptors.equals(otherConfig.propertySourceDescriptors)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(this.propertySourceProperties, otherConfig.propertySourceProperties)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.contextCustomizers.equals(otherConfig.contextCustomizers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.parent == null) {\n\t\t\tif (otherConfig.parent != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (!this.parent.equals(otherConfig.parent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!nullSafeClassName(this.contextLoader).equals(nullSafeClassName(otherConfig.contextLoader))) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getActiveProfiles()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged active bean definition profiles for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see ActiveProfiles\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "String[]",
    "signature": "public String[] getActiveProfiles()",
    "source_code": "\tpublic String[] getActiveProfiles() {\n\t\treturn this.activeProfiles;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getContextCustomizers()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged {@link ContextCustomizer ContextCustomizers} that will be applied\n\t * when the application context is loaded.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "Set<ContextCustomizer>",
    "signature": "public Set<ContextCustomizer> getContextCustomizers()",
    "source_code": "\tpublic Set<ContextCustomizer> getContextCustomizers() {\n\t\treturn this.contextCustomizers;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getContextLoader()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the resolved {@link ContextLoader} for the {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "ContextLoader",
    "signature": "public ContextLoader getContextLoader()",
    "source_code": "\tpublic ContextLoader getContextLoader() {\n\t\treturn this.contextLoader;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged resource locations for {@code ApplicationContext}\n\t * configuration files for the {@linkplain #getTestClass() test class}.\n\t * <p>Context resource locations typically represent XML configuration\n\t * files or Groovy scripts.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "String[]",
    "signature": "public String[] getLocations()",
    "source_code": "\tpublic String[] getLocations() {\n\t\treturn this.locations;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getParent()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "MergedContextConfiguration",
    "signature": "public MergedContextConfiguration getParent()",
    "source_code": "\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getParentApplicationContext()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getParentApplicationContext()",
    "source_code": "\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceDescriptors()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged descriptors for resource locations for test {@code PropertySources}\n\t * for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "List<PropertySourceDescriptor>",
    "signature": "public List<PropertySourceDescriptor> getPropertySourceDescriptors()",
    "source_code": "\tpublic List<PropertySourceDescriptor> getPropertySourceDescriptors() {\n\t\treturn this.propertySourceDescriptors;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged resource locations of properties files for the\n\t * {@linkplain #getTestClass() test class}.\n\t * @see TestPropertySource#locations\n\t * @see java.util.Properties\n\t * @deprecated since 6.1 in favor of {@link #getPropertySourceDescriptors()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "String[]",
    "signature": "public String[] getPropertySourceLocations()",
    "source_code": "\tpublic String[] getPropertySourceLocations() {\n\t\treturn this.propertySourceLocations;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#getPropertySourceProperties()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the merged inlined properties for the {@linkplain #getTestClass() test class}.\n\t * <p>Properties will be loaded into the {@code Environment}'s set of\n\t * {@code PropertySources}.\n\t * @see TestPropertySource#properties\n\t * @see java.util.Properties\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "String[]",
    "signature": "public String[] getPropertySourceProperties()",
    "source_code": "\tpublic String[] getPropertySourceProperties() {\n\t\treturn this.propertySourceProperties;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasClasses()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * class-based resources.\n\t * @return {@code true} if the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasLocations()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "boolean",
    "signature": "public boolean hasClasses()",
    "source_code": "\tpublic boolean hasClasses() {\n\t\treturn !ObjectUtils.isEmpty(getClasses());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasLocations()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * path-based context resource locations.\n\t * @return {@code true} if the {@link #getLocations() locations} array is not empty\n\t * @since 4.0.4\n\t * @see #hasResources()\n\t * @see #hasClasses()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "boolean",
    "signature": "public boolean hasLocations()",
    "source_code": "\tpublic boolean hasLocations() {\n\t\treturn !ObjectUtils.isEmpty(getLocations());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hasResources()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if this {@code MergedContextConfiguration} instance has\n\t * either path-based context resource locations or class-based resources.\n\t * @return {@code true} if either the {@link #getLocations() locations}\n\t * or the {@link #getClasses() classes} array is not empty\n\t * @since 4.0.4\n\t * @see #hasLocations()\n\t * @see #hasClasses()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "boolean",
    "signature": "public boolean hasResources()",
    "source_code": "\tpublic boolean hasResources() {\n\t\treturn (hasLocations() || hasClasses());\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a unique hash code for all properties of this\n\t * {@code MergedContextConfiguration} excluding the\n\t * {@linkplain #getTestClass() test class}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\tint result = Arrays.hashCode(this.locations);\n\t\tresult = 31 * result + Arrays.hashCode(this.classes);\n\t\tresult = 31 * result + this.contextInitializerClasses.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.activeProfiles);\n\t\tresult = 31 * result + this.propertySourceDescriptors.hashCode();\n\t\tresult = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n\t\tresult = 31 * result + this.contextCustomizers.hashCode();\n\t\tresult = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n\t\tresult = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n\t\treturn result;\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#nullSafeClassName(contextLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a null-safe {@link String} representation of the supplied\n\t * {@link ContextLoader} based solely on the fully qualified name of the\n\t * loader or &quot;null&quot; if the supplied loader is {@code null}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "contextLoader"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "String",
    "signature": "protected String nullSafeClassName(@Nullable ContextLoader contextLoader)",
    "source_code": "\tprotected static String nullSafeClassName(@Nullable ContextLoader contextLoader) {\n\t\treturn (contextLoader != null ? contextLoader.getClass().getName() : \"null\");\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#processStrings(array)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "array"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "String[]",
    "signature": "protected String[] processStrings(@Nullable String[] array)",
    "source_code": "\tprotected static String[] processStrings(@Nullable String[] array) {\n\t\treturn (array != null ? array : EMPTY_STRING_ARRAY);\n\t}"
  },
  "org.springframework.test.context.MergedContextConfiguration#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * the name of the {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", this.testClass)\n\t\t\t\t.append(\"locations\", this.locations)\n\t\t\t\t.append(\"classes\", this.classes)\n\t\t\t\t.append(\"contextInitializerClasses\", this.contextInitializerClasses)\n\t\t\t\t.append(\"activeProfiles\", this.activeProfiles)\n\t\t\t\t.append(\"propertySourceDescriptors\", this.propertySourceDescriptors)\n\t\t\t\t.append(\"propertySourceProperties\", this.propertySourceProperties)\n\t\t\t\t.append(\"contextCustomizers\", this.contextCustomizers)\n\t\t\t\t.append(\"contextLoader\", (this.contextLoader != null ? this.contextLoader.getClass() : null))\n\t\t\t\t.append(\"parent\", this.parent)\n\t\t\t\t.toString();\n\t}"
  },
  "org.springframework.test.context.aot.FAIL_ON_ERROR_PROPERTY_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * JVM system property used to set the {@code failOnError} flag: {@value}.\n\t * <p>The {@code failOnError} flag controls whether errors encountered during\n\t * AOT processing in the <em>Spring TestContext Framework</em> should result\n\t * in an exception that fails the overall process.\n\t * <p>Defaults to {@code true}.\n\t * <p>Supported values include {@code true} or {@code false}, ignoring case.\n\t * For example, the default may be changed to {@code false} by supplying\n\t * the following JVM system property via the command line.\n\t * <pre style=\"code\">-Dspring.test.aot.processing.failOnError=false</pre>\n\t * <p>May alternatively be configured via the\n\t * {@link org.springframework.core.SpringProperties SpringProperties}\n\t * mechanism.\n\t * @since 6.1\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "public String FAIL_ON_ERROR_PROPERTY_NAME",
    "source_code": "\tpublic static final String FAIL_ON_ERROR_PROPERTY_NAME = \"spring.test.aot.processing.failOnError\";",
    "type": "String"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedConfig,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(replaceIfNecessary(mergedContextConfiguration), hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(mergedConfig);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#isContextLoaded(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "boolean",
    "signature": "public boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic boolean isContextLoaded(MergedContextConfiguration mergedContextConfiguration) {\n\t\tsynchronized (this.contextCache) {\n\t\t\treturn this.contextCache.contains(replaceIfNecessary(mergedContextConfiguration));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedConfig);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\tInteger failureCount = this.contextCache.getFailureCount(mergedConfig);\n\t\t\t\t\tif (failureCount >= this.failureThreshold) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\t\t\tApplicationContext failure threshold (%d) exceeded: \\\n\t\t\t\t\t\t\t\tskipping repeated attempt to load context for %s\"\"\"\n\t\t\t\t\t\t\t\t\t.formatted(this.failureThreshold, mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedConfig instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedConfig, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Incrementing ApplicationContext failure count for \" + mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.incrementFailureCount(mergedConfig);\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedConfig, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration) {\n\t\tmergedContextConfiguration = replaceIfNecessary(mergedContextConfiguration);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedContextConfiguration);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedContextConfiguration instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedContextConfiguration);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedContextConfiguration, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedContextConfiguration, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedContextConfiguration));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedConfig)"
  },
  "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContextInternal(mergedContextConfiguration)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the {@code ApplicationContext} for the supplied merged context configuration.\n\t * <p>Supports both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.\n\t * @throws Exception if an error occurs while loading the application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mergedContextConfiguration"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "ApplicationContext",
    "signature": "protected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)",
    "source_code": "\tprotected ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)"
  },
  "org.springframework.test.context.cache.DefaultContextCache#getFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "int",
    "signature": "public int getFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic int getFailureCount(MergedContextConfiguration key) {\n\t\treturn this.failureCounts.getOrDefault(key, 0);\n\t}"
  },
  "org.springframework.test.context.cache.DefaultContextCache#incrementFailureCount(key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "public void incrementFailureCount(MergedContextConfiguration key)",
    "source_code": "\tpublic void incrementFailureCount(MergedContextConfiguration key) {\n\t\tthis.totalFailureCount.incrementAndGet();\n\t\tthis.failureCounts.merge(key, 1, Integer::sum);\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#afterTestClass(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} once per test class <em>after</em> all test methods\n\t * have been run.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void afterTestClass(TestContext testContext)",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\texecuteClassLevelSqlScripts(testContext, ExecutionPhase.AFTER_TEST_CLASS);\n\t}"
  },
  "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#beforeTestClass(testContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} once per test class <em>before</em> any test method\n\t * is run.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void beforeTestClass(TestContext testContext)",
    "source_code": "\tpublic void beforeTestClass(TestContext testContext) throws Exception {\n\t\texecuteClassLevelSqlScripts(testContext, ExecutionPhase.BEFORE_TEST_CLASS);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@code SpringExtension} integrates the <em>Spring TestContext Framework</em>\n * into JUnit 5's <em>Jupiter</em> programming model.\n *\n * <p>To use this extension, simply annotate a JUnit Jupiter based test class with\n * {@code @ExtendWith(SpringExtension.class)}, {@code @SpringJUnitConfig}, or\n * {@code @SpringJUnitWebConfig}.\n *\n * @author Sam Brannen\n * @author Simon Basl\u00e9\n * @since 5.0\n * @see org.springframework.test.context.junit.jupiter.EnabledIf\n * @see org.springframework.test.context.junit.jupiter.DisabledIf\n * @see org.springframework.test.context.junit.jupiter.SpringJUnitConfig\n * @see org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig\n * @see org.springframework.test.context.TestContextManager\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "signature": "public class SpringExtension",
    "source_code": "public class SpringExtension implements BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor,"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void afterAll(ExtensionContext context)",
    "source_code": "\tpublic void afterAll(ExtensionContext context) throws Exception {\n\t\ttry {\n\t\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\t\tregisterMethodInvoker(testContextManager, context);\n\t\t\ttestContextManager.afterTestClass();\n\t\t}\n\t\tfinally {\n\t\t\tgetStore(context).remove(context.getRequiredTestClass());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void afterEach(ExtensionContext context)",
    "source_code": "\tpublic void afterEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.afterTestMethod(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#afterTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#afterTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "public void afterTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void afterTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tThrowable testException = context.getExecutionException().orElse(null);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.afterTestExecution(testInstance, testMethod, testException);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeAll(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestClass}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void beforeAll(ExtensionContext context)",
    "source_code": "\tpublic void beforeAll(ExtensionContext context) throws Exception {\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.beforeTestClass();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeEach(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void beforeEach(ExtensionContext context)",
    "source_code": "\tpublic void beforeEach(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.beforeTestMethod(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#beforeTestExecution(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#beforeTestExecution}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void beforeTestExecution(ExtensionContext context)",
    "source_code": "\tpublic void beforeTestExecution(ExtensionContext context) throws Exception {\n\t\tObject testInstance = context.getRequiredTestInstance();\n\t\tMethod testMethod = context.getRequiredTestMethod();\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.beforeTestExecution(testInstance, testMethod);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#getApplicationContext(context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.\n\t * @param context the current {@code ExtensionContext} (never {@code null})\n\t * @return the application context\n\t * @throws IllegalStateException if an error occurs while retrieving the application context\n\t * @see org.springframework.test.context.TestContext#getApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext getApplicationContext(ExtensionContext context)",
    "source_code": "\tpublic static ApplicationContext getApplicationContext(ExtensionContext context) {\n\t\treturn getTestContextManager(context).getTestContext().getApplicationContext();\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#postProcessTestInstance(testInstance,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#prepareTestInstance}.\n\t * <p>As of Spring Framework 5.3.2, this method also validates that test\n\t * methods and test lifecycle methods are not annotated with\n\t * {@link Autowired @Autowired}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void postProcessTestInstance(Object testInstance, ExtensionContext context)",
    "source_code": "\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {\n\t\tvalidateAutowiredConfig(context);\n\t\tvalidateRecordApplicationEventsConfig(context);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.prepareTestInstance(testInstance);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#resolveParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by\n\t * retrieving the corresponding dependency from the test's {@link ApplicationContext}.\n\t * <p>Delegates to {@link ParameterResolutionDelegate#resolveDependency}.\n\t * @see #supportsParameter\n\t * @see ParameterResolutionDelegate#resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tint index = parameterContext.getIndex();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tApplicationContext applicationContext = getApplicationContext(extensionContext);\n\t\treturn ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,\n\t\t\t\tapplicationContext.getAutowireCapableBeanFactory());\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.SpringExtension#supportsParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}\n\t * should be autowired from the test's {@link ApplicationContext}.\n\t * <p>A parameter is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t * <ol>\n\t * <li>The {@linkplain ParameterContext#getDeclaringExecutable() declaring\n\t * executable} is a {@link Constructor} and\n\t * {@link TestConstructorUtils#isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * returns {@code true}. Note that {@code isAutowirableConstructor()} will be\n\t * invoked with a fallback {@link PropertyProvider} that delegates its lookup\n\t * to {@link ExtensionContext#getConfigurationParameter(String)}.</li>\n\t * <li>The parameter is of type {@link ApplicationContext} or a sub-type thereof.</li>\n\t * <li>The parameter is of type {@link ApplicationEvents} or a sub-type thereof.</li>\n\t * <li>{@link ParameterResolutionDelegate#isAutowirable} returns {@code true}.</li>\n\t * </ol>\n\t * <p><strong>WARNING</strong>: If a test class {@code Constructor} is annotated\n\t * with {@code @Autowired} or automatically autowirable (see {@link TestConstructor}),\n\t * Spring will assume the responsibility for resolving all parameters in the\n\t * constructor. Consequently, no other registered {@link ParameterResolver}\n\t * will be able to resolve parameters.\n\t * @see #resolveParameter\n\t * @see TestConstructorUtils#isAutowirableConstructor(Constructor, Class)\n\t * @see ParameterResolutionDelegate#isAutowirable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tPropertyProvider junitPropertyProvider = propertyName ->\n\t\t\t\textensionContext.getConfigurationParameter(propertyName).orElse(null);\n\t\treturn (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||\n\t\t\t\tApplicationContext.class.isAssignableFrom(parameter.getType()) ||\n\t\t\t\tsupportsApplicationEvents(parameterContext) ||\n\t\t\t\tParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));\n\t}"
  },
  "org.springframework.test.context.support.DefaultTestContext#getMethodInvoker()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "MethodInvoker",
    "signature": "public MethodInvoker getMethodInvoker()",
    "source_code": "\tpublic final MethodInvoker getMethodInvoker() {\n\t\treturn this.methodInvoker;\n\t}"
  },
  "org.springframework.test.context.support.DefaultTestContext#setMethodInvoker(methodInvoker)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodInvoker"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void setMethodInvoker(MethodInvoker methodInvoker)",
    "source_code": "\tpublic final void setMethodInvoker(MethodInvoker methodInvoker) {\n\t\tAssert.notNull(methodInvoker, \"MethodInvoker must not be null\");\n\t\tthis.methodInvoker = methodInvoker;\n\t}"
  },
  "org.springframework.test.context.support.INLINED_PROPERTIES_PROPERTY_SOURCE_NAME": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * The name of the {@link MapPropertySource} created from <em>inlined properties</em>.\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment\n\t */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "signature": "public String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME",
    "source_code": "\tpublic static final String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME = \"Inlined Test Properties\";",
    "type": "String"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods for working with {@link TestPropertySource @TestPropertySource}\n * and adding test {@link PropertySource PropertySources} to the {@code Environment}.\n *\n * <p>Primarily intended for use within the framework.\n *\n * @author Sam Brannen\n * @author Anatoliy Korovin\n * @author Phillip Webb\n * @since 4.1\n * @see TestPropertySource\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class TestPropertySourceUtils",
    "source_code": "public abstract class TestPropertySourceUtils {\n\n\t/**\n\t * The name of the {@link MapPropertySource} created from <em>inlined properties</em>.\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment\n\t */\n\tpublic static final String INLINED_PROPERTIES_PROPERTY_SOURCE_NAME = \"Inlined Test Properties\";\n\n\tprivate static final PropertySourceFactory defaultPropertySourceFactory = new DefaultPropertySourceFactory();\n\n\tprivate static Comparator<MergedAnnotation<? extends Annotation>> reversedMetaDistance =\n\t\t\tComparator.<MergedAnnotation<? extends Annotation>> comparingInt(MergedAnnotation::getDistance).reversed();\n\n\tprivate static final Log logger = LogFactory.getLog(TestPropertySourceUtils.class);\n\n\n\tstatic MergedTestPropertySources buildMergedTestPropertySources(Class<?> testClass) {\n\t\tList<TestPropertySourceAttributes> attributesList = new ArrayList<>();\n\n\t\tTestPropertySourceAttributes previousAttributes = null;\n\t\t// Iterate over all aggregate levels, where each level is represented by\n\t\t// a list of merged annotations found at that level (e.g., on a test\n\t\t// class in the class hierarchy).\n\t\tfor (List<MergedAnnotation<TestPropertySource>> aggregatedAnnotations :\n\t\t\t\tfindRepeatableAnnotations(testClass, TestPropertySource.class)) {\n\n\t\t\t// Convert all the merged annotations for the current aggregate\n\t\t\t// level to a list of TestPropertySourceAttributes.\n\t\t\tList<TestPropertySourceAttributes> aggregatedAttributesList =\n\t\t\t\t\taggregatedAnnotations.stream().map(TestPropertySourceAttributes::new).toList();\n\t\t\t// Merge all TestPropertySourceAttributes instances for the current\n\t\t\t// aggregate level into a single TestPropertySourceAttributes instance.\n\t\t\tTestPropertySourceAttributes mergedAttributes = mergeTestPropertySourceAttributes(aggregatedAttributesList);\n\t\t\tif (mergedAttributes != null) {\n\t\t\t\tif (!duplicationDetected(mergedAttributes, previousAttributes)) {\n\t\t\t\t\tattributesList.add(mergedAttributes);\n\t\t\t\t}\n\t\t\t\tpreviousAttributes = mergedAttributes;\n\t\t\t}\n\t\t}\n\n\t\tif (attributesList.isEmpty()) {\n\t\t\treturn MergedTestPropertySources.empty();\n\t\t}\n\t\treturn new MergedTestPropertySources(mergeLocations(attributesList), mergeProperties(attributesList));\n\t}\n\n\t@Nullable\n\tprivate static TestPropertySourceAttributes mergeTestPropertySourceAttributes(\n\t\t\tList<TestPropertySourceAttributes> aggregatedAttributesList) {\n\n\t\tTestPropertySourceAttributes mergedAttributes = null;\n\t\tTestPropertySourceAttributes previousAttributes = null;\n\t\tfor (TestPropertySourceAttributes currentAttributes : aggregatedAttributesList) {\n\t\t\tif (mergedAttributes == null) {\n\t\t\t\tmergedAttributes = currentAttributes;\n\t\t\t}\n\t\t\telse if (!duplicationDetected(currentAttributes, previousAttributes)) {\n\t\t\t\tmergedAttributes.mergeWith(currentAttributes);\n\t\t\t}\n\t\t\tpreviousAttributes = currentAttributes;\n\t\t}\n\n\t\treturn mergedAttributes;\n\t}\n\n\tprivate static boolean duplicationDetected(TestPropertySourceAttributes currentAttributes,\n\t\t\t@Nullable TestPropertySourceAttributes previousAttributes) {\n\n\t\tboolean duplicationDetected =\n\t\t\t\t(currentAttributes.equals(previousAttributes) && !currentAttributes.isEmpty());\n\n\t\tif (duplicationDetected && logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Ignoring duplicate %s declaration on %s since it is also declared on %s\",\n\t\t\t\t\tcurrentAttributes, currentAttributes.getDeclaringClass().getName(),\n\t\t\t\t\tpreviousAttributes.getDeclaringClass().getName()));\n\t\t}\n\n\t\treturn duplicationDetected;\n\t}\n\n\tprivate static List<PropertySourceDescriptor> mergeLocations(List<TestPropertySourceAttributes> attributesList) {\n\t\tList<PropertySourceDescriptor> descriptors = new ArrayList<>();\n\t\tfor (TestPropertySourceAttributes attrs : attributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Processing locations for \" + attrs);\n\t\t\t}\n\t\t\tdescriptors.addAll(0, attrs.getPropertySourceDescriptors());\n\t\t\tif (!attrs.isInheritLocations()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn descriptors;\n\t}\n\n\tprivate static String[] mergeProperties(List<TestPropertySourceAttributes> attributesList) {\n\t\tList<String> properties = new ArrayList<>();\n\t\tfor (TestPropertySourceAttributes attrs : attributesList) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Processing inlined properties for \" + attrs);\n\t\t\t}\n\t\t\tString[] attrProps = attrs.getProperties();\n\t\t\tproperties.addAll(0, Arrays.asList(attrProps));\n\t\t\tif (!attrs.isInheritProperties()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(properties);\n\t}\n\n\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */\n\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}\n\n\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */\n\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations) {\n\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertySourcesToEnvironment(environment, resourceLoader,\n\t\t\t\tList.of(new PropertySourceDescriptor(locations)));\n\t}\n\n\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */\n\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\taddPropertySourcesToEnvironment(context.getEnvironment(), context, descriptors);\n\t}\n\n\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */\n\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(resourceLoader, \"'resourceLoader' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\tResourcePatternResolver resourcePatternResolver =\n\t\t\t\tResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tMutablePropertySources propertySources = environment.getPropertySources();\n\t\ttry {\n\t\t\tfor (PropertySourceDescriptor descriptor : descriptors) {\n\t\t\t\tif (!descriptor.locations().isEmpty()) {\n\t\t\t\t\tClass<? extends PropertySourceFactory> factoryClass = descriptor.propertySourceFactory();\n\t\t\t\t\tPropertySourceFactory factory = (factoryClass != null ?\n\t\t\t\t\t\t\tBeanUtils.instantiateClass(factoryClass) : defaultPropertySourceFactory);\n\n\t\t\t\t\tfor (String location : descriptor.locations()) {\n\t\t\t\t\t\tString resolvedLocation = environment.resolveRequiredPlaceholders(location);\n\t\t\t\t\t\tfor (Resource resource : resourcePatternResolver.getResources(resolvedLocation)) {\n\t\t\t\t\t\t\tPropertySource<?> propertySource = factory.createPropertySource(descriptor.name(),\n\t\t\t\t\t\t\t\t\tnew EncodedResource(resource, descriptor.encoding()));\n\t\t\t\t\t\t\tpropertySources.addFirst(propertySource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to add PropertySource to Environment\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */\n\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}\n\n\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */\n\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}\n\n\t/**\n\t * Convert the supplied <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) into a map keyed by property name.\n\t * <p>Parsing of the key-value pairs is achieved by converting all supplied\n\t * strings into <em>virtual</em> properties files in memory and delegating to\n\t * {@link Properties#load(java.io.Reader)} to parse each virtual file.\n\t * <p>The ordering of property names will be preserved in the returned map,\n\t * analogous to the order in which the key-value pairs are supplied to this\n\t * method. This also applies if a single string contains multiple key-value\n\t * pairs separated by newlines &mdash; for example, when supplied by a user\n\t * via a <em>text block</em>.\n\t * <p>For a full discussion of <em>inlined properties</em>, consult the Javadoc\n\t * for {@link TestPropertySource#properties}.\n\t * @param inlinedProperties the inlined properties to convert; potentially empty\n\t * but never {@code null}\n\t * @return a new, ordered map containing the converted properties\n\t * @throws IllegalStateException if a given key-value pair cannot be parsed\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */\n\tpublic static Map<String, Object> convertInlinedPropertiesToMap(String... inlinedProperties) {\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\n\t\tSequencedProperties sequencedProperties = new SequencedProperties();\n\t\tfor (String input : inlinedProperties) {\n\t\t\tif (!StringUtils.hasText(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsequencedProperties.load(new StringReader(input));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load test environment properties from [\" + input + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn sequencedProperties.getSequencedMap();\n\t}\n\n\tprivate static <T extends Annotation> List<List<MergedAnnotation<T>>> findRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\tList<List<MergedAnnotation<T>>> listOfLists = new ArrayList<>();\n\t\tfindRepeatableAnnotations(clazz, annotationType, listOfLists, new int[] {0});\n\t\treturn listOfLists;\n\t}\n\n\tprivate static <T extends Annotation> void findRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType, List<List<MergedAnnotation<T>>> listOfLists, int[] aggregateIndex) {\n\n\t\t// Ensure we have a list for the current aggregate index.\n\t\tif (listOfLists.size() < aggregateIndex[0] + 1) {\n\t\t\tlistOfLists.add(new ArrayList<>());\n\t\t}\n\n\t\tMergedAnnotations.from(clazz, SearchStrategy.DIRECT)\n\t\t\t.stream(annotationType)\n\t\t\t.sorted(reversedMetaDistance)\n\t\t\t.forEach(annotation -> listOfLists.get(aggregateIndex[0]).add(0, annotation));\n\n\t\taggregateIndex[0]++;\n\n\t\t// Declared on an interface?\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tfindRepeatableAnnotations(ifc, annotationType, listOfLists, aggregateIndex);\n\t\t}\n\n\t\t// Declared on a superclass?\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (superclass != null & superclass != Object.class) {\n\t\t\tfindRepeatableAnnotations(superclass, annotationType, listOfLists, aggregateIndex);\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (TestContextAnnotationUtils.searchEnclosingClass(clazz)) {\n\t\t\tfindRepeatableAnnotations(clazz.getEnclosingClass(), annotationType, listOfLists, aggregateIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Extension of {@link Properties} that mimics a {@code SequencedMap} by tracking\n\t * all added properties with a {@link String} key in a {@link LinkedHashMap}.\n\t * @since 6.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class SequencedProperties extends Properties {\n\n\t\tprivate final LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n\n\t\t@Override\n\t\tpublic Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\treturn this.map.put(str, value);\n\t\t\t}\n\t\t\t// No need to invoke super.put(key, value);\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Map<String, Object> getSequencedMap() {\n\t\t\treturn this.map;\n\t\t}\n\n\t}\n\n}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addInlinedPropertiesToEnvironment(context,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addInlinedPropertiesToEnvironment(environment,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(context,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(environment,resourceLoader,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(context,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(environment,resourceLoader,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#convertInlinedPropertiesToMap(inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) into a map keyed by property name.\n\t * <p>Parsing of the key-value pairs is achieved by converting all supplied\n\t * strings into <em>virtual</em> properties files in memory and delegating to\n\t * {@link Properties#load(java.io.Reader)} to parse each virtual file.\n\t * <p>The ordering of property names will be preserved in the returned map,\n\t * analogous to the order in which the key-value pairs are supplied to this\n\t * method. This also applies if a single string contains multiple key-value\n\t * pairs separated by newlines &mdash; for example, when supplied by a user\n\t * via a <em>text block</em>.\n\t * <p>For a full discussion of <em>inlined properties</em>, consult the Javadoc\n\t * for {@link TestPropertySource#properties}.\n\t * @param inlinedProperties the inlined properties to convert; potentially empty\n\t * but never {@code null}\n\t * @return a new, ordered map containing the converted properties\n\t * @throws IllegalStateException if a given key-value pair cannot be parsed\n\t * @since 4.1.5\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "Object>",
    "signature": "public Object> convertInlinedPropertiesToMap(String... inlinedProperties)",
    "source_code": "\tpublic static Map<String, Object> convertInlinedPropertiesToMap(String... inlinedProperties) {\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\n\t\tSequencedProperties sequencedProperties = new SequencedProperties();\n\t\tfor (String input : inlinedProperties) {\n\t\t\tif (!StringUtils.hasText(input)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsequencedProperties.load(new StringReader(input));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load test environment properties from [\" + input + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn sequencedProperties.getSequencedMap();\n\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#getSequencedMap()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "Object>",
    "signature": "public Object> getSequencedMap()",
    "source_code": "\t\tpublic Map<String, Object> getSequencedMap() {\n\t\t\treturn this.map;\n\t\t}"
  },
  "org.springframework.test.context.support.TestPropertySourceUtils#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\t\tpublic Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\treturn this.map.put(str, value);\n\t\t\t}\n\t\t\t// No need to invoke super.put(key, value);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.test.context.transaction.TestContextTransactionUtils#createDelegatingTransactionAttribute(testContext,targetAttribute,includeMethodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a delegating {@link TransactionAttribute} for the supplied target\n\t * {@link TransactionAttribute} and {@link TestContext}, using the names of\n\t * the test class and test method (if requested) to build the name of the\n\t * transaction.\n\t * @param testContext the {@code TestContext} upon which to base the name\n\t * @param targetAttribute the {@code TransactionAttribute} to delegate to\n\t * @param includeMethodName {@code true} if the test method's name should be\n\t * included in the name of the transaction\n\t * @return the delegating {@code TransactionAttribute}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "targetAttribute",
      "includeMethodName"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute createDelegatingTransactionAttribute(TestContext testContext, TransactionAttribute targetAttribute, boolean includeMethodName)",
    "source_code": "\tpublic static TransactionAttribute createDelegatingTransactionAttribute("
  },
  "org.springframework.test.web.reactive.server.<unknown>#configureBlockingExecution(configurer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configurer"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void configureBlockingExecution(BlockingExecutionConfigurer configurer)",
    "source_code": "\t\tpublic void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n\t\t\tif (this.executionConsumer != null) {\n\t\t\t\tthis.executionConsumer.accept(configurer);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.ExchangeResult#getRawStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HTTP status code as an integer.\n\t * @since 5.1.10\n\t * @deprecated as of 6.0, in favor of {@link #getStatus()}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "int",
    "signature": "public int getRawStatusCode()",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn getStatus().value();\n\t}"
  },
  "org.springframework.test.web.servlet.client.MockMvcHttpConnector#with(postProcessors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new instance that applies the given {@link RequestPostProcessor}s\n\t * to performed requests.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "MockMvcHttpConnector",
    "signature": "public MockMvcHttpConnector with(List<RequestPostProcessor> postProcessors)",
    "source_code": "\tpublic MockMvcHttpConnector with(List<RequestPostProcessor> postProcessors) {\n\t\treturn new MockMvcHttpConnector(this.mockMvc, postProcessors);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilter(filter,Map<String,initParams,dispatcherTypes,urlPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "Map<String",
      "initParams",
      "dispatcherTypes",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns)",
    "source_code": "\tpublic <T extends B> T addFilter("
  },
  "org.springframework.transaction.event.<unknown>#afterCompletion(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> afterCompletion(int status)",
    "source_code": "\t\tpublic Mono<Void> afterCompletion(int status) {\n\t\t\tTransactionPhase phase = getTransactionPhase();\n\t\t\tif (phase == TransactionPhase.AFTER_COMMIT && status == STATUS_COMMITTED) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\telse if (phase == TransactionPhase.AFTER_ROLLBACK && status == STATUS_ROLLED_BACK) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\telse if (phase == TransactionPhase.AFTER_COMPLETION) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#beforeCommit(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> beforeCommit(boolean readOnly)",
    "source_code": "\t\tpublic Mono<Void> beforeCommit(boolean readOnly) {\n\t\t\tif (getTransactionPhase() == TransactionPhase.BEFORE_COMMIT) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#getOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "int",
    "signature": "public int getOrder()",
    "source_code": "\tpublic int getOrder() {\n\t\treturn this.listener.getOrder();\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#getTransactionPhase()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "TransactionPhase",
    "signature": "public TransactionPhase getTransactionPhase()",
    "source_code": "\tpublic TransactionPhase getTransactionPhase() {\n\t\treturn this.listener.getTransactionPhase();\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#processEventWithCallbacks()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void processEventWithCallbacks()",
    "source_code": "\tpublic void processEventWithCallbacks() {\n\t\tthis.callbacks.forEach(callback -> callback.preProcessEvent(this.event));\n\t\ttry {\n\t\t\tthis.listener.processEvent(this.event);\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tthis.callbacks.forEach(callback -> callback.postProcessEvent(this.event, ex));\n\t\t\tthrow ex;\n\t\t}\n\t\tthis.callbacks.forEach(callback -> callback.postProcessEvent(this.event, null));\n\t}"
  },
  "org.springframework.transaction.event.<unknown>#register(event,listener,callbacks)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "listener",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean register(E event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks)",
    "source_code": "\tpublic static <E extends ApplicationEvent> boolean register("
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Default implementation of the {@link TransactionDefinition} interface,\n * offering bean-style configuration and sensible default values\n * (PROPAGATION_REQUIRED, ISOLATION_DEFAULT, TIMEOUT_DEFAULT, readOnly=false).\n *\n * <p>Base class for both {@link TransactionTemplate} and\n * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 08.05.2003\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "signature": "public class DefaultTransactionDefinition",
    "source_code": "public class DefaultTransactionDefinition implements TransactionDefinition, Serializable {\n\n\t/** Prefix for the propagation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";\n\n\t/** Prefix for the isolation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";\n\n\t/** Prefix for transaction timeout values in description strings. */\n\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";\n\n\t/** Marker for read-only transactions in description strings. */\n\tpublic static final String READ_ONLY_MARKER = \"readOnly\";\n\n\n\t/**\n\t * Map of constant names to constant values for the propagation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> propagationConstants = Map.of(\n\t\t\t\"PROPAGATION_REQUIRED\", TransactionDefinition.PROPAGATION_REQUIRED,\n\t\t\t\"PROPAGATION_SUPPORTS\", TransactionDefinition.PROPAGATION_SUPPORTS,\n\t\t\t\"PROPAGATION_MANDATORY\", TransactionDefinition.PROPAGATION_MANDATORY,\n\t\t\t\"PROPAGATION_REQUIRES_NEW\", TransactionDefinition.PROPAGATION_REQUIRES_NEW,\n\t\t\t\"PROPAGATION_NOT_SUPPORTED\", TransactionDefinition.PROPAGATION_NOT_SUPPORTED,\n\t\t\t\"PROPAGATION_NEVER\", TransactionDefinition.PROPAGATION_NEVER,\n\t\t\t\"PROPAGATION_NESTED\", TransactionDefinition.PROPAGATION_NESTED\n\t\t);\n\n\t/**\n\t * Map of constant names to constant values for the isolation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> isolationConstants = Map.of(\n\t\t\t\"ISOLATION_DEFAULT\", TransactionDefinition.ISOLATION_DEFAULT,\n\t\t\t\"ISOLATION_READ_UNCOMMITTED\", TransactionDefinition.ISOLATION_READ_UNCOMMITTED,\n\t\t\t\"ISOLATION_READ_COMMITTED\", TransactionDefinition.ISOLATION_READ_COMMITTED,\n\t\t\t\"ISOLATION_REPEATABLE_READ\", TransactionDefinition.ISOLATION_REPEATABLE_READ,\n\t\t\t\"ISOLATION_SERIALIZABLE\", TransactionDefinition.ISOLATION_SERIALIZABLE\n\t\t);\n\n\tprivate int propagationBehavior = PROPAGATION_REQUIRED;\n\n\tprivate int isolationLevel = ISOLATION_DEFAULT;\n\n\tprivate int timeout = TIMEOUT_DEFAULT;\n\n\tprivate boolean readOnly = false;\n\n\t@Nullable\n\tprivate String name;\n\n\n\t/**\n\t * Create a new DefaultTransactionDefinition, with default settings.\n\t * Can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition() {\n\t}\n\n\t/**\n\t * Copy constructor. Definition can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition(TransactionDefinition other) {\n\t\tthis.propagationBehavior = other.getPropagationBehavior();\n\t\tthis.isolationLevel = other.getIsolationLevel();\n\t\tthis.timeout = other.getTimeout();\n\t\tthis.readOnly = other.isReadOnly();\n\t\tthis.name = other.getName();\n\t}\n\n\t/**\n\t * Create a new DefaultTransactionDefinition with the given\n\t * propagation behavior. Can be modified through bean property setters.\n\t * @param propagationBehavior one of the propagation constants in the\n\t * TransactionDefinition interface\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t */\n\tpublic DefaultTransactionDefinition(int propagationBehavior) {\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\n\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t@Override\n\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}\n\n\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t@Override\n\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}\n\n\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */\n\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a positive integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}\n\n\t@Override\n\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}\n\n\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */\n\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}\n\n\t@Override\n\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}\n\n\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */\n\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\n\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}\n\n\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */\n\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static String getPropagationBehaviorName(int propagationBehavior) {\n\t\treturn switch(propagationBehavior) {\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRED -> \"PROPAGATION_REQUIRED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_SUPPORTS -> \"PROPAGATION_SUPPORTS\";\n\t\t\tcase TransactionDefinition.PROPAGATION_MANDATORY -> \"PROPAGATION_MANDATORY\";\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRES_NEW -> \"PROPAGATION_REQUIRES_NEW\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NOT_SUPPORTED -> \"PROPAGATION_NOT_SUPPORTED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NEVER -> \"PROPAGATION_NEVER\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NESTED -> \"PROPAGATION_NESTED\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported propagation behavior: \" + propagationBehavior);\n\t\t};\n\t}\n\n\tstatic String getIsolationLevelName(int isolationLevel) {\n\t\treturn switch(isolationLevel) {\n\t\t\tcase TransactionDefinition.ISOLATION_DEFAULT -> \"ISOLATION_DEFAULT\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_UNCOMMITTED -> \"ISOLATION_READ_UNCOMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_COMMITTED -> \"ISOLATION_READ_COMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_REPEATABLE_READ -> \"ISOLATION_REPEATABLE_READ\";\n\t\t\tcase TransactionDefinition.ISOLATION_SERIALIZABLE -> \"ISOLATION_SERIALIZABLE\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported isolation level: \" + isolationLevel);\n\t\t};\n\t}\n\n}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getDefinitionDescription()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder getDefinitionDescription()",
    "source_code": "\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getIsolationLevel()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "int",
    "signature": "public int getIsolationLevel()",
    "source_code": "\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "String",
    "signature": "public String getName()",
    "source_code": "\tpublic final String getName() {\n\t\treturn this.name;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getPropagationBehavior()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "int",
    "signature": "public int getPropagationBehavior()",
    "source_code": "\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#getTimeout()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "int",
    "signature": "public int getTimeout()",
    "source_code": "\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#isReadOnly()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly()",
    "source_code": "\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevel(isolationLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "isolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setIsolationLevel(int isolationLevel)",
    "source_code": "\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevelName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setIsolationLevelName(String constantName)",
    "source_code": "\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setName(name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "public void setName(String name)",
    "source_code": "\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setPropagationBehavior(propagationBehavior)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propagationBehavior"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setPropagationBehavior(int propagationBehavior)",
    "source_code": "\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setPropagationBehaviorName(constantName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constantName"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setPropagationBehaviorName(String constantName)",
    "source_code": "\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setReadOnly(readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void setReadOnly(boolean readOnly)",
    "source_code": "\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#setTimeout(timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void setTimeout(int timeout)",
    "source_code": "\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a positive integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionDefinition#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#getTransactionName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "String",
    "signature": "public String getTransactionName()",
    "source_code": "\tpublic String getTransactionName() {\n\t\treturn (this.transactionName != null ? this.transactionName : \"\");\n\t}"
  },
  "org.springframework.transaction.support.DefaultTransactionStatus#isNested()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isNested()",
    "source_code": "\tpublic boolean isNested() {\n\t\treturn this.nested;\n\t}"
  },
  "org.springframework.transaction.support.PREFIX_ISOLATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for the isolation constants defined in TransactionDefinition. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public String PREFIX_ISOLATION",
    "source_code": "\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.PREFIX_PROPAGATION": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for the propagation constants defined in TransactionDefinition. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "signature": "public String PREFIX_PROPAGATION",
    "source_code": "\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.PREFIX_TIMEOUT": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Prefix for transaction timeout values in description strings. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "signature": "public String PREFIX_TIMEOUT",
    "source_code": "\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";",
    "type": "String"
  },
  "org.springframework.transaction.support.READ_ONLY_MARKER": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/** Marker for read-only transactions in description strings. */",
    "kind": "field",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public String READ_ONLY_MARKER",
    "source_code": "\tpublic static final String READ_ONLY_MARKER = \"readOnly\";",
    "type": "String"
  },
  "org.springframework.util.ObjectUtils#nullSafeHash(elements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a hash code for the given elements, delegating to\n\t * {@link #nullSafeHashCode(Object)} for each element. Contrary\n\t * to {@link Objects#hash(Object...)}, this method can handle an\n\t * element that is an array.\n\t * @param elements the elements to be hashed\n\t * @return a hash value of the elements\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "int",
    "signature": "public int nullSafeHash(@Nullable Object... elements)",
    "source_code": "\tpublic static int nullSafeHash(@Nullable Object... elements) {\n\t\tif (elements == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tint result = 1;\n\t\tfor (Object element : elements) {\n\t\t\tresult = 31 * result + nullSafeHashCode(element);\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(clazz,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "Field",
    "signature": "public Field findFieldIgnoreCase(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "int",
    "signature": "public int compare(Boolean left, Boolean right)",
    "source_code": "\tpublic int compare(Boolean left, Boolean right) {\n\t\tint multiplier = this.trueLow ? -1 : 1;\n\t\treturn multiplier * Boolean.compare(left, right);\n\t}"
  },
  "org.springframework.util.comparator.BooleanComparator#compare(v1,v2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v1",
      "v2"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "public int compare(Boolean v1, Boolean v2)",
    "source_code": "\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}"
  },
  "org.springframework.util.comparator.NullSafeComparator#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int compare(@Nullable T left, @Nullable T right)",
    "source_code": "\tpublic int compare(@Nullable T left, @Nullable T right) {\n\t\tComparator<T> comparator = this.nullsLow ? Comparator.nullsFirst(this.nonNullComparator) : Comparator.nullsLast(this.nonNullComparator);\n\t\treturn comparator.compare(left, right);\n\t}"
  },
  "org.springframework.util.comparator.NullSafeComparator#compare(o1,o2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int compare(@Nullable T o1, @Nullable T o2)",
    "source_code": "\tpublic int compare(@Nullable T o1, @Nullable T o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (o1 == null) {\n\t\t\treturn (this.nullsLow ? -1 : 1);\n\t\t}\n\t\tif (o2 == null) {\n\t\t\treturn (this.nullsLow ? 1 : -1);\n\t\t}\n\t\treturn this.nonNullComparator.compare(o1, o2);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endPrefixMapping(prefix)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * End the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void endPrefixMapping(String prefix)",
    "source_code": "\tprotected void endPrefixMapping(String prefix) throws SAXException {\n\t\tif (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\n\t\t\tgetContentHandler().endPrefixMapping(prefix);\n\t\t\tthis.namespaces.remove(prefix);\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#construct(valueResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target with constructor injection of values. It is expected that\n\t * {@link #setTargetType(ResolvableType)} was previously called and that\n\t * {@link #getTarget()} is {@code null}.\n\t * <p>Uses a public, no-arg constructor if available in the target object type,\n\t * also supporting a \"primary constructor\" approach for data classes as follows:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as\n\t * well as runtime-retained parameter names in the bytecode, associating\n\t * input values with constructor arguments by name. If no such constructor is\n\t * found, the default constructor will be used (even if not public), assuming\n\t * subsequent bean property bindings through setter methods.\n\t * <p>After the call, use {@link #getBindingResult()} to check for failures\n\t * to bind to, and/or validate constructor arguments. If there are no errors,\n\t * the target is set, and {@link #doBind(MutablePropertyValues)} can be used\n\t * for further initialization via setters.\n\t * @param valueResolver to resolve constructor argument values with\n\t * @throws BeanInstantiationException in case of constructor failure\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueResolver"
    ],
    "position": {
      "column": 1,
      "line": 898
    },
    "return": "void",
    "signature": "public void construct(ValueResolver valueResolver)",
    "source_code": "\tpublic final void construct(ValueResolver valueResolver) {\n\t\tAssert.state(this.target == null, \"Target instance already available\");\n\t\tAssert.state(this.targetType != null, \"Target type not set\");\n\n\t\tthis.target = createObject(this.targetType, \"\", valueResolver);\n\n\t\tif (!getBindingResult().hasErrors()) {\n\t\t\tthis.bindingResult = null;\n\t\t\tif (this.typeConverter != null) {\n\t\t\t\tthis.typeConverter.registerCustomEditors(getPropertyAccessor());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.DataBinder#getNameResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setNameResolver configured} name resolver for\n\t * constructor parameters.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 634
    },
    "return": "NameResolver",
    "signature": "public NameResolver getNameResolver()",
    "source_code": "\tpublic NameResolver getNameResolver() {\n\t\treturn this.nameResolver;\n\t}"
  },
  "org.springframework.validation.DataBinder#getTargetType()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setTargetType configured} type for the target object.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getTargetType()",
    "source_code": "\tpublic ResolvableType getTargetType() {\n\t\treturn this.targetType;\n\t}"
  },
  "org.springframework.validation.DataBinder#getValidatorsToApply()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Validators to apply after data binding. This includes the\n\t * configured {@link #getValidators() validators} filtered by the\n\t * {@link #setExcludedValidators(Predicate) exclude predicate}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "List<Validator>",
    "signature": "public List<Validator> getValidatorsToApply()",
    "source_code": "\tpublic List<Validator> getValidatorsToApply() {\n\t\treturn (this.excludedValidators != null ?\n\t\t\t\tthis.validators.stream().filter(validator -> !this.excludedValidators.test(validator)).toList() :\n\t\t\t\tCollections.unmodifiableList(this.validators));\n\t}"
  },
  "org.springframework.validation.DataBinder#isDeclarativeBinding()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether to bind only fields intended for binding.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "boolean",
    "signature": "public boolean isDeclarativeBinding()",
    "source_code": "\tpublic boolean isDeclarativeBinding() {\n\t\treturn this.declarativeBinding;\n\t}"
  },
  "org.springframework.validation.DataBinder#registerCustomEditors(registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 1305
    },
    "return": "void",
    "signature": "public void registerCustomEditors(PropertyEditorRegistry registry)",
    "source_code": "\t\tpublic void registerCustomEditors(PropertyEditorRegistry registry) {\n\t\t\tcopyCustomEditorsTo(registry, null);\n\t\t}"
  },
  "org.springframework.validation.DataBinder#setDeclarativeBinding(declarativeBinding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set whether to bind only fields explicitly intended for binding including:\n\t * <ul>\n\t * <li>Constructor binding via {@link #construct}.\n\t * <li>Property binding with configured\n\t * {@link #setAllowedFields(String...) allowedFields}.\n\t * </ul>\n\t * <p>Default is \"false\". Turn this on to limit binding to constructor\n\t * parameters and allowed fields.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declarativeBinding"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "void",
    "signature": "public void setDeclarativeBinding(boolean declarativeBinding)",
    "source_code": "\tpublic void setDeclarativeBinding(boolean declarativeBinding) {\n\t\tthis.declarativeBinding = declarativeBinding;\n\t}"
  },
  "org.springframework.validation.DataBinder#setExcludedValidators(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate to exclude validators.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 697
    },
    "return": "void",
    "signature": "public void setExcludedValidators(Predicate<Validator> predicate)",
    "source_code": "\tpublic void setExcludedValidators(Predicate<Validator> predicate) {\n\t\tthis.excludedValidators = predicate;\n\t}"
  },
  "org.springframework.validation.DataBinder#setNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver to determine the name of the value to bind to a\n\t * constructor parameter in {@link #construct}.\n\t * <p>If not configured, or if the name cannot be resolved, by default\n\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} is used.\n\t * @param nameResolver the resolver to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "void",
    "signature": "public void setNameResolver(NameResolver nameResolver)",
    "source_code": "\tpublic void setNameResolver(NameResolver nameResolver) {\n\t\tthis.nameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.DataBinder#setTargetType(targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the type for the target object. When the target is {@code null},\n\t * setting the targetType allows using {@link #construct} to\n\t * create the target.\n\t * @param targetType the type of the target object\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setTargetType(ResolvableType targetType)",
    "source_code": "\tpublic void setTargetType(ResolvableType targetType) {\n\t\tAssert.state(this.target == null, \"targetType is used to for target creation, but target is already set\");\n\t\tthis.targetType = targetType;\n\t}"
  },
  "org.springframework.validation.DataBinder#shouldNotBindPropertyValues()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to not bind parameters to properties. Returns \"true\" if\n\t * {@link #isDeclarativeBinding()} is on, and\n\t * {@link #setAllowedFields(String...) allowedFields} are not configured.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 1072
    },
    "return": "boolean",
    "signature": "protected boolean shouldNotBindPropertyValues()",
    "source_code": "\tprotected boolean shouldNotBindPropertyValues() {\n\t\treturn (isDeclarativeBinding() && ObjectUtils.isEmpty(this.allowedFields));\n\t}"
  },
  "org.springframework.validation.NameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy to determine the name of the value to bind to a method parameter.\n\t * Supported on constructor parameters with {@link #construct constructor\n\t * binding} which performs lookups via {@link ValueResolver#resolveValue}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1265
    },
    "signature": "public interface NameResolver",
    "source_code": "\tpublic interface NameResolver {\n\n\t\t/**\n\t\t * Return the name to use for the given method parameter, or {@code null}\n\t\t * if unresolved. For constructor parameters, the name is determined via\n\t\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} if\n\t\t * unresolved.\n\t\t */\n\t\t@Nullable\n\t\tString resolveName(MethodParameter parameter);\n\n\t}"
  },
  "org.springframework.validation.SimpleErrors": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A simple implementation of the {@link Errors} interface, managing global\n * errors and field errors for a top-level target object. Flexibly retrieves\n * field values through bean property getter methods, and automatically\n * falls back to raw field access if necessary.\n *\n * <p>Note that this {@link Errors} implementation comes without support for\n * nested paths. It is exclusively designed for the validation of individual\n * top-level objects, not aggregating errors from multiple sources.\n * If this is insufficient for your purposes, use a binding-capable\n * {@link Errors} implementation such as {@link BeanPropertyBindingResult}.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see Validator#validateObject(Object)\n * @see BeanPropertyBindingResult\n * @see DirectFieldBindingResult\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "signature": "public class SimpleErrors",
    "source_code": "public class SimpleErrors implements Errors, Serializable {\n\n\tprivate final Object target;\n\n\tprivate final String objectName;\n\n\tprivate final List<ObjectError> globalErrors = new ArrayList<>();\n\n\tprivate final List<FieldError> fieldErrors = new ArrayList<>();\n\n\n\t/**\n\t * Create a new {@link SimpleErrors} holder for the given target,\n\t * using the simple name of the target class as the object name.\n\t * @param target the target to wrap\n\t */\n\tpublic SimpleErrors(Object target) {\n\t\tAssert.notNull(target, \"Target must not be null\");\n\t\tthis.target = target;\n\t\tthis.objectName = this.target.getClass().getSimpleName();\n\t}\n\n\t/**\n\t * Create a new {@link SimpleErrors} holder for the given target.\n\t * @param target the target to wrap\n\t * @param objectName the name of the target object for error reporting\n\t */\n\tpublic SimpleErrors(Object target, String objectName) {\n\t\tAssert.notNull(target, \"Target must not be null\");\n\t\tthis.target = target;\n\t\tthis.objectName = objectName;\n\t}\n\n\n\t@Override\n\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}\n\n\t@Override\n\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}\n\n\t@Override\n\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tif (!StringUtils.hasLength(field)) {\n\t\t\treject(errorCode, errorArgs, defaultMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tObject newVal = getFieldValue(field);\n\t\tthis.fieldErrors.add(new FieldError(getObjectName(), field, newVal, false,\n\t\t\t\tnew String[] {errorCode}, errorArgs, defaultMessage));\n\t}\n\n\t@Override\n\tpublic void addAllErrors(Errors errors) {\n\t\tthis.globalErrors.addAll(errors.getGlobalErrors());\n\t\tthis.fieldErrors.addAll(errors.getFieldErrors());\n\t}\n\n\t@Override\n\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.globalErrors;\n\t}\n\n\t@Override\n\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.fieldErrors;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object getFieldValue(String field) {\n\t\tFieldError fieldError = getFieldError(field);\n\t\tif (fieldError != null) {\n\t\t\treturn fieldError.getRejectedValue();\n\t\t}\n\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.target);\n\t\t}\n\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\tReflectionUtils.makeAccessible(rawField);\n\t\t\treturn ReflectionUtils.getField(rawField, this.target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for field '\" + field +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}\n\n\t@Override\n\tpublic Class<?> getFieldType(String field) {\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null) {\n\t\t\treturn pd.getPropertyType();\n\t\t}\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\treturn rawField.getType();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleErrors that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.target, that.target) &&\n\t\t\t\tthis.globalErrors.equals(that.globalErrors) &&\n\t\t\t\tthis.fieldErrors.equals(that.fieldErrors)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.target.hashCode();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ObjectError error : this.globalErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\tfor (ObjectError error : this.fieldErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}"
  },
  "org.springframework.validation.SimpleErrors#addAllErrors(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void addAllErrors(Errors errors)",
    "source_code": "\tpublic void addAllErrors(Errors errors) {\n\t\tthis.globalErrors.addAll(errors.getGlobalErrors());\n\t\tthis.fieldErrors.addAll(errors.getFieldErrors());\n\t}"
  },
  "org.springframework.validation.SimpleErrors#equals(other)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "boolean",
    "signature": "public boolean equals(@Nullable Object other)",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof SimpleErrors that &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.target, that.target) &&\n\t\t\t\tthis.globalErrors.equals(that.globalErrors) &&\n\t\t\t\tthis.fieldErrors.equals(that.fieldErrors)));\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getFieldErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "List<FieldError>",
    "signature": "public List<FieldError> getFieldErrors()",
    "source_code": "\tpublic List<FieldError> getFieldErrors() {\n\t\treturn this.fieldErrors;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getFieldValue(field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Object",
    "signature": "public Object getFieldValue(String field)",
    "source_code": "\tpublic Object getFieldValue(String field) {\n\t\tFieldError fieldError = getFieldError(field);\n\t\tif (fieldError != null) {\n\t\t\treturn fieldError.getRejectedValue();\n\t\t}\n\n\t\tPropertyDescriptor pd = BeanUtils.getPropertyDescriptor(this.target.getClass(), field);\n\t\tif (pd != null && pd.getReadMethod() != null) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.target);\n\t\t}\n\n\t\tField rawField = ReflectionUtils.findField(this.target.getClass(), field);\n\t\tif (rawField != null) {\n\t\t\tReflectionUtils.makeAccessible(rawField);\n\t\t\treturn ReflectionUtils.getField(rawField, this.target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for field '\" + field +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getGlobalErrors()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "List<ObjectError>",
    "signature": "public List<ObjectError> getGlobalErrors()",
    "source_code": "\tpublic List<ObjectError> getGlobalErrors() {\n\t\treturn this.globalErrors;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#getObjectName()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getObjectName()",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.objectName;\n\t}"
  },
  "org.springframework.validation.SimpleErrors#hashCode()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "int",
    "signature": "public int hashCode()",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.target.hashCode();\n\t}"
  },
  "org.springframework.validation.SimpleErrors#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}"
  },
  "org.springframework.validation.SimpleErrors#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,"
  },
  "org.springframework.validation.SimpleErrors#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ObjectError error : this.globalErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\tfor (ObjectError error : this.fieldErrors) {\n\t\t\tsb.append('\\n').append(error);\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.validation.ValueResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy for {@link #construct constructor binding} to look up the values\n\t * to bind to a given constructor parameter.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 1283
    },
    "signature": "public interface ValueResolver",
    "source_code": "\tpublic interface ValueResolver {\n\n\t\t/**\n\t\t * Resolve the value for the given name and target parameter type.\n\t\t * @param name the name to use for the lookup, possibly a nested path\n\t\t * for constructor parameters on nested objects\n\t\t * @param type the target type, based on the constructor parameter type\n\t\t * @return the resolved value, possibly {@code null} if none found\n\t\t */\n\t\t@Nullable\n\t\tObject resolveValue(String name, Class<?> type);\n\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodValidator} that uses a Bean Validation\n * {@link jakarta.validation.Validator} for validation, and adapts\n * {@link ConstraintViolation}s to {@link MethodValidationResult}.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "signature": "public class MethodValidationAdapter",
    "source_code": "public class MethodValidationAdapter implements MethodValidator {\n\n\tprivate static final MethodValidationResult emptyValidationResult = MethodValidationResult.emptyResult();\n\n\tprivate static final ObjectNameResolver defaultObjectNameResolver = new DefaultObjectNameResolver();\n\n\tprivate static final Comparator<ParameterValidationResult> resultComparator = new ResultComparator();\n\n\n\tprivate final Supplier<Validator> validator;\n\n\tprivate final Supplier<SpringValidatorAdapter> validatorAdapter;\n\n\tprivate MessageCodesResolver messageCodesResolver = new DefaultMessageCodesResolver();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\tprivate ObjectNameResolver objectNameResolver = defaultObjectNameResolver;\n\n\n\t/**\n\t * Create an instance using a default JSR-303 validator underneath.\n\t */\n\tpublic MethodValidationAdapter() {\n\t\tthis.validator = SingletonSupplier.of(() -> Validation.buildDefaultValidatorFactory().getValidator());\n\t\tthis.validatorAdapter = initValidatorAdapter(this.validator);\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 ValidatorFactory.\n\t * @param validatorFactory the JSR-303 ValidatorFactory to use\n\t */\n\t@SuppressWarnings(\"DataFlowIssue\")\n\tpublic MethodValidationAdapter(ValidatorFactory validatorFactory) {\n\t\tif (validatorFactory instanceof SpringValidatorAdapter adapter) {\n\t\t\tthis.validator = () -> adapter;\n\t\t\tthis.validatorAdapter = () -> adapter;\n\t\t}\n\t\telse {\n\t\t\tthis.validator = SingletonSupplier.of(validatorFactory::getValidator);\n\t\t\tthis.validatorAdapter = SingletonSupplier.of(() -> new SpringValidatorAdapter(this.validator.get()));\n\t\t}\n\t}\n\n\t/**\n\t * Create an instance using the given JSR-303 Validator.\n\t * @param validator the JSR-303 Validator to use\n\t */\n\tpublic MethodValidationAdapter(Validator validator) {\n\t\tthis.validator = () -> validator;\n\t\tthis.validatorAdapter = initValidatorAdapter(this.validator);\n\t}\n\n\t/**\n\t * Create an instance for the supplied (potentially lazily initialized) Validator.\n\t * @param validator a Supplier for the Validator to use\n\t */\n\tpublic MethodValidationAdapter(Supplier<Validator> validator) {\n\t\tthis.validator = validator;\n\t\tthis.validatorAdapter = initValidatorAdapter(validator);\n\t}\n\n\tprivate static Supplier<SpringValidatorAdapter> initValidatorAdapter(Supplier<Validator> validatorSupplier) {\n\t\treturn SingletonSupplier.of(() -> {\n\t\t\tValidator validator = validatorSupplier.get();\n\t\t\treturn (validator instanceof SpringValidatorAdapter sva ? sva : new SpringValidatorAdapter(validator));\n\t\t});\n\t}\n\n\n\t/**\n\t * Return the {@link SpringValidatorAdapter} configured for use.\n\t */\n\tpublic Supplier<SpringValidatorAdapter> getSpringValidatorAdapter() {\n\t\treturn this.validatorAdapter;\n\t}\n\n\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */\n\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}\n\n\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */\n\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}\n\n\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the {@link #setParameterNameDiscoverer configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */\n\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Configure a resolver to determine the name of an {@code @Valid} method\n\t * parameter to use for its {@link BindingResult}. This allows aligning with\n\t * a higher level programming model such as to resolve the name of an\n\t * {@code @ModelAttribute} method parameter in Spring MVC.\n\t * <p>By default, the object name is resolved through:\n\t * <ul>\n\t * <li>{@link MethodParameter#getParameterName()} for input parameters\n\t * <li>{@link Conventions#getVariableNameForReturnType(Method, Class, Object)}\n\t * for a return type\n\t * </ul>\n\t * If a name cannot be determined, e.g. a return value with insufficient\n\t * type information, then it defaults to one of:\n\t * <ul>\n\t * <li>{@code \"{methodName}.arg{index}\"} for input parameters\n\t * <li>{@code \"{methodName}.returnValue\"} for a return type\n\t * </ul>\n\t */\n\tpublic void setObjectNameResolver(ObjectNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}\n\n\n\t/**\n\t * {@inheritDoc}.\n\t * <p>Default are the validation groups as specified in the {@link Validated}\n\t * annotation on the method, or on the containing target class of the method,\n\t * or for an AOP proxy without a target (with all behavior in advisors), also\n\t * check on proxied interfaces.\n\t */\n\t@Override\n\tpublic Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\tValidated validatedAnn = AnnotationUtils.findAnnotation(method, Validated.class);\n\t\tif (validatedAnn == null) {\n\t\t\tif (AopUtils.isAopProxy(target)) {\n\t\t\t\tfor (Class<?> type : AopProxyUtils.proxiedUserInterfaces(target)) {\n\t\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(type, Validated.class);\n\t\t\t\t\tif (validatedAnn != null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalidatedAnn = AnnotationUtils.findAnnotation(target.getClass(), Validated.class);\n\t\t\t}\n\t\t}\n\t\treturn (validatedAnn != null ? validatedAnn.value() : new Class<?>[0]);\n\t}\n\n\t@Override\n\tpublic final MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForArguments(target, method, arguments, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (parameters != null ? parameters[i] : initMethodParameter(method, i)),\n\t\t\t\ti -> arguments[i]);\n\t}\n\n\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */\n\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments(\n\t\t\tObject target, Method method, Object[] arguments, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tSet<ConstraintViolation<Object>> violations;\n\t\ttry {\n\t\t\tviolations = execVal.validateParameters(target, method, arguments, groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tMethod mostSpecificMethod = ClassUtils.getMostSpecificMethod(method, target.getClass());\n\t\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(mostSpecificMethod);\n\t\t\tviolations = execVal.validateParameters(target, bridgedMethod, arguments, groups);\n\t\t}\n\t\treturn violations;\n\t}\n\n\t@Override\n\tpublic final MethodValidationResult validateReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForReturnValue(target, method, returnValue, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (returnType != null ? returnType : initMethodParameter(method, -1)),\n\t\t\t\ti -> returnValue);\n\t}\n\n\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */\n\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(\n\t\t\tObject target, Method method, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\treturn execVal.validateReturnValue(target, method, returnValue, groups);\n\t}\n\n\tprivate MethodValidationResult adaptViolations(\n\t\t\tObject target, Method method, Set<ConstraintViolation<Object>> violations,\n\t\t\tFunction<Integer, MethodParameter> parameterFunction,\n\t\t\tFunction<Integer, Object> argumentFunction) {\n\n\t\tMap<MethodParameter, ValueResultBuilder> parameterViolations = new LinkedHashMap<>();\n\t\tMap<Path.Node, BeanResultBuilder> cascadedViolations = new LinkedHashMap<>();\n\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tIterator<Path.Node> itr = violation.getPropertyPath().iterator();\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tPath.Node node = itr.next();\n\n\t\t\t\tMethodParameter parameter;\n\t\t\t\tif (node.getKind().equals(ElementKind.PARAMETER)) {\n\t\t\t\t\tint index = node.as(Path.ParameterNode.class).getParameterIndex();\n\t\t\t\t\tparameter = parameterFunction.apply(index);\n\t\t\t\t}\n\t\t\t\telse if (node.getKind().equals(ElementKind.RETURN_VALUE)) {\n\t\t\t\t\tparameter = parameterFunction.apply(-1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tObject argument = argumentFunction.apply(parameter.getParameterIndex());\n\t\t\t\tif (!itr.hasNext()) {\n\t\t\t\t\tparameterViolations\n\t\t\t\t\t\t\t.computeIfAbsent(parameter, p -> new ValueResultBuilder(target, parameter, argument))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcascadedViolations\n\t\t\t\t\t\t\t.computeIfAbsent(node, n -> new BeanResultBuilder(parameter, argument, itr.next()))\n\t\t\t\t\t\t\t.addViolation(violation);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tList<ParameterValidationResult> validatonResultList = new ArrayList<>();\n\t\tparameterViolations.forEach((parameter, builder) -> validatonResultList.add(builder.build()));\n\t\tcascadedViolations.forEach((node, builder) -> validatonResultList.add(builder.build()));\n\t\tvalidatonResultList.sort(resultComparator);\n\n\t\treturn MethodValidationResult.create(target, method, validatonResultList);\n\t}\n\n\tprivate MethodParameter initMethodParameter(Method method, int index) {\n\t\tMethodParameter\tparameter = new MethodParameter(method, index);\n\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\treturn parameter;\n\t}\n\n\tprivate MessageSourceResolvable createMessageSourceResolvable(\n\t\t\tObject target, MethodParameter parameter, ConstraintViolation<Object> violation) {\n\n\t\tString objectName = Conventions.getVariableName(target) + \"#\" + parameter.getExecutable().getName();\n\t\tString paramName = (parameter.getParameterName() != null ? parameter.getParameterName() : \"\");\n\t\tClass<?> parameterType = parameter.getParameterType();\n\n\t\tConstraintDescriptor<?> descriptor = violation.getConstraintDescriptor();\n\t\tString code = descriptor.getAnnotation().annotationType().getSimpleName();\n\t\tString[] codes = this.messageCodesResolver.resolveMessageCodes(code, objectName, paramName, parameterType);\n\t\tObject[] arguments = this.validatorAdapter.get().getArgumentsForConstraint(objectName, paramName, descriptor);\n\n\t\treturn new DefaultMessageSourceResolvable(codes, arguments, violation.getMessage());\n\t}\n\n\tprivate BindingResult createBindingResult(MethodParameter parameter, @Nullable Object argument) {\n\t\tString objectName = this.objectNameResolver.resolveName(parameter, argument);\n\t\tBeanPropertyBindingResult result = new BeanPropertyBindingResult(argument, objectName);\n\t\tresult.setMessageCodesResolver(this.messageCodesResolver);\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Strategy to resolve the name of an {@code @Valid} method parameter to\n\t * use for its {@link BindingResult}.\n\t */\n\tpublic interface ObjectNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method argument.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument value or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for a value method parameter with constraints\n\t * declared directly on it.\n\t */\n\tprivate final class ValueResultBuilder {\n\n\t\tprivate final Object target;\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object argument;\n\n\t\tprivate final List<MessageSourceResolvable> resolvableErrors = new ArrayList<>();\n\n\t\tpublic ValueResultBuilder(Object target, MethodParameter parameter, @Nullable Object argument) {\n\t\t\tthis.target = target;\n\t\t\tthis.parameter = parameter;\n\t\t\tthis.argument = argument;\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.resolvableErrors.add(createMessageSourceResolvable(this.target, this.parameter, violation));\n\t\t}\n\n\t\tpublic ParameterValidationResult build() {\n\t\t\treturn new ParameterValidationResult(this.parameter, this.argument, this.resolvableErrors);\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Builds a validation result for an {@link jakarta.validation.Valid @Valid}\n\t * annotated bean method parameter with cascaded constraints.\n\t */\n\tprivate final class BeanResultBuilder {\n\n\t\tprivate final MethodParameter parameter;\n\n\t\t@Nullable\n\t\tprivate final Object argument;\n\n\t\t@Nullable\n\t\tprivate final Object container;\n\n\t\t@Nullable\n\t\tprivate final Integer containerIndex;\n\n\t\t@Nullable\n\t\tprivate final Object containerKey;\n\n\t\tprivate final Errors errors;\n\n\t\tprivate final Set<ConstraintViolation<Object>> violations = new LinkedHashSet<>();\n\n\t\tpublic BeanResultBuilder(MethodParameter parameter, @Nullable Object argument, Path.Node node) {\n\t\t\tthis.parameter = parameter;\n\n\t\t\tthis.containerIndex = node.getIndex();\n\t\t\tthis.containerKey = node.getKey();\n\t\t\tif (argument instanceof List<?> list && this.containerIndex != null) {\n\t\t\t\tthis.container = list;\n\t\t\t\targument = list.get(this.containerIndex);\n\t\t\t}\n\t\t\telse if (argument instanceof Map<?, ?> map && this.containerKey != null) {\n\t\t\t\tthis.container = map;\n\t\t\t\targument = map.get(this.containerKey);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.container = null;\n\t\t\t}\n\n\t\t\tthis.argument = argument;\n\t\t\tthis.errors = createBindingResult(parameter, argument);\n\t\t}\n\n\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}\n\n\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.argument, this.errors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}\n\t}\n\n\n\t/**\n\t * Default algorithm to select an object name, as described in\n\t * {@link #setObjectNameResolver(ObjectNameResolver)}.\n\t */\n\tprivate static class DefaultObjectNameResolver implements ObjectNameResolver {\n\n\t\t@Override\n\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}\n\t}\n\n\n\t/**\n\t * Comparator for validation results, sorted by method parameter index first,\n\t * also falling back on container indexes if necessary for cascaded\n\t * constraints on a List container.\n\t */\n\tprivate final static class ResultComparator implements Comparator<ParameterValidationResult> {\n\n\t\t@Override\n\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate <E> int compareKeys(ParameterErrors errors1, ParameterErrors errors2) {\n\t\t\tObject key1 = errors1.getContainerKey();\n\t\t\tObject key2 = errors2.getContainerKey();\n\t\t\tif (key1 instanceof Comparable<?> && key2 instanceof Comparable<?>) {\n\t\t\t\treturn ((Comparable<E>) key1).compareTo((E) key2);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#addViolation(violation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "violation"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "void",
    "signature": "public void addViolation(ConstraintViolation<Object> violation)",
    "source_code": "\t\tpublic void addViolation(ConstraintViolation<Object> violation) {\n\t\t\tthis.violations.add(violation);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "ParameterErrors",
    "signature": "public ParameterErrors build()",
    "source_code": "\t\tpublic ParameterErrors build() {\n\t\t\tvalidatorAdapter.get().processConstraintViolations(this.violations, this.errors);\n\t\t\treturn new ParameterErrors(\n\t\t\t\t\tthis.parameter, this.argument, this.errors, this.container,\n\t\t\t\t\tthis.containerIndex, this.containerKey);\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#compare(result1,result2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result1",
      "result2"
    ],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "int",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getMessageCodesResolver()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setMessageCodesResolver(MessageCodesResolver) configured}\n\t * {@code MessageCodesResolver}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "MessageCodesResolver",
    "signature": "public MessageCodesResolver getMessageCodesResolver()",
    "source_code": "\tpublic MessageCodesResolver getMessageCodesResolver() {\n\t\treturn this.messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getParameterNameDiscoverer()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link #setParameterNameDiscoverer configured}\n\t * {@code ParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "ParameterNameDiscoverer",
    "signature": "public ParameterNameDiscoverer getParameterNameDiscoverer()",
    "source_code": "\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#getSpringValidatorAdapter()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link SpringValidatorAdapter} configured for use.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "Supplier<SpringValidatorAdapter>",
    "signature": "public Supplier<SpringValidatorAdapter> getSpringValidatorAdapter()",
    "source_code": "\tpublic Supplier<SpringValidatorAdapter> getSpringValidatorAdapter() {\n\t\treturn this.validatorAdapter;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForArguments(target,method,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForArguments(Object target, Method method, Object[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForReturnValue(target,method,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(Object target, Method method, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#resolveName(parameter,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter parameter, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setMessageCodesResolver(messageCodesResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the strategy to use to determine message codes for violations.\n\t * <p>Default is a DefaultMessageCodesResolver.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageCodesResolver"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setMessageCodesResolver(MessageCodesResolver messageCodesResolver)",
    "source_code": "\tpublic void setMessageCodesResolver(MessageCodesResolver messageCodesResolver) {\n\t\tthis.messageCodesResolver = messageCodesResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setObjectNameResolver(nameResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a resolver to determine the name of an {@code @Valid} method\n\t * parameter to use for its {@link BindingResult}. This allows aligning with\n\t * a higher level programming model such as to resolve the name of an\n\t * {@code @ModelAttribute} method parameter in Spring MVC.\n\t * <p>By default, the object name is resolved through:\n\t * <ul>\n\t * <li>{@link MethodParameter#getParameterName()} for input parameters\n\t * <li>{@link Conventions#getVariableNameForReturnType(Method, Class, Object)}\n\t * for a return type\n\t * </ul>\n\t * If a name cannot be determined, e.g. a return value with insufficient\n\t * type information, then it defaults to one of:\n\t * <ul>\n\t * <li>{@code \"{methodName}.arg{index}\"} for input parameters\n\t * <li>{@code \"{methodName}.returnValue\"} for a return type\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nameResolver"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setObjectNameResolver(ObjectNameResolver nameResolver)",
    "source_code": "\tpublic void setObjectNameResolver(ObjectNameResolver nameResolver) {\n\t\tthis.objectNameResolver = nameResolver;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#setParameterNameDiscoverer(parameterNameDiscoverer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterNameDiscoverer"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}"
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateArguments("
  },
  "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateReturnValue("
  },
  "org.springframework.validation.beanvalidation.MethodValidationInterceptor#insertAsyncValidation(validatorAdapterSupplier,adaptViolations,target,method,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validatorAdapterSupplier",
      "adaptViolations",
      "target",
      "method",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "Object[]",
    "signature": "public Object[] insertAsyncValidation(Supplier<SpringValidatorAdapter> validatorAdapterSupplier, boolean adaptViolations,\n\t\t\t\tObject target, Method method, Object[] arguments)",
    "source_code": "\t\tpublic static Object[] insertAsyncValidation("
  },
  "org.springframework.validation.beanvalidation.ObjectNameResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Strategy to resolve the name of an {@code @Valid} method parameter to\n\t * use for its {@link BindingResult}.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "signature": "public interface ObjectNameResolver",
    "source_code": "\tpublic interface ObjectNameResolver {\n\n\t\t/**\n\t\t * Determine the name for the given method argument.\n\t\t * @param parameter the method parameter\n\t\t * @param value the argument value or return value\n\t\t * @return the name to use\n\t\t */\n\t\tString resolveName(MethodParameter parameter, @Nullable Object value);\n\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Exception to be thrown when validation on an argument annotated with {@code @Valid} fails.\n * Extends {@link BindException} as of 5.3.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "signature": "public class MethodArgumentNotValidException",
    "source_code": "public class MethodArgumentNotValidException extends BindException implements ErrorResponse {\n\n\t@Nullable\n\tprivate final MethodParameter parameter;\n\n\t@Nullable\n\tprivate final Executable executable;\n\n\tprivate final ProblemDetail body;\n\n\n\t/**\n\t * Constructor for {@link MethodArgumentNotValidException}.\n\t * @param parameter the parameter that failed validation\n\t * @param bindingResult the results of the validation\n\t */\n\tpublic MethodArgumentNotValidException(MethodParameter parameter, BindingResult bindingResult) {\n\t\tsuper(bindingResult);\n\t\tthis.parameter = parameter;\n\t\tthis.executable = null;\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), \"Invalid request content.\");\n\t}\n\n\t/**\n\t * Constructor for {@link MethodArgumentNotValidException}.\n\t * @param executable the executable that failed validation\n\t * @param bindingResult the results of the validation\n\t * @since 6.0.5\n\t * @deprecated in favor of {@link #MethodArgumentNotValidException(MethodParameter, BindingResult)}\n\t */\n\t@Deprecated(since = \"6.0.10\", forRemoval = true)\n\tpublic MethodArgumentNotValidException(Executable executable, BindingResult bindingResult) {\n\t\tsuper(bindingResult);\n\t\tthis.parameter = null;\n\t\tthis.executable = executable;\n\t\tthis.body = ProblemDetail.forStatusAndDetail(getStatusCode(), \"Invalid request content.\");\n\t}\n\n\n\t@Override\n\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}\n\n\t@Override\n\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}\n\n\t/**\n\t * Return the method parameter that failed validation.\n\t */\n\tpublic final MethodParameter getParameter() {\n\t\treturn this.parameter;\n\t}\n\n\t@Override\n\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed \");\n\t\tif (this.parameter != null) {\n\t\t\tsb.append(\"for argument [\")\n\t\t\t\t\t.append(this.parameter.getParameterIndex()).append(\"] in \")\n\t\t\t\t\t.append(this.parameter.getExecutable().toGenericString());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"in \")\n\t\t\t\t\t.append(this.executable.toGenericString());\n\t\t}\n\t\tBindingResult bindingResult = getBindingResult();\n\t\tif (bindingResult.getErrorCount() > 1) {\n\t\t\tsb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n\t\t}\n\t\tsb.append(\": \");\n\t\tfor (ObjectError error : bindingResult.getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {errorsToStringList(getGlobalErrors()), errorsToStringList(getFieldErrors())};\n\t}\n\n\t@Override\n\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}\n\n\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */\n\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}\n\n\tprivate static void addMessages(\n\t\t\tMap<ObjectError, String> map, List<? extends ObjectError> errors,\n\t\t\tMessageSource messageSource, Locale locale) {\n\n\t\tList<String> messages = errorsToStringList(errors, messageSource, locale);\n\t\tfor (int i = 0; i < errors.size(); i++) {\n\t\t\tmap.put(errors.get(i), messages.get(i));\n\t\t}\n\t}\n\n\n\t/**\n\t * Convert each given {@link ObjectError} to a String in single quotes, taking\n\t * either the error's default message, or its error code.\n\t * @since 6.0\n\t */\n\tpublic static List<String> errorsToStringList(List<? extends ObjectError> errors) {\n\t\treturn errorsToStringList(errors, error ->\n\t\t\t\terror.getDefaultMessage() != null ? error.getDefaultMessage() : error.getCode());\n\t}\n\n\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */\n\tpublic static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale) {\n\n\t\treturn (source != null ?\n\t\t\t\terrorsToStringList(errors, error -> source.getMessage(error, locale)) :\n\t\t\t\terrorsToStringList(errors));\n\t}\n\n\tprivate static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, Function<ObjectError, String> formatter) {\n\n\t\tList<String> result = new ArrayList<>(errors.size());\n\t\tfor (ObjectError error : errors) {\n\t\t\tString value = formatter.apply(error);\n\t\t\tif (StringUtils.hasText(value)) {\n\t\t\t\tresult.add(error instanceof FieldError fieldError ?\n\t\t\t\t\t\tfieldError.getField() + \": '\" + value + \"'\" : \"'\" + value + \"'\");\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#errorsToStringList(errors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert each given {@link ObjectError} to a String in single quotes, taking\n\t * either the error's default message, or its error code.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors)",
    "source_code": "\tpublic static List<String> errorsToStringList(List<? extends ObjectError> errors) {\n\t\treturn errorsToStringList(errors, error ->\n\t\t\t\terror.getDefaultMessage() != null ? error.getDefaultMessage() : error.getCode());\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#errorsToStringList(errors,source,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale)",
    "source_code": "\tpublic static List<String> errorsToStringList("
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getBody()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail getBody()",
    "source_code": "\tpublic ProblemDetail getBody() {\n\t\treturn this.body;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getDetailMessageArguments()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments()",
    "source_code": "\tpublic Object[] getDetailMessageArguments() {\n\t\treturn new Object[] {errorsToStringList(getGlobalErrors()), errorsToStringList(getFieldErrors())};\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getDetailMessageArguments(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getMessage()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "String",
    "signature": "public String getMessage()",
    "source_code": "\tpublic String getMessage() {\n\t\tStringBuilder sb = new StringBuilder(\"Validation failed \");\n\t\tif (this.parameter != null) {\n\t\t\tsb.append(\"for argument [\")\n\t\t\t\t\t.append(this.parameter.getParameterIndex()).append(\"] in \")\n\t\t\t\t\t.append(this.parameter.getExecutable().toGenericString());\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"in \")\n\t\t\t\t\t.append(this.executable.toGenericString());\n\t\t}\n\t\tBindingResult bindingResult = getBindingResult();\n\t\tif (bindingResult.getErrorCount() > 1) {\n\t\t\tsb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n\t\t}\n\t\tsb.append(\": \");\n\t\tfor (ObjectError error : bindingResult.getAllErrors()) {\n\t\t\tsb.append('[').append(error).append(\"] \");\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getParameter()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameter that failed validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getParameter()",
    "source_code": "\tpublic final MethodParameter getParameter() {\n\t\treturn this.parameter;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#getStatusCode()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "HttpStatusCode",
    "signature": "public HttpStatusCode getStatusCode()",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn HttpStatus.BAD_REQUEST;\n\t}"
  },
  "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Create a {@link WebRequestDataBinder} instance and initialize it with a\n * {@link WebBindingInitializer}.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class DefaultDataBinderFactory",
    "source_code": "public class DefaultDataBinderFactory implements WebDataBinderFactory {\n\n\t@Nullable\n\tprivate final WebBindingInitializer initializer;\n\n\tprivate boolean methodValidationApplicable;\n\n\n\t/**\n\t * Create a new {@code DefaultDataBinderFactory} instance.\n\t * @param initializer for global data binder initialization\n\t * (or {@code null} if none)\n\t */\n\tpublic DefaultDataBinderFactory(@Nullable WebBindingInitializer initializer) {\n\t\tthis.initializer = initializer;\n\t}\n\n\n\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */\n\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}\n\n\n\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */\n\t@Override\n\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, null);\n\t}\n\n\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */\n\t@Override\n\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, type);\n\t}\n\n\tprivate WebDataBinder createBinderInternal(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\t@Nullable ResolvableType type) throws Exception {\n\n\t\tWebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);\n\t\tdataBinder.setNameResolver(new BindParamNameResolver());\n\n\t\tif (target == null && type != null) {\n\t\t\tdataBinder.setTargetType(type);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\n\t\tinitBinder(dataBinder, webRequest);\n\n\t\tif (this.methodValidationApplicable && type != null) {\n\t\t\tif (type.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}\n\n\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */\n\tprotected WebDataBinder createBinderInstance(\n\t\t\t@Nullable Object target, String objectName, NativeWebRequest webRequest) throws Exception {\n\n\t\treturn new WebRequestDataBinder(target, objectName);\n\t}\n\n\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */\n\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t}\n\n\n\t/**\n\t * Excludes Bean Validation if the method parameter has {@code @Valid}.\n\t */\n\tprivate static class MethodValidationInitializer {\n\n\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)",
    "source_code": "\tpublic final WebDataBinder createBinder("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type)",
    "source_code": "\tpublic final WebDataBinder createBinder("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinderInstance(target,objectName,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "objectName",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "WebDataBinder",
    "signature": "protected WebDataBinder createBinderInstance(@Nullable Object target, String objectName, NativeWebRequest webRequest)",
    "source_code": "\tprotected WebDataBinder createBinderInstance("
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(dataBinder,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBinder",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "protected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)",
    "source_code": "\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)"
  },
  "org.springframework.web.bind.support.DefaultDataBinderFactory#setMethodValidationApplicable(methodValidationApplicable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidationApplicable"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setMethodValidationApplicable(boolean methodValidationApplicable)",
    "source_code": "\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#construct(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind} can be called for\n\t * further initialization via setters.\n\t * @param exchange the request to bind\n\t * @return a {@code Mono<Void>} that completes when the target is created\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> construct(ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Void> construct(ServerWebExchange exchange) {\n\t\treturn getValuesToBind(exchange)\n\t\t\t\t.doOnNext(map -> construct(new MapValueResolver(map)))\n\t\t\t\t.then();\n\t}"
  },
  "org.springframework.web.bind.support.WebExchangeDataBinder#resolveValue(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Object",
    "signature": "public Object resolveValue(String name, Class<?> type)",
    "source_code": "\t\tpublic Object resolveValue(String name, Class<?> type) {\n\t\t\treturn this.map.get(name);\n\t\t}"
  },
  "org.springframework.web.bind.support.WebRequestDataBinder#construct(request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind(WebRequest)}\n\t * can be called for further initialization via setters.\n\t * @param request the request to bind\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void construct(WebRequest request)",
    "source_code": "\tpublic void construct(WebRequest request) {\n\t\tif (request instanceof NativeWebRequest nativeRequest) {\n\t\t\tServletRequest servletRequest = nativeRequest.getNativeRequest(ServletRequest.class);\n\t\t\tif (servletRequest != null) {\n\t\t\t\tconstruct(ServletRequestDataBinder.valueResolver(servletRequest, this));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#accept(acceptableMediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableMediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes) {\n\t\t\tgetHeaders().setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#acceptCharset(acceptableCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "acceptableCharsets"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(StreamingHttpOutputMessage.Body body)",
    "source_code": "\t\tpublic RequestBodySpec body(StreamingHttpOutputMessage.Body body) {\n\t\t\tthis.body = request -> body.writeTo(request.getBody());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType) {\n\t\t\tthis.body = clientHttpRequest -> writeWithMessageConverters(body, bodyType.getType(), clientHttpRequest);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "T",
    "signature": "public T body(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> T body(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn readWithMessageConverters(type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "RestClient",
    "signature": "public RestClient build()",
    "source_code": "\tpublic RestClient build() {\n\t\tClientHttpRequestFactory requestFactory = initRequestFactory();\n\t\tUriBuilderFactory uriBuilderFactory = initUriBuilderFactory();\n\t\tHttpHeaders defaultHeaders = copyDefaultHeaders();\n\t\tList<HttpMessageConverter<?>> messageConverters = (this.messageConverters != null ?\n\t\t\t\tthis.messageConverters : initMessageConverters());\n\t\treturn new DefaultRestClient(requestFactory,\n\t\t\t\tthis.interceptors, this.initializers, uriBuilderFactory,\n\t\t\t\tdefaultHeaders,\n\t\t\t\tthis.statusHandlers,\n\t\t\t\tmessageConverters,\n\t\t\t\tthis.observationRegistry,\n\t\t\t\tthis.observationConvention,\n\t\t\t\tnew DefaultRestClientBuilder(this)\n\t\t\t\t);\n\t}"
  },
  "org.springframework.web.client.<unknown>#contentLength(contentLength)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentLength(long contentLength)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentLength(long contentLength) {\n\t\t\tgetHeaders().setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#contentType(contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec contentType(MediaType contentType)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec contentType(MediaType contentType) {\n\t\t\tgetHeaders().setContentType(contentType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(exchangeFunction,close)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction",
      "close"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "T",
    "signature": "public T exchange(ExchangeFunction<T> exchangeFunction, boolean close)",
    "source_code": "\t\tpublic <T> T exchange(ExchangeFunction<T> exchangeFunction, boolean close) {\n\t\t\treturn exchangeInternal(exchangeFunction, close);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#headers(headersConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headersConsumer"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(getHeaders());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#httpRequest(requestConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestConsumer"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer)",
    "source_code": "\t\tpublic RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer) {\n\t\t\tthis.httpRequestConsumer = (this.httpRequestConsumer != null ?\n\t\t\t\t\tthis.httpRequestConsumer.andThen(requestConsumer) : requestConsumer);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#ifModifiedSince(ifModifiedSince)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifModifiedSince"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tgetHeaders().setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#ifNoneMatch(ifNoneMatches)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ifNoneMatches"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#method(method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec method(HttpMethod method)",
    "source_code": "\tpublic RequestBodyUriSpec method(HttpMethod method) {\n\t\tAssert.notNull(method, \"HttpMethod must not be null\");\n\t\treturn methodInternal(method);\n\t}"
  },
  "org.springframework.web.client.<unknown>#mutate()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "Builder",
    "signature": "public Builder mutate()",
    "source_code": "\tpublic Builder mutate() {\n\t\treturn new DefaultRestClientBuilder(this.builder);\n\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(ResponseErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(ResponseErrorHandler errorHandler) {\n\t\t\tAssert.notNull(errorHandler, \"ResponseErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.fromErrorHandler(errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(statusPredicate,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler) {\n\t\t\tAssert.notNull(statusPredicate, \"StatusPredicate must not be null\");\n\t\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.of(statusPredicate, errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#patch()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec patch()",
    "source_code": "\tpublic RequestBodyUriSpec patch() {\n\t\treturn methodInternal(HttpMethod.PATCH);\n\t}"
  },
  "org.springframework.web.client.<unknown>#post()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec post()",
    "source_code": "\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "RequestBodyUriSpec",
    "signature": "public RequestBodyUriSpec put()",
    "source_code": "\tpublic RequestBodyUriSpec put() {\n\t\treturn methodInternal(HttpMethod.PUT);\n\t}"
  },
  "org.springframework.web.client.<unknown>#retrieve()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec retrieve()",
    "source_code": "\t\tpublic ResponseSpec retrieve() {\n\t\t\treturn exchangeInternal(DefaultResponseSpec::new, false);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#toBodilessEntity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 579
    },
    "return": "ResponseEntity<Void>",
    "signature": "public ResponseEntity<Void> toBodilessEntity()",
    "source_code": "\t\tpublic ResponseEntity<Void> toBodilessEntity() {\n\t\t\ttry (this.clientResponse) {\n\t\t\t\tapplyStatusHandlers(this.clientRequest, this.clientResponse);\n\t\t\t\treturn ResponseEntity.status(this.clientResponse.getStatusCode())\n\t\t\t\t\t\t.headers(this.clientResponse.getHeaders())\n\t\t\t\t\t\t.build();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new ResourceAccessException(\"Could not retrieve response status code: \" + ex.getMessage(), ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#toEntity(bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> ResponseEntity<T> toEntity(ParameterizedTypeReference<T> bodyType) {\n\t\t\tType type = bodyType.getType();\n\t\t\tClass<T> bodyClass = bodyClass(type);\n\t\t\treturn toEntityInternal(type, bodyClass);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uri)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(URI uri)",
    "source_code": "\t\tpublic RequestBodySpec uri(URI uri) {\n\t\t\tthis.uri = uri;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.uriString(uriTemplate)));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.RestTemplate#getObservationConvention()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ClientRequestObservationConvention}, or {@code null} if not set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "ClientRequestObservationConvention",
    "signature": "public ClientRequestObservationConvention getObservationConvention()",
    "source_code": "\tpublic ClientRequestObservationConvention getObservationConvention() {\n\t\treturn this.observationConvention;\n\t}"
  },
  "org.springframework.web.client.RestTemplate#getObservationRegistry()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the configured {@link ObservationRegistry}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ObservationRegistry",
    "signature": "public ObservationRegistry getObservationRegistry()",
    "source_code": "\tpublic ObservationRegistry getObservationRegistry() {\n\t\treturn this.observationRegistry;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkArguments(beanType,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "boolean",
    "signature": "public boolean checkArguments(Class<?> beanType, MethodParameter[] parameters)",
    "source_code": "\t\tpublic static boolean checkArguments(Class<?> beanType, MethodParameter[] parameters) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tfor (MethodParameter parameter : parameters) {\n\t\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(parameter.getParameterAnnotations());\n\t\t\t\t\tif (merged.stream().anyMatch(CONSTRAINT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tClass<?> type = parameter.getParameterType();\n\t\t\t\t\t\tif (merged.stream().anyMatch(VALID_PREDICATE) && List.class.isAssignableFrom(type)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#checkReturnValue(beanType,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean checkReturnValue(Class<?> beanType, Method method)",
    "source_code": "\t\tpublic static boolean checkReturnValue(Class<?> beanType, Method method) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n\t\t\t\treturn merged.stream().anyMatch(CONSTRAINT_PREDICATE.or(VALID_PREDICATE));\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#clone()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 597
    },
    "return": "ReturnValueMethodParameter",
    "signature": "public ReturnValueMethodParameter clone()",
    "source_code": "\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getBridgedMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Method",
    "signature": "protected Method getBridgedMethod()",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethod()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "Method",
    "signature": "public Method getMethod()",
    "source_code": "\t\tpublic Method getMethod() {\n\t\t\treturn HandlerMethod.this.bridgedMethod;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "T",
    "signature": "public T getMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getMethodParameters()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the method parameters for this handler method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodParameter[]",
    "signature": "public MethodParameter[] getMethodParameters()",
    "source_code": "\tpublic MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#getReturnType()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the HandlerMethod return type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnType()",
    "source_code": "\tpublic MethodParameter getReturnType() {\n\t\treturn new HandlerMethodParameter(-1);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#getReturnValueType(returnValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the actual return value type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#hasMethodAnnotation(annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "boolean",
    "signature": "public boolean hasMethodAnnotation(Class<T> annotationType)",
    "source_code": "\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}"
  },
  "org.springframework.web.method.HandlerMethod#isVoid()": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the method return type is void, {@code false} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "boolean",
    "signature": "public boolean isVoid()",
    "source_code": "\tpublic boolean isVoid() {\n\t\treturn Void.TYPE.equals(getReturnType().getParameterType());\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateArguments()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method arguments are a candidate for method validation, which\n\t * is the case when there are parameter {@code jakarta.validation.Constraint}\n\t * annotations.\n\t * <p>The presence of {@code jakarta.validation.Valid} by itself does not\n\t * trigger method validation since such parameters are already validated at\n\t * the level of argument resolvers.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateArguments()",
    "source_code": "\tpublic boolean shouldValidateArguments() {\n\t\treturn this.validateArguments;\n\t}"
  },
  "org.springframework.web.method.HandlerMethod#shouldValidateReturnValue()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the method return value is a candidate for method validation, which\n\t * is the case when there are method {@code jakarta.validation.Constraint}\n\t * or {@code jakarta.validation.Valid} annotations.\n\t * <p><strong>Note:</strong> if the class is annotated with {@link Validated},\n\t * this method returns false, deferring to method validation via AOP proxy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "boolean",
    "signature": "public boolean shouldValidateReturnValue()",
    "source_code": "\tpublic boolean shouldValidateReturnValue() {\n\t\treturn this.validateReturnValue;\n\t}"
  },
  "org.springframework.web.method.HandlerMethodParameter": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A MethodParameter with HandlerMethod-specific behavior.\n\t */",
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "signature": "protected class HandlerMethodParameter",
    "source_code": "\tprotected class HandlerMethodParameter extends SynthesizingMethodParameter {\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic HandlerMethodParameter(int index) {\n\t\t\tsuper(HandlerMethod.this.bridgedMethod, index);\n\t\t}\n\n\t\tprotected HandlerMethodParameter(HandlerMethodParameter original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\t@NonNull\n\t\tpublic Method getMethod() {\n\t\t\treturn HandlerMethod.this.bridgedMethod;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn HandlerMethod.this.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn HandlerMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInterfaceParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic HandlerMethodParameter clone() {\n\t\t\treturn new HandlerMethodParameter(this);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link MethodValidator} that\n * uses Bean Validation to validate {@code @RequestMapping} method arguments.\n *\n * <p>Handles validation results by populating {@link BindingResult} method\n * arguments with errors from {@link MethodValidationResult#getBeanResults()\n * beanResults}. Also, helps to determine parameter names for\n * {@code @ModelAttribute} and {@code @RequestBody} parameters.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "signature": "public class HandlerMethodValidator",
    "source_code": "public final class HandlerMethodValidator implements MethodValidator {\n\n\tprivate static final MethodValidationAdapter.ObjectNameResolver objectNameResolver = new WebObjectNameResolver();\n\n\n\tprivate final MethodValidationAdapter validationAdapter;\n\n\tprivate final Predicate<MethodParameter> modelAttribitePredicate;\n\n\tprivate final Predicate<MethodParameter> requestParamPredicate;\n\n\n\tprivate HandlerMethodValidator(MethodValidationAdapter validationAdapter,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tthis.validationAdapter = validationAdapter;\n\t\tthis.modelAttribitePredicate = modelAttribitePredicate;\n\t\tthis.requestParamPredicate = requestParamPredicate;\n\t}\n\n\n\t@Override\n\tpublic Class<?>[] determineValidationGroups(Object target, Method method) {\n\t\treturn this.validationAdapter.determineValidationGroups(target, method);\n\t}\n\n\t@Override\n\tpublic void applyArgumentValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateArguments(target, method, parameters, arguments, groups);\n\t\tif (!result.hasErrors()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.getBeanResults().isEmpty()) {\n\t\t\tint bindingResultCount = 0;\n\t\t\tfor (ParameterErrors errors : result.getBeanResults()) {\n\t\t\t\tfor (Object arg : arguments) {\n\t\t\t\t\tif (arg instanceof BindingResult bindingResult) {\n\t\t\t\t\t\tif (bindingResult.getObjectName().equals(errors.getObjectName())) {\n\t\t\t\t\t\t\tbindingResult.addAllErrors(errors);\n\t\t\t\t\t\t\tbindingResultCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.getAllValidationResults().size() == bindingResultCount) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new HandlerMethodValidationException(\n\t\t\t\tresult, this.modelAttribitePredicate, this.requestParamPredicate);\n\t}\n\n\t@Override\n\tpublic MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateArguments(target, method, parameters, arguments, groups);\n\t}\n\n\t@Override\n\tpublic void applyReturnValueValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateReturnValue(target, method, returnType, returnValue, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new HandlerMethodValidationException(result);\n\t\t}\n\t}\n\n\t@Override\n\tpublic MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateReturnValue(target, method, returnType, returnValue, groups);\n\t}\n\n\n\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */\n\t@Nullable\n\tpublic static MethodValidator from(\n\t\t\t@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tif (initializer instanceof ConfigurableWebBindingInitializer configurableInitializer) {\n\t\t\tValidator validator = getValidator(configurableInitializer);\n\t\t\tif (validator != null) {\n\t\t\t\tMethodValidationAdapter adapter = new MethodValidationAdapter(validator);\n\t\t\t\tadapter.setObjectNameResolver(objectNameResolver);\n\t\t\t\tif (paramNameDiscoverer != null) {\n\t\t\t\t\tadapter.setParameterNameDiscoverer(paramNameDiscoverer);\n\t\t\t\t}\n\t\t\t\tMessageCodesResolver codesResolver = configurableInitializer.getMessageCodesResolver();\n\t\t\t\tif (codesResolver != null) {\n\t\t\t\t\tadapter.setMessageCodesResolver(codesResolver);\n\t\t\t\t}\n\t\t\t\treturn new HandlerMethodValidator(adapter, modelAttribitePredicate, requestParamPredicate);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate static Validator getValidator(ConfigurableWebBindingInitializer initializer) {\n\t\tif (initializer.getValidator() instanceof Validator validator) {\n\t\t\treturn validator;\n\t\t}\n\t\tif (initializer.getValidator() instanceof SmartValidator smartValidator) {\n\t\t\treturn smartValidator.unwrap(Validator.class);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * ObjectNameResolver for web controller methods.\n\t */\n\tprivate static class WebObjectNameResolver implements MethodValidationAdapter.ObjectNameResolver {\n\n\t\t@Override\n\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#applyArgumentValidation(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void applyArgumentValidation(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic void applyArgumentValidation("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#applyReturnValueValidation(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void applyReturnValueValidation(Object target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic void applyReturnValueValidation("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#from(initializer,paramNameDiscoverer,modelAttribitePredicate,requestParamPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initializer",
      "paramNameDiscoverer",
      "modelAttribitePredicate",
      "requestParamPredicate"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "MethodValidator",
    "signature": "public MethodValidator from(@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate)",
    "source_code": "\tpublic static MethodValidator from("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#resolveName(param,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter param, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateArguments("
  },
  "org.springframework.web.method.annotation.HandlerMethodValidator#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateReturnValue(Object target, Method method,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments and handle\n * return values from {@code @ModelAttribute} annotated methods.\n *\n * <p>Model attributes are obtained from the model or created with a default\n * constructor (and then added to the model). Once created the attribute is\n * populated via data binding to Servlet request parameters. Validation may be\n * applied if the argument is annotated with {@code @jakarta.validation.Valid}.\n * or Spring's own {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code annotationNotRequired=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Vladislav Kisel\n * @since 3.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "signature": "public class ModelAttributeMethodProcessor",
    "source_code": "public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final boolean annotationNotRequired;\n\n\n\t/**\n\t * Class constructor.\n\t * @param annotationNotRequired if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation\n\t */\n\tpublic ModelAttributeMethodProcessor(boolean annotationNotRequired) {\n\t\tthis.annotationNotRequired = annotationNotRequired;\n\t}\n\n\n\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}\n\n\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */\n\t@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\");\n\t\tAssert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\");\n\n\t\tString name = ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann != null) {\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t}\n\n\t\tObject attribute = null;\n\t\tBindingResult bindingResult = null;\n\n\t\tif (mavContainer.containsAttribute(name)) {\n\t\t\tattribute = mavContainer.getModel().get(name);\n\t\t}\n\t\telse {\n\t\t\t// Create attribute instance\n\t\t\ttry {\n\t\t\t\tattribute = createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t}\n\t\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\t\tif (isBindExceptionRequired(parameter)) {\n\t\t\t\t\t// No BindingResult parameter -> fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Otherwise, expose null/empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\t\t\tattribute = Optional.empty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattribute = ex.getTarget();\n\t\t\t\t}\n\t\t\t\tbindingResult = ex.getBindingResult();\n\t\t\t}\n\t\t}\n\n\t\tif (bindingResult == null) {\n\t\t\t// Bean property binding and validation;\n\t\t\t// skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() != null) {\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) {\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t}\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) {\n\t\t\t\tattribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t}\n\t\t\tbindingResult = binder.getBindingResult();\n\t\t}\n\n\t\t// Add resolved attribute and BindingResult at the end of the model\n\t\tMap<String, Object> bindingResultModel = bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */\n\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\ttry {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\tcatch (BeanInstantiationException ex) {\n\t\t\tif (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) &&\n\t\t\t\t\tex.getCause() instanceof NullPointerException cause) {\n\t\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\t\tObjectError error = new ObjectError(ctor.getName(), cause.getMessage());\n\t\t\t\tresult.addError(error);\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */\n\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}\n\n\t@Nullable\n\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */\n\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */\n\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */\n\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */\n\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}\n\n\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}\n\n\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t * @since 5.1\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate final String parameterName;\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, String parameterName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = parameterName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#bindRequestParameters(binder,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterAnnotations()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "Annotation[]",
    "signature": "public Annotation[] getParameterAnnotations()",
    "source_code": "\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterName()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "String",
    "signature": "public String getParameterName()",
    "source_code": "\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getTarget()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "Object",
    "signature": "public Object getTarget()",
    "source_code": "\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#isBindExceptionRequired(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsParameter(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsReturnType(returnType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "boolean",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateIfApplicable(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,"
  },
  "org.springframework.web.method.annotation.logger": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "field",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "signature": "protected Log logger",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "type": "Log"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#invokeFunction(method,target,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args) {\n\t\t\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\n\t\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t}\n\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\tint index = 0;\n\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\tcase VALUE -> {\n\t\t\t\t\t\tif (!parameter.isOptional() || args[index] != null) {\n\t\t\t\t\t\t\targMap.put(parameter, args[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function.callBy(argMap);\n\t\t}"
  },
  "org.springframework.web.method.support.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Context to assist with binding request data onto Objects and provide access\n * to a shared {@link Model} with controller-specific attributes.\n *\n * <p>Provides  methods to create a {@link WebExchangeDataBinder} for a specific\n * target, command Object to apply data binding and validation to, or without a\n * target Object for simple type conversion from request values.\n *\n * <p>Container for the default model for the request.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class BindingContext",
    "source_code": "public class BindingContext {\n\n\t@Nullable\n\tprivate final WebBindingInitializer initializer;\n\n\tprivate final Model model = new BindingAwareConcurrentModel();\n\n\tprivate boolean methodValidationApplicable;\n\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Create an instance without an initializer.\n\t */\n\tpublic BindingContext() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Create an instance with the given initializer, which may be {@code null}.\n\t */\n\tpublic BindingContext(@Nullable WebBindingInitializer initializer) {\n\t\tthis(initializer, ReactiveAdapterRegistry.getSharedInstance());\n\t}\n\n\t/**\n\t * Create an instance with the given initializer and {@code ReactiveAdapterRegistry}.\n\t * @since 6.1\n\t */\n\tpublic BindingContext(@Nullable WebBindingInitializer initializer, ReactiveAdapterRegistry registry) {\n\t\tthis.initializer = initializer;\n\t\tthis.reactiveAdapterRegistry = new ReactiveAdapterRegistry();\n\t}\n\n\n\t/**\n\t * Return the default model.\n\t */\n\tpublic Model getModel() {\n\t\treturn this.model;\n\t}\n\n\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */\n\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}\n\n\n\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}\n\n\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}\n\n\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */\n\tpublic WebExchangeDataBinder createDataBinder(\n\t\t\tServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType) {\n\n\t\tWebExchangeDataBinder dataBinder = new ExtendedWebExchangeDataBinder(target, name);\n\t\tdataBinder.setNameResolver(new BindParamNameResolver());\n\n\t\tif (target == null && targetType != null) {\n\t\t\tdataBinder.setTargetType(targetType);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\n\t\tdataBinder = initDataBinder(dataBinder, exchange);\n\n\t\tif (this.methodValidationApplicable && targetType != null) {\n\t\t\tif (targetType.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}\n\n\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */\n\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}\n\n\t/**\n\t * Invoked before rendering to add {@link BindingResult} attributes where\n\t * necessary, and also to promote model attributes listed as\n\t * {@code @SessionAttributes} to the session.\n\t * @param exchange the current exchange\n\t * @since 6.1\n\t */\n\tpublic void updateModel(ServerWebExchange exchange) {\n\t\tMap<String, Object> model = getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isBindingCandidate(String name, @Nullable Object value) {\n\t\treturn (!name.startsWith(BindingResult.MODEL_KEY_PREFIX) && value != null &&\n\t\t\t\t!value.getClass().isArray() && !(value instanceof Collection) && !(value instanceof Map) &&\n\t\t\t\tthis.reactiveAdapterRegistry.getAdapter(null, value) == null &&\n\t\t\t\t!BeanUtils.isSimpleValueType(value.getClass()));\n\t}\n\n\n\t/**\n\t * Extended variant of {@link WebExchangeDataBinder}, adding path variables.\n\t */\n\tprivate static class ExtendedWebExchangeDataBinder extends WebExchangeDataBinder {\n\n\t\tpublic ExtendedWebExchangeDataBinder(@Nullable Object target, String objectName) {\n\t\t\tsuper(target, objectName);\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}\n\t}\n\n\n\t/**\n\t * Excludes Bean Validation if the method parameter has {@code @Valid}.\n\t */\n\tprivate static class MethodValidationInitializer {\n\n\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#createDataBinder(exchange,target,name,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder("
  },
  "org.springframework.web.reactive.BindingContext#getModel()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Model",
    "signature": "public Model getModel()",
    "source_code": "\tpublic Model getModel() {\n\t\treturn this.model;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#getValuesToBind(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(ServerWebExchange exchange)",
    "source_code": "\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}"
  },
  "org.springframework.web.reactive.BindingContext#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.BindingContext#initDataBinder(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#setMethodValidationApplicable(methodValidationApplicable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure flag to signal whether validation will be applied to handler\n\t * method arguments, which is the case if Bean Validation is enabled in\n\t * Spring MVC, and method parameters have {@code @Constraint} annotations.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidationApplicable"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void setMethodValidationApplicable(boolean methodValidationApplicable)",
    "source_code": "\tpublic void setMethodValidationApplicable(boolean methodValidationApplicable) {\n\t\tthis.methodValidationApplicable = methodValidationApplicable;\n\t}"
  },
  "org.springframework.web.reactive.BindingContext#updateModel(exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked before rendering to add {@link BindingResult} attributes where\n\t * necessary, and also to promote model attributes listed as\n\t * {@code @SessionAttributes} to the session.\n\t * @param exchange the current exchange\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void updateModel(ServerWebExchange exchange)",
    "source_code": "\tpublic void updateModel(ServerWebExchange exchange) {\n\t\tMap<String, Object> model = getModel().asMap();\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (isBindingCandidate(name, value)) {\n\t\t\t\tif (!model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) {\n\t\t\t\t\tWebExchangeDataBinder binder = createDataBinder(exchange, value, name);\n\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.BodyInserters#fromOutputStream(outputStreamConsumer,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter based on bytes written to a {@code OutputStream}.\n\t * @param outputStreamConsumer invoked with an {@link OutputStream} that\n\t * writes to the output message\n\t * @param executor used to invoke the {@code outputStreamHandler} on a\n\t * separate thread\n\t * @return an inserter that writes what is written to the output stream\n\t * @since 6.1\n\t * @see DataBufferUtils#outputStreamPublisher(Consumer, DataBufferFactory, Executor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromOutputStream(Consumer<OutputStream> outputStreamConsumer, Executor executor)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromOutputStream("
  },
  "org.springframework.web.reactive.function.BodyInserters#fromOutputStream(outputStreamConsumer,executor,chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter based on bytes written to a {@code OutputStream}.\n\t * @param outputStreamConsumer invoked with an {@link OutputStream} that\n\t * writes to the output message\n\t * @param executor used to invoke the {@code outputStreamHandler} on a\n\t * separate thread\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return an inserter that writes what is written to the output stream\n\t * @since 6.1\n\t * @see DataBufferUtils#outputStreamPublisher(Consumer, DataBufferFactory, Executor, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromOutputStream(Consumer<OutputStream> outputStreamConsumer, Executor executor, int chunkSize)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromOutputStream("
  },
  "org.springframework.web.reactive.function.client.<unknown>#request()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "HttpRequest",
    "signature": "public HttpRequest request()",
    "source_code": "\tpublic HttpRequest request() {\n\t\treturn this.requestSupplier.get();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link ReactorHttpExchangeAdapter} that enables an {@link HttpServiceProxyFactory}\n * to use {@link WebClient} for request execution.\n *\n * <p>Use static factory methods in this class to create an\n * {@code HttpServiceProxyFactory} configured with a given {@code WebClient}.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "signature": "public class WebClientAdapter",
    "source_code": "public final class WebClientAdapter extends AbstractReactorHttpExchangeAdapter {\n\n\tprivate final WebClient webClient;\n\n\n\t/**\n\t * Package private constructor. See static factory methods.\n\t */\n\tprivate WebClientAdapter(WebClient webClient) {\n\t\tthis.webClient = webClient;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Mono<Void> exchangeForMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().then();\n\t}\n\n\t@Override\n\tpublic Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().map(ResponseEntity::getHeaders);\n\t}\n\n\t@Override\n\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}\n\n\t@Override\n\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}\n\n\t@Override\n\tpublic Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity();\n\t}\n\n\t@Override\n\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}\n\n\t@Override\n\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}\n\n\t@SuppressWarnings(\"ReactiveStreamsUnusedPublisher\")\n\tprivate WebClient.RequestBodySpec newRequest(HttpRequestValues requestValues) {\n\n\t\tHttpMethod httpMethod = requestValues.getHttpMethod();\n\t\tAssert.notNull(httpMethod, \"HttpMethod is required\");\n\n\t\tWebClient.RequestBodyUriSpec uriSpec = this.webClient.method(httpMethod);\n\n\t\tWebClient.RequestBodySpec bodySpec;\n\t\tif (requestValues.getUri() != null) {\n\t\t\tbodySpec = uriSpec.uri(requestValues.getUri());\n\t\t}\n\t\telse if (requestValues.getUriTemplate() != null) {\n\t\t\tbodySpec = uriSpec.uri(requestValues.getUriTemplate(), requestValues.getUriVariables());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither full URL nor URI template\");\n\t\t}\n\n\t\tbodySpec.headers(headers -> headers.putAll(requestValues.getHeaders()));\n\t\tbodySpec.cookies(cookies -> cookies.putAll(requestValues.getCookies()));\n\t\tbodySpec.attributes(attributes -> attributes.putAll(requestValues.getAttributes()));\n\n\t\tif (requestValues.getBodyValue() != null) {\n\t\t\tbodySpec.bodyValue(requestValues.getBodyValue());\n\t\t}\n\t\telse if (requestValues instanceof ReactiveHttpRequestValues reactiveRequestValues) {\n\t\t\tPublisher<?> body = reactiveRequestValues.getBodyPublisher();\n\t\t\tif (body != null) {\n\t\t\t\tParameterizedTypeReference<?> elementType = reactiveRequestValues.getBodyPublisherElementType();\n\t\t\t\tAssert.notNull(elementType, \"Publisher body element type is required\");\n\t\t\t\tbodySpec.body(body, elementType);\n\t\t\t}\n\t\t}\n\n\t\treturn bodySpec;\n\t}\n\n\n\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @since 6.1\n\t */\n\tpublic static WebClientAdapter create(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}\n\n\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @deprecated in favor of {@link #create(WebClient)} aligning with other adapter\n\t * implementations; to be removed in 6.2.\n\t */\n\t@Deprecated(since = \"6.1\", forRemoval = true)\n\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}\n\n}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#create(webClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webClient"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "WebClientAdapter",
    "signature": "public WebClientAdapter create(WebClient webClient)",
    "source_code": "\tpublic static WebClientAdapter create(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodilessEntityMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Mono<ResponseEntity<Void>>",
    "signature": "public Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<ResponseEntity<Void>> exchangeForBodilessEntityMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodyFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForBodyMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForEntityFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForEntityMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForHeadersMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "Mono<HttpHeaders>",
    "signature": "public Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<HttpHeaders> exchangeForHeadersMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().map(ResponseEntity::getHeaders);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#exchangeForMono(requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> exchangeForMono(HttpRequestValues requestValues)",
    "source_code": "\tpublic Mono<Void> exchangeForMono(HttpRequestValues requestValues) {\n\t\treturn newRequest(requestValues).retrieve().toBodilessEntity().then();\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#forClient(webClient)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @deprecated in favor of {@link #create(WebClient)} aligning with other adapter\n\t * implementations; to be removed in 6.2.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webClient"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "WebClientAdapter",
    "signature": "public WebClientAdapter forClient(WebClient webClient)",
    "source_code": "\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.WebClientAdapter#supportsRequestAttributes()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean supportsRequestAttributes()",
    "source_code": "\tpublic boolean supportsRequestAttributes() {\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bind(bindType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType"
    ],
    "position": {
      "column": 1,
      "line": 1144
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType) {\n\t\t\treturn this.request.bind(bindType);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1149
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) {\n\t\t\treturn this.request.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#modify(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "void",
    "signature": "public void modify(ServerRequest request)",
    "source_code": "\t\t\tpublic void modify(ServerRequest request) {\n\t\t\t\tif (this.modify != null) {\n\t\t\t\t\tthis.modify.accept(request);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#of(requestPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPredicate"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "RequestModifyingPredicate",
    "signature": "public RequestModifyingPredicate of(RequestPredicate requestPredicate)",
    "source_code": "\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#of(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "Result",
    "signature": "public Result of(boolean value)",
    "source_code": "\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#of(value,commit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "commit"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<ServerRequest> commit)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<ServerRequest> commit) {\n\t\t\t\tif (commit == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, commit);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#testInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 976
    },
    "return": "Result",
    "signature": "protected Result testInternal(ServerRequest request)",
    "source_code": "\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.rightModifying.testInternal(request);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.RequestPredicates#value()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "boolean",
    "signature": "public boolean value()",
    "source_code": "\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.Result": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "signature": "protected class Result",
    "source_code": "\t\tprotected static final class Result {\n\n\t\t\tprivate static final Result TRUE = new Result(true, null);\n\n\t\t\tprivate static final Result FALSE = new Result(false, null);\n\n\n\t\t\tprivate final boolean value;\n\n\t\t\t@Nullable\n\t\t\tprivate final Consumer<ServerRequest> modify;\n\n\n\t\t\tprivate Result(boolean value, @Nullable Consumer<ServerRequest> modify) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.modify = modify;\n\t\t\t}\n\n\n\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}\n\n\t\t\tpublic static Result of(boolean value, @Nullable Consumer<ServerRequest> commit) {\n\t\t\t\tif (commit == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, commit);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tpublic void modify(ServerRequest request) {\n\t\t\t\tif (this.modify != null) {\n\t\t\t\t\tthis.modify.accept(request);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#invokeFunction(method,target,args,isSuspendingFunction,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args",
      "isSuspendingFunction",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,"
  },
  "org.springframework.web.reactive.result.method.InvocableHandlerMethod#setMethodValidator(methodValidator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link MethodValidator} to perform method validation with if the\n\t * controller method {@link #shouldValidateArguments()} or\n\t * {@link #shouldValidateReturnValue()}.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodValidator"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setMethodValidator(@Nullable MethodValidator methodValidator)",
    "source_code": "\tpublic void setMethodValidator(@Nullable MethodValidator methodValidator) {\n\t\tthis.methodValidator = methodValidator;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments.\n *\n * <p>Model attributes are sourced from the model, or created using a default\n * constructor and then added to the model. Once created the attribute is\n * populated via data binding to the request (form data, query params).\n * Validation also may be applied if the argument is annotated with\n * {@code @jakarta.validation.Valid} or Spring's own\n * {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code useDefaultResolution=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "signature": "public class ModelAttributeMethodArgumentResolver",
    "source_code": "public class ModelAttributeMethodArgumentResolver extends HandlerMethodArgumentResolverSupport {\n\n\tprivate final boolean useDefaultResolution;\n\n\n\t/**\n\t * Class constructor with a default resolution mode flag.\n\t * @param adapterRegistry for adapting to other reactive types from and to Mono\n\t * @param useDefaultResolution if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation present.\n\t */\n\tpublic ModelAttributeMethodArgumentResolver(ReactiveAdapterRegistry adapterRegistry,\n\t\t\tboolean useDefaultResolution) {\n\n\t\tsuper(adapterRegistry);\n\t\tthis.useDefaultResolution = useDefaultResolution;\n\t}\n\n\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter, exchange);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}\n\n\t/**\n\t * Determine if binding should be disabled for the supplied {@link MethodParameter},\n\t * based on the {@link ModelAttribute#binding} annotation attribute.\n\t * @since 5.2.15\n\t */\n\tprivate boolean bindingDisabled(MethodParameter parameter) {\n\t\tModelAttribute modelAttribute = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\treturn (modelAttribute != null && !modelAttribute.binding());\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */\n\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}\n\n\tprivate Mono<?> prepareAttributeMono(String attributeName, ResolvableType attributeType,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tObject attribute = context.getModel().asMap().get(attributeName);\n\n\t\tif (attribute == null) {\n\t\t\tattribute = findAndRemoveReactiveAttribute(context.getModel(), attributeName);\n\t\t}\n\n\t\tif (attribute == null) {\n\t\t\treturn createAttribute(attributeName, attributeType.toClass(), context, exchange);\n\t\t}\n\n\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, attribute);\n\t\tif (adapter != null) {\n\t\t\tAssert.isTrue(!adapter.isMultiValue(), \"Data binding only supports single-value async types\");\n\t\t\treturn Mono.from(adapter.toPublisher(attribute));\n\t\t}\n\t\telse {\n\t\t\treturn Mono.justOrEmpty(attribute);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object findAndRemoveReactiveAttribute(Model model, String attributeName) {\n\t\treturn model.asMap().entrySet().stream()\n\t\t\t\t.filter(entry -> {\n\t\t\t\t\tif (!entry.getKey().startsWith(attributeName)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tReactiveAdapter adapter = getAdapterRegistry().getAdapter(null, entry.getValue());\n\t\t\t\t\tif (adapter == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tString name = attributeName + ClassUtils.getShortName(adapter.getReactiveType());\n\t\t\t\t\treturn entry.getKey().equals(name);\n\t\t\t\t})\n\t\t\t\t.findFirst()\n\t\t\t\t.map(entry -> {\n\t\t\t\t\t// Remove since we will be re-inserting the resolved attribute value\n\t\t\t\t\tmodel.asMap().remove(entry.getKey());\n\t\t\t\t\treturn entry.getValue();\n\t\t\t\t})\n\t\t\t\t.orElse(null);\n\t}\n\n\tprivate Mono<?> createAttribute(\n\t\t\tString attributeName, Class<?> clazz, BindingContext context, ServerWebExchange exchange) {\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\treturn constructAttribute(ctor, attributeName, context, exchange);\n\t}\n\n\tprivate Mono<?> constructAttribute(Constructor<?> ctor, String attributeName,\n\t\t\tBindingContext context, ServerWebExchange exchange) {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn Mono.just(BeanUtils.instantiateClass(ctor));\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, null, attributeName);\n\t\treturn getValuesToBind(binder, exchange).map(bindValues -> {\n\t\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tObject value = bindValues.get(paramName);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\t\tvalue = bindValues.get(fieldDefaultPrefix + paramName);\n\t\t\t\t\t}\n\t\t\t\t\tif (value == null && fieldMarkerPrefix != null) {\n\t\t\t\t\t\tif (bindValues.get(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = (value instanceof List<?> list ? list.toArray() : value);\n\t\t\t\tMethodParameter methodParam = new MethodParameter(ctor, i);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tthrow new ServerWebInputException(\"Type mismatch.\", methodParam, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t});\n\t}\n\n\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */\n\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}\n\n\tprivate boolean hasErrorsArgument(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\treturn (paramTypes.length > i + 1 && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t}\n\n\tprivate void validateIfApplicable(WebExchangeDataBinder binder, MethodParameter parameter, ServerWebExchange exchange) {\n\t\tLocaleContext localeContext = null;\n\t\ttry {\n\t\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\t\tif (validationHints != null) {\n\t\t\t\t\tif (localeContext == null) {\n\t\t\t\t\t\tlocaleContext = exchange.getLocaleContext();\n\t\t\t\t\t\tLocaleContextHolder.setLocaleContext(localeContext);\n\t\t\t\t\t}\n\t\t\t\t\tbinder.validate(validationHints);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (localeContext != null) {\n\t\t\t\tLocaleContextHolder.resetLocaleContext();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#bindRequestParameters(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#getValuesToBind(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#resolveArgument(parameter,context,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument("
  },
  "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#supportsParameter(parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setBlockingExecutor(executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an executor to invoke blocking controller methods with.\n\t * <p>By default, this is not set in which case controller methods are\n\t * invoked without the use of an Executor.\n\t * @param executor the task executor to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void setBlockingExecutor(@Nullable Executor executor)",
    "source_code": "\tpublic void setBlockingExecutor(@Nullable Executor executor) {\n\t\tthis.scheduler = (executor != null ? Schedulers.fromExecutor(executor) : null);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setBlockingMethodPredicate(predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a predicate to decide which controller methods to invoke through\n\t * the configured {@link #setBlockingExecutor blockingExecutor}.\n\t * <p>If an executor is configured, the default predicate matches controller\n\t * methods whose return type is not recognized by the configured\n\t * {@link org.springframework.core.ReactiveAdapterRegistry}.\n\t * @param predicate the predicate to use\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setBlockingMethodPredicate(Predicate<HandlerMethod> predicate)",
    "source_code": "\tpublic void setBlockingMethodPredicate(Predicate<HandlerMethod> predicate) {\n\t\tthis.blockingMethodPredicate = predicate;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#test(handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "boolean",
    "signature": "public boolean test(HandlerMethod handlerMethod)",
    "source_code": "\t\tpublic boolean test(HandlerMethod handlerMethod) {\n\t\t\tClass<?> returnType = handlerMethod.getReturnType().getParameterType();\n\t\t\treturn (this.adapterRegistry.getAdapter(returnType) == null);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, or meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException("
  },
  "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#handleMethodValidationException(ex,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodValidationException(MethodValidationException ex, HttpStatus status, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodValidationException("
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Jetty {@link WebSocket @WebSocket} handler that delegates events to a\n * reactive {@link WebSocketHandler} and its session.\n *\n * @author Violeta Georgieva\n * @author Rossen Stoyanchev\n * @since 5.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "signature": "public class JettyWebSocketHandlerAdapter",
    "source_code": "public class JettyWebSocketHandlerAdapter {\n\n\tprivate static final ByteBuffer EMPTY_PAYLOAD = ByteBuffer.wrap(new byte[0]);\n\n\n\tprivate final WebSocketHandler delegateHandler;\n\n\tprivate final Function<Session, JettyWebSocketSession> sessionFactory;\n\n\t@Nullable\n\tprivate JettyWebSocketSession delegateSession;\n\n\n\tpublic JettyWebSocketHandlerAdapter(WebSocketHandler handler,\n\t\t\tFunction<Session, JettyWebSocketSession> sessionFactory) {\n\n\t\tAssert.notNull(handler, \"WebSocketHandler is required\");\n\t\tAssert.notNull(sessionFactory, \"'sessionFactory' is required\");\n\t\tthis.delegateHandler = handler;\n\t\tthis.sessionFactory = sessionFactory;\n\t}\n\n\n\t@OnWebSocketOpen\n\tpublic void onWebSocketOpen(Session session) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getUpgradeRequest().getRequestURI() + \" [JettyWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}\n\n\t@OnWebSocketMessage\n\tpublic void onWebSocketText(String message) {\n\t\tif (this.delegateSession != null) {\n\t\t\tbyte[] bytes = message.getBytes(StandardCharsets.UTF_8);\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(bytes);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.TEXT, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}\n\n\t@OnWebSocketMessage\n\tpublic void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.BINARY, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}\n\n\t@OnWebSocketFrame\n\tpublic void onWebSocketFrame(Frame frame, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tif (OpCode.PONG == frame.getOpCode()) {\n\t\t\t\tByteBuffer byteBuffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);\n\t\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.PONG, buffer);\n\t\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t\t}\n\t\t}\n\t}\n\n\t@OnWebSocketClose\n\tpublic void onWebSocketClose(int statusCode, String reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(statusCode, reason));\n\t\t}\n\t}\n\n\t@OnWebSocketError\n\tpublic void onWebSocketError(Throwable cause) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(cause);\n\t\t}\n\t}\n\n\n\tprivate static final class JettyDataBuffer implements CloseableDataBuffer {\n\n\t\tprivate final DataBuffer delegate;\n\n\t\tprivate final Callback callback;\n\n\t\tpublic JettyDataBuffer(DataBuffer delegate, Callback callback) {\n\t\t\tAssert.notNull(delegate, \"'delegate` must not be null\");\n\t\t\tAssert.notNull(callback, \"Callback must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.callback = callback;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tthis.callback.succeed();\n\t\t}\n\n\t\t// delegation\n\n\t\t@Override\n\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}\n\n\t\t@Override\n\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}\n\n\t\t@Override\n\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(DataBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.callback);\n\t\t}\n\n\t\t@Override\n\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.callback);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}\n\n\n\t\tprivate record JettyByteBufferIterator(ByteBufferIterator delegate) implements ByteBufferIterator {\n\n\t\t\t@Override\n\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#asByteBuffer()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer()",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer() {\n\t\t\treturn this.delegate.asByteBuffer();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#capacity()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "int",
    "signature": "public int capacity()",
    "source_code": "\t\tpublic int capacity() {\n\t\t\treturn this.delegate.capacity();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#capacity(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer capacity(int capacity)",
    "source_code": "\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#close()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void close()",
    "source_code": "\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#ensureWritable(capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer ensureWritable(int capacity)",
    "source_code": "\t\tpublic DataBuffer ensureWritable(int capacity) {\n\t\t\tthis.delegate.ensureWritable(capacity);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#factory()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "DataBufferFactory",
    "signature": "public DataBufferFactory factory()",
    "source_code": "\t\tpublic DataBufferFactory factory() {\n\t\t\treturn this.delegate.factory();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#getByte(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "byte",
    "signature": "public byte getByte(int index)",
    "source_code": "\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#hasNext()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "public boolean hasNext()",
    "source_code": "\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn this.delegate.hasNext();\n\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#next()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer next()",
    "source_code": "\t\t\tpublic ByteBuffer next() {\n\t\t\t\treturn this.delegate.next();\n\t\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketBinary(byteBuffer,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback)",
    "source_code": "\tpublic void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.BINARY, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketClose(statusCode,reason)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void onWebSocketClose(int statusCode, String reason)",
    "source_code": "\tpublic void onWebSocketClose(int statusCode, String reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(statusCode, reason));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketError(cause)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void onWebSocketError(Throwable cause)",
    "source_code": "\tpublic void onWebSocketError(Throwable cause) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(cause);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketFrame(frame,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "frame",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void onWebSocketFrame(Frame frame, Callback callback)",
    "source_code": "\tpublic void onWebSocketFrame(Frame frame, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tif (OpCode.PONG == frame.getOpCode()) {\n\t\t\t\tByteBuffer byteBuffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);\n\t\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.PONG, buffer);\n\t\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketOpen(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void onWebSocketOpen(Session session)",
    "source_code": "\tpublic void onWebSocketOpen(Session session) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getUpgradeRequest().getRequestURI() + \" [JettyWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#onWebSocketText(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void onWebSocketText(String message)",
    "source_code": "\tpublic void onWebSocketText(String message) {\n\t\tif (this.delegateSession != null) {\n\t\t\tbyte[] bytes = message.getBytes(StandardCharsets.UTF_8);\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(bytes);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.TEXT, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#read()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "byte",
    "signature": "public byte read()",
    "source_code": "\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#read(destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination) {\n\t\t\tthis.delegate.read(destination);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readPosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "int",
    "signature": "public int readPosition()",
    "source_code": "\t\tpublic int readPosition() {\n\t\t\treturn this.delegate.readPosition();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readPosition(readPosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "readPosition"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer readPosition(int readPosition)",
    "source_code": "\t\tpublic DataBuffer readPosition(int readPosition) {\n\t\t\tthis.delegate.readPosition(readPosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator readableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator readableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#readableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "int",
    "signature": "public int readableByteCount()",
    "source_code": "\t\tpublic int readableByteCount() {\n\t\t\treturn this.delegate.readableByteCount();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.callback);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#split(index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer split(int index)",
    "source_code": "\t\tpublic DataBuffer split(int index) {\n\t\t\tDataBuffer delegateSplit = this.delegate.split(index);\n\t\t\treturn new JettyDataBuffer(delegateSplit, this.callback);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writableByteBuffers()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "ByteBufferIterator",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writableByteCount()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "int",
    "signature": "public int writableByteCount()",
    "source_code": "\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte b)",
    "source_code": "\t\tpublic DataBuffer write(byte b) {\n\t\t\tthis.delegate.write(b);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(buffers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(ByteBuffer... buffers)",
    "source_code": "\t\tpublic DataBuffer write(ByteBuffer... buffers) {\n\t\t\tthis.delegate.write(buffers);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source) {\n\t\t\tthis.delegate.write(source);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writePosition()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "int",
    "signature": "public int writePosition()",
    "source_code": "\t\tpublic int writePosition() {\n\t\t\treturn this.delegate.writePosition();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#writePosition(writePosition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writePosition"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "source_code": "\t\tpublic DataBuffer writePosition(int writePosition) {\n\t\t\tthis.delegate.writePosition(writePosition);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#fail(x)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "x"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void fail(Throwable x)",
    "source_code": "\t\tpublic void fail(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#succeed()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void succeed()",
    "source_code": "\t\tpublic void succeed() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeFailed(x)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "x"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void writeFailed(Throwable x)",
    "source_code": "\t\tpublic void writeFailed(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeSuccess()": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void writeSuccess()",
    "source_code": "\t\tpublic void writeSuccess() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationConvention(observationConvention)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link ServerRequestObservationConvention} to use for server observations.\n\t * By default, a {@link DefaultServerRequestObservationConvention} will be used.\n\t * @param observationConvention the convention to use for all recorded observations\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationConvention"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationConvention(ServerRequestObservationConvention observationConvention) {\n\t\tthis.observationConvention = observationConvention;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "observationRegistry"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(ReactorHttpExchangeAdapter client, Method method)",
    "source_code": "\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method,reactiveRegistry,blockTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method's return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method",
      "reactiveRegistry",
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(HttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout)",
    "source_code": "\t\tpublic static ResponseFunction create("
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create("
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver,requestValuesSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver",
      "requestValuesSupplier"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create("
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#builderFor(exchangeAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a builder that's initialized with the given client.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeAdapter"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Builder",
    "signature": "public Builder builderFor(HttpExchangeAdapter exchangeAdapter)",
    "source_code": "\tpublic static Builder builderFor(HttpExchangeAdapter exchangeAdapter) {\n\t\treturn new Builder().exchangeAdapter(exchangeAdapter);\n\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#exchangeAdapter(adapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Provide the HTTP client to perform requests through.\n\t\t * @param adapter a client adapted to {@link HttpExchangeAdapter}\n\t\t * @return this same builder instance\n\t\t * @since 6.1\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Builder",
    "signature": "public Builder exchangeAdapter(HttpExchangeAdapter adapter)",
    "source_code": "\t\tpublic Builder exchangeAdapter(HttpExchangeAdapter adapter) {\n\t\t\tthis.exchangeAdapter = adapter;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.HttpServiceProxyFactory#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.service.invoker.RequestBodyArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestBody @RequestBody}\n * annotated arguments.\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 35
    },
    "signature": "public class RequestBodyArgumentResolver",
    "source_code": "public class RequestBodyArgumentResolver implements HttpServiceArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestBodyArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestBodyArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tRequestBody annot = parameter.getParameterAnnotation(RequestBody.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument != null) {\n\t\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(parameter.getParameterType());\n\t\t\t\tif (adapter != null) {\n\t\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\t\tString message = \"Async type for @RequestBody should produce value(s)\";\n\t\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveRequestValues) {\n\t\t\t\t\t\treactiveRequestValues.setBodyPublisher(\n\t\t\t\t\t\t\t\tadapter.toPublisher(argument), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"RequestBody with a reactive type is only supported with reactive client\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not a reactive type\n\t\t\trequestValues.setBodyValue(argument);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.RequestBodyArgumentResolver#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve("
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestPart @RequestPart}\n * annotated arguments.\n *\n * <p>The argument may be:\n * <ul>\n * <li>String -- form field\n * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n * <li>{@link MultipartFile} -- uploaded file\n * <li>Object -- content to be encoded (e.g. to JSON)\n * <li>{@link HttpEntity} -- part content and headers although generally it's\n * easier to add headers through the returned builder\n * <li>{@link Part} -- a part from a server request\n * <li>{@link Publisher} of any of the above\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "signature": "public class RequestPartArgumentResolver",
    "source_code": "public class RequestPartArgumentResolver extends AbstractNamedValueArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestPartArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestPartArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isMultiPartFile = parameter.nestedIfOptional().getNestedParameterType().equals(MultipartFile.class);\n\t\tString label = (isMultiPartFile ? \"MultipartFile\" : \"request part\");\n\n\t\tif (annot != null) {\n\t\t\treturn new NamedValueInfo(annot.name(), annot.required(), null, label, true);\n\t\t}\n\t\telse if (isMultiPartFile) {\n\t\t\treturn new NamedValueInfo(\"\", true, null, label, true);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\tClass<?> type = parameter.getParameterType();\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(type);\n\t\t\tif (adapter != null) {\n\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\tString message = \"Async type for @RequestPart should produce value(s)\";\n\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveValues) {\n\t\t\t\t\treactiveValues.addRequestPartPublisher(\n\t\t\t\t\t\t\tname, adapter.toPublisher(value), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"RequestPart with a reactive type is only supported with reactive client\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (value instanceof MultipartFile multipartFile) {\n\t\t\tvalue = toHttpEntity(name, multipartFile);\n\t\t}\n\n\t\trequestValues.addRequestPart(name, value);\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n\tprivate static Object toHttpEntity(String name, MultipartFile multipartFile) {\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tif (multipartFile.getOriginalFilename() != null) {\n\t\t\theaders.setContentDispositionFormData(name, multipartFile.getOriginalFilename());\n\t\t}\n\t\tif (multipartFile.getContentType() != null) {\n\t\t\theaders.add(HttpHeaders.CONTENT_TYPE, multipartFile.getContentType());\n\t\t}\n\t\treturn new HttpEntity<>(multipartFile.getResource(), headers);\n\t}\n\n}"
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver#addRequestValue(name,value,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected void addRequestValue("
  },
  "org.springframework.web.service.invoker.RequestPartArgumentResolver#createNamedValueInfo(parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isMultiPartFile = parameter.nestedIfOptional().getNestedParameterType().equals(MultipartFile.class);\n\t\tString label = (isMultiPartFile ? \"MultipartFile\" : \"request part\");\n\n\t\tif (annot != null) {\n\t\t\treturn new NamedValueInfo(annot.name(), annot.required(), null, label, true);\n\t\t}\n\t\telse if (isMultiPartFile) {\n\t\t\treturn new NamedValueInfo(\"\", true, null, label, true);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\tAssert.notNull(bindType, \"BindType must not be null\");\n\t\t\tAssert.notNull(dataBinderCustomizer, \"DataBinderCustomizer must not be null\");\n\n\t\t\tServletRequestDataBinder dataBinder = new ServletRequestDataBinder(null);\n\t\t\tdataBinder.setTargetType(ResolvableType.forClass(bindType));\n\t\t\tdataBinderCustomizer.accept(dataBinder);\n\n\t\t\tHttpServletRequest servletRequest = servletRequest();\n\t\t\tdataBinder.construct(servletRequest);\n\t\t\tdataBinder.bind(servletRequest);\n\n\t\t\tBindingResult bindingResult = dataBinder.getBindingResult();\n\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\tthrow new BindException(bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT result = (T) bindingResult.getTarget();\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"Binding result has neither target nor errors\");\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#bind(bindType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType"
    ],
    "position": {
      "column": 1,
      "line": 1119
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType) throws BindException {\n\t\t\treturn this.request.bind(bindType);\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1124
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\treturn this.request.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#modify(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "void",
    "signature": "public void modify(ServerRequest request)",
    "source_code": "\t\t\tpublic void modify(ServerRequest request) {\n\t\t\t\tif (this.modify != null) {\n\t\t\t\t\tthis.modify.accept(request);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#of(requestPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPredicate"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "RequestModifyingPredicate",
    "signature": "public RequestModifyingPredicate of(RequestPredicate requestPredicate)",
    "source_code": "\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#of(value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "Result",
    "signature": "public Result of(boolean value)",
    "source_code": "\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#of(value,commit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "commit"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<ServerRequest> commit)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<ServerRequest> commit) {\n\t\t\t\tif (commit == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, commit);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#testInternal(request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request"
    ],
    "position": {
      "column": 1,
      "line": 975
    },
    "return": "Result",
    "signature": "protected Result testInternal(ServerRequest request)",
    "source_code": "\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.rightModifying.testInternal(request);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.RequestPredicates#value()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "boolean",
    "signature": "public boolean value()",
    "source_code": "\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.Result": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "class",
    "modifiers": [
      "protected"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "signature": "protected class Result",
    "source_code": "\t\tprotected static final class Result {\n\n\t\t\tprivate static final Result TRUE = new Result(true, null);\n\n\t\t\tprivate static final Result FALSE = new Result(false, null);\n\n\n\t\t\tprivate final boolean value;\n\n\t\t\t@Nullable\n\t\t\tprivate final Consumer<ServerRequest> modify;\n\n\n\t\t\tprivate Result(boolean value, @Nullable Consumer<ServerRequest> modify) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.modify = modify;\n\t\t\t}\n\n\n\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}\n\n\t\t\tpublic static Result of(boolean value, @Nullable Consumer<ServerRequest> commit) {\n\t\t\t\tif (commit == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, commit);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tpublic void modify(ServerRequest request) {\n\t\t\t\tif (this.modify != null) {\n\t\t\t\t\tthis.modify.accept(request);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getExcludePathPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the exclude path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getIncludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String[]",
    "signature": "public String[] getExcludePathPatterns()",
    "source_code": "\tpublic String[] getExcludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.excludePatterns) ?\n\t\t\t\tArrays.stream(this.excludePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.handler.MappedInterceptor#getIncludePathPatterns()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the include path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getExcludePathPatterns()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String[]",
    "signature": "public String[] getIncludePathPatterns()",
    "source_code": "\tpublic String[] getIncludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#shouldApplyTo(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\treturn (handler instanceof ResourceHttpRequestHandler ?\n\t\t\t\thasGlobalExceptionHandlers() : super.shouldApplyTo(request, handler));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#execute(task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task"
    ],
    "position": {
      "column": 1,
      "line": 1058
    },
    "return": "void",
    "signature": "public void execute(Runnable task)",
    "source_code": "\t\tpublic void execute(Runnable task) {\n\t\t\tif (taskExecutorWarning && logger.isWarnEnabled()) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (taskExecutorWarning) {\n\t\t\t\t\t\tlogger.warn(\"\"\"\n\t\t\t\t\t\t\t\t!!!\n\t\t\t\t\t\t\t\tPerforming asynchronous handling through the default Spring MVC SimpleAsyncTaskExecutor.\n\t\t\t\t\t\t\t\tThis executor is not suitable for production use under load.\n\t\t\t\t\t\t\t\tPlease, configure an AsyncTaskExecutor through the WebMvc config.\n\t\t\t\t\t\t\t\t-------------------------------\n\t\t\t\t\t\t\t\t!!!\"\"\");\n\t\t\t\t\t\ttaskExecutorWarning = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.execute(task);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, or meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHandlerMethodValidationException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodValidationException(MethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodValidationException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleNoResourceFoundException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoResourceFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoResourceFoundException(NoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoResourceFoundException("
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A specialization of {@link ResponseBodyEmitter} for sending\n * <a href=\"https://www.w3.org/TR/eventsource/\">Server-Sent Events</a>.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 4.2\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "signature": "public class SseEmitter",
    "source_code": "public class SseEmitter extends ResponseBodyEmitter {\n\n\tprivate static final MediaType TEXT_PLAIN = new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8);\n\n\t/**\n\t * Guards access to write operations on the response.\n\t */\n\tprivate final Lock writeLock = new ReentrantLock();\n\n\t/**\n\t * Create a new SseEmitter instance.\n\t */\n\tpublic SseEmitter() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Create a SseEmitter with a custom timeout value.\n\t * <p>By default not set in which case the default configured in the MVC\n\t * Java Config or the MVC namespace is used, or if that's not set, then the\n\t * timeout depends on the default of the underlying server.\n\t * @param timeout the timeout value in milliseconds\n\t * @since 4.2.2\n\t */\n\tpublic SseEmitter(Long timeout) {\n\t\tsuper(timeout);\n\t}\n\n\n\t@Override\n\tprotected void extendResponse(ServerHttpResponse outputMessage) {\n\t\tsuper.extendResponse(outputMessage);\n\n\t\tHttpHeaders headers = outputMessage.getHeaders();\n\t\tif (headers.getContentType() == null) {\n\t\t\theaders.setContentType(MediaType.TEXT_EVENT_STREAM);\n\t\t}\n\t}\n\n\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @throws IOException raised when an I/O error occurs\n\t * @throws java.lang.IllegalStateException wraps any other errors\n\t */\n\t@Override\n\tpublic void send(Object object) throws IOException {\n\t\tsend(object, null);\n\t}\n\n\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject, MediaType.APPLICATION_JSON));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @param mediaType a MediaType hint for selecting an HttpMessageConverter\n\t * @throws IOException raised when an I/O error occurs\n\t */\n\t@Override\n\tpublic void send(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\tsend(event().data(object, mediaType));\n\t}\n\n\t/**\n\t * Send an SSE event prepared with the given builder. For example:\n\t * <pre>\n\t * // static import of SseEmitter\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().name(\"update\").id(\"1\").data(myObject));\n\t * </pre>\n\t * @param builder a builder for an SSE formatted event.\n\t * @throws IOException raised when an I/O error occurs\n\t */\n\tpublic void send(SseEventBuilder builder) throws IOException {\n\t\tSet<DataWithMediaType> dataToSend = builder.build();\n\t\tthis.writeLock.lock();\n\t\ttry {\n\t\t\tsuper.send(dataToSend);\n\t\t}\n\t\tfinally {\n\t\t\tthis.writeLock.unlock();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SseEmitter@\" + ObjectUtils.getIdentityHexString(this);\n\t}\n\n\n\tpublic static SseEventBuilder event() {\n\t\treturn new SseEventBuilderImpl();\n\t}\n\n\n\t/**\n\t * A builder for an SSE event.\n\t */\n\tpublic interface SseEventBuilder {\n\n\t\t/**\n\t\t * Add an SSE \"id\" line.\n\t\t */\n\t\tSseEventBuilder id(String id);\n\n\t\t/**\n\t\t * Add an SSE \"event\" line.\n\t\t */\n\t\tSseEventBuilder name(String eventName);\n\n\t\t/**\n\t\t * Add an SSE \"retry\" line.\n\t\t */\n\t\tSseEventBuilder reconnectTime(long reconnectTimeMillis);\n\n\t\t/**\n\t\t * Add an SSE \"comment\" line.\n\t\t */\n\t\tSseEventBuilder comment(String comment);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object, @Nullable MediaType mediaType);\n\n\t\t/**\n\t\t * Return one or more Object-MediaType pairs to write via\n\t\t * {@link #send(Object, MediaType)}.\n\t\t * @since 4.2.3\n\t\t */\n\t\tSet<DataWithMediaType> build();\n\t}\n\n\n\t/**\n\t * Default implementation of SseEventBuilder.\n\t */\n\tprivate static class SseEventBuilderImpl implements SseEventBuilder {\n\n\t\tprivate final Set<DataWithMediaType> dataToSend = new LinkedHashSet<>(4);\n\n\t\t@Nullable\n\t\tprivate StringBuilder sb;\n\n\t\t@Override\n\t\tpublic SseEventBuilder id(String id) {\n\t\t\tappend(\"id:\").append(id).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder name(String name) {\n\t\t\tappend(\"event:\").append(name).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder reconnectTime(long reconnectTimeMillis) {\n\t\t\tappend(\"retry:\").append(String.valueOf(reconnectTimeMillis)).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder comment(String comment) {\n\t\t\tappend(':').append(comment).append('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder data(Object object) {\n\t\t\treturn data(object, null);\n\t\t}\n\n\t\t@Override\n\t\tpublic SseEventBuilder data(Object object, @Nullable MediaType mediaType) {\n\t\t\tappend(\"data:\");\n\t\t\tsaveAppendedText();\n\t\t\tif (object instanceof String text) {\n\t\t\t\tobject = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t}\n\t\t\tthis.dataToSend.add(new DataWithMediaType(object, mediaType));\n\t\t\tappend('\\n');\n\t\t\treturn this;\n\t\t}\n\n\t\tSseEventBuilderImpl append(String text) {\n\t\t\tif (this.sb == null) {\n\t\t\t\tthis.sb = new StringBuilder();\n\t\t\t}\n\t\t\tthis.sb.append(text);\n\t\t\treturn this;\n\t\t}\n\n\t\tSseEventBuilderImpl append(char ch) {\n\t\t\tif (this.sb == null) {\n\t\t\t\tthis.sb = new StringBuilder();\n\t\t\t}\n\t\t\tthis.sb.append(ch);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<DataWithMediaType> build() {\n\t\t\tif (!StringUtils.hasLength(this.sb) && this.dataToSend.isEmpty()) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tappend('\\n');\n\t\t\tsaveAppendedText();\n\t\t\treturn this.dataToSend;\n\t\t}\n\n\t\tprivate void saveAppendedText() {\n\t\t\tif (this.sb != null) {\n\t\t\t\tthis.dataToSend.add(new DataWithMediaType(this.sb.toString(), TEXT_PLAIN));\n\t\t\t\tthis.sb = null;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#build()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Set<DataWithMediaType>",
    "signature": "public Set<DataWithMediaType> build()",
    "source_code": "\t\tpublic Set<DataWithMediaType> build() {\n\t\t\tif (!StringUtils.hasLength(this.sb) && this.dataToSend.isEmpty()) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tappend('\\n');\n\t\t\tsaveAppendedText();\n\t\t\treturn this.dataToSend;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#comment(comment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "comment"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder comment(String comment)",
    "source_code": "\t\tpublic SseEventBuilder comment(String comment) {\n\t\t\tappend(':').append(comment).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#data(object)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder data(Object object)",
    "source_code": "\t\tpublic SseEventBuilder data(Object object) {\n\t\t\treturn data(object, null);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#data(object,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder data(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic SseEventBuilder data(Object object, @Nullable MediaType mediaType) {\n\t\t\tappend(\"data:\");\n\t\t\tsaveAppendedText();\n\t\t\tif (object instanceof String text) {\n\t\t\t\tobject = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t}\n\t\t\tthis.dataToSend.add(new DataWithMediaType(object, mediaType));\n\t\t\tappend('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#event()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder event()",
    "source_code": "\tpublic static SseEventBuilder event() {\n\t\treturn new SseEventBuilderImpl();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#extendResponse(outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "protected void extendResponse(ServerHttpResponse outputMessage)",
    "source_code": "\tprotected void extendResponse(ServerHttpResponse outputMessage) {\n\t\tsuper.extendResponse(outputMessage);\n\n\t\tHttpHeaders headers = outputMessage.getHeaders();\n\t\tif (headers.getContentType() == null) {\n\t\t\theaders.setContentType(MediaType.TEXT_EVENT_STREAM);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#id(id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder id(String id)",
    "source_code": "\t\tpublic SseEventBuilder id(String id) {\n\t\t\tappend(\"id:\").append(id).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#name(name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder name(String name)",
    "source_code": "\t\tpublic SseEventBuilder name(String name) {\n\t\t\tappend(\"event:\").append(name).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#reconnectTime(reconnectTimeMillis)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reconnectTimeMillis"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder reconnectTime(long reconnectTimeMillis)",
    "source_code": "\t\tpublic SseEventBuilder reconnectTime(long reconnectTimeMillis) {\n\t\t\tappend(\"retry:\").append(String.valueOf(reconnectTimeMillis)).append('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#send(builder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send an SSE event prepared with the given builder. For example:\n\t * <pre>\n\t * // static import of SseEmitter\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().name(\"update\").id(\"1\").data(myObject));\n\t * </pre>\n\t * @param builder a builder for an SSE formatted event.\n\t * @throws IOException raised when an I/O error occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void send(SseEventBuilder builder)",
    "source_code": "\tpublic void send(SseEventBuilder builder) throws IOException {\n\t\tSet<DataWithMediaType> dataToSend = builder.build();\n\t\tthis.writeLock.lock();\n\t\ttry {\n\t\t\tsuper.send(dataToSend);\n\t\t}\n\t\tfinally {\n\t\t\tthis.writeLock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#send(object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @throws IOException raised when an I/O error occurs\n\t * @throws java.lang.IllegalStateException wraps any other errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void send(Object object)",
    "source_code": "\tpublic void send(Object object) throws IOException {\n\t\tsend(object, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#send(object,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject, MediaType.APPLICATION_JSON));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @param mediaType a MediaType hint for selecting an HttpMessageConverter\n\t * @throws IOException raised when an I/O error occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void send(Object object, @Nullable MediaType mediaType)",
    "source_code": "\tpublic void send(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\tsend(event().data(object, mediaType));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#toString()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "String",
    "signature": "public String toString()",
    "source_code": "\tpublic String toString() {\n\t\treturn \"SseEmitter@\" + ObjectUtils.getIdentityHexString(this);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.SseEventBuilder": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A builder for an SSE event.\n\t */",
    "kind": "interface",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "signature": "public interface SseEventBuilder",
    "source_code": "\tpublic interface SseEventBuilder {\n\n\t\t/**\n\t\t * Add an SSE \"id\" line.\n\t\t */\n\t\tSseEventBuilder id(String id);\n\n\t\t/**\n\t\t * Add an SSE \"event\" line.\n\t\t */\n\t\tSseEventBuilder name(String eventName);\n\n\t\t/**\n\t\t * Add an SSE \"retry\" line.\n\t\t */\n\t\tSseEventBuilder reconnectTime(long reconnectTimeMillis);\n\n\t\t/**\n\t\t * Add an SSE \"comment\" line.\n\t\t */\n\t\tSseEventBuilder comment(String comment);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object);\n\n\t\t/**\n\t\t * Add an SSE \"data\" line.\n\t\t */\n\t\tSseEventBuilder data(Object object, @Nullable MediaType mediaType);\n\n\t\t/**\n\t\t * Return one or more Object-MediaType pairs to write via\n\t\t * {@link #send(Object, MediaType)}.\n\t\t * @since 4.2.3\n\t\t */\n\t\tSet<DataWithMediaType> build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleHandlerMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation for a controller method failed.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation failed on a component that is\n\t * not a web controller, e.g. on some underlying service.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodValidationException(MethodValidationException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleNoResourceFoundException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no static resource was found.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link NoResourceFoundException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the resource handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,"
  },
  "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#logException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (ex instanceof NoHandlerFoundException || ex instanceof NoResourceFoundException) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(buildLogMessage(ex, request));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.logException(ex, request);\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * A {@link WebSocketSession} for use with the Jetty 9.4 WebSocket API.\n *\n * @author Phillip Webb\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 4.0\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "signature": "public class JettyWebSocketSession",
    "source_code": "public class JettyWebSocketSession extends AbstractWebSocketSession<Session> {\n\n\tprivate final String id;\n\n\t@Nullable\n\tprivate URI uri;\n\n\t@Nullable\n\tprivate HttpHeaders headers;\n\n\t@Nullable\n\tprivate String acceptedProtocol;\n\n\t@Nullable\n\tprivate List<WebSocketExtension> extensions;\n\n\t@Nullable\n\tprivate Principal user;\n\n\n\t/**\n\t * Create a new {@link JettyWebSocketSession} instance.\n\t * @param attributes the attributes from the HTTP handshake to associate with the WebSocket session\n\t */\n\tpublic JettyWebSocketSession(Map<String, Object> attributes) {\n\t\tthis(attributes, null);\n\t}\n\n\t/**\n\t * Create a new {@link JettyWebSocketSession} instance associated with the given user.\n\t * @param attributes the attributes from the HTTP handshake to associate with the WebSocket\n\t * session; the provided attributes are copied, the original map is not used.\n\t * @param user the user associated with the session; if {@code null} we'll fall back on the\n\t * user available via {@link org.eclipse.jetty.websocket.api.Session#getUpgradeRequest()}\n\t */\n\tpublic JettyWebSocketSession(Map<String, Object> attributes, @Nullable Principal user) {\n\t\tsuper(attributes);\n\t\tthis.id = idGenerator.generateId().toString();\n\t\tthis.user = user;\n\t}\n\n\n\t@Override\n\tpublic String getId() {\n\t\treturn this.id;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic URI getUri() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.uri;\n\t}\n\n\t@Override\n\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tAssert.state(this.headers != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.headers;\n\t}\n\n\t@Override\n\tpublic String getAcceptedProtocol() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.acceptedProtocol;\n\t}\n\n\t@Override\n\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.extensions != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.extensions;\n\t}\n\n\t@Override\n\tpublic Principal getPrincipal() {\n\t\treturn this.user;\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getLocalAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getLocalSocketAddress();\n\t}\n\n\t@Override\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getRemoteSocketAddress();\n\t}\n\n\t/**\n\t * This method is a no-op for Jetty.\n\t */\n\t@Override\n\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t}\n\n\t@Override\n\tpublic int getTextMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxTextMessageSize();\n\t}\n\n\t/**\n\t * This method is a no-op for Jetty.\n\t */\n\t@Override\n\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t}\n\n\t@Override\n\tpublic int getBinaryMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxBinaryMessageSize();\n\t}\n\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn getNativeSession().isOpen();\n\t}\n\n\n\t@Override\n\tpublic void initializeNativeSession(Session session) {\n\t\tsuper.initializeNativeSession(session);\n\n\t\tthis.uri = session.getUpgradeRequest().getRequestURI();\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tMap<String, List<String>> nativeHeaders = session.getUpgradeRequest().getHeaders();\n\t\tif (!CollectionUtils.isEmpty(nativeHeaders)) {\n\t\t\theaders.putAll(nativeHeaders);\n\t\t}\n\t\tthis.headers = HttpHeaders.readOnlyHttpHeaders(headers);\n\n\t\tthis.acceptedProtocol = session.getUpgradeResponse().getAcceptedSubProtocol();\n\t\tthis.extensions = getExtensions(session);\n\n\t\tif (this.user == null) {\n\t\t\ttry {\n\t\t\t\tthis.user = session.getUpgradeRequest().getUserPrincipal();\n\t\t\t}\n\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t// Necessary until https://github.com/eclipse/jetty.project/issues/10498 is resolved\n\t\t\t\tlogger.error(\"Failure from UpgradeRequest while getting Principal\", ex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate List<WebSocketExtension> getExtensions(Session session) {\n\t\tList<ExtensionConfig> configs = session.getUpgradeResponse().getExtensions();\n\t\tif (!CollectionUtils.isEmpty(configs)) {\n\t\t\tList<WebSocketExtension> result = new ArrayList<>(configs.size());\n\t\t\tfor (ExtensionConfig config : configs) {\n\t\t\t\tresult.add(new WebSocketExtension(config.getName(), config.getParameters()));\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(result);\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\n\t@Override\n\tprotected void sendTextMessage(TextMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendText(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void sendBinaryMessage(BinaryMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendBinary(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void sendPingMessage(PingMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPing(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void sendPongMessage(PongMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPong(message.getPayload(), callback));\n\t}\n\n\t@Override\n\tprotected void closeInternal(CloseStatus status) throws IOException {\n\t\tuseSession((session, callback) -> session.close(status.getCode(), status.getReason(), callback));\n\t}\n\n\tprivate void useSession(SessionConsumer sessionConsumer) throws IOException {\n\t\ttry {\n\t\t\tCallback.Completable completable = new Callback.Completable();\n\t\t\tsessionConsumer.consume(getNativeSession(), completable);\n\t\t\tcompletable.get();\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse if (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(ex.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t}\n\t}\n\n\t@FunctionalInterface\n\tprivate interface SessionConsumer {\n\n\t\tvoid consume(Session session, Callback callback) throws IOException;\n\t}\n\n}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#closeInternal(status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "status"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "protected void closeInternal(CloseStatus status)",
    "source_code": "\tprotected void closeInternal(CloseStatus status) throws IOException {\n\t\tuseSession((session, callback) -> session.close(status.getCode(), status.getReason(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getAcceptedProtocol()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String",
    "signature": "public String getAcceptedProtocol()",
    "source_code": "\tpublic String getAcceptedProtocol() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.acceptedProtocol;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getBinaryMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "int",
    "signature": "public int getBinaryMessageSizeLimit()",
    "source_code": "\tpublic int getBinaryMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxBinaryMessageSize();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getExtensions()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "List<WebSocketExtension>",
    "signature": "public List<WebSocketExtension> getExtensions()",
    "source_code": "\tpublic List<WebSocketExtension> getExtensions() {\n\t\tAssert.state(this.extensions != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.extensions;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getHandshakeHeaders()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders getHandshakeHeaders()",
    "source_code": "\tpublic HttpHeaders getHandshakeHeaders() {\n\t\tAssert.state(this.headers != null, \"WebSocket session is not yet initialized\");\n\t\treturn this.headers;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getId()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String",
    "signature": "public String getId()",
    "source_code": "\tpublic String getId() {\n\t\treturn this.id;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getLocalAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getLocalAddress()",
    "source_code": "\tpublic InetSocketAddress getLocalAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getLocalSocketAddress();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getPrincipal()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Principal",
    "signature": "public Principal getPrincipal()",
    "source_code": "\tpublic Principal getPrincipal() {\n\t\treturn this.user;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getRemoteAddress()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress getRemoteAddress()",
    "source_code": "\tpublic InetSocketAddress getRemoteAddress() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (InetSocketAddress) getNativeSession().getRemoteSocketAddress();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getTextMessageSizeLimit()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "int",
    "signature": "public int getTextMessageSizeLimit()",
    "source_code": "\tpublic int getTextMessageSizeLimit() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn (int) getNativeSession().getMaxTextMessageSize();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getUri()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "URI",
    "signature": "public URI getUri()",
    "source_code": "\tpublic URI getUri() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.uri;\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#initializeNativeSession(session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void initializeNativeSession(Session session)",
    "source_code": "\tpublic void initializeNativeSession(Session session) {\n\t\tsuper.initializeNativeSession(session);\n\n\t\tthis.uri = session.getUpgradeRequest().getRequestURI();\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tMap<String, List<String>> nativeHeaders = session.getUpgradeRequest().getHeaders();\n\t\tif (!CollectionUtils.isEmpty(nativeHeaders)) {\n\t\t\theaders.putAll(nativeHeaders);\n\t\t}\n\t\tthis.headers = HttpHeaders.readOnlyHttpHeaders(headers);\n\n\t\tthis.acceptedProtocol = session.getUpgradeResponse().getAcceptedSubProtocol();\n\t\tthis.extensions = getExtensions(session);\n\n\t\tif (this.user == null) {\n\t\t\ttry {\n\t\t\t\tthis.user = session.getUpgradeRequest().getUserPrincipal();\n\t\t\t}\n\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t// Necessary until https://github.com/eclipse/jetty.project/issues/10498 is resolved\n\t\t\t\tlogger.error(\"Failure from UpgradeRequest while getting Principal\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#isOpen()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "boolean",
    "signature": "public boolean isOpen()",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn getNativeSession().isOpen();\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendBinaryMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "protected void sendBinaryMessage(BinaryMessage message)",
    "source_code": "\tprotected void sendBinaryMessage(BinaryMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendBinary(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendPingMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void sendPingMessage(PingMessage message)",
    "source_code": "\tprotected void sendPingMessage(PingMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPing(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendPongMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "protected void sendPongMessage(PongMessage message)",
    "source_code": "\tprotected void sendPongMessage(PongMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPong(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendTextMessage(message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void sendTextMessage(TextMessage message)",
    "source_code": "\tprotected void sendTextMessage(TextMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendText(message.getPayload(), callback));\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#setBinaryMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method is a no-op for Jetty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setBinaryMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setBinaryMessageSizeLimit(int messageSizeLimit) {\n\t}"
  },
  "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#setTextMessageSizeLimit(messageSizeLimit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method is a no-op for Jetty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSizeLimit"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void setTextMessageSizeLimit(int messageSizeLimit)",
    "source_code": "\tpublic void setTextMessageSizeLimit(int messageSizeLimit) {\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#isPreserveReceiveOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "protected boolean isPreserveReceiveOrder()",
    "source_code": "\tprotected boolean isPreserveReceiveOrder() {\n\t\treturn this.stompHandler.isPreserveReceiveOrder();\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry#setPreserveReceiveOrder(preserveReceiveOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preserveReceiveOrder"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "WebMvcStompEndpointRegistry",
    "signature": "public WebMvcStompEndpointRegistry setPreserveReceiveOrder(boolean preserveReceiveOrder)",
    "source_code": "\tpublic WebMvcStompEndpointRegistry setPreserveReceiveOrder(boolean preserveReceiveOrder) {\n\t\tthis.stompHandler.setPreserveReceiveOrder(preserveReceiveOrder);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping("
  },
  "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler,clientInboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler",
      "clientInboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler,\n\t\t\tAbstractSubscribableChannel clientInboundChannel)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping("
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient(session,webSocketMessage,outputChannel)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#handleMessageFromClient(session,webSocketMessage,targetChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "targetChannel"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel targetChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#isPreserveReceiveOrder()": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the handler is configured to handle inbound messages in the\n\t * order in which they were received.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "public boolean isPreserveReceiveOrder()",
    "source_code": "\tpublic boolean isPreserveReceiveOrder() {\n\t\treturn (this.orderedHandlingMessageChannels != null);\n\t}"
  },
  "org.springframework.web.socket.messaging.StompSubProtocolHandler#setPreserveReceiveOrder(preserveReceiveOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether client messages must be handled in the order received.\n\t * <p>By default messages sent to the {@code \"clientInboundChannel\"} may\n\t * not be handled in the same order because the channel is backed by a\n\t * ThreadPoolExecutor that in turn does not guarantee processing in order.\n\t * <p>When this flag is set to {@code true} messages within the same session\n\t * will be sent to the {@code \"clientInboundChannel\"} one at a time to\n\t * preserve the order in which they were received.\n\t * @param preserveReceiveOrder whether to publish in order\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "preserveReceiveOrder"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void setPreserveReceiveOrder(boolean preserveReceiveOrder)",
    "source_code": "\tpublic void setPreserveReceiveOrder(boolean preserveReceiveOrder) {\n\t\tthis.orderedHandlingMessageChannels = (preserveReceiveOrder ? new ConcurrentHashMap<>() : null);\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Utility methods to resolve a list of {@link MessageSourceResolvable}s, and\n * optionally join them.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "kind": "class",
    "modifiers": [
      "public"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "signature": "public class BindErrorUtils",
    "source_code": "public abstract class BindErrorUtils {\n\n\tprivate final static MessageSource defaultMessageSource = new MethodArgumentErrorMessageSource();\n\n\n\t/**\n\t * Shortcut for {@link #resolveAndJoin(List, MessageSource, Locale)} with\n\t * an empty {@link MessageSource} that simply formats the default message,\n\t * or first error code, also prepending the field name for field errors.\n\t */\n\tpublic static String resolveAndJoin(List<? extends MessageSourceResolvable> errors) {\n\t\treturn resolveAndJoin(errors, defaultMessageSource, Locale.getDefault());\n\t}\n\n\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */\n\tpublic static String resolveAndJoin(\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn resolveAndJoin(\", and \", \"\", \"\", errors, messageSource, locale);\n\t}\n\n\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */\n\tpublic static String resolveAndJoin(\n\t\t\tCharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn errors.stream()\n\t\t\t\t.map(error -> messageSource.getMessage(error, locale))\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.collect(Collectors.joining(delimiter, prefix, suffix));\n\t}\n\n\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */\n\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}\n\n\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */\n\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(\n\t\t\tList<E> errors, MessageSource messageSource, Locale locale) {\n\n\t\tMap<E, String> map = new LinkedHashMap<>(errors.size());\n\t\terrors.forEach(error -> map.put(error, messageSource.getMessage(error, locale)));\n\t\treturn map;\n\t}\n\n\n\t/**\n\t * {@code MessageSource} for default error formatting.\n\t */\n\tprivate static class MethodArgumentErrorMessageSource extends StaticMessageSource {\n\n\t\tMethodArgumentErrorMessageSource() {\n\t\t\tsetUseCodeAsDefaultMessage(true);\n\t\t}\n\n\t\t@Override\n\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}\n\t}\n\n}"
  },
  "org.springframework.web.util.BindErrorUtils#getDefaultMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolve(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolve(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve("
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(delimiter,prefix,suffix,errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter",
      "prefix",
      "suffix",
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String resolveAndJoin(CharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin("
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(List, MessageSource, Locale)} with\n\t * an empty {@link MessageSource} that simply formats the default message,\n\t * or first error code, also prepending the field name for field errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors)",
    "source_code": "\tpublic static String resolveAndJoin(List<? extends MessageSourceResolvable> errors) {\n\t\treturn resolveAndJoin(errors, defaultMessageSource, Locale.getDefault());\n\t}"
  },
  "org.springframework.web.util.BindErrorUtils#resolveAndJoin(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin("
  }
}