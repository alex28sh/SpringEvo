[
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.support.MessageHeaderAccessor#getShortLogMessage(payload)",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public String getShortLogMessage(Object payload)",
    "documentation": "\t/**\n\t * Return a concise message for logging purposes.\n\t * @param payload the payload that corresponds to the headers.\n\t * @return the message\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String getShortLogMessage(Object payload) {\n\t\treturn \"headers=\" + this.headers.toString() + getShortPayloadLogMessage(payload);\n\t}",
    "query": "Design a service method that handles incoming messages by extracting key header details and creating streamlined log entries. The implementation should ensure that logs remain informative yet concise, facilitating easier monitoring and debugging without overwhelming the log files.",
    "function_signature": "public String createStreamlinedLogEntry(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.DefaultTransactionStatus#isGlobalRollbackOnly()",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public boolean isGlobalRollbackOnly()",
    "documentation": "\t/**\n\t * Determine the rollback-only flag via checking the transaction object, provided\n\t * that the latter implements the {@link SmartTransactionObject} interface.\n\t * <p>Will return {@code true} if the global transaction itself has been marked\n\t * rollback-only by the transaction coordinator, for example in case of a timeout.\n\t * @see SmartTransactionObject#isRollbackOnly()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isGlobalRollbackOnly() {\n\t\treturn (this.transaction instanceof SmartTransactionObject smartTransactionObject &&\n\t\t\t\tsmartTransactionObject.isRollbackOnly());\n\t}",
    "query": "Design a transactional service method that proceeds with critical business logic only if the entire transaction hasn't been flagged for rollback, ensuring operations are skipped in case of global transaction failures like timeouts.",
    "function_signature": "public void executeBusinessLogicIfTransactionActive()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.EscapedErrors#getFieldErrorCount()",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public int getFieldErrorCount()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int getFieldErrorCount() {\n\t\treturn this.source.getFieldErrorCount();\n\t}",
    "query": "Design a controller method in a Spring MVC application that processes form submissions and returns the total number of fields that failed validation, ensuring the response accurately reflects the validation state.",
    "function_signature": "public int getFieldErrorCount(EscapedErrors escapedErrors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.stomp.StompEncoder#removeEldestEntry(Map.Entry<String,eldest)",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {\n\t\t\t\t\tif (size() > HEADER_KEY_CACHE_LIMIT) {\n\t\t\t\t\t\theaderKeyAccessCache.remove(eldest.getKey());\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}",
    "query": "Design a custom message encoder for a high-throughput messaging system that efficiently manages a limited cache of header keys to prevent excessive memory usage when processing numerous unique headers.",
    "function_signature": "protected boolean shouldEvictHeaderEntry(Map.Entry<String, byte[]> headerEntry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.OpMinus#getRightOperand()",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public SpelNodeImpl getRightOperand()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic SpelNodeImpl getRightOperand() {\n\t\tif (this.children.length < 2) {\n\t\t\tthrow new IllegalStateException(\"No right operand\");\n\t\t}\n\t\treturn this.children[1];\n\t}",
    "query": "Design a service that parses user-defined arithmetic expressions and extracts the right-hand values of all subtraction operations for validation and logging purposes.",
    "function_signature": "public List<Object> extractSubtractionRightOperands(String expression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.persistenceunit.<unknown>#init(classLoader)",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public void init(@Nullable ClassLoader classLoader)",
    "documentation": "\t/**\n\t * Initialize this PersistenceUnitInfo with the current class loader\n\t * (instead of with a LoadTimeWeaver).\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void init(@Nullable ClassLoader classLoader) {\n\t\tthis.classLoader = classLoader;\n\t}",
    "query": "Configure your Spring application to initialize JPA persistence units using a specific class loader, ensuring that the persistence context is set up without relying on a LoadTimeWeaver.",
    "function_signature": "public void initializePersistenceContext(ClassLoader customClassLoader)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.Target#resources(Function<ServerRequest,lookupFunction)",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public void resources(Function<ServerRequest, Optional<Resource>> lookupFunction)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void resources(Function<ServerRequest, Optional<Resource>> lookupFunction) {\n\t}",
    "query": "Implement a feature in your Spring application that dynamically serves different static resources based on custom logic evaluated from each incoming HTTP request.",
    "function_signature": "public void configureDynamicResourceMapping(Function<ServerRequest, Optional<Resource>> resourceProvider)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.jta.JtaTransactionManager#lookupTransactionSynchronizationRegistry(registryName)",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "protected TransactionSynchronizationRegistry lookupTransactionSynchronizationRegistry(String registryName)",
    "documentation": "\t/**\n\t * Look up the JTA 1.1 TransactionSynchronizationRegistry in JNDI via the configured name.\n\t * <p>Can be overridden in subclasses to provide a different TransactionManager object.\n\t * @param registryName the JNDI name of the\n\t * TransactionSynchronizationRegistry\n\t * @return the TransactionSynchronizationRegistry object\n\t * @throws TransactionSystemException if the JNDI lookup failed\n\t * @see #setJndiTemplate\n\t * @see #setTransactionSynchronizationRegistryName\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected TransactionSynchronizationRegistry lookupTransactionSynchronizationRegistry(String registryName) throws TransactionSystemException {\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Retrieving JTA TransactionSynchronizationRegistry from JNDI location [\" + registryName + \"]\");\n\t\t\t}\n\t\t\treturn getJndiTemplate().lookup(registryName, TransactionSynchronizationRegistry.class);\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new TransactionSystemException(\n\t\t\t\t\t\"JTA TransactionSynchronizationRegistry is not available at JNDI location [\" + registryName + \"]\", ex);\n\t\t}\n\t}",
    "query": "Design a service method that initializes transaction management by accessing a synchronization registry from a configurable JNDI location. This setup should ensure that transaction boundaries are properly synchronized across multiple transactional resources in a distributed system.",
    "function_signature": "protected TransactionSynchronizationRegistry initializeTransactionSynchronization(String jndiLocation) throws TransactionSystemException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scripting.support.ScriptFactoryPostProcessor#destroy()",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public void destroy()",
    "documentation": "\t/**\n\t * Destroy the inner bean factory (used for scripts) on shutdown.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void destroy() {\n\t\tthis.scriptBeanFactory.destroySingletons();\n\t}",
    "query": "Design a shutdown procedure that ensures all script-related bean factories are properly terminated, thereby releasing resources tied to dynamically executed scripts and preventing memory leaks in your Spring application.",
    "function_signature": "public void destroyScriptFactories();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.support.JstlUtils#exposeLocalizationContext(requestContext)",
    "from_version": "v5.3.34",
    "to_version": "v6.0.19",
    "type": "method",
    "signature": "public void exposeLocalizationContext(RequestContext requestContext)",
    "documentation": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param requestContext the context for the current HTTP request,\n\t * including the ApplicationContext to expose as MessageSource\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static void exposeLocalizationContext(RequestContext requestContext) {\n\t\tConfig.set(requestContext.getRequest(), Config.FMT_LOCALE, requestContext.getLocale());\n\t\tTimeZone timeZone = requestContext.getTimeZone();\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(requestContext.getRequest(), Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tMessageSource messageSource = getJstlAwareMessageSource(\n\t\t\t\trequestContext.getServletContext(), requestContext.getMessageSource());\n\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, requestContext.getRequest());\n\t\tConfig.set(requestContext.getRequest(), Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t}",
    "query": "Implement a solution that allows JSP pages using JSTL tags to automatically reflect the user's locale and resource bundles managed by Spring, ensuring consistent localization across your web application.",
    "function_signature": "public void initializeJstlLocalizationSupport(RequestContext requestContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor#isEligible(bean,beanName)",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "protected boolean isEligible(Object bean, String beanName)",
    "documentation": "\t/**\n\t * Check whether the given bean is eligible for advising with this\n\t * post-processor's {@link Advisor}.\n\t * <p>Delegates to {@link #isEligible(Class)} for target class checking.\n\t * Can be overridden e.g. to specifically exclude certain beans by name.\n\t * <p>Note: Only called for regular bean instances but not for existing\n\t * proxy instances which implement {@link Advised} and allow for adding\n\t * the local {@link Advisor} to the existing proxy's {@link Advisor} chain.\n\t * For the latter, {@link #isEligible(Class)} is being called directly,\n\t * with the actual target class behind the existing proxy (as determined\n\t * by {@link AopUtils#getTargetClass(Object)}).\n\t * @param bean the bean instance\n\t * @param beanName the name of the bean\n\t * @see #isEligible(Class)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected boolean isEligible(Object bean, String beanName) {\n\t\treturn isEligible(bean.getClass());\n\t}",
    "query": "Design a mechanism to assess whether a component qualifies for advisory processing by utilizing solely its class information. This approach should streamline the evaluation process, minimizing overhead associated with additional parameters.",
    "function_signature": "protected boolean qualifiesForAdvising(Class<?> componentClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.annotation.InjectionMetadata#getInjectedElements()",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "public Collection<InjectedElement> getInjectedElements()",
    "documentation": "\t/**\n\t * Return the {@link InjectedElement elements} to inject.\n\t * @return the elements to inject\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Collection<InjectedElement> getInjectedElements() {\n\t\treturn Collections.unmodifiableCollection(this.injectedElements);\n\t}",
    "query": "Enhance the dependency injection process to improve thread safety and reduce resource consumption. Create a method that efficiently obtains the active injection points using the most recent framework standards.",
    "function_signature": "public List<InjectionPoint> retrieveActiveInjectionPoints()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanFactory#setCacheBeanMetadata(cacheBeanMetadata)",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "public void setCacheBeanMetadata(boolean cacheBeanMetadata)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setCacheBeanMetadata(boolean cacheBeanMetadata) {\n\t\tthis.cacheBeanMetadata = cacheBeanMetadata;\n\t}",
    "query": "Optimize the bean factory's metadata handling to boost application performance and ensure safer configuration practices by implementing an advanced caching strategy.",
    "function_signature": "public void configureBeanMetadataCaching(BeanMetadataCacheConfig cacheConfig)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.SingleColumnRowMapper#newInstance(requiredType)",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "public SingleColumnRowMapper<T> newInstance(Class<T> requiredType)",
    "documentation": "\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @since 4.1\n\t * @see #newInstance(Class, ConversionService)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {\n\t\treturn new SingleColumnRowMapper<>(requiredType);\n\t}",
    "query": "Design a method that constructs a mapper for single-column JDBC queries, ensuring robust type conversion and optimal performance by leveraging appropriate conversion mechanisms.",
    "function_signature": "public SingleColumnRowMapper<T> buildSingleColumnMapper(Class<T> targetType, ConversionService conversionService)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.client.MockMvcHttpConnector#getAsyncResult()",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "public Object getAsyncResult()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Object getAsyncResult() {\n\t\t\treturn this.mvcResult.getAsyncResult();\n\t\t}",
    "query": "Implement a test scenario using Spring's MockMvc where asynchronous request handling ensures non-blocking operations and improved response management.",
    "function_signature": "public CompletableFuture<ResultActions> performAsyncRequest(MockMvc mockMvc, RequestBuilder requestBuilder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.APPLICATION_ATOM_XML",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "field",
    "signature": "public MediaType APPLICATION_ATOM_XML",
    "documentation": "\t/**\n\t *  Public constant media type for {@code application/atom+xml}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final MediaType APPLICATION_ATOM_XML;",
    "query": "Design a method to obtain the appropriate media type for Atom XML responses, enhancing your application's performance and reliability.",
    "function_signature": "public MediaType fetchOptimizedAtomXmlMediaType()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.client.SockJsClient",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "class",
    "signature": "public class SockJsClient",
    "documentation": "/**\n * A SockJS implementation of\n * {@link org.springframework.web.socket.client.WebSocketClient WebSocketClient}\n * with fallback alternatives that simulate a WebSocket interaction through plain\n * HTTP streaming and long polling techniques.\n *\n * <p>Implements {@link Lifecycle} in order to propagate lifecycle events to\n * the transports it is configured with.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.1\n * @see <a href=\"https://github.com/sockjs/sockjs-client\">https://github.com/sockjs/sockjs-client</a>\n * @see org.springframework.web.socket.sockjs.client.Transport\n */",
    "changetype": "deprecated",
    "source_code": "public class SockJsClient implements WebSocketClient, Lifecycle {\n\n\tprivate static final boolean jackson2Present = ClassUtils.isPresent(\n\t\t\t\"com.fasterxml.jackson.databind.ObjectMapper\", SockJsClient.class.getClassLoader());\n\n\tprivate static final Log logger = LogFactory.getLog(SockJsClient.class);\n\n\tprivate static final Set<String> supportedProtocols = Set.of(\"ws\", \"wss\", \"http\", \"https\");\n\n\n\tprivate final List<Transport> transports;\n\n\t@Nullable\n\tprivate String[] httpHeaderNames;\n\n\tprivate InfoReceiver infoReceiver;\n\n\t@Nullable\n\tprivate SockJsMessageCodec messageCodec;\n\n\t@Nullable\n\tprivate TaskScheduler connectTimeoutScheduler;\n\n\tprivate volatile boolean running;\n\n\tprivate final Map<URI, ServerInfo> serverInfoCache = new ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a {@code SockJsClient} with the given transports.\n\t * <p>If the list includes an {@link XhrTransport} (or more specifically an\n\t * implementation of {@link InfoReceiver}) the instance is used to initialize\n\t * the {@link #setInfoReceiver(InfoReceiver) infoReceiver} property, or\n\t * otherwise is defaulted to {@link RestTemplateXhrTransport}.\n\t * @param transports the (non-empty) list of transports to use\n\t */\n\tpublic SockJsClient(List<Transport> transports) {\n\t\tAssert.notEmpty(transports, \"No transports provided\");\n\t\tthis.transports = new ArrayList<>(transports);\n\t\tthis.infoReceiver = initInfoReceiver(transports);\n\t\tif (jackson2Present) {\n\t\t\tthis.messageCodec = new Jackson2SockJsMessageCodec();\n\t\t}\n\t}\n\n\tprivate static InfoReceiver initInfoReceiver(List<Transport> transports) {\n\t\tfor (Transport transport : transports) {\n\t\t\tif (transport instanceof InfoReceiver infoReceiver) {\n\t\t\t\treturn infoReceiver;\n\t\t\t}\n\t\t}\n\t\treturn new RestTemplateXhrTransport();\n\t}\n\n\n\t/**\n\t * The names of HTTP headers that should be copied from the handshake headers\n\t * of each call to {@link SockJsClient#doHandshake(WebSocketHandler, WebSocketHttpHeaders, URI)}\n\t * and also used with other HTTP requests issued as part of that SockJS\n\t * connection, e.g. the initial info request, XHR send or receive requests.\n\t * <p>By default if this property is not set, all handshake headers are also\n\t * used for other HTTP requests. Set it if you want only a subset of handshake\n\t * headers (e.g. auth headers) to be used for other HTTP requests.\n\t * @param httpHeaderNames the HTTP header names\n\t */\n\tpublic void setHttpHeaderNames(@Nullable String... httpHeaderNames) {\n\t\tthis.httpHeaderNames = httpHeaderNames;\n\t}\n\n\t/**\n\t * The configured HTTP header names to be copied from the handshake\n\t * headers and also included in other HTTP requests.\n\t */\n\t@Nullable\n\tpublic String[] getHttpHeaderNames() {\n\t\treturn this.httpHeaderNames;\n\t}\n\n\t/**\n\t * Configure the {@code InfoReceiver} to use to perform the SockJS \"Info\"\n\t * request before the SockJS session starts.\n\t * <p>If the list of transports provided to the constructor contained an\n\t * {@link XhrTransport} or an implementation of {@link InfoReceiver} that\n\t * instance would have been used to initialize this property, or otherwise\n\t * it defaults to {@link RestTemplateXhrTransport}.\n\t * @param infoReceiver the transport to use for the SockJS \"Info\" request\n\t */\n\tpublic void setInfoReceiver(InfoReceiver infoReceiver) {\n\t\tAssert.notNull(infoReceiver, \"InfoReceiver is required\");\n\t\tthis.infoReceiver = infoReceiver;\n\t}\n\n\t/**\n\t * Return the configured {@code InfoReceiver} (never {@code null}).\n\t */\n\tpublic InfoReceiver getInfoReceiver() {\n\t\treturn this.infoReceiver;\n\t}\n\n\t/**\n\t * Set the SockJsMessageCodec to use.\n\t * <p>By default {@link org.springframework.web.socket.sockjs.frame.Jackson2SockJsMessageCodec\n\t * Jackson2SockJsMessageCodec} is used if Jackson is on the classpath.\n\t */\n\tpublic void setMessageCodec(SockJsMessageCodec messageCodec) {\n\t\tAssert.notNull(messageCodec, \"SockJsMessageCodec is required\");\n\t\tthis.messageCodec = messageCodec;\n\t}\n\n\t/**\n\t * Return the SockJsMessageCodec to use.\n\t */\n\tpublic SockJsMessageCodec getMessageCodec() {\n\t\tAssert.state(this.messageCodec != null, \"No SockJsMessageCodec set\");\n\t\treturn this.messageCodec;\n\t}\n\n\t/**\n\t * Configure a {@code TaskScheduler} for scheduling a connect timeout task\n\t * where the timeout value is calculated based on the duration of the initial\n\t * SockJS \"Info\" request. The connect timeout task ensures a more timely\n\t * fallback but is otherwise entirely optional.\n\t * <p>By default this is not configured in which case a fallback may take longer.\n\t * @param connectTimeoutScheduler the task scheduler to use\n\t */\n\tpublic void setConnectTimeoutScheduler(TaskScheduler connectTimeoutScheduler) {\n\t\tthis.connectTimeoutScheduler = connectTimeoutScheduler;\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tfor (Transport transport : this.transports) {\n\t\t\t\tif (transport instanceof Lifecycle lifecycle && !lifecycle.isRunning()) {\n\t\t\t\t\tlifecycle.start();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (isRunning()) {\n\t\t\tthis.running = false;\n\t\t\tfor (Transport transport : this.transports) {\n\t\t\t\tif (transport instanceof Lifecycle lifecycle && lifecycle.isRunning()) {\n\t\t\t\t\tlifecycle.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t@Override\n\tpublic CompletableFuture<WebSocketSession> execute(\n\t\t\tWebSocketHandler handler, String uriTemplate, Object... uriVars) {\n\n\t\tAssert.notNull(uriTemplate, \"uriTemplate must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().toUri();\n\t\treturn execute(handler, null, uri);\n\t}\n\n\t@Override\n\tpublic final CompletableFuture<WebSocketSession> execute(\n\t\t\tWebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url) {\n\n\t\tAssert.notNull(handler, \"WebSocketHandler is required\");\n\t\tAssert.notNull(url, \"URL is required\");\n\n\t\tString scheme = url.getScheme();\n\t\tif (!supportedProtocols.contains(scheme)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scheme: '\" + scheme + \"'\");\n\t\t}\n\n\t\tCompletableFuture<WebSocketSession> connectFuture = new CompletableFuture<>();\n\t\ttry {\n\t\t\tSockJsUrlInfo sockJsUrlInfo = new SockJsUrlInfo(url);\n\t\t\tServerInfo serverInfo = getServerInfo(sockJsUrlInfo, getHttpRequestHeaders(headers));\n\t\t\tcreateRequest(sockJsUrlInfo, headers, serverInfo).connect(handler, connectFuture);\n\t\t}\n\t\tcatch (Exception exception) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Initial SockJS \\\"Info\\\" request to server failed, url=\" + url, exception);\n\t\t\t}\n\t\t\tconnectFuture.completeExceptionally(exception);\n\t\t}\n\t\treturn connectFuture;\n\t}\n\n\t@Nullable\n\tprivate HttpHeaders getHttpRequestHeaders(@Nullable HttpHeaders webSocketHttpHeaders) {\n\t\tif (getHttpHeaderNames() == null || webSocketHttpHeaders == null) {\n\t\t\treturn webSocketHttpHeaders;\n\t\t}\n\t\telse {\n\t\t\tHttpHeaders httpHeaders = new HttpHeaders();\n\t\t\tfor (String name : getHttpHeaderNames()) {\n\t\t\t\tList<String> values = webSocketHttpHeaders.get(name);\n\t\t\t\tif (values != null) {\n\t\t\t\t\thttpHeaders.put(name, values);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn httpHeaders;\n\t\t}\n\t}\n\n\tprivate ServerInfo getServerInfo(SockJsUrlInfo sockJsUrlInfo, @Nullable HttpHeaders headers) {\n\t\tURI infoUrl = sockJsUrlInfo.getInfoUrl();\n\t\tServerInfo info = this.serverInfoCache.get(infoUrl);\n\t\tif (info == null) {\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tString response = this.infoReceiver.executeInfoRequest(infoUrl, headers);\n\t\t\tlong infoRequestTime = System.currentTimeMillis() - start;\n\t\t\tinfo = new ServerInfo(response, infoRequestTime);\n\t\t\tthis.serverInfoCache.put(infoUrl, info);\n\t\t}\n\t\treturn info;\n\t}\n\n\tprivate DefaultTransportRequest createRequest(\n\t\t\tSockJsUrlInfo urlInfo, @Nullable HttpHeaders headers, ServerInfo serverInfo) {\n\n\t\tList<DefaultTransportRequest> requests = new ArrayList<>(this.transports.size());\n\t\tfor (Transport transport : this.transports) {\n\t\t\tfor (TransportType type : transport.getTransportTypes()) {\n\t\t\t\tif (serverInfo.isWebSocketEnabled() || !TransportType.WEBSOCKET.equals(type)) {\n\t\t\t\t\trequests.add(new DefaultTransportRequest(urlInfo, headers, getHttpRequestHeaders(headers),\n\t\t\t\t\t\t\ttransport, type, getMessageCodec()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (CollectionUtils.isEmpty(requests)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No transports: \" + urlInfo + \", webSocketEnabled=\" + serverInfo.isWebSocketEnabled());\n\t\t}\n\t\tfor (int i = 0; i < requests.size() - 1; i++) {\n\t\t\tDefaultTransportRequest request = requests.get(i);\n\t\t\tPrincipal user = getUser();\n\t\t\tif (user != null) {\n\t\t\t\trequest.setUser(user);\n\t\t\t}\n\t\t\tif (this.connectTimeoutScheduler != null) {\n\t\t\t\trequest.setTimeoutValue(serverInfo.getRetransmissionTimeout());\n\t\t\t\trequest.setTimeoutScheduler(this.connectTimeoutScheduler);\n\t\t\t}\n\t\t\trequest.setFallbackRequest(requests.get(i + 1));\n\t\t}\n\t\treturn requests.get(0);\n\t}\n\n\t/**\n\t * Return the user to associate with the SockJS session and make available via\n\t * {@link org.springframework.web.socket.WebSocketSession#getPrincipal()}.\n\t * <p>By default this method returns {@code null}.\n\t * @return the user to associate with the session (possibly {@code null})\n\t */\n\t@Nullable\n\tprotected Principal getUser() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * By default, the result of a SockJS \"Info\" request, including whether the\n\t * server has WebSocket disabled and how long the request took (used for\n\t * calculating transport timeout time) is cached. This method can be used to\n\t * clear that cache hence causing it to re-populate.\n\t */\n\tpublic void clearServerInfoCache() {\n\t\tthis.serverInfoCache.clear();\n\t}\n\n\n\t/**\n\t * A simple value object holding the result from a SockJS \"Info\" request.\n\t */\n\tprivate static class ServerInfo {\n\n\t\tprivate final boolean webSocketEnabled;\n\n\t\tprivate final long responseTime;\n\n\t\tpublic ServerInfo(String response, long responseTime) {\n\t\t\tthis.responseTime = responseTime;\n\t\t\tthis.webSocketEnabled = !response.matches(\".*[\\\"']websocket[\\\"']\\\\s*:\\\\s*false.*\");\n\t\t}\n\n\t\tpublic boolean isWebSocketEnabled() {\n\t\t\treturn this.webSocketEnabled;\n\t\t}\n\n\t\tpublic long getRetransmissionTimeout() {\n\t\t\treturn (this.responseTime > 100 ? 4 * this.responseTime : this.responseTime + 300);\n\t\t}\n\t}\n\n}",
    "query": "Develop a WebSocket interaction module that utilizes current client strategies to enhance connection stability and performance, ensuring seamless communication with server endpoints.",
    "function_signature": "public CompletableFuture<WebSocketSession> initializeEnhancedWebSocketClient(WebSocketHandler handler, URI uri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractGenericHttpMessageConverter#writeInternal(t,type,outputMessage)",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "protected void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "documentation": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write (may be {@code null})\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected abstract void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "query": "Create a converter that ensures efficient and secure serialization of objects to HTTP responses, enhancing overall application performance.",
    "function_signature": "protected void serializeObject(T object, @Nullable Type targetType, HttpOutputMessage responseMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.result.PrintingResultHandler#getRequestHeaders(request)",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "method",
    "signature": "protected HttpHeaders getRequestHeaders(MockHttpServletRequest request)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected final HttpHeaders getRequestHeaders(MockHttpServletRequest request) {\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tEnumeration<String> names = request.getHeaderNames();\n\t\twhile (names.hasMoreElements()) {\n\t\t\tString name = names.nextElement();\n\t\t\theaders.put(name, Collections.list(request.getHeaders(name)));\n\t\t}\n\t\treturn headers;\n\t}",
    "query": "Develop a mechanism to efficiently extract and manage HTTP headers from a mock servlet request, prioritizing thread safety and enhanced performance. Ensure your solution aligns with the latest best practices for handling request headers in modern Spring applications.",
    "function_signature": "protected HttpHeaders extractAndManageHeaders(MockHttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.DefaultLifecycleProcessor",
    "from_version": "v6.0.3",
    "to_version": "v5.3.25",
    "type": "class",
    "signature": "public class DefaultLifecycleProcessor",
    "documentation": "/**\n * Default implementation of the {@link LifecycleProcessor} strategy.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public class DefaultLifecycleProcessor implements LifecycleProcessor, BeanFactoryAware {\n\n\tprivate final Log logger = LogFactory.getLog(getClass());\n\n\tprivate volatile long timeoutPerShutdownPhase = 30000;\n\n\tprivate volatile boolean running;\n\n\t@Nullable\n\tprivate volatile ConfigurableListableBeanFactory beanFactory;\n\n\n\t/**\n\t * Specify the maximum time allotted in milliseconds for the shutdown of\n\t * any phase (group of SmartLifecycle beans with the same 'phase' value).\n\t * <p>The default value is 30 seconds.\n\t */\n\tpublic void setTimeoutPerShutdownPhase(long timeoutPerShutdownPhase) {\n\t\tthis.timeoutPerShutdownPhase = timeoutPerShutdownPhase;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory clbf)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"DefaultLifecycleProcessor requires a ConfigurableListableBeanFactory: \" + beanFactory);\n\t\t}\n\t\tthis.beanFactory = clbf;\n\t}\n\n\tprivate ConfigurableListableBeanFactory getBeanFactory() {\n\t\tConfigurableListableBeanFactory beanFactory = this.beanFactory;\n\t\tAssert.state(beanFactory != null, \"No BeanFactory available\");\n\t\treturn beanFactory;\n\t}\n\n\n\t// Lifecycle implementation\n\n\t/**\n\t * Start all registered beans that implement {@link Lifecycle} and are <i>not</i>\n\t * already running. Any bean that implements {@link SmartLifecycle} will be\n\t * started within its 'phase', and all phases will be ordered from lowest to\n\t * highest value. All beans that do not implement {@link SmartLifecycle} will be\n\t * started in the default phase 0. A bean declared as a dependency of another bean\n\t * will be started before the dependent bean regardless of the declared phase.\n\t */\n\t@Override\n\tpublic void start() {\n\t\tstartBeans(false);\n\t\tthis.running = true;\n\t}\n\n\t/**\n\t * Stop all registered beans that implement {@link Lifecycle} and <i>are</i>\n\t * currently running. Any bean that implements {@link SmartLifecycle} will be\n\t * stopped within its 'phase', and all phases will be ordered from highest to\n\t * lowest value. All beans that do not implement {@link SmartLifecycle} will be\n\t * stopped in the default phase 0. A bean declared as dependent on another bean\n\t * will be stopped before the dependency bean regardless of the declared phase.\n\t */\n\t@Override\n\tpublic void stop() {\n\t\tstopBeans();\n\t\tthis.running = false;\n\t}\n\n\t@Override\n\tpublic void onRefresh() {\n\t\tstartBeans(true);\n\t\tthis.running = true;\n\t}\n\n\t@Override\n\tpublic void onClose() {\n\t\tstopBeans();\n\t\tthis.running = false;\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn this.running;\n\t}\n\n\n\t// Internal helpers\n\n\tprivate void startBeans(boolean autoStartupOnly) {\n\t\tMap<String, Lifecycle> lifecycleBeans = getLifecycleBeans();\n\t\tMap<Integer, LifecycleGroup> phases = new TreeMap<>();\n\n\t\tlifecycleBeans.forEach((beanName, bean) -> {\n\t\t\tif (!autoStartupOnly || (bean instanceof SmartLifecycle smartLifecycle && smartLifecycle.isAutoStartup())) {\n\t\t\t\tint phase = getPhase(bean);\n\t\t\t\tphases.computeIfAbsent(\n\t\t\t\t\t\tphase,\n\t\t\t\t\t\tp -> new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly)\n\t\t\t\t).add(beanName, bean);\n\t\t\t}\n\t\t});\n\t\tif (!phases.isEmpty()) {\n\t\t\tphases.values().forEach(LifecycleGroup::start);\n\t\t}\n\t}\n\n\t/**\n\t * Start the specified bean as part of the given set of Lifecycle beans,\n\t * making sure that any beans that it depends on are started first.\n\t * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value\n\t * @param beanName the name of the bean to start\n\t */\n\tprivate void doStart(Map<String, ? extends Lifecycle> lifecycleBeans, String beanName, boolean autoStartupOnly) {\n\t\tLifecycle bean = lifecycleBeans.remove(beanName);\n\t\tif (bean != null && bean != this) {\n\t\t\tString[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);\n\t\t\tfor (String dependency : dependenciesForBean) {\n\t\t\t\tdoStart(lifecycleBeans, dependency, autoStartupOnly);\n\t\t\t}\n\t\t\tif (!bean.isRunning() &&\n\t\t\t\t\t(!autoStartupOnly || !(bean instanceof SmartLifecycle smartLifecycle) || smartLifecycle.isAutoStartup())) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Starting bean '\" + beanName + \"' of type [\" + bean.getClass().getName() + \"]\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tbean.start();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new ApplicationContextException(\"Failed to start bean '\" + beanName + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Successfully started bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void stopBeans() {\n\t\tMap<String, Lifecycle> lifecycleBeans = getLifecycleBeans();\n\t\tMap<Integer, LifecycleGroup> phases = new HashMap<>();\n\t\tlifecycleBeans.forEach((beanName, bean) -> {\n\t\t\tint shutdownPhase = getPhase(bean);\n\t\t\tLifecycleGroup group = phases.get(shutdownPhase);\n\t\t\tif (group == null) {\n\t\t\t\tgroup = new LifecycleGroup(shutdownPhase, this.timeoutPerShutdownPhase, lifecycleBeans, false);\n\t\t\t\tphases.put(shutdownPhase, group);\n\t\t\t}\n\t\t\tgroup.add(beanName, bean);\n\t\t});\n\t\tif (!phases.isEmpty()) {\n\t\t\tList<Integer> keys = new ArrayList<>(phases.keySet());\n\t\t\tkeys.sort(Collections.reverseOrder());\n\t\t\tfor (Integer key : keys) {\n\t\t\t\tphases.get(key).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stop the specified bean as part of the given set of Lifecycle beans,\n\t * making sure that any beans that depends on it are stopped first.\n\t * @param lifecycleBeans a Map with bean name as key and Lifecycle instance as value\n\t * @param beanName the name of the bean to stop\n\t */\n\tprivate void doStop(Map<String, ? extends Lifecycle> lifecycleBeans, final String beanName,\n\t\t\tfinal CountDownLatch latch, final Set<String> countDownBeanNames) {\n\n\t\tLifecycle bean = lifecycleBeans.remove(beanName);\n\t\tif (bean != null) {\n\t\t\tString[] dependentBeans = getBeanFactory().getDependentBeans(beanName);\n\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\tdoStop(lifecycleBeans, dependentBean, latch, countDownBeanNames);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (bean.isRunning()) {\n\t\t\t\t\tif (bean instanceof SmartLifecycle smartLifecycle) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Asking bean '\" + beanName + \"' of type [\" +\n\t\t\t\t\t\t\t\t\tbean.getClass().getName() + \"] to stop\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcountDownBeanNames.add(beanName);\n\t\t\t\t\t\tsmartLifecycle.stop(() -> {\n\t\t\t\t\t\t\tlatch.countDown();\n\t\t\t\t\t\t\tcountDownBeanNames.remove(beanName);\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Bean '\" + beanName + \"' completed its stop procedure\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Stopping bean '\" + beanName + \"' of type [\" +\n\t\t\t\t\t\t\t\t\tbean.getClass().getName() + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbean.stop();\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Successfully stopped bean '\" + beanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (bean instanceof SmartLifecycle) {\n\t\t\t\t\t// Don't wait for beans that aren't running...\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to stop bean '\" + beanName + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// overridable hooks\n\n\t/**\n\t * Retrieve all applicable Lifecycle beans: all singletons that have already been created,\n\t * as well as all SmartLifecycle beans (even if they are marked as lazy-init).\n\t * @return the Map of applicable beans, with bean names as keys and bean instances as values\n\t */\n\tprotected Map<String, Lifecycle> getLifecycleBeans() {\n\t\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\t\tMap<String, Lifecycle> beans = new LinkedHashMap<>();\n\t\tString[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, false, false);\n\t\tfor (String beanName : beanNames) {\n\t\t\tString beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tboolean isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);\n\t\t\tString beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);\n\t\t\tif ((beanFactory.containsSingleton(beanNameToRegister) &&\n\t\t\t\t\t(!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) ||\n\t\t\t\t\tmatchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) {\n\t\t\t\tObject bean = beanFactory.getBean(beanNameToCheck);\n\t\t\t\tif (bean != this && bean instanceof Lifecycle lifecycle) {\n\t\t\t\t\tbeans.put(beanNameToRegister, lifecycle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beans;\n\t}\n\n\tprivate boolean matchesBeanType(Class<?> targetType, String beanName, BeanFactory beanFactory) {\n\t\tClass<?> beanType = beanFactory.getType(beanName);\n\t\treturn (beanType != null && targetType.isAssignableFrom(beanType));\n\t}\n\n\t/**\n\t * Determine the lifecycle phase of the given bean.\n\t * <p>The default implementation checks for the {@link Phased} interface, using\n\t * a default of 0 otherwise. Can be overridden to apply other/further policies.\n\t * @param bean the bean to introspect\n\t * @return the phase (an integer value)\n\t * @see Phased#getPhase()\n\t * @see SmartLifecycle\n\t */\n\tprotected int getPhase(Lifecycle bean) {\n\t\treturn (bean instanceof Phased phased ? phased.getPhase() : 0);\n\t}\n\n\n\t/**\n\t * Helper class for maintaining a group of Lifecycle beans that should be started\n\t * and stopped together based on their 'phase' value (or the default value of 0).\n\t */\n\tprivate class LifecycleGroup {\n\n\t\tprivate final int phase;\n\n\t\tprivate final long timeout;\n\n\t\tprivate final Map<String, ? extends Lifecycle> lifecycleBeans;\n\n\t\tprivate final boolean autoStartupOnly;\n\n\t\tprivate final List<LifecycleGroupMember> members = new ArrayList<>();\n\n\t\tprivate int smartMemberCount;\n\n\t\tpublic LifecycleGroup(\n\t\t\t\tint phase, long timeout, Map<String, ? extends Lifecycle> lifecycleBeans, boolean autoStartupOnly) {\n\n\t\t\tthis.phase = phase;\n\t\t\tthis.timeout = timeout;\n\t\t\tthis.lifecycleBeans = lifecycleBeans;\n\t\t\tthis.autoStartupOnly = autoStartupOnly;\n\t\t}\n\n\t\tpublic void add(String name, Lifecycle bean) {\n\t\t\tthis.members.add(new LifecycleGroupMember(name, bean));\n\t\t\tif (bean instanceof SmartLifecycle) {\n\t\t\t\tthis.smartMemberCount++;\n\t\t\t}\n\t\t}\n\n\t\tpublic void start() {\n\t\t\tif (this.members.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Starting beans in phase \" + this.phase);\n\t\t\t}\n\t\t\tCollections.sort(this.members);\n\t\t\tfor (LifecycleGroupMember member : this.members) {\n\t\t\t\tdoStart(this.lifecycleBeans, member.name, this.autoStartupOnly);\n\t\t\t}\n\t\t}\n\n\t\tpublic void stop() {\n\t\t\tif (this.members.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Stopping beans in phase \" + this.phase);\n\t\t\t}\n\t\t\tthis.members.sort(Collections.reverseOrder());\n\t\t\tCountDownLatch latch = new CountDownLatch(this.smartMemberCount);\n\t\t\tSet<String> countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet<>());\n\t\t\tSet<String> lifecycleBeanNames = new HashSet<>(this.lifecycleBeans.keySet());\n\t\t\tfor (LifecycleGroupMember member : this.members) {\n\t\t\t\tif (lifecycleBeanNames.contains(member.name)) {\n\t\t\t\t\tdoStop(this.lifecycleBeans, member.name, latch, countDownBeanNames);\n\t\t\t\t}\n\t\t\t\telse if (member.bean instanceof SmartLifecycle) {\n\t\t\t\t\t// Already removed: must have been a dependent bean from another phase\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlatch.await(this.timeout, TimeUnit.MILLISECONDS);\n\t\t\t\tif (latch.getCount() > 0 && !countDownBeanNames.isEmpty() && logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Failed to shut down \" + countDownBeanNames.size() + \" bean\" +\n\t\t\t\t\t\t\t(countDownBeanNames.size() > 1 ? \"s\" : \"\") + \" with phase value \" +\n\t\t\t\t\t\t\tthis.phase + \" within timeout of \" + this.timeout + \"ms: \" + countDownBeanNames);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Adapts the Comparable interface onto the lifecycle phase model.\n\t */\n\tprivate class LifecycleGroupMember implements Comparable<LifecycleGroupMember> {\n\n\t\tprivate final String name;\n\n\t\tprivate final Lifecycle bean;\n\n\t\tLifecycleGroupMember(String name, Lifecycle bean) {\n\t\t\tthis.name = name;\n\t\t\tthis.bean = bean;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(LifecycleGroupMember other) {\n\t\t\tint thisPhase = getPhase(this.bean);\n\t\t\tint otherPhase = getPhase(other.bean);\n\t\t\treturn Integer.compare(thisPhase, otherPhase);\n\t\t}\n\t}\n\n}",
    "query": "Create a utility that orchestrates the initialization and termination sequences of application components, enhancing reliability and reducing resource contention during these phases.",
    "function_signature": "public void configureLifecycleManagement(LifecycleProcessor lifecycleProcessor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#setTransactionFactory(transactionFactory)",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "public void setTransactionFactory(TransactionFactory transactionFactory)",
    "documentation": "\t/**\n\t * Set the Spring TransactionFactory to use for wrapping endpoint\n\t * invocations, enlisting the endpoint resource in each such transaction.\n\t * <p>Alternatively, specify an appropriate transaction manager through\n\t * the {@link #setTransactionManager \"transactionManager\"} property.\n\t * <p>If no transaction factory is specified, the endpoint invocation\n\t * will simply not be wrapped in an XA transaction. Check out your\n\t * resource provider's ActivationSpec documentation for local\n\t * transaction options of your particular provider.\n\t * @see #setTransactionName\n\t * @see #setTransactionTimeout\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setTransactionFactory(TransactionFactory transactionFactory) {\n\t\tthis.transactionFactory = transactionFactory;\n\t}",
    "query": "Configure a message processing component to ensure that each incoming message is handled within a transactional context, allowing the endpoint to participate in distributed transactions seamlessly.",
    "function_signature": "public void initializeTransactionalEndpoint(TransactionFactory transactionFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.interceptor.CoroutinesInvocationCallback",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "interface",
    "signature": "protected interface CoroutinesInvocationCallback",
    "documentation": "\t/**\n\t * Coroutines-supporting extension of the callback interface.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected interface CoroutinesInvocationCallback extends InvocationCallback {\n\n\t\tObject getTarget();\n\n\t\tObject[] getArguments();\n\n\t\tdefault Object getContinuation() {\n\t\t\tObject[] args = getArguments();\n\t\t\treturn args[args.length - 1];\n\t\t}\n\t}",
    "query": "Develop a service method that manages database transactions asynchronously, enabling smooth integration with coroutine-based processing for enhanced scalability and responsiveness.",
    "function_signature": "public <T> T executeTransactionalOperation(UserRequest request, InvocationCallback coroutineCallback)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.interceptor.TransactionAspectSupport#newTransactionStatus(status)",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "public void newTransactionStatus(@Nullable TransactionStatus status)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void newTransactionStatus(@Nullable TransactionStatus status) {\n\t\t\tthis.transactionStatus = status;\n\t\t}",
    "query": "Design an aspect that dynamically modifies the current transaction's status based on specific business conditions during service layer execution.",
    "function_signature": "public void adjustCurrentTransactionStatus(@Nullable TransactionStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#endTransaction()",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "public void endTransaction()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void endTransaction() throws Exception {\n\t\t\tif (this.transaction != null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (this.rollbackOnly) {\n\t\t\t\t\t\tthis.transaction.rollback();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.transaction.commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tthis.transaction = null;\n\t\t\t\t\tthis.rollbackOnly = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a component that handles inbound messages from a messaging system, ensuring that each message processing is encapsulated within a transaction that commits upon successful handling or rolls back in case of failures.",
    "function_signature": "public void handleInboundMessage(Message incomingMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.AbstractResource#isOpen()",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "public boolean isOpen()",
    "documentation": "\t/**\n\t * This implementation always returns {@code false}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isOpen() {\n\t\treturn false;\n\t}",
    "query": "Create a utility that verifies the accessibility of various resource types before initiating data streaming operations.",
    "function_signature": "public void streamDataIfResourceOpen(Resource resource)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.DescriptiveResource#equals(obj)",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object obj)",
    "documentation": "\t/**\n\t * This implementation compares the underlying description String.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof DescriptiveResource that &&\n\t\t\t\tthis.description.equals(that.description)));\n\t}",
    "query": "Design a service method that efficiently determines if two resource representations are identical based solely on their descriptive metadata, ensuring that resources with matching descriptions are treated as duplicates.",
    "function_signature": "public boolean areResourcesEquivalent(DescriptiveResource resource1, DescriptiveResource resource2)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.jta.JtaTransactionManager#retrieveTransactionSynchronizationRegistry()",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "protected TransactionSynchronizationRegistry retrieveTransactionSynchronizationRegistry()",
    "documentation": "\t/**\n\t * Allows subclasses to retrieve the JTA 1.1 TransactionSynchronizationRegistry\n\t * in a vendor-specific manner.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @return the JTA TransactionSynchronizationRegistry handle to use,\n\t * or {@code null} if none found\n\t * @throws TransactionSystemException in case of errors\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected TransactionSynchronizationRegistry retrieveTransactionSynchronizationRegistry() throws TransactionSystemException {\n\t\treturn null;\n\t}",
    "query": "You're enhancing a Spring application's transaction management to support advanced synchronization callbacks with a JTA provider. How would you implement a method within your transaction manager to access the synchronization registry for managing these callbacks?",
    "function_signature": "protected TransactionSynchronizationRegistry obtainSynchronizationRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory#hasBeforeDeliveryBeenCalled()",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "protected boolean hasBeforeDeliveryBeenCalled()",
    "documentation": "\t\t/**\n\t\t * Return whether the {@link #beforeDelivery} method of this endpoint\n\t\t * has already been called.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tprotected final boolean hasBeforeDeliveryBeenCalled() {\n\t\t\treturn this.beforeDeliveryCalled;\n\t\t}",
    "query": "Design a message processing component that guarantees initialization routines are executed a single time before handling incoming messages, enhancing efficiency and preventing redundant operations in a concurrent environment.",
    "function_signature": "public boolean isInitializationCompleted()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor#setPersistenceExceptionTranslator(pet)",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "method",
    "signature": "public void setPersistenceExceptionTranslator(PersistenceExceptionTranslator pet)",
    "documentation": "\t/**\n\t * Specify the PersistenceExceptionTranslator to use.\n\t * <p>Default is to autodetect all PersistenceExceptionTranslators\n\t * in the containing BeanFactory, using them in a chain.\n\t * @see #detectPersistenceExceptionTranslators\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPersistenceExceptionTranslator(PersistenceExceptionTranslator pet) {\n\t\tthis.persistenceExceptionTranslator = pet;\n\t}",
    "query": "Design a component that integrates a specialized translator to handle persistence exceptions, ensuring that all data access errors are consistently converted into a unified exception hierarchy.",
    "function_signature": "public void setCustomPersistenceExceptionTranslator(PersistenceExceptionTranslator translator);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.InputStreamResource",
    "from_version": "v6.0.5",
    "to_version": "v6.0.6",
    "type": "class",
    "signature": "public class InputStreamResource",
    "documentation": "/**\n * {@link Resource} implementation for a given {@link InputStream}.\n * <p>Should only be used if no other specific {@code Resource} implementation\n * is applicable. In particular, prefer {@link ByteArrayResource} or any of the\n * file-based {@code Resource} implementations where possible.\n *\n * <p>In contrast to other {@code Resource} implementations, this is a descriptor\n * for an <i>already opened</i> resource - therefore returning {@code true} from\n * {@link #isOpen()}. Do not use an {@code InputStreamResource} if you need to\n * keep the resource descriptor somewhere, or if you need to read from a stream\n * multiple times.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n * @see ByteArrayResource\n * @see ClassPathResource\n * @see FileSystemResource\n * @see UrlResource\n */",
    "changetype": "stabilized",
    "source_code": "public class InputStreamResource extends AbstractResource {\n\n\tprivate final InputStream inputStream;\n\n\tprivate final String description;\n\n\tprivate boolean read = false;\n\n\n\t/**\n\t * Create a new InputStreamResource.\n\t * @param inputStream the InputStream to use\n\t */\n\tpublic InputStreamResource(InputStream inputStream) {\n\t\tthis(inputStream, \"resource loaded through InputStream\");\n\t}\n\n\t/**\n\t * Create a new InputStreamResource.\n\t * @param inputStream the InputStream to use\n\t * @param description where the InputStream comes from\n\t */\n\tpublic InputStreamResource(InputStream inputStream, @Nullable String description) {\n\t\tAssert.notNull(inputStream, \"InputStream must not be null\");\n\t\tthis.inputStream = inputStream;\n\t\tthis.description = (description != null ? description : \"\");\n\t}\n\n\n\t/**\n\t * This implementation always returns {@code true}.\n\t */\n\t@Override\n\tpublic boolean exists() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * This implementation always returns {@code true}.\n\t */\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * This implementation throws IllegalStateException if attempting to\n\t * read the underlying stream multiple times.\n\t */\n\t@Override\n\tpublic InputStream getInputStream() throws IOException, IllegalStateException {\n\t\tif (this.read) {\n\t\t\tthrow new IllegalStateException(\"InputStream has already been read - \" +\n\t\t\t\t\t\"do not use InputStreamResource if a stream needs to be read multiple times\");\n\t\t}\n\t\tthis.read = true;\n\t\treturn this.inputStream;\n\t}\n\n\t/**\n\t * This implementation returns a description that includes the passed-in\n\t * description, if any.\n\t */\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"InputStream resource [\" + this.description + \"]\";\n\t}\n\n\n\t/**\n\t * This implementation compares the underlying InputStream.\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof InputStreamResource that &&\n\t\t\t\tthis.inputStream.equals(that.inputStream)));\n\t}\n\n\t/**\n\t * This implementation returns the hash code of the underlying InputStream.\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.inputStream.hashCode();\n\t}\n\n}",
    "query": "Design a controller method that returns an already opened data stream as a resource in a Spring application, ensuring the stream cannot be re-read.",
    "function_signature": "@GetMapping(\"/stream\")\npublic ResponseEntity<Resource> getOpenStreamResource()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.codec.NettyByteBufEncoder",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "class",
    "signature": "public class NettyByteBufEncoder",
    "documentation": "/**\n * Encoder for {@link ByteBuf ByteBufs}.\n *\n * @author Vladislav Kisel\n * @since 5.3\n */",
    "changetype": "deprecated",
    "source_code": "public class NettyByteBufEncoder extends AbstractEncoder<ByteBuf> {\n\n\tpublic NettyByteBufEncoder() {\n\t\tsuper(MimeTypeUtils.ALL);\n\t}\n\n\n\t@Override\n\tpublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tClass<?> clazz = type.toClass();\n\t\treturn super.canEncode(type, mimeType) && ByteBuf.class.isAssignableFrom(clazz);\n\t}\n\n\t@Override\n\tpublic Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(inputStream).map(byteBuffer ->\n\t\t\t\tencodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));\n\t}\n\n\t@Override\n\tpublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\n\t\t\treturn nettyDataBufferFactory.wrap(byteBuf);\n\t\t}\n\t\tbyte[] bytes = new byte[byteBuf.readableBytes()];\n\t\tbyteBuf.readBytes(bytes);\n\t\tbyteBuf.release();\n\t\treturn bufferFactory.wrap(bytes);\n\t}\n}",
    "query": "Develop a component that efficiently transforms binary data streams into a reactive-friendly format, ensuring optimal memory usage and thread-safe operations for high-performance applications.",
    "function_signature": "public class ReactiveDataBufferEncoder implements Encoder<DataBuffer> {\n    // Implementation details\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#afterPropertiesSet()",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public void afterPropertiesSet()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tthis.config = new RequestMappingInfo.BuilderConfiguration();\n\t\tthis.config.setTrailingSlashMatch(useTrailingSlashMatch());\n\t\tthis.config.setContentNegotiationManager(getContentNegotiationManager());\n\n\t\tif (getPatternParser() != null && this.defaultPatternParser &&\n\t\t\t\t(this.useSuffixPatternMatch || this.useRegisteredSuffixPatternMatch)) {\n\n\t\t\tsetPatternParser(null);\n\t\t}\n\n\t\tif (getPatternParser() != null) {\n\t\t\tthis.config.setPatternParser(getPatternParser());\n\t\t\tAssert.isTrue(!this.useSuffixPatternMatch && !this.useRegisteredSuffixPatternMatch,\n\t\t\t\t\t\"Suffix pattern matching not supported with PathPatternParser.\");\n\t\t}\n\t\telse {\n\t\t\tthis.config.setSuffixPatternMatch(useSuffixPatternMatch());\n\t\t\tthis.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());\n\t\t\tthis.config.setPathMatcher(getPathMatcher());\n\t\t}\n\n\t\tsuper.afterPropertiesSet();\n\t}",
    "query": "Optimize the initialization of request mappings by implementing a configuration method that ensures efficient pattern parsing and robust content negotiation without relying on legacy setup procedures.",
    "function_signature": "public void configureRequestMappingHandlerMapping()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.AbstractFactoryBean#setBeanClassLoader(classLoader)",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}",
    "query": "Optimize your bean factory configuration to enhance class loading performance and ensure thread safety by adopting the latest class loader management practices.",
    "function_signature": "public void configureOptimizedClassLoader()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ResponseEntity#status(status)",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public BodyBuilder status(int status)",
    "documentation": "\t/**\n\t * Create a builder with the given status.\n\t * @param status the response status\n\t * @return the created builder\n\t * @since 4.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static BodyBuilder status(int status) {\n\t\treturn new DefaultBuilder(status);\n\t}",
    "query": "Refactor the method responsible for generating HTTP responses to enhance type safety and improve readability. Ensure that the response status is clearly defined using standardized status codes.",
    "function_signature": "public ResponseEntity<Void> createCustomResponse(HttpStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.listener.adapter.MessageListenerAdapter#getSubscriptionName()",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public String getSubscriptionName()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getSubscriptionName() {\n\t\tObject delegate = getDelegate();\n\t\tif (delegate != this && delegate instanceof SubscriptionNameProvider provider) {\n\t\t\treturn provider.getSubscriptionName();\n\t\t}\n\t\telse {\n\t\t\treturn delegate.getClass().getName();\n\t\t}\n\t}",
    "query": "Refactor the message listener configuration to efficiently obtain the subscription identifier, enhancing type safety and performance.",
    "function_signature": "public String retrieveSubscriptionIdentifier();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.DefaultListableBeanFactory#stream()",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public Stream<Object> stream()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Stream<Object> stream() {\n\t\t\treturn resolveStream(false);\n\t\t}",
    "query": "Design a method to efficiently access and handle all beans within the application context, ensuring optimal resource management and minimizing potential concurrency issues.",
    "function_signature": "public Collection<Object> fetchAllBeans()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.BeanMetadataAttribute#getName()",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public String getName()",
    "documentation": "\t/**\n\t * Return the name of the attribute.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String getName() {\n\t\treturn this.name;\n\t}",
    "query": "Design a method to obtain the identifier of a bean's metadata attribute, prioritizing efficiency and type safety within your Spring application.",
    "function_signature": "public String fetchAttributeIdentifier()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getDefaultReturnValueHandlers()",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "protected List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers()",
    "documentation": "\t/**\n\t * Return the list of return value handlers to use including built-in and\n\t * custom handlers provided via {@link #setReturnValueHandlers}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n\t\tList<HandlerMethodReturnValueHandler> handlers = new ArrayList<>();\n\n\t\t// Single-purpose return value types\n\t\thandlers.add(new ModelAndViewMethodReturnValueHandler());\n\t\thandlers.add(new ModelMethodProcessor());\n\t\thandlers.add(new ViewMethodReturnValueHandler());\n\t\thandlers.add(new HttpEntityMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\n\t\t// Annotation-based return value types\n\t\thandlers.add(new ServletModelAttributeMethodProcessor(false));\n\t\thandlers.add(new RequestResponseBodyMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice));\n\n\t\t// Multi-purpose return value types\n\t\thandlers.add(new ViewNameMethodReturnValueHandler());\n\t\thandlers.add(new MapMethodProcessor());\n\n\t\t// Custom return value types\n\t\tif (getCustomReturnValueHandlers() != null) {\n\t\t\thandlers.addAll(getCustomReturnValueHandlers());\n\t\t}\n\n\t\t// Catch-all\n\t\thandlers.add(new ServletModelAttributeMethodProcessor(true));\n\n\t\treturn handlers;\n\t}",
    "query": "Optimize your exception handling by configuring custom return value processors to enhance response flexibility and performance.",
    "function_signature": "public void configureCustomReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory#shutdownDatabase()",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "protected void shutdownDatabase()",
    "documentation": "\t/**\n\t * Hook to shut down the embedded database. Subclasses may call this method\n\t * to force shutdown.\n\t * <p>After calling, {@link #getDataSource()} returns {@code null}.\n\t * <p>Does nothing if no embedded database has been initialized.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected void shutdownDatabase() {\n\t\tif (this.dataSource != null) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tif (this.dataSource instanceof SimpleDriverDataSource simpleDriverDataSource) {\n\t\t\t\t\tlogger.info(String.format(\"Shutting down embedded database: url='%s'\",\n\t\t\t\t\t\t\tsimpleDriverDataSource.getUrl()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.info(String.format(\"Shutting down embedded database '%s'\", this.databaseName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.databaseConfigurer != null) {\n\t\t\t\tthis.databaseConfigurer.shutdown(this.dataSource, this.databaseName);\n\t\t\t}\n\t\t\tthis.dataSource = null;\n\t\t}\n\t}",
    "query": "Develop a component that gracefully terminates the embedded database instance, ensuring enhanced performance and thread safety by utilizing the most recent best practices.",
    "function_signature": "public void closeEmbeddedDatabase()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.BeanUtils#findEditorByConvention(targetType)",
    "from_version": "v6.1.0-RC2",
    "to_version": "v5.3.31",
    "type": "method",
    "signature": "public PropertyEditor findEditorByConvention(@Nullable Class<?> targetType)",
    "documentation": "\t/**\n\t * Find a JavaBeans PropertyEditor following the 'Editor' suffix convention\n\t * (e.g. \"mypackage.MyDomainClass\" &rarr; \"mypackage.MyDomainClassEditor\").\n\t * <p>Compatible to the standard JavaBeans convention as implemented by\n\t * {@link java.beans.PropertyEditorManager} but isolated from the latter's\n\t * registered default editors for primitive types.\n\t * @param targetType the type to find an editor for\n\t * @return the corresponding editor, or {@code null} if none found\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {\n\t\tif (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClassLoader cl = targetType.getClassLoader();\n\t\tif (cl == null) {\n\t\t\ttry {\n\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\tif (cl == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// e.g. AccessControlException on Google App Engine\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tString targetTypeName = targetType.getName();\n\t\tString editorName = targetTypeName + \"Editor\";\n\t\ttry {\n\t\t\tClass<?> editorClass = cl.loadClass(editorName);\n\t\t\tif (editorClass != null) {\n\t\t\t\tif (!PropertyEditor.class.isAssignableFrom(editorClass)) {\n\t\t\t\t\tunknownEditorTypes.add(targetType);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn (PropertyEditor) instantiateClass(editorClass);\n\t\t\t}\n\t\t\t// Misbehaving ClassLoader returned null instead of ClassNotFoundException\n\t\t\t// - fall back to unknown editor type registration below\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// Ignore - fall back to unknown editor type registration below\n\t\t}\n\t\tunknownEditorTypes.add(targetType);\n\t\treturn null;\n\t}",
    "query": "Implement a method to efficiently obtain a PropertyEditor for a specified target type, leveraging Spring's contemporary type conversion facilities to enhance performance and reliability.",
    "function_signature": "public PropertyEditor resolveEditor(Class<?> targetType, ConversionService conversionService)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.reactive.server.<unknown>#writeAndFlushWith(publisher)",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> publisher)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> publisher) {\n\t\t\tthis.recorder = new WiretapRecorder(null, publisher);\n\t\t\treturn super.writeAndFlushWith(this.recorder.getNestedPublisherToUse());\n\t\t}",
    "query": "Design a test case that streams multiple segments of binary data to a reactive web service endpoint, ensuring each segment is sent and processed in the correct sequence without delay.",
    "function_signature": "public Mono<Void> streamDataSegmentsSequentially(Publisher<? extends Publisher<? extends DataBuffer>> dataSegments)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.server.RequestPredicates#path(pattern)",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public RequestPredicate path(String pattern)",
    "documentation": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request path\n\t * against the given path pattern.\n\t * @param pattern the pattern to match to\n\t * @return a predicate that tests against the given path pattern\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static RequestPredicate path(String pattern) {\n\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\tif (!pattern.isEmpty() && !pattern.startsWith(\"/\")) {\n\t\t\tpattern = \"/\" + pattern;\n\t\t}\n\t\treturn pathPredicates(PathPatternParser.defaultInstance).apply(pattern);\n\t}",
    "query": "Configure a reactive endpoint that exclusively handles HTTP requests matching a specific URL pattern, ensuring precise and efficient routing within your Spring WebFlux application.",
    "function_signature": "public RouterFunction<ServerResponse> configurePatternBasedRouting()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.config.ResourceHandlerRegistry#addResourceHandler(patterns)",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public ResourceHandlerRegistration addResourceHandler(String... patterns)",
    "documentation": "\t * <p>Patterns like {@code \"/static/**\"} or {@code \"/css/{filename:\\\\w+\\\\.css}\"}\n\t * are allowed. See {@link org.springframework.web.util.pattern.PathPattern}\n\t * for more details on the syntax.\n\t * @return a {@link ResourceHandlerRegistration} to use to further configure\n\t * the registered resource handler\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ResourceHandlerRegistration addResourceHandler(String... patterns) {\n\t\tResourceHandlerRegistration registration = new ResourceHandlerRegistration(this.resourceLoader, patterns);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}",
    "query": "Design a configuration method that assigns multiple URL patterns for serving static assets, leveraging advanced pattern matching to optimize resource delivery in your reactive Spring application.",
    "function_signature": "public ResourceHandlerRegistration registerStaticResourceHandlers(String... patterns)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "class",
    "signature": "public class AbstractMockMvcBuilder",
    "documentation": "/**\n * Abstract implementation of {@link MockMvcBuilder} with common methods for\n * configuring filters, default request properties, global expectations and\n * global result actions.\n *\n * <p>Subclasses can use different strategies to prepare the Spring\n * {@code WebApplicationContext} that will be passed to the\n * {@code DispatcherServlet}.\n *\n * @author Rossen Stoyanchev\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 4.0\n * @param <B> a self reference to the builder type\n */",
    "changetype": "stabilized",
    "source_code": "public abstract class AbstractMockMvcBuilder<B extends AbstractMockMvcBuilder<B>>",
    "query": "Create a testing utility that initializes a MockMvc instance with standardized filters, default request settings, and global expectations to ensure consistency and reduce repetitive configuration across various controller tests.",
    "function_signature": "public MockMvc configureGlobalMockMvc();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.BodyInserters#empty()",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public ReactiveHttpOutputMessage> empty()",
    "documentation": "\t/**\n\t * Inserter that does not write.\n\t * @return the inserter\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> empty() {\n\t\treturn (BodyInserter<T, ReactiveHttpOutputMessage>) EMPTY_INSERTER;\n\t}",
    "query": "In a reactive Spring application, how would you implement a method to send a DELETE request to remove a resource without including a request body?",
    "function_signature": "public Mono<Void> deleteResource(String resourceUrl)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.proxy.<unknown>#getCallbackTypes()",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public Class[] getCallbackTypes()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "    public Class[] getCallbackTypes() {\n        if (callbacks.size() == 0) {\n            return new Class[0];\n        }\n        if (callbacks.get(0) instanceof Callback) {\n            return ReflectUtils.getClasses(getCallbacks());\n        }\n        else {\n            return (Class[])callbacks.toArray(new Class[callbacks.size()]);\n        }\n    }",
    "query": "Design a service that dynamically applies multiple interception behaviors to repository methods for logging, security, and transaction management without manually specifying each proxy configuration.",
    "function_signature": "public Class<?>[] determineInterceptorTypes()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.SESSION_COOKIE_NAME",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "field",
    "signature": "public String SESSION_COOKIE_NAME",
    "documentation": "\t/**\n\t * The session cookie name.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String SESSION_COOKIE_NAME = \"JSESSION\";",
    "query": "Create a unit test to verify that the mock web environment uses the standardized session cookie name, ensuring consistency across your application's testing scenarios.",
    "function_signature": "public void validateDefaultSessionCookieName()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.FunctionReference#generateCode(mv,cf)",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tMethod method = this.method;\n\t\tAssert.state(method != null, \"No method handle\");\n\t\tString classDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn(INVOKESTATIC, classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), false);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}",
    "query": "Enhance your Spring application's expression evaluation performance by implementing a feature that dynamically generates optimized bytecode for custom functions during runtime.",
    "function_signature": "public void generateOptimizedFunctionBytecode(MethodVisitor mv, CodeFlow cf);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockBodyContent#print(value)",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "public void print(String value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void print(String value) throws IOException {\n\t\tgetEnclosingWriter().print(value);\n\t}",
    "query": "Create a unit test that verifies the correct writing of dynamic content to a mocked HTTP response body, ensuring that the content is accurately captured and can be asserted against expected values.",
    "function_signature": "public void writeMockResponseBody(String content) throws IOException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#initWebAppContext()",
    "from_version": "v6.0.2",
    "to_version": "v6.0.3",
    "type": "method",
    "signature": "protected WebApplicationContext initWebAppContext()",
    "documentation": "\t/**\n\t * A method to obtain the {@code WebApplicationContext} to be passed to the\n\t * {@code DispatcherServlet}. Invoked from {@link #build()} before the\n\t * {@link MockMvc} instance is created.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected abstract WebApplicationContext initWebAppContext();",
    "query": "How can you configure a MockMvc setup to initialize the web application context automatically before building the MockMvc instance for integration testing?",
    "function_signature": "protected WebApplicationContext initializeWebAppContext()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.AnnotatedMethod#getReturnValueType(returnValue)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public MethodParameter getReturnValueType(@Nullable Object returnValue)",
    "documentation": "\t/**\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}",
    "query": "Design a feature that intercepts service method executions to log comprehensive details about the return value's type, including generic information, enhancing debugging and monitoring capabilities.",
    "function_signature": "public MethodParameter captureReturnValueType(Object returnValue)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DataBufferUtils#map(b)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public DataBuffer map(int b)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DataBuffer map(int b) {\n\t\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(1);\n\t\t\tbuffer.write((byte) b);\n\t\t\treturn buffer;\n\t\t}",
    "query": "Develop a service method that takes a single byte value and prepares it for transmission in a non-blocking reactive stream, ensuring efficient buffer management.",
    "function_signature": "public DataBuffer prepareByteForStream(int byteValue)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#userInfo()",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public String userInfo()",
    "documentation": "\t\t/**\n\t\t * Convenience method to return the full user info.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic String userInfo() {\n\t\t\tif (!includesCredentials()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tStringBuilder userInfo = new StringBuilder(username());\n\t\t\tif (!password().isEmpty()) {\n\t\t\t\tuserInfo.append(':');\n\t\t\t\tuserInfo.append(password());\n\t\t\t}\n\t\t\treturn userInfo.toString();\n\t\t}",
    "query": "Develop a component that extracts and returns the comprehensive authentication details of the active user, seamlessly including sensitive information when credentials are present.",
    "function_signature": "public String retrieveFullUserCredentials()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applicationContext(context)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public WebHttpHandlerBuilder applicationContext(ApplicationContext context)",
    "documentation": "\t/**\n\t * Static factory method to create a new builder instance by detecting beans\n\t * in an {@link ApplicationContext}. The following are detected:\n\t * <ul>\n\t * <li>{@link WebHandler} [1] -- looked up by the name\n\t * {@link #WEB_HANDLER_BEAN_NAME}.\n\t * <li>{@link WebFilter} [0..N] -- detected by type and ordered,\n\t * see {@link AnnotationAwareOrderComparator}.\n\t * <li>{@link WebExceptionHandler} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link HttpHandlerDecoratorFactory} [0..N] -- detected by type and\n\t * ordered.\n\t * <li>{@link ObservationRegistry} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link ServerRequestObservationConvention} -- detected by type and\n\t * configured if unique.\n\t * <li>{@link WebSessionManager} [0..1] -- looked up by the name\n\t * {@link #WEB_SESSION_MANAGER_BEAN_NAME}.\n\t * <li>{@link ServerCodecConfigurer} [0..1] -- looked up by the name\n\t * {@link #SERVER_CODEC_CONFIGURER_BEAN_NAME}.\n\t * <li>{@link LocaleContextResolver} [0..1] -- looked up by the name\n\t * {@link #LOCALE_CONTEXT_RESOLVER_BEAN_NAME}.\n\t * </ul>\n\t * @param context the application context to use for the lookup\n\t * @return the prepared builder\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static WebHttpHandlerBuilder applicationContext(ApplicationContext context) {\n\n\t\tWebHttpHandlerBuilder builder = new WebHttpHandlerBuilder(\n\t\t\t\tcontext.getBean(WEB_HANDLER_BEAN_NAME, WebHandler.class), context);\n\n\t\tList<WebFilter> webFilters = context\n\t\t\t\t.getBeanProvider(WebFilter.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.filters(filters -> filters.addAll(webFilters));\n\n\t\tList<WebExceptionHandler> exceptionHandlers = context\n\t\t\t\t.getBeanProvider(WebExceptionHandler.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.toList();\n\t\tbuilder.exceptionHandlers(handlers -> handlers.addAll(exceptionHandlers));\n\n\t\tcontext.getBeanProvider(HttpHandlerDecoratorFactory.class)\n\t\t\t\t.orderedStream()\n\t\t\t\t.forEach(builder::httpHandlerDecorator);\n\n\t\tcontext.getBeanProvider(ObservationRegistry.class).ifUnique(builder::observationRegistry);\n\t\tcontext.getBeanProvider(ServerRequestObservationConvention.class).ifAvailable(builder::observationConvention);\n\n\t\ttry {\n\t\t\tbuilder.sessionManager(\n\t\t\t\t\tcontext.getBean(WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.codecConfigurer(\n\t\t\t\t\tcontext.getBean(SERVER_CODEC_CONFIGURER_BEAN_NAME, ServerCodecConfigurer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.localeContextResolver(\n\t\t\t\t\tcontext.getBean(LOCALE_CONTEXT_RESOLVER_BEAN_NAME, LocaleContextResolver.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\ttry {\n\t\t\tbuilder.forwardedHeaderTransformer(\n\t\t\t\t\tcontext.getBean(FORWARDED_HEADER_TRANSFORMER_BEAN_NAME, ForwardedHeaderTransformer.class));\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Fall back on default\n\t\t}\n\n\t\treturn builder;\n\t}",
    "query": "Design a web handler setup that leverages dependency injection for configuring essential components, enhancing both performance and scalability of your application.",
    "function_signature": "public static WebHttpHandlerBuilder builderWithDependencies(DependencyProvider provider)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#servletPath(servletPath)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public B servletPath(String servletPath)",
    "documentation": "\t/**\n\t * Specify the portion of the requestURI that represents the path to which\n\t * the Servlet is mapped. This is typically a portion of the requestURI\n\t * after the context path.\n\t * <p>In most cases, tests can be written by omitting the servlet path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the prefix to which a servlet is mapped. For example if a Servlet is\n\t * mapped to {@code \"/main/*\"}, tests can be written with the requestURI\n\t * {@code \"/accounts/1\"} as opposed to {@code \"/main/accounts/1\"}.\n\t * If specified here, the servletPath must start with a \"/\" and must not\n\t * end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getServletPath()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic B servletPath(String servletPath) {\n\t\tif (StringUtils.hasText(servletPath)) {\n\t\t\tAssert.isTrue(servletPath.startsWith(\"/\"), \"Servlet path must start with a '/'\");\n\t\t\tAssert.isTrue(!servletPath.endsWith(\"/\"), \"Servlet path must not end with a '/'\");\n\t\t}\n\t\tthis.servletPath = servletPath;\n\t\treturn self();\n\t}",
    "query": "Design a unit test for a Spring MVC controller that is mapped to a specific servlet prefix (e.g., \"/api\"). Ensure that the test accurately simulates requests to endpoints like \"/api/users/1\" without hardcoding the servlet prefix in each request URI.",
    "function_signature": "public void testGetUserById_withCustomServletPrefix(String servletPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#isUnreservedOrSubDelimiter(c)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "protected boolean isUnreservedOrSubDelimiter(int c)",
    "documentation": "\t\t/**\n\t\t * Combined check whether a character is unreserved or a sub-delimiter.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tprotected boolean isUnreservedOrSubDelimiter(int c) {\n\t\t\treturn (c < unreservedOrSubDelimiterArray.length && c >= 0 && unreservedOrSubDelimiterArray[c]);\n\t\t}",
    "query": "Implement a method within your URL processing service that verifies each character of a user-provided path segment to ensure it adheres to the allowed character set, thereby enhancing URL safety and compliance.",
    "function_signature": "protected boolean isValidPathCharacter(char c)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setAdvice(advice)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public void setAdvice(Advice advice)",
    "documentation": "\t/**\n\t * Specify a particular instance of the target advice directly,\n\t * avoiding lazy resolution in {@link #getAdvice()}.\n\t * @since 3.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setAdvice(Advice advice) {\n\t\tsynchronized (this.adviceMonitor) {\n\t\t\tthis.advice = advice;\n\t\t}\n\t}",
    "query": "Create a Spring AOP advisor that defers the initialization of advice instances to enhance application performance and ensure thread-safe operations.",
    "function_signature": "public void configureAdviceProvider(Supplier<Advice> adviceProvider)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.generate.FileSystemGeneratedFiles#copy(content,override)",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "protected void copy(InputStreamSource content, boolean override)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tprotected void copy(InputStreamSource content, boolean override) {\n\t\t\tif (override) {\n\t\t\t\tcopy(content, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopy(content);\n\t\t\t}\n\t\t}",
    "query": "Implement a feature that generates essential configuration files during the Ahead-of-Time (AOT) compilation process, allowing the option to prevent overwriting existing files unless explicitly permitted.",
    "function_signature": "protected void generateConfiguration(InputStreamSource configData, boolean allowOverride)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.ServerSentEvent#data()",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public T data()",
    "documentation": "\t/**\n\t * Return the {@code data} field of this event, if available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic T data() {\n\t\treturn this.data;\n\t}",
    "query": "Design a reactive endpoint that streams live sensor data to clients by efficiently extracting the necessary information from incoming event streams.",
    "function_signature": "public Flux<SensorData> streamLiveSensorUpdates()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.DefaultResponseErrorHandler#isHandled()",
    "from_version": "v6.1.17",
    "to_version": "v6.2.3",
    "type": "method",
    "signature": "public boolean isHandled()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isHandled() {\n\t\t\treturn this.handled;\n\t\t}",
    "query": "Design a REST client component that determines whether to process or ignore specific HTTP error responses, enabling conditional error handling based on response status codes.",
    "function_signature": "public boolean isErrorHandled(HttpStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.event.ApplicationListenerMethodAdapter#toString()",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}",
    "query": "Implement a feature that captures and displays the generic signatures of all event listener methods registered in your Spring application for enhanced debugging and monitoring.",
    "function_signature": "public String getRegisteredEventListenerSignatures()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.view.xslt.XsltView#setUriResolver(uriResolver)",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public void setUriResolver(URIResolver uriResolver)",
    "documentation": "\t/**\n\t * Set the URIResolver used in the transform.\n\t * <p>The URIResolver handles calls to the XSLT {@code document()} function.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setUriResolver(URIResolver uriResolver) {\n\t\tthis.uriResolver = uriResolver;\n\t}",
    "query": "In your Spring MVC application, ensure that XSLT transformations can securely access external XML resources by integrating a custom resolution strategy.",
    "function_signature": "public void configureCustomUriResolver(URIResolver uriResolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader#setMetaClass(metaClass)",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public void setMetaClass(MetaClass metaClass)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void setMetaClass(MetaClass metaClass) {\n\t\t\tthis.metaClass = metaClass;\n\t\t}",
    "query": "Design a Spring configuration approach that enables the dynamic augmentation of bean behaviors during their initialization phase, allowing for runtime customization without altering the original bean definitions.",
    "function_signature": "public void enhanceBeanBehavior(Class<?> beanClass, MetaClass metaClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#toString()",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn this.delegate.toString();\n\t\t}",
    "query": "Develop a feature that generates consistent and detailed string representations of various objects to enhance logging and debugging capabilities within your Spring application.",
    "function_signature": "public String generateObjectDescription(Object target)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.RequestMappingInfo#params(params)",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public Builder params(String... params)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Builder params(String... params) {\n\t\t\tthis.paramsCondition = (ObjectUtils.isEmpty(params) ?\n\t\t\t\t\tEMPTY_PARAMS : new ParamsRequestCondition(params));\n\t\t\treturn this;\n\t\t}",
    "query": "Design a reactive controller method that handles GET requests to \"/reports\" exclusively when specific query parameters are provided. Ensure that the method efficiently filters requests based on the presence of these parameters.",
    "function_signature": "public Mono<ResponseEntity<Report>> generateReport(String... requiredParams)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.annotation.InjectionMetadata#hashCode()",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn this.member.getClass().hashCode() * 29 + this.member.getName().hashCode();\n\t\t}",
    "query": "Develop a custom bean post-processor that efficiently caches and compares injection metadata for beans, ensuring consistent identification and reuse of metadata to optimize dependency injection performance.",
    "function_signature": "public int getInjectionMetadataHash(Object bean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getRemoteAddr()",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public String getRemoteAddr()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getRemoteAddr() {\n\t\treturn this.remoteAddr;\n\t}",
    "query": "Develop a unit test to verify that your controller correctly retrieves and utilizes the client's IP address from HTTP requests.",
    "function_signature": "public String getClientIpAddress(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#remove(key)",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public List<V> remove(Object key)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic List<V> remove(Object key) {\n\t\tthrow new UnsupportedOperationException();\n\t}",
    "query": "Design a feature for an application that manages user roles, where each user can have multiple roles. Implement functionality to revoke all roles from a specific user and retrieve the list of roles that were removed in the process.",
    "function_signature": "public List<String> revokeAllRoles(String userId)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.HandlerMethod#setLogger(logger)",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public void setLogger(Log logger)",
    "documentation": "\t/**\n\t * Set an alternative logger to use than the one based on the class name.\n\t * @param logger the logger to use\n\t * @since 5.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setLogger(Log logger) {\n\t\tthis.logger = logger;\n\t}",
    "query": "Design a feature that allows specific request handlers in your Spring application to utilize distinct logging mechanisms, enabling tailored logging strategies for different endpoints.",
    "function_signature": "public void applyCustomLoggingStrategy(Log customLogger)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mail.javamail.MimeMessageHelper#getName()",
    "from_version": "v5.2.22.RELEASE",
    "to_version": "v6.0.0-M4",
    "type": "method",
    "signature": "public String getName()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}",
    "query": "Design a service that constructs and sends richly formatted emails, ensuring that each email's unique identifier can be retrieved for logging and tracking purposes after creation.",
    "function_signature": "public String sendRichEmailWithTracking(EmailDetails emailDetails);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Create a service method that dynamically manages user subscriptions to multiple messaging channels, ensuring real-time updates and efficient message routing by leveraging Spring's enhanced subscription tracking capabilities.",
    "function_signature": "public void manageUserSubscriptions(SubscriptionRegistry subscriptionRegistry, String userId, List<String> channels)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Design a component for a real-time chat application that initializes user subscriptions based on varying load conditions. The setup should efficiently manage destinations when there are no subscribers, multiple subscribers to the same destination, or a dynamic distribution of subscribers across multiple destinations.",
    "function_signature": "public void initializeSubscriptionEnvironment(SystemState systemState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Design a message processing component that dynamically resolves message destinations based on message content, leveraging the latest enhancements in Spring's messaging infrastructure for optimized destination lookup.",
    "function_signature": "public String resolveDestinationForMessage(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Create a messaging service that assigns a unique, thread-safe identifier to each incoming message, ensuring efficient handling in a concurrent processing environment.",
    "function_signature": "public int generateAtomicUniqueId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a service that dynamically retrieves and manages the set of active messaging endpoints to optimize the distribution of real-time updates across various client applications.",
    "function_signature": "public String[] fetchActiveMessagingEndpoints()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Develop a feature that allows an interceptor to apply sophisticated URL pattern matching, enabling it to target requests based on dynamic and flexible path criteria within your Spring MVC application.",
    "function_signature": "public PathMatcher getInterceptorPathMatcher()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a mechanism that intercepts HTTP requests to specific endpoints, allowing you to modify the response model data after the controller processes the request but before the view is rendered.",
    "function_signature": "public void customizeResponseModel(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "In a Spring-based messaging application, implement a service method that retrieves the current number of active destinations managed by the message broker, enabling administrators to monitor and scale the messaging infrastructure effectively.",
    "function_signature": "public int getBrokerDestinationCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a component that initializes a subscription registry capable of managing numerous WebSocket sessions and destinations, with configurable caching limits and support for selective message filtering based on custom headers.",
    "function_signature": "public void initializeSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.2.10.RELEASE",
    "to_version": "v5.3.0",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Optimize a WebSocket messaging service to handle and benchmark the registration and unregistration of thousands of client subscriptions across multiple destinations, ensuring minimal latency and efficient resource management under high concurrency.",
    "function_signature": "public void benchmarkSubscriptionPerformance(SubscriptionPerformanceContext context);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.view.ContentNegotiatingViewResolver#setUseNotAcceptableStatusCode(useNotAcceptableStatusCode)",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public void setUseNotAcceptableStatusCode(boolean useNotAcceptableStatusCode)",
    "documentation": "\t/**\n\t * Indicate whether a {@link HttpServletResponse#SC_NOT_ACCEPTABLE 406 Not Acceptable}\n\t * status code should be returned if no suitable view can be found.\n\t * <p>Default is {@code false}, meaning that this view resolver returns {@code null} for\n\t * {@link #resolveViewName(String, Locale)} when an acceptable view cannot be found.\n\t * This will allow for view resolvers chaining. When this property is set to {@code true},\n\t * {@link #resolveViewName(String, Locale)} will respond with a view that sets the\n\t * response status to {@code 406 Not Acceptable} instead.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setUseNotAcceptableStatusCode(boolean useNotAcceptableStatusCode) {\n\t\tthis.useNotAcceptableStatusCode = useNotAcceptableStatusCode;\n\t}",
    "query": "Configure your Spring MVC application to return an HTTP 406 Not Acceptable status when it fails to find a suitable view for the requested content type, preventing further view resolver attempts.",
    "function_signature": "public void enableNotAcceptableStatusOnViewResolutionFailure(boolean enable)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.messaging.DefaultSimpUserRegistry#supportsSourceType(sourceType)",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public boolean supportsSourceType(@Nullable Class<?> sourceType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean supportsSourceType(@Nullable Class<?> sourceType) {\n\t\treturn true;\n\t}",
    "query": "Design a component that validates the compatibility of various message sources with your application's user management system, ensuring that only supported source types are processed for WebSocket communications.",
    "function_signature": "public boolean isSourceTypeSupported(@Nullable Class<?> sourceType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.EnhancedConfiguration",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "interface",
    "signature": "public interface EnhancedConfiguration",
    "documentation": "\t/**\n\t * Marker interface to be implemented by all @Configuration CGLIB subclasses.\n\t * Facilitates idempotent behavior for {@link ConfigurationClassEnhancer#enhance}\n\t * through checking to see if candidate classes are already assignable to it, e.g.\n\t * have already been enhanced.\n\t * <p>Also extends {@link BeanFactoryAware}, as all enhanced {@code @Configuration}\n\t * classes require access to the {@link BeanFactory} that created them.\n\t * <p>Note that this interface is intended for framework-internal use only, however\n\t * must remain public in order to allow access to subclasses generated from other\n\t * packages (i.e. user code).\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic interface EnhancedConfiguration extends BeanFactoryAware {\n\t}",
    "query": "In a Spring application, create a configuration component that can access the BeanFactory responsible for its creation and verify if it has already undergone configuration enhancement to avoid duplicate processing.",
    "function_signature": "public void registerEnhancedConfig(BeanFactoryAware config)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getAttributes()",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public Object getAttributes()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Object getAttributes() {\n\t\t\treturn VfsPatternUtils.getVisitorAttributes();\n\t\t}",
    "query": "Design a feature that dynamically adjusts resource scanning behavior based on custom metadata, enabling more granular control over which resources are loaded during application initialization.",
    "function_signature": "public void configureDynamicResourceAttributes()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DataBufferUtils#failed(exc,byteBuffer)",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public void failed(Throwable exc, ByteBuffer byteBuffer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void failed(Throwable exc, ByteBuffer byteBuffer) {\n\t\t\tsinkDataBuffer();\n\t\t\tthis.sink.error(exc);\n\t\t}",
    "query": "Create a component that manages real-time data streams, ensuring that any issues with buffer processing are properly handled to maintain system stability.",
    "function_signature": "public void onBufferFailure(Throwable error, ByteBuffer buffer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DataBufferUtils#delimiter()",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public byte[] delimiter()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic byte[] delimiter() {\n\t\t\treturn this.delimiter;\n\t\t}",
    "query": "Design a reactive service that processes a continuous stream of data, splitting the incoming byte buffers into individual messages whenever a specific byte sequence delimiter is detected.",
    "function_signature": "public Flux<String> processDataStreamWithDelimiter(Flux<DataBuffer> dataStream, byte[] delimiter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.WebSocketHttpHeaders#containsKey(key)",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public boolean containsKey(Object key)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean containsKey(Object key) {\n\t\treturn this.headers.containsKey(key);\n\t}",
    "query": "Develop a WebSocket endpoint that accepts connections only if a designated custom header is present in the handshake request.",
    "function_signature": "public boolean hasRequiredHandshakeHeader(WebSocketHttpHeaders headers, String headerName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.MethodCallback",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "interface",
    "signature": "public interface MethodCallback",
    "documentation": "\t/**\n\t * Action to take on each method.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic interface MethodCallback {\n\n\t\t/**\n\t\t * Perform an operation using the given method.\n\t\t * @param method the method to operate on\n\t\t */\n\t\tvoid doWith(Method method) throws IllegalArgumentException, IllegalAccessException;\n\t}",
    "query": "Design a feature that systematically examines every method within a given class to apply custom behaviors like logging or validation, ensuring scalability and reducing repetitive code.",
    "function_signature": "public void inspectAllMethods(Class<?> targetClass, MethodOperation operation);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.resource.VersionResourceResolver#getURI()",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public URI getURI()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic URI getURI() throws IOException {\n\t\t\treturn this.original.getURI();\n\t\t}",
    "query": "Design a reactive controller method that retrieves the correct URI for a versioned static resource based on a given resource path, optimizing for client-side caching.",
    "function_signature": "public Mono<URI> resolveVersionedResourceUri(String resourcePath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
    "from_version": "v5.3.24",
    "to_version": "v6.0.0",
    "type": "method",
    "signature": "public V>> entrySet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Set<Entry<String, V>> entrySet() {\n\t\tSet<Entry<String, V>> entrySet = this.entrySet;\n\t\tif (entrySet == null) {\n\t\t\tentrySet = new EntrySet(this.targetMap.entrySet());\n\t\t\tthis.entrySet = entrySet;\n\t\t}\n\t\treturn entrySet;\n\t}",
    "query": "Design a method to manage application settings where keys are treated without case sensitivity, ensuring consistent access and ordered iteration of the entries.",
    "function_signature": "public Set<Map.Entry<String, String>> getSettingsEntries()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#capacity(capacity)",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public DataBuffer capacity(int capacity)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic DataBuffer capacity(int capacity) {\n\t\tthis.delegate.capacity(capacity);\n\t\treturn this;\n\t}",
    "query": "Design a component that can adjust the memory allocation for data buffers on-the-fly to efficiently handle fluctuating data loads in a high-throughput reactive application.",
    "function_signature": "public DataBuffer adjustBufferCapacity(int newCapacity)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#clientInboundChannelExecutor()",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public Executor clientInboundChannelExecutor()",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic Executor clientInboundChannelExecutor() {\n\t\tChannelRegistration registration = getClientInboundChannelRegistration();\n\t\tExecutor executor = getExecutor(registration, \"clientInboundChannel-\", this::defaultExecutor);\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}",
    "query": "Set up the messaging system in your Spring application to handle incoming messages with a thread pool executor that integrates seamlessly with the application's lifecycle phases, ensuring optimal resource management during startup and shutdown.",
    "function_signature": "public Executor configureInboundChannelExecutor();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#write(b)",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public DataBuffer write(byte b)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic DataBuffer write(byte b) {\n\t\tthis.delegate.write(b);\n\t\treturn this;\n\t}",
    "query": "Create a method in a reactive service that appends a single byte to a data buffer, enabling efficient byte-wise data manipulation in streaming responses.",
    "function_signature": "public DataBuffer writeByte(DataBuffer buffer, byte b)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#setContentTypeResolver(contentTypeResolver)",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver)",
    "documentation": "\t/**\n\t * Set the {@link RequestedContentTypeResolver} to use to determine requested\n\t * media types. If not set, the default constructor is used.\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setContentTypeResolver(RequestedContentTypeResolver contentTypeResolver) {\n\t\tAssert.notNull(contentTypeResolver, \"'contentTypeResolver' must not be null\");\n\t\tthis.contentTypeResolver = contentTypeResolver;\n\t}",
    "query": "Implement a feature in your reactive Spring application that allows dynamically determining the client's preferred media types based on custom request parameters. Ensure that your solution can seamlessly integrate with the request handling mechanism to optimize content negotiation without altering existing controller methods.",
    "function_signature": "public void configureCustomMediaTypeResolver(RequestedContentTypeResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#onTimeout(onTimeout)",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public StreamBuilder onTimeout(Runnable onTimeout)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\t\tpublic StreamBuilder onTimeout(Runnable onTimeout) {\n\t\t\tthis.deferredResult.onTimeout(onTimeout);\n\t\t\treturn this;\n\t\t}",
    "query": "Implement a RESTful endpoint that processes streaming data and ensures specific actions are executed if the processing exceeds a predefined time limit. Address the challenge of managing long-running streams by incorporating a mechanism that gracefully handles timeout scenarios without compromising the application's responsiveness.",
    "function_signature": "public StreamBuilder configureStreamEndpoint(String path, Runnable timeoutHandler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#isAllocated()",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public boolean isAllocated()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isAllocated() {\n\t\treturn this.refCount.get() > 0;\n\t}",
    "query": "Ensure that your data processing pipeline only manipulates buffers that are actively allocated to maintain optimal memory usage.",
    "function_signature": "public void processIfBufferAllocated(DataBuffer buffer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.AbstractApplicationContext#isClosed()",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public boolean isClosed()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isClosed() {\n\t\treturn this.closed.get();\n\t}",
    "query": "Create a component that ensures no further processing occurs once the application is in the process of shutting down. This component should verify the application's state before handling any new tasks, preventing resource leaks and ensuring graceful termination.",
    "function_signature": "public boolean isApplicationContextClosed()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#release()",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public boolean release()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}",
    "query": "Develop a method to efficiently manage and finalize resource handling within a reactive HTTP client connector, ensuring optimal performance and preventing potential resource leaks.",
    "function_signature": "public boolean finalizeResourceHandling()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.MockMvcTester#create(mockMvc)",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public MockMvcTester create(MockMvc mockMvc)",
    "documentation": "\t/**\n\t * Create an instance that delegates to the given {@link MockMvc} instance.\n\t * @param mockMvc the MockMvc instance to delegate calls to\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static MockMvcTester create(MockMvc mockMvc) {\n\t\treturn new MockMvcTester(mockMvc, null);\n\t}",
    "query": "How can you streamline your Spring MVC controller tests to leverage advanced assertion capabilities while utilizing your current MockMvc configuration?",
    "function_signature": "public MockMvcTester initializeControllerTests(MockMvc mockMvc)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#characterEncoding(encoding)",
    "from_version": "v6.1.15",
    "to_version": "v6.2.0",
    "type": "method",
    "signature": "public B characterEncoding(String encoding)",
    "documentation": "\t/**\n\t * Set the character encoding of the request.\n\t * @param encoding the character encoding\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic B characterEncoding(String encoding) {\n\t\tthis.characterEncoding = encoding;\n\t\treturn self();\n\t}",
    "query": "Ensure that your Spring MVC test correctly handles UTF-8 encoded form submissions by specifying the appropriate character encoding in your mock HTTP request setup.",
    "function_signature": "public MockHttpServletRequestBuilder withUtf8Encoding()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.Netty5DataBuffer#indexOf(predicate,fromIndex)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\tfromIndex = 0;\n\t\t}\n\t\telse if (fromIndex >= this.buffer.writerOffset()) {\n\t\t\treturn -1;\n\t\t}\n\t\tint length = this.buffer.writerOffset() - fromIndex;\n\t\tint bytes = this.buffer.openCursor(fromIndex, length).process(predicate.negate()::test);\n\t\treturn bytes == -1 ? -1 : fromIndex + bytes;\n\t}",
    "query": "Implement a service that processes incoming data streams and efficiently identifies the first occurrence of a delimiter byte sequence, starting the search from a dynamic offset based on previous operations.",
    "function_signature": "public int locateDelimiter(DataBuffer dataBuffer, IntPredicate delimiterCondition, int searchStartIndex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.DelegatingMessageSource#getParentMessageSource()",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public MessageSource getParentMessageSource()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic @Nullable MessageSource getParentMessageSource() {\n\t\treturn this.parentMessageSource;\n\t}",
    "query": "Refactor the message retrieval logic to enhance performance and ensure thread safety. Ensure that the parent message source is efficiently integrated without compromising the application's responsiveness.",
    "function_signature": "public MessageSource obtainEffectiveMessageSource()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.WebExchangeBindException#recordSuppressedField(field)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public void recordSuppressedField(String field)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void recordSuppressedField(String field) {\n\t\tthis.bindingResult.recordSuppressedField(field);\n\t}",
    "query": "Improve the robustness of your data binding process by implementing a method that efficiently handles fields that should be suppressed, ensuring better performance and enhanced error management.",
    "function_signature": "public void handleSuppressedField(String fieldName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.<unknown>#ifNoneMatch(ifNoneMatches)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}",
    "query": "Create a method that configures a request to proceed only if the server's resource has been modified, thereby improving caching efficiency and reducing unnecessary data transfers.",
    "function_signature": "public DefaultRequestBodyUriSpec conditionalResourceCheck(String... etags)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#query(sql,rch)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, EmptySqlParameterSource.INSTANCE, rch);\n\t}",
    "query": "Develop a method to execute SQL statements that accommodates dynamic parameters, enhancing both performance and the flexibility of row processing.",
    "function_signature": "public void executeQuery(String sql, SqlParameterSource parameters, RowCallbackHandler rowHandler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.MessageSourceSupport#formatMessage(msg,args,locale)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "protected String formatMessage(String msg, Object @Nullable [] args, Locale locale)",
    "documentation": "\t/**\n\t * Format the given message String, using cached MessageFormats.\n\t * By default invoked for passed-in default messages, to resolve\n\t * any argument placeholders found in them.\n\t * @param msg the message to format\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none\n\t * @param locale the Locale used for formatting\n\t * @return the formatted message (with resolved arguments)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected String formatMessage(String msg, Object @Nullable [] args, Locale locale) {\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\treturn msg;\n\t\t}\n\t\tMap<Locale, MessageFormat> messageFormatsPerLocale = this.messageFormatsPerMessage\n\t\t\t\t.computeIfAbsent(msg, key -> new ConcurrentHashMap<>());\n\t\tMessageFormat messageFormat = messageFormatsPerLocale.computeIfAbsent(locale, key -> {\n\t\t\ttry {\n\t\t\t\treturn createMessageFormat(msg, locale);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid message format - probably not intended for formatting,\n\t\t\t\t// rather using a message structure with no arguments involved...\n\t\t\t\tif (isAlwaysUseMessageFormat()) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Silently proceed with raw message if format not enforced...\n\t\t\t\treturn INVALID_MESSAGE_FORMAT;\n\t\t\t}\n\t\t});\n\t\tif (messageFormat == INVALID_MESSAGE_FORMAT) {\n\t\t\treturn msg;\n\t\t}\n\t\tsynchronized (messageFormat) {\n\t\t\treturn messageFormat.format(resolveArguments(args, locale));\n\t\t}\n\t}",
    "query": "Develop a utility that efficiently processes and formats user-facing messages with support for multiple locales. Ensure that the implementation minimizes synchronization overhead and handles message arguments safely to enhance performance and usability.",
    "function_signature": "public String resolveLocalizedMessage(String code, @Nullable Object[] args, Locale locale)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getPersistenceUnitInfo(persistenceUnitName)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "protected MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName)",
    "documentation": "\t/**\n\t * Return the specified PersistenceUnitInfo from this manager's cache\n\t * of processed persistence units, keeping it in the cache (i.e. not\n\t * 'obtaining' it for use but rather just accessing it for post-processing).\n\t * <p>This can be used in {@link #postProcessPersistenceUnitInfo} implementations,\n\t * detecting existing persistence units of the same name and potentially merging them.\n\t * @param persistenceUnitName the name of the desired persistence unit\n\t * @return the PersistenceUnitInfo in mutable form, or {@code null} if not available\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected final @Nullable MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName) {\n\t\tPersistenceUnitInfo pui = this.persistenceUnitInfos.get(persistenceUnitName);\n\t\treturn (MutablePersistenceUnitInfo) pui;\n\t}",
    "query": "Develop a method to efficiently access and modify the configuration of a specific persistence unit, ensuring thread-safe operations and improved performance when handling multiple units concurrently.",
    "function_signature": "protected EnhancedPersistenceUnitInfo retrievePersistenceUnitConfiguration(String unitName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.annotation.SpringCacheAnnotationParser#parseCacheAnnotations(type)",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public Collection<CacheOperation> parseCacheAnnotations(Class<?> type)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic @Nullable Collection<CacheOperation> parseCacheAnnotations(Class<?> type) {\n\t\tDefaultCacheConfig defaultConfig = new DefaultCacheConfig(type);\n\t\treturn parseCacheAnnotations(defaultConfig, type);\n\t}",
    "query": "Enhance the caching mechanism in your Spring application to improve efficiency and ensure thread-safe cache operations by adopting the latest configuration practices.",
    "function_signature": "public Collection<CacheOperation> evaluateCacheConfigurations(Class<?> clazz)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.SpelEvaluationException#getMessageCode()",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "method",
    "signature": "public SpelMessage getMessageCode()",
    "documentation": "\t/**\n\t * Return the message code.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic SpelMessage getMessageCode() {\n\t\treturn this.message;\n\t}",
    "query": "Design a utility method that extracts a user-friendly message from a SpEL evaluation exception, optimizing for improved performance and reliability with the latest API practices.",
    "function_signature": "public String getFriendlyErrorMessage(SpelEvaluationException exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource",
    "from_version": "v7.0.0-M3",
    "to_version": "v6.2.5",
    "type": "class",
    "signature": "public class BeanPropertySqlParameterSource",
    "documentation": "/**\n * {@link SqlParameterSource} implementation that obtains parameter values\n * from bean properties of a given JavaBean object. The names of the bean\n * properties have to match the parameter names. Supports components of\n * record classes as well, with accessor methods matching parameter names.\n *\n * <p>Uses a Spring {@link BeanWrapper} for bean property access underneath.\n *\n * @author Thomas Risberg\n * @author Juergen Hoeller\n * @since 2.0\n * @see NamedParameterJdbcTemplate\n * @see SimplePropertySqlParameterSource\n */",
    "changetype": "deprecated",
    "source_code": "public class BeanPropertySqlParameterSource extends AbstractSqlParameterSource {\n\n\tprivate final BeanWrapper beanWrapper;\n\n\tprivate String @Nullable [] propertyNames;\n\n\n\t/**\n\t * Create a new BeanPropertySqlParameterSource for the given bean.\n\t * @param object the bean instance to wrap\n\t */\n\tpublic BeanPropertySqlParameterSource(Object object) {\n\t\tthis.beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(object);\n\t}\n\n\n\t@Override\n\tpublic boolean hasValue(String paramName) {\n\t\treturn this.beanWrapper.isReadableProperty(paramName);\n\t}\n\n\t@Override\n\tpublic @Nullable Object getValue(String paramName) throws IllegalArgumentException {\n\t\ttry {\n\t\t\treturn this.beanWrapper.getPropertyValue(paramName);\n\t\t}\n\t\tcatch (NotReadablePropertyException ex) {\n\t\t\tthrow new IllegalArgumentException(ex.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Derives a default SQL type from the corresponding property type.\n\t * @see org.springframework.jdbc.core.StatementCreatorUtils#javaTypeToSqlParameterType\n\t */\n\t@Override\n\tpublic int getSqlType(String paramName) {\n\t\tint sqlType = super.getSqlType(paramName);\n\t\tif (sqlType != TYPE_UNKNOWN) {\n\t\t\treturn sqlType;\n\t\t}\n\t\tClass<?> propType = this.beanWrapper.getPropertyType(paramName);\n\t\treturn StatementCreatorUtils.javaTypeToSqlParameterType(propType);\n\t}\n\n\t@Override\n\tpublic String[] getParameterNames() {\n\t\treturn getReadablePropertyNames();\n\t}\n\n\t/**\n\t * Provide access to the property names of the wrapped bean.\n\t * Uses support provided in the {@link PropertyAccessor} interface.\n\t * @return an array containing all the known property names\n\t */\n\tpublic String[] getReadablePropertyNames() {\n\t\tif (this.propertyNames == null) {\n\t\t\tList<String> names = new ArrayList<>();\n\t\t\tPropertyDescriptor[] props = this.beanWrapper.getPropertyDescriptors();\n\t\t\tfor (PropertyDescriptor pd : props) {\n\t\t\t\tif (this.beanWrapper.isReadableProperty(pd.getName())) {\n\t\t\t\t\tnames.add(pd.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.propertyNames = StringUtils.toStringArray(names);\n\t\t}\n\t\treturn this.propertyNames;\n\t}\n\n}",
    "query": "Optimize your data access layer by implementing a strategy that efficiently maps bean properties to SQL parameters, enhancing both performance and type safety in your JDBC operations.",
    "function_signature": "public SqlParameterSource createOptimizedParameterSource(Object bean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#setBeanFactory(beanFactory)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "documentation": "\t/**\n\t * Set the containing {@link BeanFactory} for {@link CacheManager} and other\n\t * service lookups.\n\t * @since 4.3\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}",
    "query": "Develop a caching utility that seamlessly integrates with Spring's dependency management, ensuring optimal performance and reducing boilerplate code by utilizing the framework's current best practices for service lookups.",
    "function_signature": "public void configureCacheSupport(CacheManager cacheManager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.DataBinder#addCustomFormatter(formatter,fields)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, String... fields)",
    "documentation": "\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Improve the data binding process by applying a type-specific formatter to certain fields, ensuring optimal performance and type safety without affecting other fields.",
    "function_signature": "public void configureCustomEditors(PropertyEditorRegistry registry, Class<?> targetType, String... fields)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.support.DefaultMultipartCodecs#extendObjectWriters(objectWriters)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "protected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters)",
    "documentation": "\t/**\n\t * Hook for client or server specific Object writers.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected void extendObjectWriters(List<HttpMessageWriter<?>> objectWriters) {\n\t}",
    "query": "Refactor your Spring applications HTTP codec setup to enhance performance and maintainability by customizing the message writers appropriately.",
    "function_signature": "protected void configureHttpMessageWriters(List<HttpMessageWriter<?>> messageWriters)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.NO_CLOSE_FRAME",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "field",
    "signature": "public CloseStatus NO_CLOSE_FRAME",
    "documentation": "\t/**\n\t * \"1006 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that the connection was closed abnormally, e.g., without sending\n\t * or receiving a Close control frame.\"\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final CloseStatus NO_CLOSE_FRAME = new CloseStatus(1006);",
    "query": "Implement a WebSocket handler method that gracefully handles unexpected connection closures, ensuring that only valid and recommended status codes are used to maintain optimal performance and reliability of the application.",
    "function_signature": "public void handleUnexpectedClose(WebSocketSession session, CloseStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.oxm.xstream.XStreamMarshaller#setBeanClassLoader(classLoader)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public void setBeanClassLoader(ClassLoader classLoader)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}",
    "query": "Enhance the XML marshaller's configuration to improve performance and ensure thread-safe class loading during XML processing.",
    "function_signature": "public void configureMarshallerWithLoaderStrategy(ClassLoaderStrategy strategy)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.TransactionSynchronizationManager#clearSynchronization()",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public void clearSynchronization()",
    "documentation": "\t/**\n\t * Deactivate transaction synchronization for the current thread.\n\t * Called by the transaction manager on transaction cleanup.\n\t * @throws IllegalStateException if synchronization is not active\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static void clearSynchronization() throws IllegalStateException {\n\t\tif (!isSynchronizationActive()) {\n\t\t\tthrow new IllegalStateException(\"Cannot deactivate transaction synchronization - not active\");\n\t\t}\n\t\tsynchronizations.remove();\n\t}",
    "query": "Develop a method that efficiently terminates transaction synchronization for the active thread, enhancing performance and ensuring robust transaction management during cleanup processes.",
    "function_signature": "public void terminateThreadTransactionSynchronization()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.AdvisedSupport",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "class",
    "signature": "public class AdvisedSupport",
    "documentation": "/**\n * Base class for AOP proxy configuration managers.\n * These are not themselves AOP proxies, but subclasses of this class are\n * normally factories from which AOP proxy instances are obtained directly.\n *\n * <p>This class frees subclasses of the housekeeping of Advices\n * and Advisors, but doesn't actually implement proxy creation\n * methods, which are provided by subclasses.\n *\n * <p>This class is serializable; subclasses need not be.\n * This class is used to hold snapshots of proxies.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see org.springframework.aop.framework.AopProxy\n */",
    "changetype": "deprecated",
    "source_code": "public class AdvisedSupport extends ProxyConfig implements Advised {\n\n\t/** use serialVersionUID from Spring 2.0 for interoperability. */\n\tprivate static final long serialVersionUID = 2651364800145442165L;\n\n\n\t/**\n\t * Canonical TargetSource when there's no target, and behavior is\n\t * supplied by the advisors.\n\t */\n\tpublic static final TargetSource EMPTY_TARGET_SOURCE = EmptyTargetSource.INSTANCE;\n\n\n\t/** Package-protected to allow direct access for efficiency. */\n\t@SuppressWarnings(\"serial\")\n\tTargetSource targetSource = EMPTY_TARGET_SOURCE;\n\n\t/** Whether the Advisors are already filtered for the specific target class. */\n\tprivate boolean preFiltered = false;\n\n\t/** The AdvisorChainFactory to use. */\n\t@SuppressWarnings(\"serial\")\n\tAdvisorChainFactory advisorChainFactory = new DefaultAdvisorChainFactory();\n\n\t/** Cache with Method as key and advisor chain List as value. */\n\tprivate transient Map<MethodCacheKey, List<Object>> methodCache;\n\n\t/**\n\t * Interfaces to be implemented by the proxy. Held in List to keep the order\n\t * of registration, to create JDK proxy with specified order of interfaces.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate List<Class<?>> interfaces = new ArrayList<>();\n\n\t/**\n\t * List of Advisors. If an Advice is added, it will be wrapped\n\t * in an Advisor before being added to this List.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate List<Advisor> advisors = new ArrayList<>();\n\n\n\t/**\n\t * No-arg constructor for use as a JavaBean.\n\t */\n\tpublic AdvisedSupport() {\n\t\tthis.methodCache = new ConcurrentHashMap<>(32);\n\t}\n\n\t/**\n\t * Create a AdvisedSupport instance with the given parameters.\n\t * @param interfaces the proxied interfaces\n\t */\n\tpublic AdvisedSupport(Class<?>... interfaces) {\n\t\tthis();\n\t\tsetInterfaces(interfaces);\n\t}\n\n\n\t/**\n\t * Set the given object as target.\n\t * Will create a SingletonTargetSource for the object.\n\t * @see #setTargetSource\n\t * @see org.springframework.aop.target.SingletonTargetSource\n\t */\n\tpublic void setTarget(Object target) {\n\t\tsetTargetSource(new SingletonTargetSource(target));\n\t}\n\n\t@Override\n\tpublic void setTargetSource(@Nullable TargetSource targetSource) {\n\t\tthis.targetSource = (targetSource != null ? targetSource : EMPTY_TARGET_SOURCE);\n\t}\n\n\t@Override\n\tpublic TargetSource getTargetSource() {\n\t\treturn this.targetSource;\n\t}\n\n\t/**\n\t * Set a target class to be proxied, indicating that the proxy\n\t * should be castable to the given class.\n\t * <p>Internally, an {@link org.springframework.aop.target.EmptyTargetSource}\n\t * for the given target class will be used. The kind of proxy needed\n\t * will be determined on actual creation of the proxy.\n\t * <p>This is a replacement for setting a \"targetSource\" or \"target\",\n\t * for the case where we want a proxy based on a target class\n\t * (which can be an interface or a concrete class) without having\n\t * a fully capable TargetSource available.\n\t * @see #setTargetSource\n\t * @see #setTarget\n\t */\n\tpublic void setTargetClass(@Nullable Class<?> targetClass) {\n\t\tthis.targetSource = EmptyTargetSource.forClass(targetClass);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getTargetClass() {\n\t\treturn this.targetSource.getTargetClass();\n\t}\n\n\t@Override\n\tpublic void setPreFiltered(boolean preFiltered) {\n\t\tthis.preFiltered = preFiltered;\n\t}\n\n\t@Override\n\tpublic boolean isPreFiltered() {\n\t\treturn this.preFiltered;\n\t}\n\n\t/**\n\t * Set the advisor chain factory to use.\n\t * <p>Default is a {@link DefaultAdvisorChainFactory}.\n\t */\n\tpublic void setAdvisorChainFactory(AdvisorChainFactory advisorChainFactory) {\n\t\tAssert.notNull(advisorChainFactory, \"AdvisorChainFactory must not be null\");\n\t\tthis.advisorChainFactory = advisorChainFactory;\n\t}\n\n\t/**\n\t * Return the advisor chain factory to use (never {@code null}).\n\t */\n\tpublic AdvisorChainFactory getAdvisorChainFactory() {\n\t\treturn this.advisorChainFactory;\n\t}\n\n\n\t/**\n\t * Set the interfaces to be proxied.\n\t */\n\tpublic void setInterfaces(Class<?>... interfaces) {\n\t\tAssert.notNull(interfaces, \"Interfaces must not be null\");\n\t\tthis.interfaces.clear();\n\t\tfor (Class<?> ifc : interfaces) {\n\t\t\taddInterface(ifc);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new proxied interface.\n\t * @param intf the additional interface to proxy\n\t */\n\tpublic void addInterface(Class<?> intf) {\n\t\tAssert.notNull(intf, \"Interface must not be null\");\n\t\tif (!intf.isInterface()) {\n\t\t\tthrow new IllegalArgumentException(\"[\" + intf.getName() + \"] is not an interface\");\n\t\t}\n\t\tif (!this.interfaces.contains(intf)) {\n\t\t\tthis.interfaces.add(intf);\n\t\t\tadviceChanged();\n\t\t}\n\t}\n\n\t/**\n\t * Remove a proxied interface.\n\t * <p>Does nothing if the given interface isn't proxied.\n\t * @param intf the interface to remove from the proxy\n\t * @return {@code true} if the interface was removed; {@code false}\n\t * if the interface was not found and hence could not be removed\n\t */\n\tpublic boolean removeInterface(Class<?> intf) {\n\t\treturn this.interfaces.remove(intf);\n\t}\n\n\t@Override\n\tpublic Class<?>[] getProxiedInterfaces() {\n\t\treturn ClassUtils.toClassArray(this.interfaces);\n\t}\n\n\t@Override\n\tpublic boolean isInterfaceProxied(Class<?> intf) {\n\t\tfor (Class<?> proxyIntf : this.interfaces) {\n\t\t\tif (intf.isAssignableFrom(proxyIntf)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t@Override\n\tpublic final Advisor[] getAdvisors() {\n\t\treturn this.advisors.toArray(new Advisor[0]);\n\t}\n\n\t@Override\n\tpublic int getAdvisorCount() {\n\t\treturn this.advisors.size();\n\t}\n\n\t@Override\n\tpublic void addAdvisor(Advisor advisor) {\n\t\tint pos = this.advisors.size();\n\t\taddAdvisor(pos, advisor);\n\t}\n\n\t@Override\n\tpublic void addAdvisor(int pos, Advisor advisor) throws AopConfigException {\n\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t}\n\t\taddAdvisorInternal(pos, advisor);\n\t}\n\n\t@Override\n\tpublic boolean removeAdvisor(Advisor advisor) {\n\t\tint index = indexOf(advisor);\n\t\tif (index == -1) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tremoveAdvisor(index);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void removeAdvisor(int index) throws AopConfigException {\n\t\tif (isFrozen()) {\n\t\t\tthrow new AopConfigException(\"Cannot remove Advisor: Configuration is frozen.\");\n\t\t}\n\t\tif (index < 0 || index > this.advisors.size() - 1) {\n\t\t\tthrow new AopConfigException(\"Advisor index \" + index + \" is out of bounds: \" +\n\t\t\t\t\t\"This configuration only has \" + this.advisors.size() + \" advisors.\");\n\t\t}\n\n\t\tAdvisor advisor = this.advisors.remove(index);\n\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\t// We need to remove introduction interfaces.\n\t\t\tfor (Class<?> ifc : introductionAdvisor.getInterfaces()) {\n\t\t\t\tremoveInterface(ifc);\n\t\t\t}\n\t\t}\n\n\t\tadviceChanged();\n\t}\n\n\t@Override\n\tpublic int indexOf(Advisor advisor) {\n\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\treturn this.advisors.indexOf(advisor);\n\t}\n\n\t@Override\n\tpublic boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException {\n\t\tAssert.notNull(a, \"Advisor a must not be null\");\n\t\tAssert.notNull(b, \"Advisor b must not be null\");\n\t\tint index = indexOf(a);\n\t\tif (index == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tremoveAdvisor(index);\n\t\taddAdvisor(index, b);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Add all the given advisors to this proxy configuration.\n\t * @param advisors the advisors to register\n\t */\n\tpublic void addAdvisors(Advisor... advisors) {\n\t\taddAdvisors(Arrays.asList(advisors));\n\t}\n\n\t/**\n\t * Add all the given advisors to this proxy configuration.\n\t * @param advisors the advisors to register\n\t */\n\tpublic void addAdvisors(Collection<Advisor> advisors) {\n\t\tif (isFrozen()) {\n\t\t\tthrow new AopConfigException(\"Cannot add advisor: Configuration is frozen.\");\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(advisors)) {\n\t\t\tfor (Advisor advisor : advisors) {\n\t\t\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t\t\t}\n\t\t\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\t\t\tthis.advisors.add(advisor);\n\t\t\t}\n\t\t\tadviceChanged();\n\t\t}\n\t}\n\n\tprivate void validateIntroductionAdvisor(IntroductionAdvisor advisor) {\n\t\tadvisor.validateInterfaces();\n\t\t// If the advisor passed validation, we can make the change.\n\t\tClass<?>[] ifcs = advisor.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\taddInterface(ifc);\n\t\t}\n\t}\n\n\tprivate void addAdvisorInternal(int pos, Advisor advisor) throws AopConfigException {\n\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\tif (isFrozen()) {\n\t\t\tthrow new AopConfigException(\"Cannot add advisor: Configuration is frozen.\");\n\t\t}\n\t\tif (pos > this.advisors.size()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Illegal position \" + pos + \" in advisor list with size \" + this.advisors.size());\n\t\t}\n\t\tthis.advisors.add(pos, advisor);\n\t\tadviceChanged();\n\t}\n\n\t/**\n\t * Allows uncontrolled access to the {@link List} of {@link Advisor Advisors}.\n\t * <p>Use with care, and remember to {@link #adviceChanged() fire advice changed events}\n\t * when making any modifications.\n\t */\n\tprotected final List<Advisor> getAdvisorsInternal() {\n\t\treturn this.advisors;\n\t}\n\n\t@Override\n\tpublic void addAdvice(Advice advice) throws AopConfigException {\n\t\tint pos = this.advisors.size();\n\t\taddAdvice(pos, advice);\n\t}\n\n\t/**\n\t * Cannot add introductions this way unless the advice implements IntroductionInfo.\n\t */\n\t@Override\n\tpublic void addAdvice(int pos, Advice advice) throws AopConfigException {\n\t\tAssert.notNull(advice, \"Advice must not be null\");\n\t\tif (advice instanceof IntroductionInfo introductionInfo) {\n\t\t\t// We don't need an IntroductionAdvisor for this kind of introduction:\n\t\t\t// It's fully self-describing.\n\t\t\taddAdvisor(pos, new DefaultIntroductionAdvisor(advice, introductionInfo));\n\t\t}\n\t\telse if (advice instanceof DynamicIntroductionAdvice) {\n\t\t\t// We need an IntroductionAdvisor for this kind of introduction.\n\t\t\tthrow new AopConfigException(\"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor\");\n\t\t}\n\t\telse {\n\t\t\taddAdvisor(pos, new DefaultPointcutAdvisor(advice));\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean removeAdvice(Advice advice) throws AopConfigException {\n\t\tint index = indexOf(advice);\n\t\tif (index == -1) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tremoveAdvisor(index);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int indexOf(Advice advice) {\n\t\tAssert.notNull(advice, \"Advice must not be null\");\n\t\tfor (int i = 0; i < this.advisors.size(); i++) {\n\t\t\tAdvisor advisor = this.advisors.get(i);\n\t\t\tif (advisor.getAdvice() == advice) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Is the given advice included in any advisor within this proxy configuration?\n\t * @param advice the advice to check inclusion of\n\t * @return whether this advice instance is included\n\t */\n\tpublic boolean adviceIncluded(@Nullable Advice advice) {\n\t\tif (advice != null) {\n\t\t\tfor (Advisor advisor : this.advisors) {\n\t\t\t\tif (advisor.getAdvice() == advice) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Count advices of the given class.\n\t * @param adviceClass the advice class to check\n\t * @return the count of the interceptors of this class or subclasses\n\t */\n\tpublic int countAdvicesOfType(@Nullable Class<?> adviceClass) {\n\t\tint count = 0;\n\t\tif (adviceClass != null) {\n\t\t\tfor (Advisor advisor : this.advisors) {\n\t\t\t\tif (adviceClass.isInstance(advisor.getAdvice())) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n\t/**\n\t * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects\n\t * for the given method, based on this configuration.\n\t * @param method the proxied method\n\t * @param targetClass the target class\n\t * @return a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)\n\t */\n\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass) {\n\t\tMethodCacheKey cacheKey = new MethodCacheKey(method);\n\t\tList<Object> cached = this.methodCache.get(cacheKey);\n\t\tif (cached == null) {\n\t\t\tcached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\tthis, method, targetClass);\n\t\t\tthis.methodCache.put(cacheKey, cached);\n\t\t}\n\t\treturn cached;\n\t}\n\n\t/**\n\t * Invoked when advice has changed.\n\t */\n\tprotected void adviceChanged() {\n\t\tthis.methodCache.clear();\n\t}\n\n\t/**\n\t * Call this method on a new instance created by the no-arg constructor\n\t * to create an independent copy of the configuration from the given object.\n\t * @param other the AdvisedSupport object to copy configuration from\n\t */\n\tprotected void copyConfigurationFrom(AdvisedSupport other) {\n\t\tcopyConfigurationFrom(other, other.targetSource, new ArrayList<>(other.advisors));\n\t}\n\n\t/**\n\t * Copy the AOP configuration from the given AdvisedSupport object,\n\t * but allow substitution of a fresh TargetSource and a given interceptor chain.\n\t * @param other the AdvisedSupport object to take proxy configuration from\n\t * @param targetSource the new TargetSource\n\t * @param advisors the Advisors for the chain\n\t */\n\tprotected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors) {\n\t\tcopyFrom(other);\n\t\tthis.targetSource = targetSource;\n\t\tthis.advisorChainFactory = other.advisorChainFactory;\n\t\tthis.interfaces = new ArrayList<>(other.interfaces);\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t\t}\n\t\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\t\tthis.advisors.add(advisor);\n\t\t}\n\t\tadviceChanged();\n\t}\n\n\t/**\n\t * Build a configuration-only copy of this AdvisedSupport,\n\t * replacing the TargetSource.\n\t */\n\tAdvisedSupport getConfigurationOnlyCopy() {\n\t\tAdvisedSupport copy = new AdvisedSupport();\n\t\tcopy.copyFrom(this);\n\t\tcopy.targetSource = EmptyTargetSource.forClass(getTargetClass(), getTargetSource().isStatic());\n\t\tcopy.advisorChainFactory = this.advisorChainFactory;\n\t\tcopy.interfaces = new ArrayList<>(this.interfaces);\n\t\tcopy.advisors = new ArrayList<>(this.advisors);\n\t\treturn copy;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\t// Rely on default serialization; just initialize state after deserialization.\n\t\tois.defaultReadObject();\n\n\t\t// Initialize transient fields.\n\t\tthis.methodCache = new ConcurrentHashMap<>(32);\n\t}\n\n\t@Override\n\tpublic String toProxyConfigString() {\n\t\treturn toString();\n\t}\n\n\t/**\n\t * For debugging/diagnostic use.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(getClass().getName());\n\t\tsb.append(\": \").append(this.interfaces.size()).append(\" interfaces \");\n\t\tsb.append(ClassUtils.classNamesToString(this.interfaces)).append(\"; \");\n\t\tsb.append(this.advisors.size()).append(\" advisors \");\n\t\tsb.append(this.advisors).append(\"; \");\n\t\tsb.append(\"targetSource [\").append(this.targetSource).append(\"]; \");\n\t\tsb.append(super.toString());\n\t\treturn sb.toString();\n\t}\n\n\n\t/**\n\t * Simple wrapper class around a Method. Used as the key when\n\t * caching methods, for efficient equals and hashCode comparisons.\n\t */\n\tprivate static final class MethodCacheKey implements Comparable<MethodCacheKey> {\n\n\t\tprivate final Method method;\n\n\t\tprivate final int hashCode;\n\n\t\tpublic MethodCacheKey(Method method) {\n\t\t\tthis.method = method;\n\t\t\tthis.hashCode = method.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof MethodCacheKey methodCacheKey &&\n\t\t\t\t\tthis.method == methodCacheKey.method));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.hashCode;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.method.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(MethodCacheKey other) {\n\t\t\tint result = this.method.getName().compareTo(other.method.getName());\n\t\t\tif (result == 0) {\n\t\t\t\tresult = this.method.toString().compareTo(other.method.toString());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n}",
    "query": "Design a method that efficiently constructs an AOP proxy for a specified target object, leveraging modern configuration practices to enhance performance and maintainability without manually handling low-level proxy settings.",
    "function_signature": "public ProxyFactory createAopProxy(Object target)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.LinkedCaseInsensitiveMap#put(key,value)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public V put(String key, @Nullable V value)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic V put(String key, @Nullable V value) {\n\t\tString oldKey = this.caseInsensitiveKeys.put(convertKey(key), key);\n\t\tV oldKeyValue = null;\n\t\tif (oldKey != null && !oldKey.equals(key)) {\n\t\t\toldKeyValue = this.targetMap.remove(oldKey);\n\t\t}\n\t\tV oldValue = this.targetMap.put(key, value);\n\t\treturn (oldKeyValue != null ? oldKeyValue : oldValue);\n\t}",
    "query": "Optimize the handling of configuration properties by ensuring keys are managed without case sensitivity, improving both performance and reliability in your application's settings management.",
    "function_signature": "public V updateConfiguration(String propertyKey, @Nullable V propertyValue)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.server.<unknown>#render(name,modelAttributes)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public Mono<ServerResponse> render(String name, Object... modelAttributes)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Object... modelAttributes) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(modelAttributes)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}",
    "query": "Create a handler method that constructs server responses using a structured approach for model data, enhancing readability and maintainability.",
    "function_signature": "public Mono<ServerResponse> buildServerResponse(String template, Map<String, Object> model)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.invocation.reactive.<unknown>#scanUnsafe(key)",
    "from_version": "v6.0.9",
    "to_version": "v5.3.28",
    "type": "method",
    "signature": "public Object scanUnsafe(Attr key)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Object scanUnsafe(Attr key) {\n\t\tif (key == Attr.PREFETCH) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif (key == Attr.PARENT) {\n\t\t\treturn this.source;\n\t\t}\n\t\treturn null;\n\t}",
    "query": "Refactor the method responsible for accessing messaging attributes to improve type safety and performance, utilizing the latest recommended practices.",
    "function_signature": "public Optional<Object> retrieveAttributeSafely(Attr key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getPathMatcher()",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * Return the PathMatcher that this resource pattern resolver uses.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Implement a service method that retrieves all resources matching a given pattern, utilizing a customizable path matching strategy to handle dynamic resource selection.",
    "function_signature": "public List<Resource> getResourcesByPattern(String pattern, PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.resource.EncodedResourceResolver#readableChannel()",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "public ReadableByteChannel readableChannel()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic ReadableByteChannel readableChannel() throws IOException {\n\t\t\treturn this.encoded.readableChannel();\n\t\t}",
    "query": "Design a reactive service that serves compressed static assets to clients, ensuring efficient streaming and minimal memory footprint during the transfer.",
    "function_signature": "public Mono<Void> serveCompressedAsset(ServerWebExchange exchange, String assetPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler#setSystemLogin(systemLogin)",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "public void setSystemLogin(String systemLogin)",
    "documentation": "\t/**\n\t * Set the login for the shared \"system\" connection used to send messages to\n\t * the STOMP broker from within the application, i.e. messages not associated\n\t * with a specific client session (e.g. REST/HTTP request handling method).\n\t * <p>By default this is set to \"guest\".\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setSystemLogin(String systemLogin) {\n\t\tAssert.hasText(systemLogin, \"systemLogin must not be empty\");\n\t\tthis.systemLogin = systemLogin;\n\t}",
    "query": "Implement a feature that establishes a secure internal connection to the STOMP broker using custom authentication credentials, ensuring that system-initiated messages are sent with enhanced security.",
    "function_signature": "public void setupSecureBrokerConnection(String systemLogin)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.MethodParameter#adaptAnnotationArray(annotations)",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "protected Annotation[] adaptAnnotationArray(Annotation[] annotations)",
    "documentation": "\t/**\n\t * A template method to post-process a given annotation array before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation array as-is.\n\t * @param annotations the annotation array about to be returned\n\t * @return the post-processed annotation array (or simply the original one)\n\t * @since 4.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\n\t\treturn annotations;\n\t}",
    "query": "Create a feature that intercepts and modifies the annotations on handler method parameters, allowing dynamic alteration of metadata based on specific runtime conditions.",
    "function_signature": "protected Annotation[] customizeHandlerMethodParameterAnnotations(Annotation[] annotations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#isInvalidPath(path)",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "protected boolean isInvalidPath(String path)",
    "documentation": "\t/**\n\t * Identifies invalid resource paths. By default, rejects:\n\t * <ul>\n\t * <li>Paths that contain \"WEB-INF\" or \"META-INF\"\n\t * <li>Paths that contain \"../\" after a call to\n\t * {@link org.springframework.util.StringUtils#cleanPath}.\n\t * <li>Paths that represent a {@link org.springframework.util.ResourceUtils#isUrl\n\t * valid URL} or would represent one after the leading slash is removed.\n\t * </ul>\n\t * <p><strong>Note:</strong> this method assumes that leading, duplicate '/'\n\t * or control characters (e.g. white space) have been trimmed so that the\n\t * path starts predictably with a single '/' or does not have one.\n\t * @param path the path to validate\n\t * @return {@code true} if the path is invalid, {@code false} otherwise\n\t * @since 3.0.6\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected boolean isInvalidPath(String path) {\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path with \\\"WEB-INF\\\" or \\\"META-INF\\\": [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Path represents URL or has \\\"url:\\\" prefix: [\" + path + \"]\", -1, true));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"..\") && StringUtils.cleanPath(path).contains(\"../\")) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Path contains \\\"../\\\" after call to StringUtils#cleanPath: [\" + path + \"]\", -1, true));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Develop a method within your resource handling component that ensures any requested resource path is thoroughly validated to prevent access to sensitive directories and mitigate directory traversal attacks.",
    "function_signature": "protected boolean validateResourcePath(String path)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.nativex.<unknown>#println()",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "public IndentingWriter println()",
    "documentation": "\t\t/**\n\t\t * Write a new line.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic IndentingWriter println() {\n\t\t\tString separator = System.lineSeparator();\n\t\t\ttry {\n\t\t\t\tthis.out.write(separator.toCharArray(), 0, separator.length());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t\tthis.prependIndent = true;\n\t\t\treturn this;\n\t\t}",
    "query": "Implement a feature that outputs nested configuration settings with automatic indentation and line breaks to improve readability.",
    "function_signature": "public Writer createIndentedOutputWriter();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.listener.DefaultMessageListenerContainer#createDefaultTaskExecutor()",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "protected TaskExecutor createDefaultTaskExecutor()",
    "documentation": "\t/**\n\t * Create a default TaskExecutor. Called if no explicit TaskExecutor has been specified.\n\t * <p>The default implementation builds a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}\n\t * with the specified bean name (or the class name, if no bean name specified) as thread name prefix.\n\t * @see org.springframework.core.task.SimpleAsyncTaskExecutor#SimpleAsyncTaskExecutor(String)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected TaskExecutor createDefaultTaskExecutor() {\n\t\tString beanName = getBeanName();\n\t\tString threadNamePrefix = (beanName != null ? beanName + \"-\" : DEFAULT_THREAD_NAME_PREFIX);\n\t\treturn new SimpleAsyncTaskExecutor(threadNamePrefix);\n\t}",
    "query": "Design a message listener container that efficiently manages concurrent JMS message processing by customizing the thread execution strategy to include identifiable thread naming for easier monitoring and debugging.",
    "function_signature": "@Override\nprotected TaskExecutor initializeCustomTaskExecutor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.view.ContentNegotiatingViewResolver#initServletContext(servletContext)",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "protected void initServletContext(ServletContext servletContext)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void initServletContext(ServletContext servletContext) {\n\t\tCollection<ViewResolver> matchingBeans =\n\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();\n\t\tif (this.viewResolvers == null) {\n\t\t\tthis.viewResolvers = new ArrayList<>(matchingBeans.size());\n\t\t\tfor (ViewResolver viewResolver : matchingBeans) {\n\t\t\t\tif (this != viewResolver) {\n\t\t\t\t\tthis.viewResolvers.add(viewResolver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < this.viewResolvers.size(); i++) {\n\t\t\t\tViewResolver vr = this.viewResolvers.get(i);\n\t\t\t\tif (matchingBeans.contains(vr)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString name = vr.getClass().getName() + i;\n\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name);\n\t\t\t}\n\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(this.viewResolvers);\n\t\tthis.cnmFactoryBean.setServletContext(servletContext);\n\t}",
    "query": "Implement a feature in a Spring MVC application that dynamically selects the appropriate view resolver based on the client's request content type, ensuring seamless integration with multiple existing view resolvers during servlet initialization.",
    "function_signature": "protected void configureViewResolvers(ServletContext servletContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor#invokeInitMethods(target,beanName)",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "public void invokeInitMethods(Object target, String beanName)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void invokeInitMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleMethod> checkedInitMethods = this.checkedInitMethods;\n\t\t\tCollection<LifecycleMethod> initMethodsToIterate =\n\t\t\t\t\t(checkedInitMethods != null ? checkedInitMethods : this.initMethods);\n\t\t\tif (!initMethodsToIterate.isEmpty()) {\n\t\t\t\tfor (LifecycleMethod lifecycleMethod : initMethodsToIterate) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking init method on bean '\" + beanName + \"': \" + lifecycleMethod.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\tlifecycleMethod.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a Spring component that automatically triggers custom initialization procedures for beans immediately after their creation, ensuring that any necessary setup logic is executed without manual intervention.",
    "function_signature": "public void initializeBeanLifecycle(Object beanInstance, String identifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.jta.JtaTransactionManager#setTransactionSynchronizationRegistry(transactionSynchronizationRegistry)",
    "from_version": "v5.3.29",
    "to_version": "v6.0.11",
    "type": "method",
    "signature": "public void setTransactionSynchronizationRegistry(@Nullable TransactionSynchronizationRegistry transactionSynchronizationRegistry)",
    "documentation": "\t/**\n\t * Set the JTA 1.1 TransactionSynchronizationRegistry to use as direct reference.\n\t * <p>A TransactionSynchronizationRegistry allows for interposed registration\n\t * of transaction synchronizations, as an alternative to the regular registration\n\t * methods on the JTA TransactionManager API. Also, it is an official part of the\n\t * Jakarta EE platform, in contrast to the JTA TransactionManager itself.\n\t * <p>Note that the TransactionSynchronizationRegistry will be autodetected in JNDI and\n\t * also from the UserTransaction/TransactionManager object if implemented there as well.\n\t * @see #setTransactionSynchronizationRegistryName\n\t * @see #setAutodetectTransactionSynchronizationRegistry\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setTransactionSynchronizationRegistry(@Nullable TransactionSynchronizationRegistry transactionSynchronizationRegistry) {\n\t\tthis.transactionSynchronizationRegistry = transactionSynchronizationRegistry;\n\t}",
    "query": "Design a transaction management component that allows for advanced synchronization of transactional resources, ensuring compatibility with Jakarta EE standards and enabling seamless integration with external transaction synchronization registries.",
    "function_signature": "public void configureAdvancedTransactionSynchronization(TransactionSynchronizationRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.r2dbc.connection.TransactionAwareConnectionFactoryProxy#invoke(proxy,method,args)",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isObjectMethod(method)) {\n\t\t\t\tif (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\t\treturn proxyToString(proxy);\n\t\t\t\t}\n\t\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\tif (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\tcase \"unwrap\" -> this.connection;\n\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\tcase \"close\" -> ConnectionFactoryUtils.doReleaseConnection(this.connection, this.targetConnectionFactory)\n\t\t\t\t\t\t\t.doOnSubscribe(n -> this.closed = true);\n\t\t\t\tcase \"isClosed\" -> this.closed;\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (this.closed) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Connection handle already closed\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.connection, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}",
    "query": "Refactor the reactive database connection handling to ensure transactional integrity and optimal performance, utilizing the latest best practices in Spring R2DBC.",
    "function_signature": "public Mono<Void> configureReactiveTransactionSupport(ConnectionFactory connectionFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.r2dbc.connection.SingleConnectionFactory#isSuppressClose()",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "protected boolean isSuppressClose()",
    "documentation": "\t/**\n\t * Return whether the returned {@link Connection} will be a close-suppressing proxy\n\t * or the physical {@code Connection}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected boolean isSuppressClose() {\n\t\treturn this.suppressClose;\n\t}",
    "query": "Develop a connection factory for R2DBC that ensures all database connections are reliably closed, enhancing resource management and application stability in reactive environments.",
    "function_signature": "public class ReliableConnectionFactory extends AbstractConnectionFactory {\n    // Implementation details\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#on(controllerType)",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public T on(Class<T> controllerType)",
    "documentation": "\t/**\n\t * Return a \"mock\" controller instance. When an {@code @RequestMapping} method\n\t * on the controller is invoked, the supplied argument values are remembered\n\t * and the result can then be used to create a {@code UriComponentsBuilder}\n\t * via {@link #fromMethodCall(Object)}.\n\t * <p>Note that this is a shorthand version of {@link #controller(Class)} intended\n\t * for inline use (with a static import), for example:\n\t * <pre class=\"code\">\n\t * MvcUriComponentsBuilder.fromMethodCall(on(FooController.class).getFoo(1)).build();\n\t * </pre>\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the target controller\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static <T> T on(Class<T> controllerType) {\n\t\treturn controller(controllerType);\n\t}",
    "query": "Design a method that generates a URI for a specific controller's operation, enhancing performance and ensuring type safety.",
    "function_signature": "public <T> UriComponentsBuilder controller(Class<T> controllerType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.DataBinder#getTargetType()",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public ResolvableType getTargetType()",
    "documentation": "\t/**\n\t * Return the {@link #setTargetType configured} type for the target object.\n\t * @since 6.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic ResolvableType getTargetType() {\n\t\treturn this.targetType;\n\t}",
    "query": "Enhance the data binding process by retrieving the target object's type in a manner that ensures type safety and improves performance.",
    "function_signature": "public Class<?> determineBindingTargetType()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.xml.<unknown>#nextTag()",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public XMLEvent nextTag()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic XMLEvent nextTag() throws XMLStreamException {\n\t\tcheckIfClosed();\n\n\t\twhile (true) {\n\t\t\tXMLEvent event = nextEvent();\n\t\t\tswitch (event.getEventType()) {\n\t\t\t\tcase XMLStreamConstants.START_ELEMENT, XMLStreamConstants.END_ELEMENT -> {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t\tcase XMLStreamConstants.END_DOCUMENT -> {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcase XMLStreamConstants.SPACE, XMLStreamConstants.COMMENT, XMLStreamConstants.PROCESSING_INSTRUCTION -> {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcase XMLStreamConstants.CDATA, XMLStreamConstants.CHARACTERS -> {\n\t\t\t\t\tif (!event.asCharacters().isWhiteSpace()) {\n\t\t\t\t\t\tthrow new XMLStreamException(\n\t\t\t\t\t\t\t\t\"Non-ignorable whitespace CDATA or CHARACTERS event: \" + event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdefault -> throw new XMLStreamException(\"Expected START_ELEMENT or END_ELEMENT: \" + event);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a method that efficiently retrieves the next meaningful XML element, ensuring robust parsing while avoiding unnecessary processing overhead.",
    "function_signature": "public XMLEvent retrieveNextElement() throws XMLStreamException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.HandlerMethod#getBridgedMethod()",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "protected Method getBridgedMethod()",
    "documentation": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}",
    "query": "Develop a feature that accurately retrieves the original implementation of controller methods, ensuring that any synthetic bridge methods generated by the compiler are transparently handled to maintain consistent annotation processing.",
    "function_signature": "protected Method obtainEffectiveMethod(HandlerMethod handlerMethod)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#toByteBuffer(srcPos,dest,destPos,length)",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}",
    "query": "Develop a method that efficiently extracts a portion of data and encapsulates it within a `ByteBuffer`, ensuring optimal performance and enhanced memory management.",
    "function_signature": "public ByteBuffer extractDataSegment(int sourcePosition, int length);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty4HeadersAdapter#remove(key)",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public List<String> remove(Object key)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic List<String> remove(Object key) {\n\t\tif (key instanceof String headerName) {\n\t\t\tList<String> previousValues = this.headers.getAll(headerName);\n\t\t\tthis.headers.remove(headerName);\n\t\t\treturn previousValues;\n\t\t}\n\t\treturn null;\n\t}",
    "query": "Refactor the header management to utilize a method that ensures type safety and enhances performance when removing headers.",
    "function_signature": "public List<String> removeHeader(String key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#method(method)",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public RequestBodyUriSpec method(HttpMethod method)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic RequestBodyUriSpec method(HttpMethod method) {\n\t\tAssert.notNull(method, \"HttpMethod must not be null\");\n\t\treturn methodInternal(method);\n\t}",
    "query": "Design a REST client operation that enhances type safety and optimizes performance when specifying HTTP methods for requests.",
    "function_signature": "public RequestBodyUriSpec executeRequest(HttpMethod httpMethod)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.DefaultLifecycleProcessor#registerResource()",
    "from_version": "v6.1.3",
    "to_version": "v6.0.16",
    "type": "method",
    "signature": "public Object registerResource()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Object registerResource() {\n\t\t\tlogger.debug(\"Registering JVM checkpoint/restore callback for Spring-managed lifecycle beans\");\n\t\t\tCracResourceAdapter resourceAdapter = new CracResourceAdapter();\n\t\t\torg.crac.Core.getGlobalContext().register(resourceAdapter);\n\t\t\treturn resourceAdapter;\n\t\t}",
    "query": "Design a method to seamlessly integrate Spring-managed lifecycle beans with JVM checkpoint and restore functionality, optimizing for enhanced performance and reliability.",
    "function_signature": "public Object integrateLifecycleResources()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Create a mechanism that appends user-specific data and global settings to the response model automatically after any controller method is executed, eliminating the need to add this logic within each controller individually.",
    "function_signature": "public void appendGlobalAndUserData(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Develop a Spring component that initializes the subscription registry for a messaging system, handling various subscriber load scenarios to ensure reliable performance during scalability tests.",
    "function_signature": "public void initializeSubscriptionRegistry(ServerState serverState);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Develop a service method that efficiently batches and processes multiple client subscription and unsubscription requests in a WebSocket-based messaging application, ensuring optimal performance and resource management during high-load scenarios.",
    "function_signature": "public void handleBatchSubscriptionRequests(RequestBatch requestBatch)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Create a feature in your Spring application that introspects a given interceptor to display all the URL patterns it is associated with, enhancing transparency for debugging purposes.",
    "function_signature": "public void displayInterceptorUrlPatterns(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Create a Spring service responsible for assigning thread-safe, sequential identifiers to real-time chat messages, ensuring each message can be uniquely tracked across multiple client sessions.",
    "function_signature": "public int generateUniqueMessageId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Develop an interceptor that determines its applicability by analyzing the full HTTP request context, enabling more precise and context-aware request handling.",
    "function_signature": "public boolean shouldApplyInterceptor(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Design a service that gathers all current WebSocket connection identifiers to enable sending targeted notifications to each connected client.",
    "function_signature": "public String[] retrieveCurrentSessionIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int sessions;",
    "query": "Design a feature for a real-time collaborative application that displays the number of users currently connected via WebSockets, ensuring efficient tracking and retrieval of active session counts.",
    "function_signature": "public int retrieveCurrentActiveWebSocketSessions()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "How can you enhance a real-time collaboration tool to allow users to dynamically subscribe to various project updates based on their active sessions and specific interests?",
    "function_signature": "public void updateUserSubscriptions(String sessionId, String projectTopic)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.2.14.RELEASE",
    "to_version": "v5.3.7",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design a Spring interceptor that selectively processes incoming HTTP requests by evaluating intricate URL patterns, ensuring high flexibility and maintainability in route handling.",
    "function_signature": "public void configurePathMatching(CustomPathConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.apache.commons.logging.logger",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "field",
    "signature": "protected T logger",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tprotected final transient T logger;",
    "query": "Enhance the logging strategy within your application service to improve performance and ensure thread safety by adopting contemporary logging practices.",
    "function_signature": "public void configureLogger()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.AbstractNestablePropertyAccessor#isReadableProperty(propertyName)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public boolean isReadableProperty(String propertyName)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isReadableProperty(String propertyName) {\n\t\ttry {\n\t\t\tPropertyHandler ph = getPropertyHandler(propertyName);\n\t\t\tif (ph != null) {\n\t\t\t\treturn ph.isReadable();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Maybe an indexed/mapped property...\n\t\t\t\tgetPropertyValue(propertyName);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (InvalidPropertyException ex) {\n\t\t\t// Cannot be evaluated, so can't be readable.\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a utility that determines the accessibility of a specified property, prioritizing performance and ensuring thread-safe operations within a Spring application context.",
    "function_signature": "public boolean hasAccessibleProperty(String propertyName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.r2dbc.core.<unknown>#map(Readable,mappingFunction)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public FetchSpec<R> map(Function<? super Readable, R> mappingFunction)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(Function<? super Readable, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}",
    "query": "Develop a method that executes a reactive database query and transforms each resulting row into a specific type using a modern, efficient mapping approach to enhance performance and maintain type safety.",
    "function_signature": "public <T> ReactiveQueryResult<T> executeAndTransform(String sql, Function<Row, T> rowMapper);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractHttpMessageConverter#setSupportedMediaTypes(supportedMediaTypes)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public void setSupportedMediaTypes(List<MediaType> supportedMediaTypes)",
    "documentation": "\t/**\n\t * Set the list of {@link MediaType} objects supported by this converter.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setSupportedMediaTypes(List<MediaType> supportedMediaTypes) {\n\t\tAssert.notEmpty(supportedMediaTypes, \"MediaType List must not be empty\");\n\t\tthis.supportedMediaTypes = Collections.unmodifiableList(new ArrayList<>(supportedMediaTypes));\n\t}",
    "query": "Create a custom HTTP message converter that initializes supported media types upon instantiation to ensure immutability and enhance performance.",
    "function_signature": "public CustomHttpMessageConverter(List<MediaType> supportedMediaTypes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectivePropertyAccessor#findSetterForProperty(propertyName,clazz,mustBeStatic)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "protected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "documentation": "\t/**\n\t * Find a setter method for the specified property.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\treturn findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"set\", clazz, mustBeStatic, 1, ANY_TYPES);\n\t}",
    "query": "Develop a utility that identifies the appropriate setter method for a specified property within a class. Ensure the solution emphasizes enhanced performance and thread safety by adopting the latest best practices.",
    "function_signature": "protected Optional<Method> locateSetter(String propertyName, Class<?> targetClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.APPLICATION_GRAPHQL",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "field",
    "signature": "public MediaType APPLICATION_GRAPHQL",
    "documentation": "\t/**\n\t * Public constant media type for {@code application/graphql+json}.\n\t * @since 5.3.19\n\t * @see <a href=\"https://github.com/graphql/graphql-over-http\">GraphQL over HTTP spec</a>\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final MediaType APPLICATION_GRAPHQL;",
    "query": "Optimize the configuration of your GraphQL endpoint to ensure better compatibility and enhanced data handling. Implement a method that sets the appropriate media type for GraphQL requests, taking advantage of the latest standards to improve performance and maintainability.",
    "function_signature": "public void configureGraphqlMediaType(MediaType mediaType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.aspectj.AspectJExpressionPointcut#matches(method,targetClass,hasIntroductions)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tobtainPointcutExpression();\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Special handling for this, target, @this, @target, @annotation\n\t\t// in Spring - we can optimize since we know we have exactly this class,\n\t\t// and there will never be matching subclass at runtime.\n\t\tif (shadowMatch.alwaysMatches()) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (shadowMatch.neverMatches()) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// the maybe case\n\t\t\tif (hasIntroductions) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// A match test returned maybe - if there are any subtype sensitive variables\n\t\t\t// involved in the test (this, target, at_this, at_target, at_annotation) then\n\t\t\t// we say this is not a match as in Spring there will never be a different\n\t\t\t// runtime subtype.\n\t\t\tRuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);\n\t\t\treturn (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));\n\t\t}\n\t}",
    "query": "Optimize the aspect-oriented matching logic to enhance performance and ensure type safety when determining if a method applies to a specific target class, especially in scenarios involving introductions.",
    "function_signature": "public boolean isApplicable(Method method, Class<?> targetClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ResponseCookie#isSecure()",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public boolean isSecure()",
    "documentation": "\t/**\n\t * Return {@code true} if the cookie has the \"Secure\" attribute.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isSecure() {\n\t\treturn this.secure;\n\t}",
    "query": "Improve the handling of cookie security attributes by implementing a modern approach that enhances performance and ensures safer operations within your application.",
    "function_signature": "public boolean assessCookieSecurity(ResponseCookie cookie)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#updateAfterRemovedSubscription(sessionId,subscription)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public void updateAfterRemovedSubscription(String sessionId, Subscription subscription)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void updateAfterRemovedSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tString subscriptionId = subscription.getId();\n\t\t\t\tthis.destinationCache.forEach((destination, sessionIdToSubscriptionIds) -> {\n\t\t\t\t\tList<String> subscriptionIds = sessionIdToSubscriptionIds.get(sessionId);\n\t\t\t\t\tif (subscriptionIds != null && subscriptionIds.contains(subscriptionId)) {\n\t\t\t\t\t\tremoveInternal(destination, sessionId, subscriptionId);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveInternal(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}",
    "query": "Develop a method to efficiently handle the cleanup of client subscriptions, ensuring optimal performance and thread safety by leveraging the latest framework enhancements for subscription management.",
    "function_signature": "public void manageSubscriptionCleanup(String sessionId, SubscriptionDetails subscriptionDetails)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.EntityManagerFactoryUtils#getTransactionalEntityManager(emf)",
    "from_version": "v6.0.0-M6",
    "to_version": "v5.3.23",
    "type": "method",
    "signature": "public EntityManager getTransactionalEntityManager(EntityManagerFactory emf)",
    "documentation": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Note: Will return {@code null} if no thread-bound EntityManager found!\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws DataAccessResourceFailureException if the EntityManager couldn't be obtained\n\t * @see JpaTransactionManager\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static EntityManager getTransactionalEntityManager(EntityManagerFactory emf)",
    "query": "Create a utility method that efficiently retrieves the active JPA `EntityManager`, ensuring seamless integration with transaction management and handling cases where an `EntityManager` might not be bound to the current context.",
    "function_signature": "public EntityManager acquireActiveEntityManager(EntityManagerFactory emf)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.<unknown>#values()",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "public Collection<List<String>> values()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Collection<List<String>> values() {\n\t\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\t\tforEach((key, value) -> result.add(value));\n\t\t\treturn result;\n\t\t}",
    "query": "Design a Spring service method that aggregates all values from incoming HTTP headers and performs a bulk validation check on them. Ensure the method efficiently handles multiple header values without iterating manually over each header entry.",
    "function_signature": "public Collection<List<String>> aggregateAndValidateHeaderValues(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#segment()",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "public String segment()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String segment() {\n\t\t\tString result = this.segment;\n\t\t\tif (result == null) {\n\t\t\t\tAssert.state(this.builder != null, \"String nor StringBuilder available\");\n\t\t\t\tresult = this.builder.toString();\n\t\t\t\tthis.segment = result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}",
    "query": "Develop a utility function that efficiently retrieves the current URL segment, ensuring thread safety and minimizing memory consumption in high-concurrency scenarios.",
    "function_signature": "public Optional<String> fetchCurrentSegment()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange#checkNotModified(eTag,lastModified)",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "public boolean checkNotModified(@Nullable String eTag, Instant lastModified)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}",
    "query": "Enhance the server's ability to handle conditional requests by validating cache headers efficiently, ensuring better performance and reliability in your web exchange handling.",
    "function_signature": "public boolean validateCacheHeaders(@Nullable String eTag, Instant lastModified, HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#configureHandlerExceptionResolvers(exceptionResolvers)",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "protected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tprotected void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {\n\t\t\tif (handlerExceptionResolvers == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver resolver : handlerExceptionResolvers) {\n\t\t\t\tif (resolver instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\t\tApplicationContext applicationContext = getApplicationContext();\n\t\t\t\t\tif (applicationContext != null) {\n\t\t\t\t\t\tapplicationContextAware.setApplicationContext(applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resolver instanceof InitializingBean initializingBean) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failure from afterPropertiesSet\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texceptionResolvers.add(resolver);\n\t\t\t}\n\t\t}",
    "query": "Enhance the setup of your MockMvc instance to efficiently manage exception resolvers, ensuring optimal performance and seamless integration with the application context.",
    "function_signature": "protected void optimizeExceptionHandling(List<HandlerExceptionResolver> resolvers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#read(type,inputMessage,Map<String,hints)",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "public Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic final Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)",
    "query": "Create a custom HTTP message converter that efficiently processes incoming Kotlin serialization data, ensuring type safety and optimal performance without relying on additional metadata hints.",
    "function_signature": "public Object deserialize(ResolvableType type, HttpInputMessage inputMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#getNestedTypeIfNeeded(type)",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "protected ResolvableType getNestedTypeIfNeeded(ResolvableType type)",
    "documentation": "\t/**\n\t * Return the generic type of the {@code returnType} (or of the nested type\n\t * if it is an {@link HttpEntity} or/and an {@link Optional}).\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected ResolvableType getNestedTypeIfNeeded(ResolvableType type) {\n\t\tResolvableType genericType = type;\n\t\tif (Optional.class.isAssignableFrom(genericType.toClass())) {\n\t\t\tgenericType = genericType.getNested(2);\n\t\t}\n\t\tif (HttpEntity.class.isAssignableFrom(genericType.toClass())) {\n\t\t\tgenericType = genericType.getNested(2);\n\t\t}\n\t\treturn genericType;\n\t}",
    "query": "Create a utility function that accurately identifies the underlying generic type from a provided `ResolvableType`. The implementation should efficiently handle scenarios where the type is encapsulated within containers like `Optional` or `HttpEntity`, ensuring optimal performance and type safety.",
    "function_signature": "protected ResolvableType determineGenericType(ResolvableType type)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.MockMultipartMvcRequestBuilder",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "class",
    "signature": "public class MockMultipartMvcRequestBuilder",
    "documentation": "\t/**\n\t * A builder for {@link MockMultipartHttpServletRequest} that supports AssertJ.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic final class MockMultipartMvcRequestBuilder",
    "query": "Design a utility method that constructs a mock multipart HTTP request optimized for AssertJ assertions, enhancing performance and usability compared to earlier implementations.",
    "function_signature": "public MockMultipartHttpServletRequestBuilder buildOptimizedMultipartRequest()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "class",
    "signature": "public class DefaultServerWebExchange",
    "documentation": "/**\n * Default implementation of {@link ServerWebExchange}.\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 5.0\n */",
    "changetype": "deprecated",
    "source_code": "public class DefaultServerWebExchange implements ServerWebExchange {\n\n\tprivate static final Set<HttpMethod> SAFE_METHODS = Set.of(HttpMethod.GET, HttpMethod.HEAD);\n\n\tprivate static final ResolvableType FORM_DATA_TYPE =\n\t\t\tResolvableType.forClassWithGenerics(MultiValueMap.class, String.class, String.class);\n\n\tprivate static final ResolvableType MULTIPART_DATA_TYPE = ResolvableType.forClassWithGenerics(\n\t\t\tMultiValueMap.class, String.class, Part.class);\n\n\tprivate static final Mono<MultiValueMap<String, String>> EMPTY_FORM_DATA =\n\t\t\tMono.just(CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<String, String>(0)))\n\t\t\t\t\t.cache();\n\n\tprivate static final Mono<MultiValueMap<String, Part>> EMPTY_MULTIPART_DATA =\n\t\t\tMono.just(CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<String, Part>(0)))\n\t\t\t\t\t.cache();\n\n\n\tprivate final ServerHttpRequest request;\n\n\tprivate final ServerHttpResponse response;\n\n\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<>();\n\n\tprivate final Mono<WebSession> sessionMono;\n\n\tprivate final LocaleContextResolver localeContextResolver;\n\n\tprivate final Mono<MultiValueMap<String, String>> formDataMono;\n\n\tprivate final Mono<MultiValueMap<String, Part>> multipartDataMono;\n\n\tprivate volatile boolean multipartRead = false;\n\n\t@Nullable\n\tprivate final ApplicationContext applicationContext;\n\n\tprivate volatile boolean notModified;\n\n\tprivate Function<String, String> urlTransformer = url -> url;\n\n\t@Nullable\n\tprivate Object logId;\n\n\tprivate String logPrefix = \"\";\n\n\n\tpublic DefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,\n\t\t\tLocaleContextResolver localeContextResolver) {\n\n\t\tthis(request, response, sessionManager, codecConfigurer, localeContextResolver, null);\n\t}\n\n\tDefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSessionManager sessionManager, ServerCodecConfigurer codecConfigurer,\n\t\t\tLocaleContextResolver localeContextResolver, @Nullable ApplicationContext applicationContext) {\n\n\t\tAssert.notNull(request, \"'request' is required\");\n\t\tAssert.notNull(response, \"'response' is required\");\n\t\tAssert.notNull(sessionManager, \"'sessionManager' is required\");\n\t\tAssert.notNull(codecConfigurer, \"'codecConfigurer' is required\");\n\t\tAssert.notNull(localeContextResolver, \"'localeContextResolver' is required\");\n\n\t\t// Initialize before first call to getLogPrefix()\n\t\tthis.attributes.put(ServerWebExchange.LOG_ID_ATTRIBUTE, request.getId());\n\n\t\tthis.request = request;\n\t\tthis.response = response;\n\t\tthis.sessionMono = sessionManager.getSession(this).cache();\n\t\tthis.localeContextResolver = localeContextResolver;\n\t\tthis.formDataMono = initFormData(request, codecConfigurer, getLogPrefix());\n\t\tthis.multipartDataMono = initMultipartData(codecConfigurer, getLogPrefix());\n\t\tthis.applicationContext = applicationContext;\n\n\t\tif (request instanceof AbstractServerHttpRequest abstractServerHttpRequest) {\n\t\t\tabstractServerHttpRequest.setAttributesSupplier(() -> this.attributes);\n\t\t}\n\t}\n\n\tprivate static Mono<MultiValueMap<String, String>> initFormData(ServerHttpRequest request,\n\t\t\tServerCodecConfigurer configurer, String logPrefix) {\n\n\t\tMediaType contentType = getContentType(request);\n\t\tif (contentType == null || !contentType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\treturn EMPTY_FORM_DATA;\n\t\t}\n\n\t\tHttpMessageReader<MultiValueMap<String, String>> reader = getReader(configurer, contentType, FORM_DATA_TYPE);\n\t\tif (reader == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"No HttpMessageReader for \" + contentType));\n\t\t}\n\n\t\treturn reader\n\t\t\t\t.readMono(FORM_DATA_TYPE, request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))\n\t\t\t\t.switchIfEmpty(EMPTY_FORM_DATA)\n\t\t\t\t.cache();\n\t}\n\n\tprivate Mono<MultiValueMap<String, Part>> initMultipartData(ServerCodecConfigurer configurer, String logPrefix) {\n\n\t\tMediaType contentType = getContentType(this.request);\n\t\tif (contentType == null || !contentType.getType().equalsIgnoreCase(\"multipart\")) {\n\t\t\treturn EMPTY_MULTIPART_DATA;\n\t\t}\n\n\t\tHttpMessageReader<MultiValueMap<String, Part>> reader = getReader(configurer, contentType, MULTIPART_DATA_TYPE);\n\t\tif (reader == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"No HttpMessageReader for \" + contentType));\n\t\t}\n\n\t\treturn reader\n\t\t\t\t.readMono(MULTIPART_DATA_TYPE, this.request, Hints.from(Hints.LOG_PREFIX_HINT, logPrefix))\n\t\t\t\t.doOnNext(ignored -> this.multipartRead = true)\n\t\t\t\t.switchIfEmpty(EMPTY_MULTIPART_DATA)\n\t\t\t\t.cache();\n\t}\n\n\t@Nullable\n\tprivate static MediaType getContentType(ServerHttpRequest request) {\n\t\tMediaType contentType = null;\n\t\ttry {\n\t\t\tcontentType = request.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// ignore\n\t\t}\n\t\treturn contentType;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate static <E> HttpMessageReader<E> getReader(\n\t\t\tServerCodecConfigurer configurer, MediaType contentType, ResolvableType targetType) {\n\n\t\tHttpMessageReader<E> result = null;\n\t\tfor (HttpMessageReader<?> reader : configurer.getReaders()) {\n\t\t\tif (reader.canRead(targetType, contentType)) {\n\t\t\t\tresult = (HttpMessageReader<E>) reader;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t@Override\n\tpublic ServerHttpRequest getRequest() {\n\t\treturn this.request;\n\t}\n\n\tprivate HttpHeaders getRequestHeaders() {\n\t\treturn getRequest().getHeaders();\n\t}\n\n\t@Override\n\tpublic ServerHttpResponse getResponse() {\n\t\treturn this.response;\n\t}\n\n\tprivate HttpHeaders getResponseHeaders() {\n\t\treturn getResponse().getHeaders();\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\t@Override\n\tpublic Mono<WebSession> getSession() {\n\t\treturn this.sessionMono;\n\t}\n\n\t@Override\n\tpublic <T extends Principal> Mono<T> getPrincipal() {\n\t\treturn Mono.empty();\n\t}\n\n\t@Override\n\tpublic Mono<MultiValueMap<String, String>> getFormData() {\n\t\treturn this.formDataMono;\n\t}\n\n\t@Override\n\tpublic Mono<MultiValueMap<String, Part>> getMultipartData() {\n\t\treturn this.multipartDataMono;\n\t}\n\n\t@Override\n\tpublic Mono<Void> cleanupMultipart() {\n\t\treturn Mono.defer(() -> {\n\t\t\tif (this.multipartRead) {\n\t\t\t\treturn Mono.usingWhen(getMultipartData().onErrorComplete().map(this::collectParts),\n\t\t\t\t\t\tparts -> Mono.empty(),\n\t\t\t\t\t\tparts -> Flux.fromIterable(parts).flatMap(part -> part.delete().onErrorComplete())\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate List<Part> collectParts(MultiValueMap<String, Part> multipartData) {\n\t\treturn multipartData.values().stream().flatMap(List::stream).collect(Collectors.toList());\n\t}\n\n\t@Override\n\tpublic LocaleContext getLocaleContext() {\n\t\treturn this.localeContextResolver.resolveLocaleContext(this);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}\n\n\t@Override\n\tpublic boolean isNotModified() {\n\t\treturn this.notModified;\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(Instant lastModified) {\n\t\treturn checkNotModified(null, lastModified);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(String etag) {\n\t\treturn checkNotModified(etag, Instant.MIN);\n\t}\n\n\t@Override\n\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}\n\n\tprivate boolean validateIfMatch(@Nullable String eTag) {\n\t\ttry {\n\t\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList<String> values = getRequestHeaders().getOrEmpty(HttpHeaders.IF_MATCH);\n\t\t\tif (CollectionUtils.isEmpty(values)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.notModified = matchRequestedETags(values, eTag, false);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean matchRequestedETags(List<String> requestedETagValues, @Nullable String tag, boolean weakCompare) {\n\t\tif (StringUtils.hasLength(tag)) {\n\t\t\tETag eTag = ETag.create(tag);\n\t\t\tboolean isNotSafeMethod = !SAFE_METHODS.contains(getRequest().getMethod());\n\t\t\tfor (String eTagValue : requestedETagValues) {\n\t\t\t\tfor (ETag requestedETag : ETag.parse(eTagValue)) {\n\t\t\t\t\t// only consider \"lost updates\" checks for unsafe HTTP methods\n\t\t\t\t\tif (requestedETag.isWildcard() && isNotSafeMethod) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (requestedETag.compare(eTag, !weakCompare)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void updateResponseStateChanging(@Nullable String eTag, Instant lastModified) {\n\t\tif (this.notModified) {\n\t\t\tgetResponse().setStatusCode(HttpStatus.PRECONDITION_FAILED);\n\t\t}\n\t\telse {\n\t\t\taddCachingResponseHeaders(eTag, lastModified);\n\t\t}\n\t}\n\n\tprivate boolean validateIfNoneMatch(@Nullable String eTag) {\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(getRequestHeaders().get(HttpHeaders.IF_NONE_MATCH))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList<String> values = getRequestHeaders().getOrEmpty(HttpHeaders.IF_NONE_MATCH);\n\t\t\tthis.notModified = !matchRequestedETags(values, eTag, true);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void updateResponseIdempotent(@Nullable String eTag, Instant lastModified) {\n\t\tboolean isSafeMethod = SAFE_METHODS.contains(getRequest().getMethod());\n\t\tif (this.notModified) {\n\t\t\tgetResponse().setStatusCode(isSafeMethod ?\n\t\t\t\t\tHttpStatus.NOT_MODIFIED : HttpStatus.PRECONDITION_FAILED);\n\t\t}\n\t\taddCachingResponseHeaders(eTag, lastModified);\n\t}\n\n\tprivate void addCachingResponseHeaders(@Nullable String tag, Instant lastModified) {\n\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n\t\t\tif (lastModified.isAfter(Instant.EPOCH) && getResponseHeaders().getLastModified() == -1) {\n\t\t\t\tgetResponseHeaders().setLastModified(lastModified.toEpochMilli());\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(tag) && getResponseHeaders().getETag() == null) {\n\t\t\t\tgetResponseHeaders().setETag(tag);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean validateIfUnmodifiedSince(Instant lastModified) {\n\t\tif (lastModified.isBefore(Instant.EPOCH)) {\n\t\t\treturn false;\n\t\t}\n\t\tlong ifUnmodifiedSince = getRequestHeaders().getIfUnmodifiedSince();\n\t\tif (ifUnmodifiedSince == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tInstant sinceInstant = Instant.ofEpochMilli(ifUnmodifiedSince);\n\t\tthis.notModified = sinceInstant.isBefore(lastModified.truncatedTo(ChronoUnit.SECONDS));\n\t\treturn true;\n\t}\n\n\tprivate void validateIfModifiedSince(Instant lastModified) {\n\t\tif (lastModified.isBefore(Instant.EPOCH)) {\n\t\t\treturn;\n\t\t}\n\t\tlong ifModifiedSince = getRequestHeaders().getIfModifiedSince();\n\t\tif (ifModifiedSince != -1) {\n\t\t\t// We will perform this validation...\n\t\t\tthis.notModified = ChronoUnit.SECONDS.between(lastModified, Instant.ofEpochMilli(ifModifiedSince)) >= 0;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String transformUrl(String url) {\n\t\treturn this.urlTransformer.apply(url);\n\t}\n\n\t@Override\n\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}\n\n\t@Override\n\tpublic String getLogPrefix() {\n\t\tObject value = getAttribute(LOG_ID_ATTRIBUTE);\n\t\tif (this.logId != value) {\n\t\t\tthis.logId = value;\n\t\t\tthis.logPrefix = value != null ? \"[\" + value + \"] \" : \"\";\n\t\t}\n\t\treturn this.logPrefix;\n\t}\n\n}",
    "query": "Craft a method that establishes a server web exchange with enhanced thread safety and optimized data handling, leveraging the latest configuration utilities for session and locale management.",
    "function_signature": "public ServerWebExchange createSecureWebExchange(ServerHttpRequest request, ServerHttpResponse response, WebSessionManager sessionManager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#get(timeout,unit)",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}",
    "query": "Implement a method to obtain the outcome of a scheduled operation, leveraging a contemporary time abstraction to enhance clarity and reduce potential errors associated with time unit management.",
    "function_signature": "public V fetchResult(Duration timeout) throws InterruptedException, ExecutionException, TimeoutException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.<unknown>#getDomain()",
    "from_version": "v6.2.0-RC3",
    "to_version": "v6.1.15",
    "type": "method",
    "signature": "public String getDomain()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String getDomain() {\n\t\t\treturn this.responseCookie.getDomain();\n\t\t}",
    "query": "Enhance the handling of response cookies in a reactive Spring server by implementing a method that securely retrieves the cookie's domain, ensuring improved performance and maintainability.",
    "function_signature": "public Optional<String> fetchCookieDomain(ResponseCookie responseCookie)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#contextPath(contextPath)",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public B contextPath(String contextPath)",
    "documentation": "\t/**\n\t * Specify the portion of the requestURI that represents the context path.\n\t * The context path, if specified, must match to the start of the request URI.\n\t * <p>In most cases, tests can be written by omitting the context path from\n\t * the requestURI. This is because most applications don't actually depend\n\t * on the name under which they're deployed. If specified here, the context\n\t * path must start with a \"/\" and must not end with a \"/\".\n\t * @see jakarta.servlet.http.HttpServletRequest#getContextPath()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic B contextPath(String contextPath) {\n\t\tif (StringUtils.hasText(contextPath)) {\n\t\t\tAssert.isTrue(contextPath.startsWith(\"/\"), \"Context path must start with a '/'\");\n\t\t\tAssert.isTrue(!contextPath.endsWith(\"/\"), \"Context path must not end with a '/'\");\n\t\t}\n\t\tthis.contextPath = contextPath;\n\t\treturn self();\n\t}",
    "query": "Design a utility method to construct a mock HTTP GET request for testing purposes. Ensure that the method allows specifying the request URI without manually setting additional path segments, thereby simplifying test setup and minimizing configuration errors.",
    "function_signature": "public MockHttpServletRequestBuilder buildGetRequest(String uri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterValidationResult#getResolvableErrors()",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public List<MessageSourceResolvable> getResolvableErrors()",
    "documentation": "\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, for example,\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, for example,\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}",
    "query": "Develop a utility that efficiently extracts and manages detailed validation feedback from user inputs, optimizing performance and enhancing error handling mechanisms within your application.",
    "function_signature": "public List<ValidationErrorDetail> extractValidationFeedback()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setAsyncRequestTimeout(timeout)",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout)",
    "documentation": "\t/**\n\t * Specify the timeout value for async execution.\n\t * <p>In Spring MVC Test, this value is used to determine how long to wait\n\t * for async execution to complete so that a test can verify the results\n\t * synchronously.\n\t * @param timeout the timeout value in milliseconds\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setAsyncRequestTimeout(long timeout) {\n\t\tthis.asyncRequestTimeout = timeout;\n\t\treturn this;\n\t}",
    "query": "Enhance your MockMvc tests by configuring a timeout for asynchronous operations to ensure efficient and reliable request handling.",
    "function_signature": "public RouterFunctionMockMvcBuilder withAsyncTimeout(Duration timeout)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.config.TaskExecutionOutcome",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "record",
    "signature": "public record TaskExecutionOutcome",
    "documentation": "/**\n * Outcome of a {@link Task} execution.\n *\n * @author Brian Clozel\n * @since 6.2\n * @param executionTime the instant when the task execution started, or\n * {@code null} if the task has not started\n * @param status the {@link Status} of the execution outcome\n * @param throwable the exception thrown from the task execution, if any\n */",
    "changetype": "deprecated",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\n\t}\n\n}",
    "query": "Create a method to manage the lifecycle of scheduled tasks, ensuring enhanced reliability and better error handling during execution.",
    "function_signature": "public TaskExecutionResult manageTaskLifecycle(@Nullable Instant startTime, ExecutionStatus status, @Nullable Throwable error)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#flashAttr(name,value)",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder flashAttr(String name, Object value)",
    "documentation": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn this;\n\t}",
    "query": "Design a test scenario where a redirect operation needs to carry temporary attributes between requests, ensuring that these attributes are available after the redirect.",
    "function_signature": "public MockHttpServletRequestBuilder withFlashAttribute(String name, Object value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DataBufferUtils#subscriberInputStream(publisher,demand)",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public InputStream subscriberInputStream(Publisher<T> publisher, int demand)",
    "documentation": "\t/**\n\t * Subscribe to given {@link Publisher} of {@code DataBuffer}s, and return an\n\t * {@link InputStream} to consume the byte content with.\n\t * <p>Byte buffers are stored in a queue. The {@code demand} constructor value\n\t * determines the number of buffers requested initially. When storage falls\n\t * below a {@code (demand - (demand >> 2))} limit, a request is made to refill\n\t * the queue.\n\t * <p>The {@code InputStream} terminates after an onError or onComplete signal,\n\t * and stored buffers are read. If the {@code InputStream} is closed,\n\t * the {@link Flow.Subscription} is cancelled, and stored buffers released.\n\t * @param publisher the source of {@code DataBuffer}s\n\t * @param demand the number of buffers to request initially, and buffer\n\t * internally on an ongoing basis.\n\t * @return an {@link InputStream} backed by the {@link Publisher}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static <T extends DataBuffer> InputStream subscriberInputStream(Publisher<T> publisher, int demand) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(demand > 0, \"maxBufferCount must be > 0\");\n\n\t\tSubscriberInputStream subscriber = new SubscriberInputStream(demand);\n\t\tpublisher.subscribe(subscriber);\n\t\treturn subscriber;\n\t}",
    "query": "Implement a method that efficiently converts a reactive data publisher into a stream for processing, ensuring optimal resource management and responsiveness under high-load scenarios.",
    "function_signature": "public InputStream createReactiveInputStream(Publisher<DataBuffer> dataPublisher, int initialBufferSize)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.DependencyDescriptor#forFallbackMatch()",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public DependencyDescriptor forFallbackMatch()",
    "documentation": "\t/**\n\t * Return a variant of this descriptor that is intended for a fallback match.\n\t * @since 4.0\n\t * @see #fallbackMatchAllowed()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic DependencyDescriptor forFallbackMatch() {\n\t\treturn new DependencyDescriptor(this) {\n\t\t\t@Override\n\t\t\tpublic boolean fallbackMatchAllowed() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}",
    "query": "Design a method that creates a dependency descriptor optimized for primary matches, ensuring improved performance and reliability over legacy fallback strategies.",
    "function_signature": "public DependencyDescriptor createOptimizedDependencyDescriptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#removePlaceholder(placeholder)",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public void removePlaceholder(String placeholder)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void removePlaceholder(String placeholder) {\n\t\t\tAssert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\n\t\t\tthis.visitedPlaceholders.remove(placeholder);\n\t\t}",
    "query": "Refactor your application's placeholder management to utilize a more efficient method for eliminating placeholders, ensuring enhanced performance and reliability.",
    "function_signature": "public void clearPlaceholder(String placeholder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#resolvePlaceholder(placeholderName)",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public String resolvePlaceholder(String placeholderName)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String resolvePlaceholder(String placeholderName) {\n\t\t\tString value = this.resolver.resolvePlaceholder(placeholderName);\n\t\t\tif (value != null && logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}",
    "query": "Design a method to fetch configuration placeholders efficiently, ensuring improved performance and robust logging mechanisms.",
    "function_signature": "public String obtainPlaceholderValue(String key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.DependencyDescriptor#getTypeDescriptor()",
    "from_version": "v6.2.0",
    "to_version": "v6.1.16",
    "type": "method",
    "signature": "public TypeDescriptor getTypeDescriptor()",
    "documentation": "\t/**\n\t * Build a {@link TypeDescriptor} object for the wrapped parameter/field.\n\t * @since 5.1.4\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic TypeDescriptor getTypeDescriptor() {\n\t\tTypeDescriptor typeDescriptor = this.typeDescriptor;\n\t\tif (typeDescriptor == null) {\n\t\t\ttypeDescriptor = (this.field != null ?\n\t\t\t\t\tnew TypeDescriptor(getResolvableType(), getDependencyType(), getAnnotations()) :\n\t\t\t\t\tnew TypeDescriptor(obtainMethodParameter()));\n\t\t\tthis.typeDescriptor = typeDescriptor;\n\t\t}\n\t\treturn typeDescriptor;\n\t}",
    "query": "Create a utility that efficiently obtains comprehensive type details for a specific dependency, enhancing both performance and type safety within the application context.",
    "function_signature": "public ResolvableType retrieveDependencyType()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.http.client.reactive.MockClientHttpResponse#getStatusCode()",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public HttpStatusCode getStatusCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic HttpStatusCode getStatusCode() {\n\t\treturn this.statusCode;\n\t}",
    "query": "Design a unit test that retrieves and verifies the HTTP status code from a simulated reactive HTTP client response.",
    "function_signature": "public HttpStatusCode fetchMockResponseStatus()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.hibernate5.SESSION_SYNCHRONIZATION_ORDER",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "field",
    "signature": "public int SESSION_SYNCHRONIZATION_ORDER",
    "documentation": "\t/**\n\t * Order value for TransactionSynchronization objects that clean up Hibernate Sessions.\n\t * Returns {@code DataSourceUtils.CONNECTION_SYNCHRONIZATION_ORDER - 100}\n\t * to execute Session cleanup before JDBC Connection cleanup, if any.\n\t * @see DataSourceUtils#CONNECTION_SYNCHRONIZATION_ORDER\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final int SESSION_SYNCHRONIZATION_ORDER =",
    "query": "Configure a transactional service to ensure that Hibernate session cleanup executes before JDBC connection cleanup during transaction synchronization.",
    "function_signature": "public void configureHibernateSessionCleanupSynchronization()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.beanvalidation.SpringValidatorAdapter#getResolvableField(objectName,field)",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "protected MessageSourceResolvable getResolvableField(String objectName, String field)",
    "documentation": "\t/**\n\t * Build a resolvable wrapper for the specified field, allowing to resolve the field's\n\t * name in a {@code MessageSource}.\n\t * <p>The default implementation returns a first argument indicating the field:\n\t * of type {@code DefaultMessageSourceResolvable}, with \"objectName.field\" and \"field\"\n\t * as codes, and with the plain field name as default message.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @return a corresponding {@code MessageSourceResolvable} for the specified field\n\t * @since 4.3\n\t * @see #getArgumentsForConstraint\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected MessageSourceResolvable getResolvableField(String objectName, String field) {\n\t\tString[] codes = new String[] {objectName + Errors.NESTED_PATH_SEPARATOR + field, field};\n\t\treturn new DefaultMessageSourceResolvable(codes, field);\n\t}",
    "query": "Implement a validation mechanism that produces localized, context-aware error messages for deeply nested properties within a user-submitted form, ensuring that each error message accurately reflects the specific field hierarchy.",
    "function_signature": "protected MessageSourceResolvable resolveNestedFieldError(String objectName, String field)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.<unknown>#is5xxServerError()",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public boolean is5xxServerError()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean is5xxServerError() {\n\t\treturn hundreds() == 5;\n\t}",
    "query": "Implement a method that assesses whether an HTTP response signifies a server-side failure, enabling your application to trigger appropriate fallback mechanisms.",
    "function_signature": "public boolean isCriticalServerFailure(HttpStatus responseStatus)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.CloseStatus",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "class",
    "signature": "public class CloseStatus",
    "documentation": "/**\n * Representation of WebSocket \"close\" status codes and reasons. Status codes\n * in the 1xxx range are pre-defined by the protocol.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n * @see <a href=\"https://tools.ietf.org/html/rfc6455#section-7.4.1\">\n *     RFC 6455, Section 7.4.1 \"Defined Status Codes\"</a>\n */",
    "changetype": "stabilized",
    "source_code": "public final class CloseStatus {\n\n\t/**\n\t * \"1000 indicates a normal closure, meaning that the purpose for which the connection\n\t * was established has been fulfilled.\"\n\t */\n\tpublic static final CloseStatus NORMAL = new CloseStatus(1000);\n\n\t/**\n\t * \"1001 indicates that an endpoint is \"going away\", such as a server going down or a\n\t * browser having navigated away from a page.\"\n\t */\n\tpublic static final CloseStatus GOING_AWAY = new CloseStatus(1001);\n\n\t/**\n\t * \"1002 indicates that an endpoint is terminating the connection due to a protocol\n\t * error.\"\n\t */\n\tpublic static final CloseStatus PROTOCOL_ERROR  = new CloseStatus(1002);\n\n\t/**\n\t * \"1003 indicates that an endpoint is terminating the connection because it has\n\t * received a type of data it cannot accept (e.g., an endpoint that understands only\n\t * text data MAY send this if it receives a binary message).\"\n\t */\n\tpublic static final CloseStatus NOT_ACCEPTABLE = new CloseStatus(1003);\n\n\t// 10004: Reserved.\n\t// The specific meaning might be defined in the future.\n\n\t/**\n\t * \"1005 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that no status code was actually present.\"\n\t */\n\tpublic static final CloseStatus NO_STATUS_CODE = new CloseStatus(1005);\n\n\t/**\n\t * \"1006 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that the connection was closed abnormally, e.g., without sending\n\t * or receiving a Close control frame.\"\n\t */\n\tpublic static final CloseStatus NO_CLOSE_FRAME = new CloseStatus(1006);\n\n\t/**\n\t * \"1007 indicates that an endpoint is terminating the connection because it has\n\t * received data within a message that was not consistent with the type of the message\n\t * (e.g., non-UTF-8 [RFC3629] data within a text message).\"\n\t */\n\tpublic static final CloseStatus BAD_DATA = new CloseStatus(1007);\n\n\t/**\n\t * \"1008 indicates that an endpoint is terminating the connection because it has\n\t * received a message that violates its policy. This is a generic status code that can\n\t * be returned when there is no other more suitable status code (e.g., 1003 or 1009)\n\t * or if there is a need to hide specific details about the policy.\"\n\t */\n\tpublic static final CloseStatus POLICY_VIOLATION = new CloseStatus(1008);\n\n\t/**\n\t * \"1009 indicates that an endpoint is terminating the connection because it has\n\t * received a message that is too big for it to process.\"\n\t */\n\tpublic static final CloseStatus TOO_BIG_TO_PROCESS = new CloseStatus(1009);\n\n\t/**\n\t * \"1010 indicates that an endpoint (client) is terminating the connection because it\n\t * has expected the server to negotiate one or more extension, but the server didn't\n\t * return them in the response message of the WebSocket handshake. The list of\n\t * extensions that are needed SHOULD appear in the /reason/ part of the Close frame.\n\t * Note that this status code is not used by the server, because it can fail the\n\t * WebSocket handshake instead.\"\n\t */\n\tpublic static final CloseStatus REQUIRED_EXTENSION = new CloseStatus(1010);\n\n\t/**\n\t * \"1011 indicates that a server is terminating the connection because it encountered\n\t * an unexpected condition that prevented it from fulfilling the request.\"\n\t */\n\tpublic static final CloseStatus SERVER_ERROR = new CloseStatus(1011);\n\n\t/**\n\t * \"1012 indicates that the service is restarted. A client may reconnect, and if it\n\t * chooses to do, should reconnect using a randomized delay of 5 - 30s.\"\n\t */\n\tpublic static final CloseStatus SERVICE_RESTARTED = new CloseStatus(1012);\n\n\t/**\n\t * \"1013 indicates that the service is experiencing overload. A client should only\n\t * connect to a different IP (when there are multiple for the target) or reconnect to\n\t * the same IP upon user action.\"\n\t */\n\tpublic static final CloseStatus SERVICE_OVERLOAD = new CloseStatus(1013);\n\n\t/**\n\t * \"1015 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that the connection was closed due to a failure to perform a TLS\n\t * handshake (e.g., the server certificate can't be verified).\"\n\t */\n\tpublic static final CloseStatus TLS_HANDSHAKE_FAILURE = new CloseStatus(1015);\n\n\n\tprivate final int code;\n\n\t@Nullable\n\tprivate final String reason;\n\n\n\t/**\n\t * Create a new {@link CloseStatus} instance.\n\t * @param code the status code\n\t */\n\tpublic CloseStatus(int code) {\n\t\tthis(code, null);\n\t}\n\n\t/**\n\t * Create a new {@link CloseStatus} instance.\n\t * @param code the status code\n\t * @param reason the reason\n\t */\n\tpublic CloseStatus(int code, @Nullable String reason) {\n\t\tAssert.isTrue((code >= 1000 && code < 5000), \"Invalid status code\");\n\t\tthis.code = code;\n\t\tthis.reason = reason;\n\t}\n\n\n\t/**\n\t * Return the status code.\n\t */\n\tpublic int getCode() {\n\t\treturn this.code;\n\t}\n\n\t/**\n\t * Return the reason, or {@code null} if none.\n\t */\n\t@Nullable\n\tpublic String getReason() {\n\t\treturn this.reason;\n\t}\n\n\t/**\n\t * Create a new {@link CloseStatus} from this one with the specified reason.\n\t * @param reason the reason\n\t * @return a new {@link CloseStatus} instance\n\t */\n\tpublic CloseStatus withReason(String reason) {\n\t\tAssert.hasText(reason, \"Reason must not be empty\");\n\t\treturn new CloseStatus(this.code, reason);\n\t}\n\n\t/**\n\t * @deprecated as of 5.3 in favor of comparing codes directly\n\t */\n\t@Deprecated\n\tpublic boolean equalsCode(CloseStatus other) {\n\t\treturn (this.code == other.code);\n\t}\n\n\n\t/**\n\t * Return a constant for the given code, or create a new instance if the\n\t * code does not match or there is a reason.\n\t * @since 5.3\n\t */\n\tpublic static CloseStatus create(int code, @Nullable String reason) {\n\t\tif (!StringUtils.hasText(reason)) {\n\t\t\tswitch (code) {\n\t\t\t\tcase 1000:\n\t\t\t\t\treturn NORMAL;\n\t\t\t\tcase 1001:\n\t\t\t\t\treturn GOING_AWAY;\n\t\t\t\tcase 1002:\n\t\t\t\t\treturn PROTOCOL_ERROR;\n\t\t\t\tcase 1003:\n\t\t\t\t\treturn NOT_ACCEPTABLE;\n\t\t\t\tcase 1005:\n\t\t\t\t\treturn NO_STATUS_CODE;\n\t\t\t\tcase 1006:\n\t\t\t\t\treturn NO_CLOSE_FRAME;\n\t\t\t\tcase 1007:\n\t\t\t\t\treturn BAD_DATA;\n\t\t\t\tcase 1008:\n\t\t\t\t\treturn POLICY_VIOLATION;\n\t\t\t\tcase 1009:\n\t\t\t\t\treturn TOO_BIG_TO_PROCESS;\n\t\t\t\tcase 1010:\n\t\t\t\t\treturn REQUIRED_EXTENSION;\n\t\t\t\tcase 1011:\n\t\t\t\t\treturn SERVER_ERROR;\n\t\t\t\tcase 1012:\n\t\t\t\t\treturn SERVICE_RESTARTED;\n\t\t\t\tcase 1013:\n\t\t\t\t\treturn SERVICE_OVERLOAD;\n\t\t\t}\n\t\t}\n\t\treturn new CloseStatus(code, reason);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof CloseStatus otherStatus)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.code == otherStatus.code &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.reason, otherStatus.reason));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.code * 29 + ObjectUtils.nullSafeHashCode(this.reason);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CloseStatus[code=\" + this.code + \", reason=\" + this.reason + \"]\";\n\t}\n\n}",
    "query": "Design a WebSocket endpoint that securely terminates the connection when receiving invalid data types, ensuring clients receive appropriate closure reasons.",
    "function_signature": "public Mono<Void> handleInvalidData(WebSocketSession session, DataBuffer data)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ContentDisposition#toString()",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public String toString()",
    "documentation": "\t/**\n\t * Return the header value for this content disposition as defined in RFC 6266.\n\t * @see #parse(String)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (this.type != null) {\n\t\t\tsb.append(this.type);\n\t\t}\n\t\tif (this.name != null) {\n\t\t\tsb.append(\"; name=\\\"\");\n\t\t\tsb.append(this.name).append('\\\"');\n\t\t}\n\t\tif (this.filename != null) {\n\t\t\tif (this.charset == null || StandardCharsets.US_ASCII.equals(this.charset)) {\n\t\t\t\tsb.append(\"; filename=\\\"\");\n\t\t\t\tsb.append(escapeQuotationsInFilename(this.filename)).append('\\\"');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"; filename*=\");\n\t\t\t\tsb.append(encodeFilename(this.filename, this.charset));\n\t\t\t}\n\t\t}\n\t\tif (this.size != null) {\n\t\t\tsb.append(\"; size=\");\n\t\t\tsb.append(this.size);\n\t\t}\n\t\tif (this.creationDate != null) {\n\t\t\tsb.append(\"; creation-date=\\\"\");\n\t\t\tsb.append(RFC_1123_DATE_TIME.format(this.creationDate));\n\t\t\tsb.append('\\\"');\n\t\t}\n\t\tif (this.modificationDate != null) {\n\t\t\tsb.append(\"; modification-date=\\\"\");\n\t\t\tsb.append(RFC_1123_DATE_TIME.format(this.modificationDate));\n\t\t\tsb.append('\\\"');\n\t\t}\n\t\tif (this.readDate != null) {\n\t\t\tsb.append(\"; read-date=\\\"\");\n\t\t\tsb.append(RFC_1123_DATE_TIME.format(this.readDate));\n\t\t\tsb.append('\\\"');\n\t\t}\n\t\treturn sb.toString();\n\t}",
    "query": "Develop a REST endpoint that enables users to download reports. Ensure that the response includes a properly formatted header to prompt file download in the browser, handling filenames with special characters and including metadata like file size and creation date.",
    "function_signature": "public String createDownloadContentHeader(String filename, Long size, LocalDateTime creationDate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setCacheSecondsForSessionAttributeHandlers(cacheSecondsForSessionAttributeHandlers)",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers)",
    "documentation": "\t/**\n\t * Cache content produced by {@code @SessionAttributes} annotated handlers\n\t * for the given number of seconds.\n\t * <p>Possible values are:\n\t * <ul>\n\t * <li>-1: no generation of cache-related headers</li>\n\t * <li>0 (default value): \"Cache-Control: no-store\" will prevent caching</li>\n\t * <li>1 or higher: \"Cache-Control: max-age=seconds\" will ask to cache content;\n\t * not advised when dealing with session attributes</li>\n\t * </ul>\n\t * <p>In contrast to the \"cacheSeconds\" property which will apply to all general\n\t * handlers (but not to {@code @SessionAttributes} annotated handlers),\n\t * this setting will apply to {@code @SessionAttributes} handlers only.\n\t * @see #setCacheSeconds\n\t * @see org.springframework.web.bind.annotation.SessionAttributes\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers) {\n\t\tthis.cacheSecondsForSessionAttributeHandlers = cacheSecondsForSessionAttributeHandlers;\n\t}",
    "query": "In a Spring MVC application, some controllers utilize `@SessionAttributes` to maintain user state across multiple requests. To improve performance and reduce server load, implement a configuration that sets caching headers specifically for these session-managed handlers, allowing responses to be cached for a defined number of seconds.",
    "function_signature": "public void configureSessionAttributeHandlerCaching(int cacheDurationInSeconds)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockPageContext#getAttribute(name)",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public Object getAttribute(String name)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object getAttribute(String name) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\treturn this.attributes.get(name);\n\t}",
    "query": "Develop a unit test that simulates a JSP environment to access and verify specific attributes within the page context.",
    "function_signature": "public Object accessPageAttribute(String name)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.BeanDefinitionHolder#getBeanName()",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public String getBeanName()",
    "documentation": "\t/**\n\t * Return the primary name of the bean, as specified for the bean definition.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}",
    "query": "How can you obtain the main names assigned to bean definitions during runtime to enforce naming conventions across your Spring application?",
    "function_signature": "public String retrieveMainBeanName(BeanDefinitionHolder holder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.TypedStringValue#equals(other)",
    "from_version": "v5.3.21",
    "to_version": "v6.0.0-M5",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof TypedStringValue otherValue)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (ObjectUtils.nullSafeEquals(this.value, otherValue.value) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.targetType, otherValue.targetType));\n\t}",
    "query": "Create a mechanism that compares configuration parameters by evaluating both their string content and the expected data types, ensuring that parameters are treated as identical only if both aspects match precisely.",
    "function_signature": "public boolean compareConfigurationParameters(TypedStringValue param1, TypedStringValue param2)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.support.MessageHeaderAccessor#getAccessor(message,requiredType)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public T getAccessor(Message<?> message, @Nullable Class<T> requiredType)",
    "documentation": "\t/**\n\t * Return the original {@code MessageHeaderAccessor} used to create the headers\n\t * of the given {@code Message}, or {@code null} if that's not available or if\n\t * its type does not match the required type.\n\t * <p>This is for cases where the existence of an accessor is strongly expected\n\t * (followed up with an assertion) or where an accessor will be created otherwise.\n\t * @param message the message to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(Message<?> message, @Nullable Class<T> requiredType) {\n\t\treturn getAccessor(message.getHeaders(), requiredType);\n\t}",
    "query": "Implement a component that extracts and utilizes specialized header information from incoming messages to enforce security constraints.",
    "function_signature": "public CustomHeaderAccessor extractCustomHeaderAccessor(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.style.DefaultValueStyler#style(value)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public String style(@Nullable Object value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String style(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (value instanceof String) {\n\t\t\treturn \"\\'\" + value + \"\\'\";\n\t\t}\n\t\telse if (value instanceof Class) {\n\t\t\treturn ClassUtils.getShortName((Class<?>) value);\n\t\t}\n\t\telse if (value instanceof Method method) {\n\t\t\treturn method.getName() + \"@\" + ClassUtils.getShortName(method.getDeclaringClass());\n\t\t}\n\t\telse if (value instanceof Map) {\n\t\t\treturn style((Map<?, ?>) value);\n\t\t}\n\t\telse if (value instanceof Map.Entry) {\n\t\t\treturn style((Map.Entry<? ,?>) value);\n\t\t}\n\t\telse if (value instanceof Collection) {\n\t\t\treturn style((Collection<?>) value);\n\t\t}\n\t\telse if (value.getClass().isArray()) {\n\t\t\treturn styleArray(ObjectUtils.toObjectArray(value));\n\t\t}\n\t\telse {\n\t\t\treturn String.valueOf(value);\n\t\t}\n\t}",
    "query": "Design a logging utility that consistently formats various object typessuch as strings, classes, methods, collections, and arraysfor enhanced readability in application logs. Ensure the utility gracefully handles `null` values and provides clear, concise representations without manual type checking.",
    "function_signature": "public String formatLogValue(@Nullable Object value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.AnnotationUtils#getDefaultValue(annotation)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public Object getDefaultValue(Annotation annotation)",
    "documentation": "\t/**\n\t * Retrieve the <em>default value</em> of the {@code value} attribute\n\t * of a single-element Annotation, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @return the default value, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static Object getDefaultValue(Annotation annotation) {\n\t\treturn getDefaultValue(annotation, VALUE);\n\t}",
    "query": "Create a utility method that inspects single-element annotations on your Spring components and seamlessly retrieves their default values when specific attributes aren't explicitly provided.",
    "function_signature": "public Object retrieveDefaultValue(Annotation annotation)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.JdbcTemplate#queryForRowSet(sql)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public SqlRowSet queryForRowSet(String sql)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql) throws DataAccessException {\n\t\treturn result(query(sql, new SqlRowSetResultSetExtractor()));\n\t}",
    "query": "Design a service method that retrieves user activity logs from the database and allows for efficient navigation through large datasets without loading all records into memory at once.",
    "function_signature": "public SqlRowSet fetchUserActivityLogs(String userId) throws DataAccessException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.HttpMethod#resolve(method)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public HttpMethod resolve(@Nullable String method)",
    "documentation": "\t/**\n\t * Resolve the given method value to an {@code HttpMethod}.\n\t * @param method the method value as a String\n\t * @return the corresponding {@code HttpMethod}, or {@code null} if not found\n\t * @since 4.2.4\n\t * @deprecated in favor of {@link #valueOf(String)}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static HttpMethod resolve(@Nullable String method) {\n\t\treturn (method != null ? valueOf(method) : null);\n\t}",
    "query": "Develop a utility function that translates user-provided string inputs into corresponding HTTP method enums to facilitate dynamic request handling.",
    "function_signature": "public HttpMethod determineHttpMethod(String method)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.OperatorPower#getValueInternal(state)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public TypedValue getValueInternal(ExpressionState state)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tSpelNodeImpl leftOp = getLeftOperand();\n\t\tSpelNodeImpl rightOp = getRightOperand();\n\n\t\tObject leftOperand = leftOp.getValueInternal(state).getValue();\n\t\tObject rightOperand = rightOp.getValueInternal(state).getValue();\n\n\t\tif (leftOperand instanceof Number leftNumber && rightOperand instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\treturn new TypedValue(leftBigDecimal.pow(rightNumber.intValue()));\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\treturn new TypedValue(leftBigInteger.pow(rightNumber.intValue()));\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn new TypedValue(Math.pow(leftNumber.doubleValue(), rightNumber.doubleValue()));\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn new TypedValue(Math.pow(leftNumber.floatValue(), rightNumber.floatValue()));\n\t\t\t}\n\n\t\t\tdouble d = Math.pow(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\tif (d > Integer.MAX_VALUE || leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn new TypedValue((long) d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new TypedValue((int) d);\n\t\t\t}\n\t\t}\n\n\t\treturn state.operate(Operation.POWER, leftOperand, rightOperand);\n\t}",
    "query": "Design a component that evaluates complex financial formulas entered by users, ensuring precise calculations involving exponentiation for investment growth projections.",
    "function_signature": "public TypedValue evaluateFinancialFormula(String formula, EvaluationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockPageContext#getELContext()",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public ELContext getELContext()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic ELContext getELContext() {\n\t\treturn null;\n\t}",
    "query": "Design a unit test for a Spring MVC controller that renders a JSP view utilizing Expression Language (EL) expressions. Ensure that the testing environment correctly initializes and accesses the ELContext within the mock page context to accurately evaluate the EL expressions during the rendering process.",
    "function_signature": "public ELContext initializeMockElContext(MockPageContext mockPageContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.convert.Property#hashCode()",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (ObjectUtils.nullSafeHashCode(this.objectType) * 31 + ObjectUtils.nullSafeHashCode(this.name));\n\t}",
    "query": "Develop a feature that efficiently manages a collection of configuration properties, ensuring that each property is unique based on its type and name to prevent redundancy.",
    "function_signature": "public Set<Property> manageUniqueProperties(Collection<Property> properties);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractHttpMessageConverter",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "class",
    "signature": "public class AbstractHttpMessageConverter",
    "documentation": "/**\n * Abstract base class for most {@link HttpMessageConverter} implementations.\n *\n * <p>This base class adds support for setting supported {@code MediaTypes}, through the\n * {@link #setSupportedMediaTypes(List) supportedMediaTypes} bean property. It also adds\n * support for {@code Content-Type} and {@code Content-Length} when writing to output messages.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 3.0\n * @param <T> the converted object type\n */",
    "changetype": "stabilized",
    "source_code": "public abstract class AbstractHttpMessageConverter<T> implements HttpMessageConverter<T> {\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = HttpLogging.forLogName(getClass());\n\n\tprivate List<MediaType> supportedMediaTypes = Collections.emptyList();\n\n\t@Nullable\n\tprivate Charset defaultCharset;\n\n\n\t/**\n\t * Construct an {@code AbstractHttpMessageConverter} with no supported media types.\n\t * @see #setSupportedMediaTypes\n\t */\n\tprotected AbstractHttpMessageConverter() {\n\t}\n\n\t/**\n\t * Construct an {@code AbstractHttpMessageConverter} with one supported media type.\n\t * @param supportedMediaType the supported media type\n\t */\n\tprotected AbstractHttpMessageConverter(MediaType supportedMediaType) {\n\t\tsetSupportedMediaTypes(Collections.singletonList(supportedMediaType));\n\t}\n\n\t/**\n\t * Construct an {@code AbstractHttpMessageConverter} with multiple supported media types.\n\t * @param supportedMediaTypes the supported media types\n\t */\n\tprotected AbstractHttpMessageConverter(MediaType... supportedMediaTypes) {\n\t\tsetSupportedMediaTypes(Arrays.asList(supportedMediaTypes));\n\t}\n\n\t/**\n\t * Construct an {@code AbstractHttpMessageConverter} with a default charset and\n\t * multiple supported media types.\n\t * @param defaultCharset the default character set\n\t * @param supportedMediaTypes the supported media types\n\t * @since 4.3\n\t */\n\tprotected AbstractHttpMessageConverter(Charset defaultCharset, MediaType... supportedMediaTypes) {\n\t\tthis.defaultCharset = defaultCharset;\n\t\tsetSupportedMediaTypes(Arrays.asList(supportedMediaTypes));\n\t}\n\n\n\t/**\n\t * Set the list of {@link MediaType} objects supported by this converter.\n\t */\n\tpublic void setSupportedMediaTypes(List<MediaType> supportedMediaTypes) {\n\t\tAssert.notEmpty(supportedMediaTypes, \"MediaType List must not be empty\");\n\t\tthis.supportedMediaTypes = new ArrayList<>(supportedMediaTypes);\n\t}\n\n\t@Override\n\tpublic List<MediaType> getSupportedMediaTypes() {\n\t\treturn Collections.unmodifiableList(this.supportedMediaTypes);\n\t}\n\n\t/**\n\t * Set the default character set, if any.\n\t * @since 4.3\n\t */\n\tpublic void setDefaultCharset(@Nullable Charset defaultCharset) {\n\t\tthis.defaultCharset = defaultCharset;\n\t}\n\n\t/**\n\t * Return the default character set, if any.\n\t * @since 4.3\n\t */\n\t@Nullable\n\tpublic Charset getDefaultCharset() {\n\t\treturn this.defaultCharset;\n\t}\n\n\n\t/**\n\t * This implementation checks if the given class is {@linkplain #supports(Class) supported},\n\t * and if the {@linkplain #getSupportedMediaTypes() supported media types}\n\t * {@linkplain MediaType#includes(MediaType) include} the given media type.\n\t */\n\t@Override\n\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn supports(clazz) && canRead(mediaType);\n\t}\n\n\t/**\n\t * Returns {@code true} if any of the {@linkplain #setSupportedMediaTypes(List)\n\t * supported} media types {@link MediaType#includes(MediaType) include} the\n\t * given media type.\n\t * @param mediaType the media type to read, can be {@code null} if not specified.\n\t * Typically the value of a {@code Content-Type} header.\n\t * @return {@code true} if the supported media types include the media type,\n\t * or if the media type is {@code null}\n\t */\n\tprotected boolean canRead(@Nullable MediaType mediaType) {\n\t\tif (mediaType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MediaType supportedMediaType : getSupportedMediaTypes()) {\n\t\t\tif (supportedMediaType.includes(mediaType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This implementation checks if the given class is\n\t * {@linkplain #supports(Class) supported}, and if the\n\t * {@linkplain #getSupportedMediaTypes() supported} media types\n\t * {@linkplain MediaType#includes(MediaType) include} the given media type.\n\t */\n\t@Override\n\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn supports(clazz) && canWrite(mediaType);\n\t}\n\n\t/**\n\t * Returns {@code true} if the given media type includes any of the\n\t * {@linkplain #setSupportedMediaTypes(List) supported media types}.\n\t * @param mediaType the media type to write, can be {@code null} if not specified.\n\t * Typically the value of an {@code Accept} header.\n\t * @return {@code true} if the supported media types are compatible with the media type,\n\t * or if the media type is {@code null}\n\t */\n\tprotected boolean canWrite(@Nullable MediaType mediaType) {\n\t\tif (mediaType == null || MediaType.ALL.equalsTypeAndSubtype(mediaType)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MediaType supportedMediaType : getSupportedMediaTypes()) {\n\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This implementation simple delegates to {@link #readInternal(Class, HttpInputMessage)}.\n\t * Future implementations might add some default behavior, however.\n\t */\n\t@Override\n\tpublic final T read(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn readInternal(clazz, inputMessage);\n\t}\n\n\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */\n\t@Override\n\tpublic final void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(t, new HttpOutputMessage() {\n\t\t\t\t@Override\n\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\treturn outputStream;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\treturn headers;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}\n\n\t/**\n\t * Add default headers to the output message.\n\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a\n\t * content type was not provided, set if necessary the default character set, calls\n\t * {@link #getContentLength}, and sets the corresponding headers.\n\t * @since 4.2\n\t */\n\tprotected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType) throws IOException {\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || !contentType.isConcrete()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType mediaType = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\tif (contentTypeToUse.getCharset() == null) {\n\t\t\t\t\tCharset defaultCharset = getDefaultCharset();\n\t\t\t\t\tif (defaultCharset != null) {\n\t\t\t\t\t\tcontentTypeToUse = new MediaType(contentTypeToUse, defaultCharset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() < 0 && !headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the default content type for the given type. Called when {@link #write}\n\t * is invoked without a specified content type parameter.\n\t * <p>By default, this returns the first element of the\n\t * {@link #setSupportedMediaTypes(List) supportedMediaTypes} property, if any.\n\t * Can be overridden in subclasses.\n\t * @param t the type to return the content type for\n\t * @return the content type, or {@code null} if not known\n\t */\n\t@Nullable\n\tprotected MediaType getDefaultContentType(T t) throws IOException {\n\t\tList<MediaType> mediaTypes = getSupportedMediaTypes();\n\t\treturn (!mediaTypes.isEmpty() ? mediaTypes.get(0) : null);\n\t}\n\n\t/**\n\t * Returns the content length for the given type.\n\t * <p>By default, this returns {@code null}, meaning that the content length is unknown.\n\t * Can be overridden in subclasses.\n\t * @param t the type to return the content length for\n\t * @return the content length, or {@code null} if not known\n\t */\n\t@Nullable\n\tprotected Long getContentLength(T t, @Nullable MediaType contentType) throws IOException {\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Indicates whether the given class is supported by this converter.\n\t * @param clazz the class to test for support\n\t * @return {@code true} if supported; {@code false} otherwise\n\t */\n\tprotected abstract boolean supports(Class<?> clazz);\n\n\t/**\n\t * Abstract template method that reads the actual object. Invoked from {@link #read}.\n\t * @param clazz the type of object to return\n\t * @param inputMessage the HTTP input message to read from\n\t * @return the converted object\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotReadableException in case of conversion errors\n\t */\n\tprotected abstract T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */\n\tprotected abstract void writeInternal(T t, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException;\n\n}",
    "query": "Develop a mechanism to transform bespoke data objects to a designated media type, ensuring proper management of HTTP headers such as `Content-Type` and `Content-Length` during both serialization and deserialization processes.",
    "function_signature": "public class CustomDataConverter extends AbstractHttpMessageConverter<CustomData>"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.<unknown>#execute(request,body)",
    "from_version": "v5.3.16",
    "to_version": "v6.0.0-M3",
    "type": "method",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(outputStream -> StreamUtils.copy(body, outputStream));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}",
    "query": "Create a component that sends binary data to an external service, allowing for dynamic modification of the HTTP request headers and efficient handling of the request body. Ensure that the implementation leverages the most recent Spring Framework enhancements for executing HTTP requests with byte array payloads.",
    "function_signature": "public ClientHttpResponse transmitBinaryData(HttpRequest request, byte[] body)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Refactor the message broker setup to implement an enhanced subscription management approach that offers better scalability and thread safety.",
    "function_signature": "public void configureSubscriptionManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a component responsible for handling message destinations that prioritizes enhanced performance and type safety, ensuring the system remains maintainable and scalable.",
    "function_signature": "public List<String> getActiveDestinations()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Refactor the URL path matching in your Spring MVC interceptor to leverage the latest path processing strategies, enhancing performance and type safety.",
    "function_signature": "public void setPathPatternParser(PathPatternParser patternParser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Refactor the interceptor logic to efficiently determine if a request should be processed, ensuring optimal performance and enhanced pattern matching capabilities.",
    "function_signature": "public boolean shouldProcessRequest(ServerHttpRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPatternString()",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public String getPatternString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}",
    "query": "Enhance the interceptor configuration by adopting a more efficient approach for pattern matching, ensuring better performance and scalability.",
    "function_signature": "public List<PathPattern> retrievePathPatterns()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(",
    "query": "Revamp the initialization of URL patterns to leverage modern parsing techniques, ensuring enhanced performance and reduced complexity in your Spring MVC application.",
    "function_signature": "public PathPatternAdapter[] initializeUrlPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean -&gt;\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Optimize your messaging configuration by incorporating a strategy that leverages controller advice components for global exception handling, enhancing type safety and maintainability.",
    "function_signature": "public void configureGlobalExceptionHandling(ControllerAdviceBean adviceBean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Develop a configuration method that registers interceptors in a way that enhances scalability and maintains thread safety during request processing.",
    "function_signature": "public void registerCustomHandlerInterceptor(HandlerInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Design a method to obtain the target destination for message processing, prioritizing enhanced performance and reliability in a concurrent Spring application.",
    "function_signature": "public String resolveTargetDestination()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.3.27",
    "to_version": "v5.2.24.RELEASE",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Design a method that efficiently verifies whether a specific request URL conforms to defined pattern criteria, ensuring optimal performance and improved reliability in the matching process.",
    "function_signature": "public boolean isPathMatching(String requestPath, PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#header(headerName,headerValues)",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}",
    "query": "Create a method that sends an HTTP PUT request to update a resource, allowing the inclusion of multiple custom headers to accommodate various client requirements.",
    "function_signature": "public Mono<ResponseEntity<Void>> updateResourceWithHeaders(String resourceUrl, String headerName, String... headerValues)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.MergedContextConfiguration#getParent()",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public MergedContextConfiguration getParent()",
    "documentation": "\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}",
    "query": "Create a testing utility method that accesses and leverages configuration details from a superior application context within a nested context hierarchy, facilitating shared settings across multiple test scenarios.",
    "function_signature": "public MergedContextConfiguration retrieveParentContextConfiguration()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DataBufferUtils#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor,chunkSize)",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "documentation": "\t/**\n\t * Creates a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamHandler} are buffered until they\n\t * reach or exceed {@code chunkSize}, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,",
    "query": "Design a service that captures real-time data written to an `OutputStream` and exposes it as a reactive stream, ensuring efficient buffering and backpressure handling for downstream consumers.",
    "function_signature": "public Publisher<DataBuffer> streamOutputData(Consumer<OutputStream> dataWriter, DataBufferFactory bufferFactory, Executor asyncExecutor, int bufferThreshold)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#onComplete()",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public void onComplete()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void onComplete() {\n\t\t\tthis.request.performCachePut(this.cacheValue);\n\t\t}",
    "query": "Create a component that ensures the caching layer is updated with the outcome of a service method immediately after its execution completes, maintaining cache consistency without manual intervention.",
    "function_signature": "public void handleCompletion()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#handleMissingValue(name,parameter,request)",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "documentation": "\t/**\n\t * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}\n\t * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param request the current request\n\t * @since 4.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "query": "Design a REST endpoint that processes user registrations by extracting necessary parameters from the incoming request. Ensure that the method gracefully handles scenarios where required information is missing, providing meaningful feedback to the client without exposing internal server details.",
    "function_signature": "public ResponseEntity<Void> registerUser(@RequestParam String username, @RequestParam String email, @RequestParam(required = true) String password)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#next()",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public String next()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}",
    "query": "Design a Spring service that sequentially accesses each HTTP request header to perform custom authentication checks, ensuring headers are processed in order without loading all at once.",
    "function_signature": "public String fetchNextHeaderForAuthentication(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractHttpMessageConverter#supportsRepeatableWrites(t)",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "protected boolean supportsRepeatableWrites(T t)",
    "documentation": "\t/**\n\t * Indicates whether this message converter can\n\t * {@linkplain #write(Object, MediaType, HttpOutputMessage) write} the\n\t * given object multiple times.\n\t *\n\t * <p>Default implementation returns {@code false}.\n\t * @param t the object t\n\t * @return {@code true} if {@code t} can be written repeatedly;\n\t * {@code false} otherwise\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected boolean supportsRepeatableWrites(T t) {\n\t\treturn false;\n\t}",
    "query": "Create a custom HTTP message converter that can determine if a response object supports being written multiple times. This is essential for scenarios such as retry mechanisms or detailed logging where the same response needs to be serialized repeatedly without adverse effects.",
    "function_signature": "protected boolean canWriteMultipleTimes(ResponseObject response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#acceptCharset(acceptableCharsets)",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}",
    "query": "Design a method that configures an HTTP request to prefer specific character encodings when communicating with a RESTful service.",
    "function_signature": "public RequestConfigurer setPreferredCharsets(Charset... charsets)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.<unknown>#getValue()",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public List<String> getValue()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}",
    "query": "Design a method that efficiently retrieves the main value for a given header key within a reactive HTTP client, enhancing performance and ensuring type safety.",
    "function_signature": "public Optional<String> getFirstValue()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getValue(paramName)",
    "from_version": "v6.0.15",
    "to_version": "v6.1.2",
    "type": "method",
    "signature": "public Object getValue(String paramName)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}",
    "query": "Design a repository method that performs a database update by seamlessly mapping an entity's fields to the SQL statement's named parameters, eliminating the need for explicit parameter assignments.",
    "function_signature": "public int updateEntityWithNamedParameters(String sql, Object entity)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#send(items)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public void send(Set<ResponseBodyEmitter.DataWithMediaType> items)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void send(Set<ResponseBodyEmitter.DataWithMediaType> items) throws IOException {\n\t\t\tfor (ResponseBodyEmitter.DataWithMediaType item : items) {\n\t\t\t\tsendInternal(item.getData(), item.getMediaType());\n\t\t\t}\n\t\t\tthis.outputMessage.flush();\n\t\t}",
    "query": "Design a Spring REST controller method that efficiently transmits a batch of diverse data elements, each paired with its corresponding media type, to the client in one cohesive response.",
    "function_signature": "public void transmitBatchData(Set<DataWithMediaType> items)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.RootClassFilter#equals(other)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof RootClassFilter that &&\n\t\t\t\tthis.clazz.equals(that.clazz)));\n\t}",
    "query": "Challenge: Develop a method that accurately determines the equivalence of class filters in your AOP configuration to enhance performance and reliability.",
    "function_signature": "public boolean isEquivalentFilter(@Nullable Object other);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.test.tools.<unknown>#iterator()",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public Iterator<F> iterator()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Iterator<F> iterator() {\n\t\treturn this.files.values().iterator();\n\t}",
    "query": "Create a testing utility that systematically iterates through all configuration files within a test environment, allowing for dynamic adjustments and validations before each test case runs.",
    "function_signature": "public Iterator<ConfigurationFile> iterateConfigurationFiles()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#apply(result)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public Object apply(@Nullable Object result)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\t\tpublic Object apply(@Nullable Object result) {\n\t\t\tif (result instanceof CompletableFuture<?> future) {\n\t\t\t\treturn future.whenComplete((value, ex) -> {\n\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\tperformEvict(ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tperformPut(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (reactiveCachingHandler != null) {\n\t\t\t\tObject returnValue = reactiveCachingHandler.processPutRequest(this, result);\n\t\t\t\tif (returnValue != ReactiveCachingHandler.NOT_HANDLED) {\n\t\t\t\t\treturn returnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperformPut(result);\n\t\t\treturn null;\n\t\t}",
    "query": "Create a caching interceptor for service methods that handle both synchronous and asynchronous responses. Ensure that the interceptor can manage cache entries correctly when dealing with future-based or reactive return types, handling both successful results and exceptions appropriately.",
    "function_signature": "public Object manageCache(@Nullable Object result)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.env.<unknown>#equals(other)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof ParsedProfiles that &&\n\t\t\t\t\tthis.expressions.equals(that.expressions)));\n\t\t}",
    "query": "Develop a utility that verifies whether two Spring profile expressions lead to the same active configuration by efficiently comparing their parsed representations.",
    "function_signature": "public boolean areProfileExpressionsEquivalent(String profileExpressionA, String profileExpressionB)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.DefaultTransactionDefinition#getPropagationBehavior()",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public int getPropagationBehavior()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}",
    "query": "Implement a service method that ensures a new transaction is initiated for a specific business operation, independent of any existing transactional context.",
    "function_signature": "public void executeOperationInNewTransaction(Runnable operation)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.TestPropertySourceUtils#addPropertiesFilesToEnvironment(context,locations)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations)",
    "documentation": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}",
    "query": "Design a test setup where multiple external configuration files are programmatically integrated into the application context to customize the environment for different test cases.",
    "function_signature": "public void integrateExternalConfigsForTesting(ConfigurableApplicationContext context, String... configPaths)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.NameMatchMethodPointcut#equals(other)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof NameMatchMethodPointcut that &&\n\t\t\t\tthis.mappedNames.equals(that.mappedNames)));\n\t}",
    "query": "Implement a Spring AOP configuration that targets service methods by specific naming patterns and ensures that these pointcut definitions can be reliably compared for consistency within the application context.",
    "function_signature": "public Pointcut configureNameBasedServicePointcut()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.DataBinder#setDeclarativeBinding(declarativeBinding)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public void setDeclarativeBinding(boolean declarativeBinding)",
    "documentation": "\t/**\n\t * Set whether to bind only fields explicitly intended for binding including:\n\t * <ul>\n\t * <li>Constructor binding via {@link #construct}.\n\t * <li>Property binding with configured\n\t * {@link #setAllowedFields(String...) allowedFields}.\n\t * </ul>\n\t * <p>Default is \"false\". Turn this on to limit binding to constructor\n\t * parameters and allowed fields.\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setDeclarativeBinding(boolean declarativeBinding) {\n\t\tthis.declarativeBinding = declarativeBinding;\n\t}",
    "query": "Design a data binding configuration that restricts the binding process to only include explicitly specified fields and constructor parameters, thereby preventing unintended properties from being bound.",
    "function_signature": "public void configureRestrictedDataBinding(DataBinder dataBinder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.SimplePropertySqlParameterSource#getValue(paramName)",
    "from_version": "v6.1.0-M3",
    "to_version": "v6.1.0-M4",
    "type": "method",
    "signature": "public Object getValue(String paramName)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object getValue(String paramName) throws IllegalArgumentException {\n\t\tObject desc = getDescriptor(paramName);\n\t\tif (desc instanceof PropertyDescriptor pd) {\n\t\t\tReflectionUtils.makeAccessible(pd.getReadMethod());\n\t\t\treturn ReflectionUtils.invokeMethod(pd.getReadMethod(), this.paramObject);\n\t\t}\n\t\telse if (desc instanceof Field field) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\treturn ReflectionUtils.getField(field, this.paramObject);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Cannot retrieve value for parameter '\" + paramName +\n\t\t\t\t\"' - neither a getter method nor a raw field found\");\n\t}",
    "query": "Develop a utility method that accepts a domain object and a parameter name, then dynamically retrieves the corresponding property value to be used in a SQL query. Ensure the method handles both getter methods and direct field access seamlessly, leveraging the latest enhancements in Spring's JDBC support.",
    "function_signature": "public Object fetchSqlParameter(Object domainObject, String parameterName);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Implement a method to assign unique identifiers to messages in a thread-safe and high-performance manner, suitable for a production-grade messaging system.",
    "function_signature": "public long generateUniqueMessageId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Enhance the messaging configuration by implementing a method that efficiently retrieves the current set of destination prefixes, ensuring thread safety and optimal performance without directly accessing internal identifiers.",
    "function_signature": "public Collection<String> getDestinationPrefixes()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Refactor the interceptor to utilize the latest path resolution techniques, ensuring more efficient and maintainable request handling within your application.",
    "function_signature": "public boolean shouldApply(PathContainer resolvedPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a strategy to dynamically assign message destinations to subscribers, optimizing for high throughput and low latency in a concurrent environment.",
    "function_signature": "public DestinationAssigner assignDestination(String contentionLevel)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Enhance the scalability and reliability of your messaging system by improving how active sessions and destinations are managed. Develop a method that efficiently initializes and maintains subscription registries, ensuring optimal performance and thread-safe operations.",
    "function_signature": "public void setupOptimizedSubscriptionManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Improve the processing of HTTP requests by implementing a more efficient interception mechanism that enhances performance and ensures better integration with the latest Spring MVC features.",
    "function_signature": "public boolean handleIncomingRequest(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PathPattern[] includePatterns;\n\n\t@Nullable\n\tprivate final PathPattern[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\t@Nullable\n\tprivate static PathPattern[] initPatterns(\n\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\treturn null;\n\t\t}\n\t\tparser = (parser != null ? parser : PathPatternParser.defaultInstance);\n\t\treturn Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchPattern(Object path, boolean isPathContainer, PathPattern pattern) {\n\t\treturn (isPathContainer ?\n\t\t\t\tpattern.matches((PathContainer) path) :\n\t\t\t\tthis.pathMatcher.match(pattern.getPatternString(), (String) path));\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n}",
    "query": "Design a mechanism to efficiently verify incoming HTTP requests against specific criteria to ensure optimal performance and maintainable code structure within your web application.",
    "function_signature": "public boolean shouldProcessRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Develop a method to retrieve all applicable `HandlerInterceptor` instances for a request, ensuring comprehensive processing and greater configurability within your Spring application.",
    "function_signature": "public HandlerInterceptor[] getInterceptors()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design a method to optimize the path matching strategy for request interception, ensuring improved performance and thread safety within your Spring application.",
    "function_signature": "public void configurePathMatchingStrategy(PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.3.4",
    "to_version": "v5.2.13.RELEASE",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String session;",
    "query": "Design a method that efficiently obtains the active session identifier in a thread-safe manner, enhancing overall application reliability.",
    "function_signature": "public String fetchActiveSessionId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.<unknown>#header(headerName)",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public List<String> header(String headerName)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic List<String> header(String headerName) {\n\t\t\tList<String> headerValues = this.httpHeaders.get(headerName);\n\t\t\treturn (headerValues != null ? headerValues : Collections.emptyList());\n\t\t}",
    "query": "Design a method that efficiently accesses all values of a specified HTTP header, ensuring enhanced type safety and leveraging the latest best practices for managing HTTP headers in reactive web applications.",
    "function_signature": "public HttpHeaders retrieveHeaders(String headerName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.RootBeanDefinition#markAsPostProcessed()",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public void markAsPostProcessed()",
    "documentation": "\t/**\n\t * Mark this bean definition as post-processed,\n\t * i.e. processed by {@link MergedBeanDefinitionPostProcessor}.\n\t * @since 6.0\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void markAsPostProcessed() {\n\t\tsynchronized (this.postProcessingLock) {\n\t\t\tthis.postProcessed = true;\n\t\t}\n\t}",
    "query": "Design a method to efficiently indicate that a bean definition has undergone post-processing, ensuring thread safety and minimizing synchronization overhead.",
    "function_signature": "public void flagBeanDefinitionAsProcessed()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.DataBinder#isAutoGrowNestedPaths()",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public boolean isAutoGrowNestedPaths()",
    "documentation": "\t/**\n\t * Return whether \"auto-growing\" of nested paths has been activated.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isAutoGrowNestedPaths() {\n\t\treturn this.autoGrowNestedPaths;\n\t}",
    "query": "Enhance the data binding process by configuring nested property handling to prevent unintended object creation, thereby improving application performance and maintaining data integrity.",
    "function_signature": "public void configureStrictNestedPropertyHandling(DataBinder dataBinder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getBeanNameGenerator()",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public BeanNameGenerator getBeanNameGenerator()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic BeanNameGenerator getBeanNameGenerator() {\n\t\treturn this.beanNameGenerator;\n\t}",
    "query": "Improve the strategy for generating bean names to enhance application performance and maintainability.",
    "function_signature": "public BeanNameGenerator configureCustomBeanNameGenerator()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.interceptor.InvocationCallback",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "interface",
    "signature": "protected interface InvocationCallback",
    "documentation": "\t/**\n\t * Simple callback interface for proceeding with the target invocation.\n\t * Concrete interceptors/aspects adapt this to their invocation mechanism.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected interface InvocationCallback {\n\n\t\t@Nullable\n\t\tObject proceedWithInvocation() throws Throwable;\n\t}",
    "query": "Develop a transaction handling mechanism that ensures efficient execution flow and enhances type safety during method invocations.",
    "function_signature": "public interface TransactionExecutionCallback {\n    Object execute() throws Throwable;\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.OpLE",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "class",
    "signature": "public class OpLE",
    "documentation": "/**\n * Implements the less-than-or-equal operator.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Giovanni Dall'Oglio Risso\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public class OpLE extends Operator {\n\n\tpublic OpLE(int startPos, int endPos, SpelNodeImpl... operands) {\n\t\tsuper(\"<=\", startPos, endPos, operands);\n\t\tthis.exitTypeDescriptor = \"Z\";\n\t}\n\n\n\t@Override\n\tpublic BooleanTypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tObject left = getLeftOperand().getValueInternal(state).getValue();\n\t\tObject right = getRightOperand().getValueInternal(state).getValue();\n\n\t\tthis.leftActualDescriptor = CodeFlow.toDescriptorFromObject(left);\n\t\tthis.rightActualDescriptor = CodeFlow.toDescriptorFromObject(right);\n\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn BooleanTypedValue.forValue(leftBigDecimal.compareTo(rightBigDecimal) <= 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.doubleValue() <= rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.floatValue() <= rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn BooleanTypedValue.forValue(leftBigInteger.compareTo(rightBigInteger) <= 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.longValue() <= rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.intValue() <= rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.shortValue() <= rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.byteValue() <= rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtypes -> best guess is double comparison\n\t\t\t\treturn BooleanTypedValue.forValue(leftNumber.doubleValue() <= rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\treturn BooleanTypedValue.forValue(state.getTypeComparator().compare(left, right) <= 0);\n\t}\n\n\t@Override\n\tpublic boolean isCompilable() {\n\t\treturn isCompilableOperatorUsingNumerics();\n\t}\n\n\t@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tgenerateComparisonCode(mv, cf, IFGT, IF_ICMPGT);\n\t}\n\n}",
    "query": "Improve the efficiency and type safety of expression evaluations by adopting the recommended comparison approach in your application.",
    "function_signature": "public Boolean evaluateExpressionComparison(Object leftOperand, Object rightOperand)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.connection.SingleConnectionFactory#setReconnectOnException(reconnectOnException)",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public void setReconnectOnException(boolean reconnectOnException)",
    "documentation": "\t/**\n\t * Specify whether the single Connection should be reset (to be subsequently renewed)\n\t * when a JMSException is reported by the underlying Connection.\n\t * <p>Default is \"false\". Switch this to \"true\" to automatically trigger\n\t * recovery based on your JMS provider's exception notifications.\n\t * <p>Internally, this will lead to a special JMS ExceptionListener\n\t * (this SingleConnectionFactory itself) being registered with the\n\t * underlying Connection. This can also be combined with a\n\t * user-specified ExceptionListener, if desired.\n\t * @see #setExceptionListener\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setReconnectOnException(boolean reconnectOnException) {\n\t\tthis.reconnectOnException = reconnectOnException;\n\t}",
    "query": "Enhance the resilience of your JMS connection by configuring a robust exception handling mechanism that automatically manages connection recovery, ensuring optimal performance and stability.",
    "function_signature": "public void setupAdvancedExceptionHandling(ExceptionListener exceptionListener)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.ExtendedEntityManagerCreator#getOrder()",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public int getOrder()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int getOrder() {\n\t\t\treturn EntityManagerFactoryUtils.ENTITY_MANAGER_SYNCHRONIZATION_ORDER - 1;\n\t\t}",
    "query": "Design a component that assigns execution precedence efficiently, enhancing performance and thread safety by utilizing the most recent framework utilities.",
    "function_signature": "public int determineExecutionPriority()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.<unknown>#hashCode()",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int hashCode() {\n\t\treturn getSignature().hashCode();\n\t}",
    "query": "Refactor the object hashing logic to improve performance and ensure thread safety in your Spring application.",
    "function_signature": "public int computeObjectHash()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.WebUtils#getResponseEncodedHtmlEscape(servletContext)",
    "from_version": "v6.2.0-M6",
    "to_version": "v5.3.38",
    "type": "method",
    "signature": "public Boolean getResponseEncodedHtmlEscape(@Nullable ServletContext servletContext)",
    "documentation": "\t/**\n\t * Return whether response encoding should be used when HTML escaping characters,\n\t * thus only escaping XML markup significant characters with UTF-* encodings.\n\t * This option is enabled for the web application with a ServletContext param,\n\t * i.e. the value of the \"responseEncodedHtmlEscape\" context-param in {@code web.xml}\n\t * (if any).\n\t * <p>This method differentiates between no param specified at all and\n\t * an actual boolean value specified, allowing to have a context-specific\n\t * default in case of no setting at the global level.\n\t * @param servletContext the servlet context of the web application\n\t * @return whether response encoding is to be used for HTML escaping\n\t * ({@code null} = no explicit default)\n\t * @since 4.1.2\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static Boolean getResponseEncodedHtmlEscape(@Nullable ServletContext servletContext) {\n\t\tif (servletContext == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString param = servletContext.getInitParameter(RESPONSE_ENCODED_HTML_ESCAPE_CONTEXT_PARAM);\n\t\treturn (StringUtils.hasText(param) ? Boolean.valueOf(param) : null);\n\t}",
    "query": "Design a utility method that assesses the current configuration for HTML escaping within a Spring web application. Ensure that the approach leverages the latest configuration mechanisms to enhance security and maintainability, avoiding outdated practices that may compromise performance or flexibility.",
    "function_signature": "public Boolean evaluateHtmlEscapingConfiguration(ServletContext servletContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.<unknown>#list()",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public List<T> list()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic List<T> list() {\n\t\t\t\treturn namedParamOps.query(sql, namedParamSource, this.rowMapper);\n\t\t\t}",
    "query": "Implement a data access method that retrieves a list of products currently in stock, utilizing the latest simplified querying capabilities of Spring's JDBC module.",
    "function_signature": "public List<Product> listAvailableProducts()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#setupArgumentsForVarargsInvocation(requiredParameterTypes,args)",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args)",
    "documentation": "\t/**\n\t * Package up the supplied {@code args} so that they correctly match what is\n\t * expected in {@code requiredParameterTypes}.\n\t * <p>For example, if {@code requiredParameterTypes} is {@code (int, String[])}\n\t * because the second parameter was declared as {@code String...}, then if\n\t * {@code args} is {@code [1, \"a\", \"b\"]} it must be repackaged as\n\t * {@code [1, new String[] {\"a\", \"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be set up for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been performed\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\tAssert.notEmpty(requiredParameterTypes, \"Required parameter types array must not be empty\");\n\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tClass<?> lastRequiredParameterType = requiredParameterTypes[parameterCount - 1];\n\t\tAssert.isTrue(lastRequiredParameterType.isArray(),\n\t\t\t\t\"The last required parameter type must be an array to support varargs invocation\");\n\n\t\tint argumentCount = args.length;\n\t\tObject lastArgument = (argumentCount > 0 ? args[argumentCount - 1] : null);\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != argumentCount || !lastRequiredParameterType.isInstance(lastArgument)) {\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = lastRequiredParameterType.componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\n\t\treturn args;\n\t}",
    "query": "Create a utility method that dynamically invokes a target function accepting a mix of fixed and variable arguments. Ensure that the arguments are appropriately structured to match the target method's signature, especially handling cases where the number of provided arguments exceeds the fixed parameters.",
    "function_signature": "public Object invokeFunctionWithFlexibleArgs(String functionName, Class<?>[] fixedParamTypes, Object... args);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#handleResolvedValue(arg,name,parameter,message)",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Message<?> message)",
    "documentation": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param message the message\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void handleResolvedValue(",
    "query": "Develop a custom argument resolver that intercepts and processes resolved method arguments by accessing their names, types, and the originating message, enabling additional validation or transformation after argument resolution.",
    "function_signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.NamedValueInfo",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "class",
    "signature": "protected class NamedValueInfo",
    "documentation": "\t/**\n\t * Represents a named value declaration.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprotected NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}",
    "query": "Design a message processor that handles incoming user notifications. Ensure that each notification extracts the user's locale, which is optional and defaults to \"en_US\" if not provided. Additionally, the processor should mandate the presence of a timestamp for each notification to maintain chronological integrity.",
    "function_signature": "public void handleUserNotification(@Locale String locale, @Required @Timestamp String timestamp, NotificationPayload payload)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setPhase(phase)",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public void setPhase(int phase)",
    "documentation": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @since 6.1\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}",
    "query": "Implement a service that coordinates the startup sequence of multiple executors, ensuring that critical executors initialize in a specific order relative to other system components.",
    "function_signature": "public void configureExecutorStartupOrder(int phase)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.HttpComponentsHeadersAdapter#iterator()",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public List<String>>> iterator()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}",
    "query": "Design a method to efficiently traverse and log each HTTP header along with all its associated values from an incoming request, ensuring that headers with multiple entries are handled correctly.",
    "function_signature": "public Iterator<Map.Entry<String, List<String>>> logHttpRequestHeaders(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#toSingleValueMap()",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public String> toSingleValueMap()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}",
    "query": "Design a Spring service method that processes incoming HTTP requests by consolidating multiple header values into a single-value map, facilitating streamlined logging and analysis.",
    "function_signature": "public Map<String, String> consolidateRequestHeaders(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#fail(x)",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public void fail(Throwable x)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void fail(Throwable x) {\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(x);\n\t\t}",
    "query": "Design a feature that ensures any ongoing WebSocket communications are properly terminated and the client is informed when an unexpected error occurs during a reactive session.",
    "function_signature": "public void terminateSessionOnError(Throwable error)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.DefaultTransactionDefinition",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "class",
    "signature": "public class DefaultTransactionDefinition",
    "documentation": "/**\n * Default implementation of the {@link TransactionDefinition} interface,\n * offering bean-style configuration and sensible default values\n * (PROPAGATION_REQUIRED, ISOLATION_DEFAULT, TIMEOUT_DEFAULT, readOnly=false).\n *\n * <p>Base class for both {@link TransactionTemplate} and\n * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 08.05.2003\n */",
    "changetype": "stabilized",
    "source_code": "public class DefaultTransactionDefinition implements TransactionDefinition, Serializable {\n\n\t/** Prefix for the propagation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_PROPAGATION = \"PROPAGATION_\";\n\n\t/** Prefix for the isolation constants defined in TransactionDefinition. */\n\tpublic static final String PREFIX_ISOLATION = \"ISOLATION_\";\n\n\t/** Prefix for transaction timeout values in description strings. */\n\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";\n\n\t/** Marker for read-only transactions in description strings. */\n\tpublic static final String READ_ONLY_MARKER = \"readOnly\";\n\n\n\t/**\n\t * Map of constant names to constant values for the propagation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> propagationConstants = Map.of(\n\t\t\t\"PROPAGATION_REQUIRED\", TransactionDefinition.PROPAGATION_REQUIRED,\n\t\t\t\"PROPAGATION_SUPPORTS\", TransactionDefinition.PROPAGATION_SUPPORTS,\n\t\t\t\"PROPAGATION_MANDATORY\", TransactionDefinition.PROPAGATION_MANDATORY,\n\t\t\t\"PROPAGATION_REQUIRES_NEW\", TransactionDefinition.PROPAGATION_REQUIRES_NEW,\n\t\t\t\"PROPAGATION_NOT_SUPPORTED\", TransactionDefinition.PROPAGATION_NOT_SUPPORTED,\n\t\t\t\"PROPAGATION_NEVER\", TransactionDefinition.PROPAGATION_NEVER,\n\t\t\t\"PROPAGATION_NESTED\", TransactionDefinition.PROPAGATION_NESTED\n\t\t);\n\n\t/**\n\t * Map of constant names to constant values for the isolation constants\n\t * defined in {@link TransactionDefinition}.\n\t */\n\tstatic final Map<String, Integer> isolationConstants = Map.of(\n\t\t\t\"ISOLATION_DEFAULT\", TransactionDefinition.ISOLATION_DEFAULT,\n\t\t\t\"ISOLATION_READ_UNCOMMITTED\", TransactionDefinition.ISOLATION_READ_UNCOMMITTED,\n\t\t\t\"ISOLATION_READ_COMMITTED\", TransactionDefinition.ISOLATION_READ_COMMITTED,\n\t\t\t\"ISOLATION_REPEATABLE_READ\", TransactionDefinition.ISOLATION_REPEATABLE_READ,\n\t\t\t\"ISOLATION_SERIALIZABLE\", TransactionDefinition.ISOLATION_SERIALIZABLE\n\t\t);\n\n\tprivate int propagationBehavior = PROPAGATION_REQUIRED;\n\n\tprivate int isolationLevel = ISOLATION_DEFAULT;\n\n\tprivate int timeout = TIMEOUT_DEFAULT;\n\n\tprivate boolean readOnly = false;\n\n\t@Nullable\n\tprivate String name;\n\n\n\t/**\n\t * Create a new {@code DefaultTransactionDefinition} with default settings.\n\t * Can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition() {\n\t}\n\n\t/**\n\t * Copy constructor. Definition can be modified through bean property setters.\n\t * @see #setPropagationBehavior\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t * @see #setName\n\t */\n\tpublic DefaultTransactionDefinition(TransactionDefinition other) {\n\t\tthis.propagationBehavior = other.getPropagationBehavior();\n\t\tthis.isolationLevel = other.getIsolationLevel();\n\t\tthis.timeout = other.getTimeout();\n\t\tthis.readOnly = other.isReadOnly();\n\t\tthis.name = other.getName();\n\t}\n\n\t/**\n\t * Create a new {@code DefaultTransactionDefinition} with the given\n\t * propagation behavior. Can be modified through bean property setters.\n\t * @param propagationBehavior one of the propagation constants in the\n\t * TransactionDefinition interface\n\t * @see #setIsolationLevel\n\t * @see #setTimeout\n\t * @see #setReadOnly\n\t */\n\tpublic DefaultTransactionDefinition(int propagationBehavior) {\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\n\t/**\n\t * Set the propagation behavior by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"PROPAGATION_REQUIRED\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code PROPAGATION_} constants or is {@code null}\n\t * @see #setPropagationBehavior\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehaviorName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger propagationBehavior = propagationConstants.get(constantName);\n\t\tAssert.notNull(propagationBehavior, \"Only propagation behavior constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t/**\n\t * Set the propagation behavior. Must be one of the propagation constants\n\t * in the TransactionDefinition interface. Default is PROPAGATION_REQUIRED.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code PROPAGATION_} constants\n\t * @see #PROPAGATION_REQUIRED\n\t */\n\tpublic final void setPropagationBehavior(int propagationBehavior) {\n\t\tAssert.isTrue(propagationConstants.containsValue(propagationBehavior),\n\t\t\t\t\"Only values of propagation constants allowed\");\n\t\tthis.propagationBehavior = propagationBehavior;\n\t}\n\n\t@Override\n\tpublic final int getPropagationBehavior() {\n\t\treturn this.propagationBehavior;\n\t}\n\n\t/**\n\t * Set the isolation level by the name of the corresponding constant in\n\t * {@link TransactionDefinition} &mdash; for example, {@code \"ISOLATION_DEFAULT\"}.\n\t * @param constantName name of the constant\n\t * @throws IllegalArgumentException if the supplied value is not resolvable\n\t * to one of the {@code ISOLATION_} constants or is {@code null}\n\t * @see #setIsolationLevel\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevelName(String constantName) throws IllegalArgumentException {\n\t\tAssert.hasText(constantName, \"'constantName' must not be null or blank\");\n\t\tInteger isolationLevel = isolationConstants.get(constantName);\n\t\tAssert.notNull(isolationLevel, \"Only isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t/**\n\t * Set the isolation level. Must be one of the isolation constants\n\t * in the TransactionDefinition interface. Default is ISOLATION_DEFAULT.\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions. Consider switching the \"validateExistingTransactions\" flag to\n\t * \"true\" on your transaction manager if you'd like isolation level declarations\n\t * to get rejected when participating in an existing transaction with a different\n\t * isolation level.\n\t * <p>Note that a transaction manager that does not support custom isolation levels\n\t * will throw an exception when given any other level than {@link #ISOLATION_DEFAULT}.\n\t * @throws IllegalArgumentException if the supplied value is not one of the\n\t * {@code ISOLATION_} constants\n\t * @see #ISOLATION_DEFAULT\n\t */\n\tpublic final void setIsolationLevel(int isolationLevel) {\n\t\tAssert.isTrue(isolationConstants.containsValue(isolationLevel),\n\t\t\t\t\"Only values of isolation constants allowed\");\n\t\tthis.isolationLevel = isolationLevel;\n\t}\n\n\t@Override\n\tpublic final int getIsolationLevel() {\n\t\treturn this.isolationLevel;\n\t}\n\n\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */\n\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a non-negative integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}\n\n\t@Override\n\tpublic final int getTimeout() {\n\t\treturn this.timeout;\n\t}\n\n\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */\n\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}\n\n\t@Override\n\tpublic final boolean isReadOnly() {\n\t\treturn this.readOnly;\n\t}\n\n\t/**\n\t * Set the name of this transaction. Default is none.\n\t * <p>This will be used as transaction name to be shown in a\n\t * transaction monitor, if applicable (for example, WebLogic's).\n\t */\n\tpublic final void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic final String getName() {\n\t\treturn this.name;\n\t}\n\n\n\t/**\n\t * This implementation compares the {@code toString()} results.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof TransactionDefinition && toString().equals(other.toString())));\n\t}\n\n\t/**\n\t * This implementation returns {@code toString()}'s hash code.\n\t * @see #toString()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>The format matches the one used by\n\t * {@link org.springframework.transaction.interceptor.TransactionAttributeEditor},\n\t * to be able to feed {@code toString} results into bean properties of type\n\t * {@link org.springframework.transaction.interceptor.TransactionAttribute}.\n\t * <p>Has to be overridden in subclasses for correct {@code equals}\n\t * and {@code hashCode} behavior. Alternatively, {@link #equals}\n\t * and {@link #hashCode} can be overridden themselves.\n\t * @see #getDefinitionDescription()\n\t * @see org.springframework.transaction.interceptor.TransactionAttributeEditor\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDefinitionDescription().toString();\n\t}\n\n\t/**\n\t * Return an identifying description for this transaction definition.\n\t * <p>Available to subclasses, for inclusion in their {@code toString()} result.\n\t */\n\tprotected final StringBuilder getDefinitionDescription() {\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(getPropagationBehaviorName(this.propagationBehavior));\n\t\tresult.append(',');\n\t\tresult.append(getIsolationLevelName(this.isolationLevel));\n\t\tif (this.timeout != TIMEOUT_DEFAULT) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(PREFIX_TIMEOUT).append(this.timeout);\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tresult.append(',');\n\t\t\tresult.append(READ_ONLY_MARKER);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static String getPropagationBehaviorName(int propagationBehavior) {\n\t\treturn switch(propagationBehavior) {\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRED -> \"PROPAGATION_REQUIRED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_SUPPORTS -> \"PROPAGATION_SUPPORTS\";\n\t\t\tcase TransactionDefinition.PROPAGATION_MANDATORY -> \"PROPAGATION_MANDATORY\";\n\t\t\tcase TransactionDefinition.PROPAGATION_REQUIRES_NEW -> \"PROPAGATION_REQUIRES_NEW\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NOT_SUPPORTED -> \"PROPAGATION_NOT_SUPPORTED\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NEVER -> \"PROPAGATION_NEVER\";\n\t\t\tcase TransactionDefinition.PROPAGATION_NESTED -> \"PROPAGATION_NESTED\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported propagation behavior: \" + propagationBehavior);\n\t\t};\n\t}\n\n\tstatic String getIsolationLevelName(int isolationLevel) {\n\t\treturn switch(isolationLevel) {\n\t\t\tcase TransactionDefinition.ISOLATION_DEFAULT -> \"ISOLATION_DEFAULT\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_UNCOMMITTED -> \"ISOLATION_READ_UNCOMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_READ_COMMITTED -> \"ISOLATION_READ_COMMITTED\";\n\t\t\tcase TransactionDefinition.ISOLATION_REPEATABLE_READ -> \"ISOLATION_REPEATABLE_READ\";\n\t\t\tcase TransactionDefinition.ISOLATION_SERIALIZABLE -> \"ISOLATION_SERIALIZABLE\";\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported isolation level: \" + isolationLevel);\n\t\t};\n\t}\n\n}",
    "query": "Develop a method that executes business operations within a transaction, allowing callers to specify custom transaction behaviors such as propagation settings and isolation levels to cater to diverse transactional requirements.",
    "function_signature": "public void executeWithCustomTransaction(TransactionDefinition transactionDefinition, Runnable operations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder#build()",
    "from_version": "v6.0.23",
    "to_version": "v6.1.12",
    "type": "method",
    "signature": "public String build()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String build() {\n\t\t\treturn fromMethodInternal(this.baseUrl, this.controllerType, this.method, this.argumentValues)\n\t\t\t\t\t.build().encode().toUriString();\n\t\t}",
    "query": "Create a method that dynamically generates the absolute URL for a specific action within a controller, ensuring the URL adapts to the current request context and controller mappings.",
    "function_signature": "public String generateActionUrl(Class<?> controllerClass, String actionName, Object... params)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.ExtendedEntityManagerCreator",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "class",
    "signature": "public class ExtendedEntityManagerCreator",
    "documentation": "/**\n * Delegate for creating a variety of {@link jakarta.persistence.EntityManager}\n * proxies that follow the JPA spec's semantics for \"extended\" EntityManagers.\n *\n * <p>Supports several variants of \"extended\" EntityManagers:\n * in particular, an \"application-managed extended EntityManager\", as defined\n * by {@link jakarta.persistence.EntityManagerFactory#createEntityManager()},\n * as well as a \"container-managed extended EntityManager\", as defined by\n * {@link jakarta.persistence.PersistenceContextType#EXTENDED}.\n *\n * <p>The original difference between \"application-managed\" and \"container-managed\"\n * was the need for explicit joining of an externally managed transaction through\n * the {@link EntityManager#joinTransaction()} method in the \"application\" case\n * versus the automatic joining on each user-level EntityManager operation in the\n * \"container\" case. As of JPA 2.1, both join modes are available with both kinds of\n * EntityManagers, so the difference between \"application-\" and \"container-managed\"\n * is now primarily in the join mode default and in the restricted lifecycle of a\n * container-managed EntityManager (i.e. tied to the object that it is injected into).\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @author Mark Paluch\n * @since 2.0\n * @see jakarta.persistence.EntityManagerFactory#createEntityManager()\n * @see jakarta.persistence.PersistenceContextType#EXTENDED\n * @see jakarta.persistence.EntityManager#joinTransaction()\n * @see SharedEntityManagerCreator\n */",
    "changetype": "deprecated",
    "source_code": "public abstract class ExtendedEntityManagerCreator {\n\n\tprivate static final Map<Class<?>, Class<?>[]> cachedEntityManagerInterfaces = new ConcurrentReferenceHashMap<>(4);\n\n\n\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t */\n\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, false);\n\t}\n\n\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t * @since 4.0\n\t */\n\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, synchronizedWithTransaction);\n\t}\n\n\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t */\n\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, true, true);\n\t}\n\n\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager()\n\t */\n\tpublic static EntityManager createContainerManagedEntityManager(EntityManagerFactory emf) {\n\t\treturn createContainerManagedEntityManager(emf, null, true);\n\t}\n\n\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */\n\tpublic static EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createContainerManagedEntityManager(emf, properties, true);\n\t}\n\n\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a container-managed EntityManager that expects container-driven lifecycle\n\t * management but may opt out of automatic transaction synchronization\n\t * @since 4.0\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */\n\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tAssert.notNull(emf, \"EntityManagerFactory must not be null\");\n\t\tif (emf instanceof EntityManagerFactoryInfo emfInfo) {\n\t\t\tEntityManager rawEntityManager = emfInfo.createNativeEntityManager(properties);\n\t\t\treturn createProxy(rawEntityManager, emfInfo, true, synchronizedWithTransaction);\n\t\t}\n\t\telse {\n\t\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\t\temf.createEntityManager(properties) : emf.createEntityManager());\n\t\t\treturn createProxy(rawEntityManager, null, null, null, null, true, synchronizedWithTransaction);\n\t\t}\n\t}\n\n\n\t/**\n\t * Actually create the EntityManager proxy.\n\t * @param rawEntityManager raw EntityManager\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @param containerManaged whether to follow container-managed EntityManager\n\t * or application-managed EntityManager semantics\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager proxy\n\t */\n\tprivate static EntityManager createProxy(EntityManager rawEntityManager,\n\t\t\tEntityManagerFactoryInfo emfInfo, boolean containerManaged, boolean synchronizedWithTransaction) {\n\n\t\tAssert.notNull(emfInfo, \"EntityManagerFactoryInfo must not be null\");\n\t\tJpaDialect jpaDialect = emfInfo.getJpaDialect();\n\t\tPersistenceUnitInfo pui = emfInfo.getPersistenceUnitInfo();\n\t\tBoolean jta = (pui != null ? pui.getTransactionType() == PersistenceUnitTransactionType.JTA : null);\n\t\treturn createProxy(rawEntityManager, emfInfo.getEntityManagerInterface(),\n\t\t\t\temfInfo.getBeanClassLoader(), jpaDialect, jta, containerManaged, synchronizedWithTransaction);\n\t}\n\n\t/**\n\t * Actually create the EntityManager proxy.\n\t * @param rawEm raw EntityManager\n\t * @param emIfc the (potentially vendor-specific) EntityManager\n\t * interface to proxy, or {@code null} for default detection of all interfaces\n\t * @param cl the ClassLoader to use for proxy creation (maybe {@code null})\n\t * @param exceptionTranslator the PersistenceException translator to use\n\t * @param jta whether to create a JTA-aware EntityManager\n\t * (or {@code null} if not known in advance)\n\t * @param containerManaged whether to follow container-managed EntityManager\n\t * or application-managed EntityManager semantics\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager proxy\n\t */\n\tprivate static EntityManager createProxy(\n\t\t\tEntityManager rawEm, @Nullable Class<? extends EntityManager> emIfc, @Nullable ClassLoader cl,\n\t\t\t@Nullable PersistenceExceptionTranslator exceptionTranslator, @Nullable Boolean jta,\n\t\t\tboolean containerManaged, boolean synchronizedWithTransaction) {\n\n\t\tAssert.notNull(rawEm, \"EntityManager must not be null\");\n\t\tClass<?>[] interfaces;\n\n\t\tif (emIfc != null) {\n\t\t\tinterfaces = cachedEntityManagerInterfaces.computeIfAbsent(emIfc, key -> {\n\t\t\t\tif (EntityManagerProxy.class.equals(key)) {\n\t\t\t\t\treturn new Class<?>[] {key};\n\t\t\t\t}\n\t\t\t\treturn new Class<?>[] {key, EntityManagerProxy.class};\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tinterfaces = cachedEntityManagerInterfaces.computeIfAbsent(rawEm.getClass(), key -> {\n\t\t\t\tSet<Class<?>> ifcs = new LinkedHashSet<>(ClassUtils.getAllInterfacesForClassAsSet(key, cl));\n\t\t\t\tifcs.add(EntityManagerProxy.class);\n\t\t\t\treturn ClassUtils.toClassArray(ifcs);\n\t\t\t});\n\t\t}\n\n\t\treturn (EntityManager) Proxy.newProxyInstance(\n\t\t\t\t(cl != null ? cl : ExtendedEntityManagerCreator.class.getClassLoader()),\n\t\t\t\tinterfaces,\n\t\t\t\tnew ExtendedEntityManagerInvocationHandler(\n\t\t\t\t\t\trawEm, exceptionTranslator, jta, containerManaged, synchronizedWithTransaction));\n\t}\n\n\n\t/**\n\t * InvocationHandler for extended EntityManagers as defined in the JPA spec.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static final class ExtendedEntityManagerInvocationHandler implements InvocationHandler, Serializable {\n\n\t\tprivate static final Log logger = LogFactory.getLog(ExtendedEntityManagerInvocationHandler.class);\n\n\t\tprivate final EntityManager target;\n\n\t\t@Nullable\n\t\tprivate final PersistenceExceptionTranslator exceptionTranslator;\n\n\t\tprivate final boolean jta;\n\n\t\tprivate final boolean containerManaged;\n\n\t\tprivate final boolean synchronizedWithTransaction;\n\n\t\tprivate ExtendedEntityManagerInvocationHandler(EntityManager target,\n\t\t\t\t@Nullable PersistenceExceptionTranslator exceptionTranslator, @Nullable Boolean jta,\n\t\t\t\tboolean containerManaged, boolean synchronizedWithTransaction) {\n\n\t\t\tthis.target = target;\n\t\t\tthis.exceptionTranslator = exceptionTranslator;\n\t\t\tthis.jta = (jta != null ? jta : isJtaEntityManager());\n\t\t\tthis.containerManaged = containerManaged;\n\t\t\tthis.synchronizedWithTransaction = synchronizedWithTransaction;\n\t\t}\n\n\t\tprivate boolean isJtaEntityManager() {\n\t\t\ttry {\n\t\t\t\tthis.target.getTransaction();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Cannot access EntityTransaction handle - assuming we're in a JTA environment\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on EntityManager interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of EntityManager proxy.\n\t\t\t\t\treturn hashCode();\n\t\t\t\tcase \"getTargetEntityManager\":\n\t\t\t\t\t// Handle EntityManagerProxy interface.\n\t\t\t\t\treturn this.target;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\t// Handle JPA 2.0 unwrap method - could be a proxy match.\n\t\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\t\tif (targetClass == null) {\n\t\t\t\t\t\treturn this.target;\n\t\t\t\t\t}\n\t\t\t\t\telse if (targetClass.isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"isOpen\":\n\t\t\t\t\tif (this.containerManaged) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"close\":\n\t\t\t\t\tif (this.containerManaged) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Invalid usage: Cannot close a container-managed EntityManager\");\n\t\t\t\t\t}\n\t\t\t\t\tExtendedEntityManagerSynchronization synch = (ExtendedEntityManagerSynchronization)\n\t\t\t\t\t\t\tTransactionSynchronizationManager.getResource(this.target);\n\t\t\t\t\tif (synch != null) {\n\t\t\t\t\t\t// Local transaction joined - don't actually call close() before transaction completion\n\t\t\t\t\t\tsynch.closeOnCompletion = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"getTransaction\":\n\t\t\t\t\tif (this.synchronizedWithTransaction) {\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Cannot obtain local EntityTransaction from a transaction-synchronized EntityManager\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"joinTransaction\":\n\t\t\t\t\tdoJoinTransaction(true);\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isJoinedToTransaction\":\n\t\t\t\t\t// Handle JPA 2.1 isJoinedToTransaction method for the non-JTA case.\n\t\t\t\t\tif (!this.jta) {\n\t\t\t\t\t\treturn TransactionSynchronizationManager.hasResource(this.target);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Do automatic joining if required. Excludes toString, equals, hashCode calls.\n\t\t\tif (this.synchronizedWithTransaction && method.getDeclaringClass().isInterface()) {\n\t\t\t\tdoJoinTransaction(false);\n\t\t\t}\n\n\t\t\t// Invoke method on current EntityManager.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.target, args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Join an existing transaction, if not already joined.\n\t\t * @param enforce whether to enforce the transaction\n\t\t * (i.e. whether failure to join is considered fatal)\n\t\t */\n\t\tprivate void doJoinTransaction(boolean enforce) {\n\t\t\tif (this.jta) {\n\t\t\t\t// Let's try whether we're in a JTA transaction.\n\t\t\t\ttry {\n\t\t\t\t\tthis.target.joinTransaction();\n\t\t\t\t\tlogger.debug(\"Joined JTA transaction\");\n\t\t\t\t}\n\t\t\t\tcatch (TransactionRequiredException ex) {\n\t\t\t\t\tif (!enforce) {\n\t\t\t\t\t\tlogger.debug(\"No JTA transaction to join: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\tif (!TransactionSynchronizationManager.hasResource(this.target) &&\n\t\t\t\t\t\t\t!this.target.getTransaction().isActive()) {\n\t\t\t\t\t\tenlistInCurrentTransaction();\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug(\"Joined local transaction\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!enforce) {\n\t\t\t\t\t\tlogger.debug(\"No local transaction to join\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new TransactionRequiredException(\"No local transaction to join\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Enlist this application-managed EntityManager in the current transaction.\n\t\t */\n\t\tprivate void enlistInCurrentTransaction() {\n\t\t\t// Resource local transaction, need to acquire the EntityTransaction,\n\t\t\t// start a transaction now and enlist a synchronization for commit or rollback later.\n\t\t\tEntityTransaction et = this.target.getTransaction();\n\t\t\tet.begin();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Starting resource-local transaction on application-managed \" +\n\t\t\t\t\t\t\"EntityManager [\" + this.target + \"]\");\n\t\t\t}\n\t\t\tExtendedEntityManagerSynchronization extendedEntityManagerSynchronization =\n\t\t\t\t\tnew ExtendedEntityManagerSynchronization(this.target, this.exceptionTranslator);\n\t\t\tTransactionSynchronizationManager.bindResource(this.target, extendedEntityManagerSynchronization);\n\t\t\tTransactionSynchronizationManager.registerSynchronization(extendedEntityManagerSynchronization);\n\t\t}\n\t}\n\n\n\t/**\n\t * TransactionSynchronization enlisting an extended EntityManager\n\t * with a current Spring transaction.\n\t */\n\tprivate static class ExtendedEntityManagerSynchronization\n\t\t\textends ResourceHolderSynchronization<EntityManagerHolder, EntityManager>\n\t\t\timplements Ordered {\n\n\t\tprivate final EntityManager entityManager;\n\n\t\t@Nullable\n\t\tprivate final PersistenceExceptionTranslator exceptionTranslator;\n\n\t\tpublic volatile boolean closeOnCompletion;\n\n\t\tpublic ExtendedEntityManagerSynchronization(\n\t\t\t\tEntityManager em, @Nullable PersistenceExceptionTranslator exceptionTranslator) {\n\n\t\t\tsuper(new EntityManagerHolder(em), em);\n\t\t\tthis.entityManager = em;\n\t\t\tthis.exceptionTranslator = exceptionTranslator;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn EntityManagerFactoryUtils.ENTITY_MANAGER_SYNCHRONIZATION_ORDER - 1;\n\t\t}\n\n\t\t@Override\n\t\tprotected void flushResource(EntityManagerHolder resourceHolder) {\n\t\t\ttry {\n\t\t\t\tthis.entityManager.flush();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tthrow convertException(ex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean shouldReleaseBeforeCompletion() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterCommit() {\n\t\t\tsuper.afterCommit();\n\t\t\t// Trigger commit here to let exceptions propagate to the caller.\n\t\t\ttry {\n\t\t\t\tthis.entityManager.getTransaction().commit();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tthrow convertException(ex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterCompletion(int status) {\n\t\t\ttry {\n\t\t\t\tsuper.afterCompletion(status);\n\t\t\t\tif (status != STATUS_COMMITTED) {\n\t\t\t\t\t// Haven't had an afterCommit call: trigger a rollback.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.entityManager.getTransaction().rollback();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow convertException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (this.closeOnCompletion) {\n\t\t\t\t\tEntityManagerFactoryUtils.closeEntityManager(this.entityManager);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate RuntimeException convertException(RuntimeException ex) {\n\t\t\tDataAccessException dae = (this.exceptionTranslator != null) ?\n\t\t\t\t\tthis.exceptionTranslator.translateExceptionIfPossible(ex) :\n\t\t\t\t\tEntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex);\n\t\t\treturn (dae != null ? dae : ex);\n\t\t}\n\t}\n\n}",
    "query": "Design a utility method that provides a seamlessly integrated `EntityManager` proxy, optimizing transaction management and enhancing thread safety within a Spring-based JPA application.",
    "function_signature": "public static EntityManager createEntityManagerProxy(EntityManagerFactory entityManagerFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.expression.CachedExpressionEvaluator#getParser()",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "protected SpelExpressionParser getParser()",
    "documentation": "\t/**\n\t * Return the {@link SpelExpressionParser} to use.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected SpelExpressionParser getParser() {\n\t\treturn this.parser;\n\t}",
    "query": "Develop a method that provides an efficient and thread-safe parser for evaluating expressions in high-concurrency scenarios.",
    "function_signature": "public ExpressionParser createThreadSafeParser();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.AbstractResource#getFileForLastModifiedCheck()",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "protected File getFileForLastModifiedCheck()",
    "documentation": "\t/**\n\t * Determine the File to use for timestamp checking.\n\t * <p>The default implementation delegates to {@link #getFile()}.\n\t * @return the File to use for timestamp checking (never {@code null})\n\t * @throws FileNotFoundException if the resource cannot be resolved as\n\t * an absolute file path, i.e. is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected File getFileForLastModifiedCheck() throws IOException {\n\t\treturn getFile();\n\t}",
    "query": "Refactor the resource timestamp verification to utilize the latest I/O APIs, enhancing performance and reliability without depending on absolute file paths.",
    "function_signature": "protected Path resolveTimestampPath() throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.support.converter.MessagingMessageConverter#afterPropertiesSet()",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "public void afterPropertiesSet()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tAssert.notNull(this.payloadConverter, \"Property 'payloadConverter' is required\");\n\t\tAssert.notNull(this.headerMapper, \"Property 'headerMapper' is required\");\n\t}",
    "query": "Enhance the message conversion process by initializing necessary components through a more efficient and safer approach, eliminating the need for explicit property checks.",
    "function_signature": "public void configureMessageConverter(MessageConverter payloadConverter, HeaderMapper<?> headerMapper)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.ObjectUtils#nullSafeHashCode(array)",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "public int nullSafeHashCode(@Nullable short[] array)",
    "documentation": "\t/**\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static int nullSafeHashCode(@Nullable short[] array) {\n\t\tif (array == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tint hash = INITIAL_HASH;\n\t\tfor (short element : array) {\n\t\t\thash = MULTIPLIER * hash + element;\n\t\t}\n\t\treturn hash;\n\t}",
    "query": "Create a utility method that efficiently computes a hash code for an array of short values, ensuring it gracefully handles null inputs and optimizes performance for large datasets.",
    "function_signature": "public int computeOptimizedHashCode(@Nullable short[] shorts)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.support.converter.MappingJackson2MessageConverter#convertFromBytesMessage(message,targetJavaType)",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "protected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)",
    "documentation": "\t/**\n\t * Convert a BytesMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)",
    "query": "Refactor the message processing logic to enhance reliability and maintainability when converting incoming binary JMS messages to their corresponding Java objects.",
    "function_signature": "protected <T> T deserializeMessage(BytesMessage message, Class<T> targetClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.DispatcherServlet#setCleanupAfterInclude(cleanupAfterInclude)",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "public void setCleanupAfterInclude(boolean cleanupAfterInclude)",
    "documentation": "\t/**\n\t * Set whether to perform cleanup of request attributes after an include request, that is,\n\t * whether to reset the original state of all request attributes after the DispatcherServlet\n\t * has processed within an include request. Otherwise, just the DispatcherServlet's own\n\t * request attributes will be reset, but not model attributes for JSPs or special attributes\n\t * set by views (for example, JSTL's).\n\t * <p>Default is \"true\", which is strongly recommended. Views should not rely on request attributes\n\t * having been set by (dynamic) includes. This allows JSP views rendered by an included controller\n\t * to use any model attributes, even with the same names as in the main JSP, without causing side\n\t * effects. Only turn this off for special needs, for example to deliberately allow main JSPs to\n\t * access attributes from JSP views rendered by an included controller.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setCleanupAfterInclude(boolean cleanupAfterInclude) {\n\t\tthis.cleanupAfterInclude = cleanupAfterInclude;\n\t}",
    "query": "Configure the DispatcherServlet to automatically manage request attributes after processing include operations, ensuring attribute consistency and minimizing potential conflicts within your web application.",
    "function_signature": "public void enableAutomaticAttributeManagement(boolean enable)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.INDEX_ATTRIBUTE",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "field",
    "signature": "public String INDEX_ATTRIBUTE",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static final String INDEX_ATTRIBUTE = \"index\";",
    "query": "Enhance the efficiency of XML-based bean configuration by implementing a method that manages bean indexing with improved performance and safety considerations.",
    "function_signature": "public void manageBeanIndexing(ConfigurableApplicationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.MethodParameter#getParameterIndex()",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "public int getParameterIndex()",
    "documentation": "\t/**\n\t * Return the index of the method/constructor parameter.\n\t * @return the parameter index (-1 in case of the return type)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic int getParameterIndex() {\n\t\treturn this.parameterIndex;\n\t}",
    "query": "Design a utility function that determines the position of a specific parameter within a given method or constructor, prioritizing performance and type safety.",
    "function_signature": "public int findParameterPosition(MethodParameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry#success(result)",
    "from_version": "v6.0.7",
    "to_version": "v5.3.26",
    "type": "method",
    "signature": "public void success(@Nullable T result)",
    "documentation": "\t/**\n\t * Trigger a {@link ListenableFutureCallback#onSuccess(Object)} call on all\n\t * added callbacks with the given result.\n\t * @param result the result to trigger the callbacks with\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void success(@Nullable T result) {\n\t\tsynchronized (this.mutex) {\n\t\t\tthis.state = State.SUCCESS;\n\t\t\tthis.result = result;\n\t\t\tSuccessCallback<? super T> callback;\n\t\t\twhile ((callback = this.successCallbacks.poll()) != null) {\n\t\t\t\tnotifySuccess(callback);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Enhance the application's asynchronous workflow to improve thread safety and performance by utilizing a contemporary callback mechanism.",
    "function_signature": "public CompletableFuture<T> processAsyncResult()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.support.SQLErrorCodes#setTransientDataAccessResourceCodes(transientDataAccessResourceCodes)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public void setTransientDataAccessResourceCodes(String... transientDataAccessResourceCodes)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setTransientDataAccessResourceCodes(String... transientDataAccessResourceCodes) {\n\t\tthis.transientDataAccessResourceCodes = StringUtils.sortStringArray(transientDataAccessResourceCodes);\n\t}",
    "query": "Enhance your application's error handling by efficiently managing transient data access resource identifiers, ensuring scalability and improved performance.",
    "function_signature": "public void configureTransientResourceIdentifiers(List<String> resourceIdentifiers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#wasNull()",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public boolean wasNull()",
    "documentation": "\t/**\n\t * @see java.sql.ResultSet#wasNull()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean wasNull() throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.wasNull();\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}",
    "query": "Develop a method to ascertain whether the most recently accessed column in a database query result lacks a value, prioritizing direct interaction with the underlying data source to enhance performance and reduce error handling complexity.",
    "function_signature": "public boolean isLastColumnValueNull()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.Assert#state(expression,message)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public void state(boolean expression, String message)",
    "documentation": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static void state(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(message);\n\t\t}\n\t}",
    "query": "Implement a validation check to ensure that a critical condition is met before proceeding with the operation. If the condition fails, provide a descriptive error message to aid in debugging.",
    "function_signature": "public void validateCondition(boolean condition, String errorMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.<unknown>#test(status)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public boolean test(HttpStatusCode status)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic boolean test(HttpStatusCode status) {\n\t\t\t\treturn this.predicate.test(status);\n\t\t\t}",
    "query": "Develop a method that assesses the provided HTTP status code for success, optimizing for performance and reliability.",
    "function_signature": "public boolean isSuccessful(HttpStatusCode status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.test.tools.DynamicClassLoader#getInputStream()",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public InputStream getInputStream()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic InputStream getInputStream() {\n\t\t\treturn new ByteArrayInputStream(this.bytesSupplier.get());\n\t\t}",
    "query": "Enhance class loading by implementing a method that efficiently retrieves class byte data using a modern, stream-based approach to improve performance and safety.",
    "function_signature": "public InputStream fetchClassBytesStream()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.ResponseStatusException#getMessage()",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public String getMessage()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getMessage() {\n\t\treturn getStatusCode() + (this.reason != null ? \" \\\"\" + this.reason + \"\\\"\" : \"\");\n\t}",
    "query": "Implement a method to obtain both the HTTP status code and the specific reason from a ResponseStatusException, ensuring each piece of information is accessed separately for enhanced clarity and maintainability.",
    "function_signature": "public ErrorDetails extractErrorDetails(ResponseStatusException exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectivePropertyAccessor#equals(other)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof PropertyCacheKey that &&\n\t\t\t\t\tthis.clazz == that.clazz && this.property.equals(that.property) &&\n\t\t\t\t\tthis.targetIsClass == that.targetIsClass));\n\t\t}",
    "query": "Ensure that your custom property accessors can be accurately compared and efficiently reused within Spring's expression evaluations to enhance application performance.",
    "function_signature": "@Override\npublic boolean equals(@Nullable Object other)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer#getDeleteStatement(values)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "protected String getDeleteStatement(long[] values)",
    "documentation": "\t/**\n\t * Statement to use to clean up \"sequence\" values.\n\t * <p>The default implementation either deletes the entire range below\n\t * the current maximum value, or the specifically generated values\n\t * (starting with the lowest minus 1, just preserving the maximum value)\n\t * - according to the {@link #isDeleteSpecificValues()} setting.\n\t * @param values the currently generated key values\n\t * (the number of values corresponds to {@link #getCacheSize()})\n\t * @return the SQL statement to use\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected String getDeleteStatement(long[] values) {\n\t\tStringBuilder sb = new StringBuilder(64);\n\t\tsb.append(\"delete from \").append(getIncrementerName()).append(\" where \").append(getColumnName());\n\t\tif (isDeleteSpecificValues()) {\n\t\t\tsb.append(\" in (\").append(values[0] - 1);\n\t\t\tfor (int i = 0; i < values.length - 1; i++) {\n\t\t\t\tsb.append(\", \").append(values[i]);\n\t\t\t}\n\t\t\tsb.append(')');\n\t\t}\n\t\telse {\n\t\t\tlong maxValue = values[values.length - 1];\n\t\t\tsb.append(\" < \").append(maxValue);\n\t\t}\n\t\treturn sb.toString();\n\t}",
    "query": "Design a robust solution to remove outdated sequence entries from your database. Ensure the approach enhances performance and reduces potential vulnerabilities by utilizing contemporary data handling practices.",
    "function_signature": "protected String generateCleanupSql(long[] currentKeys)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#formField(name,values)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public B formField(String name, String... values)",
    "documentation": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic B formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}",
    "query": "Enhance form data handling by implementing a method that associates multiple values with a single form field in a test HTTP request, ensuring better performance and safer parameter management.",
    "function_signature": "public B addFormParameters(String name, List<String> values)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.support.RequestContext#getThemeMessage(resolvable)",
    "from_version": "v7.0.0-M1",
    "to_version": "v6.1.17",
    "type": "method",
    "signature": "public String getThemeMessage(MessageSourceResolvable resolvable)",
    "documentation": "\t/**\n\t * Retrieve the given MessageSourceResolvable in the current theme.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param resolvable the MessageSourceResolvable\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String getThemeMessage(MessageSourceResolvable resolvable) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(resolvable, getLocale());\n\t}",
    "query": "Create a Spring service that fetches the appropriate theme-specific asset paths based on the user's selected theme, ensuring that the paths are accurately resolved within the active theme context.",
    "function_signature": "public String fetchThemeAssetPath(MessageSourceResolvable assetResolvable)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.DispatcherHandler#initStrategies(context)",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "protected void initStrategies(ApplicationContext context)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void initStrategies(ApplicationContext context) {\n\t\tMap<String, HandlerMapping> mappingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\tcontext, HandlerMapping.class, true, false);\n\n\t\tArrayList<HandlerMapping> mappings = new ArrayList<>(mappingBeans.values());\n\t\tAnnotationAwareOrderComparator.sort(mappings);\n\t\tthis.handlerMappings = Collections.unmodifiableList(mappings);\n\n\t\tMap<String, HandlerAdapter> adapterBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\tcontext, HandlerAdapter.class, true, false);\n\n\t\tthis.handlerAdapters = new ArrayList<>(adapterBeans.values());\n\t\tAnnotationAwareOrderComparator.sort(this.handlerAdapters);\n\n\t\tMap<String, HandlerResultHandler> beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\tcontext, HandlerResultHandler.class, true, false);\n\n\t\tthis.resultHandlers = new ArrayList<>(beans.values());\n\t\tAnnotationAwareOrderComparator.sort(this.resultHandlers);\n\t}",
    "query": "Develop a method that aggregates and orders various handler components to streamline reactive request processing in your Spring application.",
    "function_signature": "protected void aggregateHandlerComponents(ApplicationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#isRequestedSessionIdFromUrl()",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public boolean isRequestedSessionIdFromUrl()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isRequestedSessionIdFromUrl() {\n\t\treturn isRequestedSessionIdFromURL();\n\t}",
    "query": "Enhance your mock HTTP servlet request handling by implementing a method that determines whether the session ID was transmitted via the URL, ensuring improved accuracy and compliance with current Spring Framework standards.",
    "function_signature": "public boolean isRequestedSessionIdFromURL()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.rsocket.service.RSocketServiceProxyFactory#setCustomArgumentResolvers(resolvers)",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public void setCustomArgumentResolvers(List<RSocketServiceArgumentResolver> resolvers)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void setCustomArgumentResolvers(List<RSocketServiceArgumentResolver> resolvers) {\n\t\t\tthis.customArgumentResolvers = new ArrayList<>(resolvers);\n\t\t}",
    "query": "Improve the configuration of your RSocket service proxies by adopting the modern strategy for managing argument resolvers, enhancing both performance and ease of use.",
    "function_signature": "public void configureArgumentResolvers(ArgumentResolverConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#setConversionService(conversionService)",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public void setConversionService(ConversionService conversionService)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void setConversionService(ConversionService conversionService) {\n\t\t\tthis.conversionService = conversionService;\n\t\t}",
    "query": "Refactor your HTTP service proxy setup to utilize the enhanced configuration approach, ensuring improved type safety and performance when managing data conversions within the factory.",
    "function_signature": "public HttpServiceProxyFactoryBuilder withConversionService(ConversionService conversionService)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.DispatcherHandler#handlePreFlight(exchange)",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public Mono<Void> handlePreFlight(ServerWebExchange exchange)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Mono<Void> handlePreFlight(ServerWebExchange exchange) {\n\t\treturn Flux.fromIterable(this.handlerMappings != null ? this.handlerMappings : Collections.emptyList())\n\t\t\t\t.concatMap(mapping -> mapping.getHandler(exchange))\n\t\t\t\t.switchIfEmpty(Mono.fromRunnable(() -> exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN)))\n\t\t\t\t.next()\n\t\t\t\t.then();\n\t}",
    "query": "Ensure your Spring WebFlux application gracefully handles preflight OPTIONS requests to comply with cross-origin policies.",
    "function_signature": "public Mono<Void> handlePreflightOptions(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getConnectionId()",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public String getConnectionId()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic String getConnectionId() {\n\t\t\t\treturn MockHttpServletRequest.this.getRequestId();\n\t\t\t}",
    "query": "Design a unit test scenario where retrieving a unique connection identifier from a mock HTTP request is essential for tracking and verifying the association between requests and their originating connections.",
    "function_signature": "public String fetchRequestConnectionId(MockHttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.rsocket.<unknown>#mimeType()",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public MimeType mimeType()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic MimeType mimeType() {\n\t\t\treturn this.mimeType;\n\t\t}",
    "query": "Design a service method that selects the appropriate media type for outgoing RSocket messages based on dynamic runtime conditions, ensuring optimal content negotiation between client and server.",
    "function_signature": "public MimeType determineMessageMimeType(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.DispatcherHandler#setApplicationContext(applicationContext)",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tinitStrategies(applicationContext);\n\t}",
    "query": "Optimize the initialization process of your reactive web application's request handling by ensuring that all necessary strategies are configured based on the current application context during startup.",
    "function_signature": "public void configureReactiveDispatcher(ApplicationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getServletConnection()",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public ServletConnection getServletConnection()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic ServletConnection getServletConnection() {\n\t\treturn new ServletConnection() {\n\t\t\t@Override\n\t\t\tpublic String getConnectionId() {\n\t\t\t\treturn MockHttpServletRequest.this.getRequestId();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getProtocol() {\n\t\t\t\treturn MockHttpServletRequest.this.getProtocol();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getProtocolConnectionId() {\n\t\t\t\treturn MockHttpServletRequest.this.getProtocolRequestId();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSecure() {\n\t\t\t\treturn MockHttpServletRequest.this.isSecure();\n\t\t\t}\n\t\t};\n\t}",
    "query": "Create a unit test that verifies the connection metadatasuch as connection ID and protocol detailsof a simulated HTTP request to ensure accurate handling of secure and non-secure connections.",
    "function_signature": "public ServletConnection retrieveConnectionMetadata(MockHttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getProtocolConnectionId()",
    "from_version": "v6.0.0-RC3",
    "to_version": "v6.0.0-RC4",
    "type": "method",
    "signature": "public String getProtocolConnectionId()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic String getProtocolConnectionId() {\n\t\t\t\treturn MockHttpServletRequest.this.getProtocolRequestId();\n\t\t\t}",
    "query": "Design a testing utility that assigns and retrieves a distinct identifier for each simulated HTTP request's protocol connection. This ensures that concurrent requests during integration tests can be accurately tracked and managed without interference.",
    "function_signature": "public String retrieveUniqueConnectionId(MockHttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Implement a mechanism to append a timestamp to the model after controller execution and before the view is rendered.",
    "function_signature": "public void appendTimestamp(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design a mechanism to dynamically retrieve and utilize the path matching strategy from a configured interceptor, enabling conditional processing based on complex URL patterns.",
    "function_signature": "public PathMatcher getInterceptorPathMatcher(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a request interceptor that selectively processes incoming HTTP requests based on dynamic path patterns. Ensure that the interceptor efficiently determines applicability without manually parsing URLs.",
    "function_signature": "public boolean shouldIntercept(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "In setting up a Spring MVC application, you need to implement a diagnostic tool that examines and logs all the URL patterns an interceptor is configured to handle. This tool should efficiently access and display the specific path patterns associated with the interceptor to aid in monitoring and debugging request handling.",
    "function_signature": "public void logInterceptorPathPatterns(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Create a Spring interceptor that dynamically determines whether to apply additional processing based on the details of each incoming HTTP request, allowing for more precise control over request handling.",
    "function_signature": "public boolean shouldIntercept(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PathPattern[] includePatterns;\n\n\t@Nullable\n\tprivate final PathPattern[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\t@Nullable\n\tprivate static PathPattern[] initPatterns(\n\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\treturn null;\n\t\t}\n\t\tparser = (parser != null ? parser : PathPatternParser.defaultInstance);\n\t\treturn Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchPattern(Object path, boolean isPathContainer, PathPattern pattern) {\n\t\treturn (isPathContainer ?\n\t\t\t\tpattern.matches((PathContainer) path) :\n\t\t\t\tthis.pathMatcher.match(pattern.getPatternString(), (String) path));\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n}",
    "query": "Design a security feature that intercepts requests to all user-related endpoints except for public registration and login paths. Ensure that the interceptor efficiently matches the specified URL patterns to apply the necessary security checks.",
    "function_signature": "public void configureSecurityInterceptor(String[] includePaths, String[] excludePaths, HandlerInterceptor securityInterceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Design a feature that allows you to apply a specific interceptor only to designated URL patterns within your Spring MVC application, optimizing request handling for those paths without impacting others.",
    "function_signature": "public HandlerInterceptor createInterceptorForPatterns(String... patterns)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a feature that executes specific cleanup operations after each HTTP request is fully processed, capturing any exceptions that may have occurred during handling.",
    "function_signature": "public void handleRequestCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Create a component that intercepts incoming HTTP requests to execute custom logic before they reach the designated controller, allowing selective processing based on request attributes.",
    "function_signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.7.RELEASE",
    "to_version": "v5.3.0-M1",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Implement a request interceptor that applies intricate URL pattern matching using a tailored strategy to ensure precise request handling in your Spring MVC application.",
    "function_signature": "public MappedInterceptor mappedInterceptorWithCustomPathMatcher(CustomPathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.PAGE_NOT_FOUND_LOG_CATEGORY",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "field",
    "signature": "public String PAGE_NOT_FOUND_LOG_CATEGORY",
    "documentation": "\t/** Log category to use when no mapped handler is found for a request. */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String PAGE_NOT_FOUND_LOG_CATEGORY = \"org.springframework.web.servlet.PageNotFound\";",
    "query": "Implement a mechanism to log all 404 errors using a specific logging category to enhance traceability of missing resources.",
    "function_signature": "public void setupNotFoundErrorLogging(Logger logger, String logCategory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.type.classreading.<unknown>#getReturnTypeName()",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "public String getReturnTypeName()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getReturnTypeName() {\n\t\treturn this.returnTypeName;\n\t}",
    "query": "Design a component that analyzes service layer methods to log their return types dynamically at runtime, enhancing debugging and monitoring without manually specifying each return type.",
    "function_signature": "public void logServiceMethodReturnTypes(Class<?> serviceClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.invocation.reactive.InvocableHandlerMethod#setParameterNameDiscoverer(nameDiscoverer)",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer nameDiscoverer)",
    "documentation": "\t/**\n\t * Set the ParameterNameDiscoverer for resolving parameter names when needed\n\t * (e.g. default request attribute name).\n\t * <p>Default is a {@link DefaultParameterNameDiscoverer}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer nameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = nameDiscoverer;\n\t}",
    "query": "Design a reactive message processing component that leverages a custom strategy for resolving handler method parameter names to accommodate complex binding scenarios.",
    "function_signature": "public void configureParameterNameResolver(ParameterNameDiscoverer resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#toString()",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn \"ResourceHttpRequestHandler \" + locationToString(getLocations());\n\t}",
    "query": "Create a feature that generates a comprehensive string summary of all static resource handlers in your Spring application, facilitating easy monitoring and debugging of resource configurations.",
    "function_signature": "public String summarizeStaticResourceHandlers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.dao.support.DataAccessUtils#longResult(results)",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "public long longResult(@Nullable Collection<?> results)",
    "documentation": "\t/**\n\t * Return a unique long result from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to a long.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique long result\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object\n\t * in the collection is not convertible to a long\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static long longResult(@Nullable Collection<?> results)",
    "query": "Design a service method that processes a collection of database query results to retrieve a single numeric value, ensuring that exactly one result is present and correctly typed. The method should handle cases where no results or multiple results are found by throwing appropriate exceptions.",
    "function_signature": "public long extractUniqueLongResult(@Nullable Collection<?> results);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer#doReceiveAndExecute(invoker,session,consumer,status)",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status)",
    "documentation": "\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,",
    "query": "Design a JMS-based service in your Spring application that continuously polls for messages and processes each message within a transactional context, ensuring reliable handling even under high load.",
    "function_signature": "protected boolean processPolledMessage(Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer, @Nullable TransactionStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.<unknown>#touchDataBuffer(buffer)",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "protected void touchDataBuffer(DataBuffer buffer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void touchDataBuffer(DataBuffer buffer) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (this.response instanceof ChannelOperationsId operationsId) {\n\t\t\t\tDataBufferUtils.touch(buffer, \"Channel id: \" + operationsId.asLongText());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.response.withConnection(connection -> {\n\t\t\t\t\tChannelId id = connection.channel().id();\n\t\t\t\t\tDataBufferUtils.touch(buffer, \"Channel id: \" + id.asShortText());\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}",
    "query": "In a reactive web application, ensure that each data buffer sent in the HTTP response carries contextual information about its originating channel. This enhancement should facilitate improved monitoring and debugging by associating buffers with their respective channel identifiers.",
    "function_signature": "protected void attachChannelContext(DataBuffer buffer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.InvocableHandlerMethod#getParameterNameDiscoverer()",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "public ParameterNameDiscoverer getParameterNameDiscoverer()",
    "documentation": "\t/**\n\t * Return the configured parameter name discoverer.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}",
    "query": "Develop a reactive request handler that dynamically binds incoming request data to controller method parameters by accurately resolving parameter names, enhancing flexibility and reducing boilerplate code.",
    "function_signature": "public Mono<HandlerResult> processRequestUsingParameterNames(Object handler, ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#getOperation()",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "public CacheOperation getOperation()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic CacheOperation getOperation() {\n\t\t\treturn this.metadata.operation;\n\t\t}",
    "query": "Develop a feature that requires accessing the metadata of the current cache operation to make runtime decisions on cache handling strategies.",
    "function_signature": "public CacheOperation getCurrentCacheOperation()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.concurrent.FutureAdapter#adapt(adapteeResult)",
    "from_version": "v5.3.30",
    "to_version": "v6.0.12",
    "type": "method",
    "signature": "protected T adapt(S adapteeResult)",
    "documentation": "\t/**\n\t * Adapts the given adaptee's result into T.\n\t * @return the adapted result\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected abstract T adapt(S adapteeResult) throws ExecutionException;",
    "query": "Design a method that processes the outcome of an asynchronous service call, transforming it into a client-friendly format while efficiently handling potential execution exceptions.",
    "function_signature": "protected ClientResponse adapt(Future<ServiceResult> serviceResult) throws ExecutionException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.ServiceUnavailable",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "class",
    "signature": "public class ServiceUnavailable",
    "documentation": "\t/**\n\t * {@link HttpServerErrorException} for status HTTP 503 Service Unavailable.\n\t * @since 5.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final class ServiceUnavailable extends HttpServerErrorException {\n\n\t\tprivate ServiceUnavailable(String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\t\t\tsuper(HttpStatus.SERVICE_UNAVAILABLE, statusText, headers, body, charset);\n\t\t}\n\n\t\tprivate ServiceUnavailable(String message, String statusText,\n\t\t\t\tHttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\t\tsuper(message, HttpStatus.SERVICE_UNAVAILABLE, statusText, headers, body, charset);\n\t\t}\n\t}",
    "query": "Create a service method that communicates with an external API and ensures a distinct exception is thrown when the external service is temporarily unavailable, facilitating precise error handling for HTTP 503 responses.",
    "function_signature": "public ResponseEntity<?> retrieveExternalData() throws ServiceUnavailable"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#doFindPathMatchingFileResources(rootDirResource,subPattern)",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "method",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "documentation": "\t/**\n\t * Find all resources in the file system that match the given location pattern\n\t * via the Ant-style PathMatcher.\n\t * @param rootDirResource the root directory as Resource\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see #retrieveMatchingFiles\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "query": "Design a method to retrieve all resource files under a specified directory that match a given Ant-style pattern, enabling dynamic loading of configuration files in your Spring application.",
    "function_signature": "public Set<Resource> loadMatchingResources(Resource baseDirectory, String pattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.LinkedCaseInsensitiveMap#get(key)",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "method",
    "signature": "public V get(Object key)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic V get(Object key) {\n\t\tif (key instanceof String string) {\n\t\t\tString caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey(string));\n\t\t\tif (caseInsensitiveKey != null) {\n\t\t\t\treturn this.targetMap.get(caseInsensitiveKey);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}",
    "query": "How would you implement a lookup function that retrieves values from a configuration map without considering the case of the keys?",
    "function_signature": "public V getValueIgnoreCase(String key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.Netty5DataBufferFactory",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "class",
    "signature": "public class Netty5DataBufferFactory",
    "documentation": "/**\n * Implementation of the {@code DataBufferFactory} interface based on a\n * Netty 5 {@link BufferAllocator}.\n *\n * @author Violeta Georgieva\n * @author Arjen Poutsma\n * @since 6.0\n */",
    "changetype": "stabilized",
    "source_code": "public class Netty5DataBufferFactory implements DataBufferFactory {\n\n\tprivate final BufferAllocator bufferAllocator;\n\n\n\t/**\n\t * Create a new {@code Netty5DataBufferFactory} based on the given factory.\n\t * @param bufferAllocator the factory to use\n\t */\n\tpublic Netty5DataBufferFactory(BufferAllocator bufferAllocator) {\n\t\tAssert.notNull(bufferAllocator, \"BufferAllocator must not be null\");\n\t\tthis.bufferAllocator = bufferAllocator;\n\t}\n\n\n\t/**\n\t * Return the {@code BufferAllocator} used by this factory.\n\t */\n\tpublic BufferAllocator getBufferAllocator() {\n\t\treturn this.bufferAllocator;\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic Netty5DataBuffer allocateBuffer() {\n\t\tBuffer buffer = this.bufferAllocator.allocate(256);\n\t\treturn new Netty5DataBuffer(buffer, this);\n\t}\n\n\t@Override\n\tpublic Netty5DataBuffer allocateBuffer(int initialCapacity) {\n\t\tBuffer buffer = this.bufferAllocator.allocate(initialCapacity);\n\t\treturn new Netty5DataBuffer(buffer, this);\n\t}\n\n\t@Override\n\tpublic Netty5DataBuffer wrap(ByteBuffer byteBuffer) {\n\t\tBuffer buffer = this.bufferAllocator.copyOf(byteBuffer);\n\t\treturn new Netty5DataBuffer(buffer, this);\n\t}\n\n\t@Override\n\tpublic Netty5DataBuffer wrap(byte[] bytes) {\n\t\tBuffer buffer = this.bufferAllocator.copyOf(bytes);\n\t\treturn new Netty5DataBuffer(buffer, this);\n\t}\n\n\t/**\n\t * Wrap the given Netty {@link Buffer} in a {@code Netty5DataBuffer}.\n\t * @param buffer the Netty buffer to wrap\n\t * @return the wrapped buffer\n\t */\n\tpublic Netty5DataBuffer wrap(Buffer buffer) {\n\t\tbuffer.touch(\"Wrap buffer\");\n\t\treturn new Netty5DataBuffer(buffer, this);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>This implementation uses Netty's {@link CompositeBuffer}.\n\t */\n\t@Override\n\tpublic DataBuffer join(List<? extends DataBuffer> dataBuffers) {\n\t\tAssert.notEmpty(dataBuffers, \"DataBuffer List must not be empty\");\n\t\tif (dataBuffers.size() == 1) {\n\t\t\treturn dataBuffers.get(0);\n\t\t}\n\t\tCompositeBuffer composite = this.bufferAllocator.compose();\n\t\tfor (DataBuffer dataBuffer : dataBuffers) {\n\t\t\tAssert.isInstanceOf(Netty5DataBuffer.class, dataBuffer);\n\t\t\tcomposite.extendWith(((Netty5DataBuffer) dataBuffer).getNativeBuffer().send());\n\t\t}\n\t\treturn new Netty5DataBuffer(composite, this);\n\t}\n\n\t@Override\n\tpublic boolean isDirect() {\n\t\treturn this.bufferAllocator.getAllocationType().isDirect();\n\t}\n\n\t/**\n\t * Return the given Netty {@link DataBuffer} as a {@link Buffer}.\n\t * <p>Returns the {@linkplain Netty5DataBuffer#getNativeBuffer() native buffer}\n\t * if {@code buffer} is a {@link Netty5DataBuffer}; returns\n\t * {@link BufferAllocator#copyOf(ByteBuffer)} otherwise.\n\t * @param buffer the {@code DataBuffer} to return a {@code Buffer} for\n\t * @return the netty {@code Buffer}\n\t */\n\tpublic static Buffer toBuffer(DataBuffer buffer) {\n\t\tif (buffer instanceof Netty5DataBuffer netty5DataBuffer) {\n\t\t\treturn netty5DataBuffer.getNativeBuffer();\n\t\t}\n\t\telse {\n\t\t\treturn DefaultBufferAllocators.preferredAllocator().copyOf(buffer.toByteBuffer());\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Netty5DataBufferFactory (\" + this.bufferAllocator + \")\";\n\t}\n}",
    "query": "Design a component that handles high-throughput data streaming by efficiently allocating and managing memory buffers, ensuring optimal performance and minimal latency in a reactive Spring application.",
    "function_signature": "public Flux<DataBuffer> processHighVolumeStream(DataStream inputStream)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#addHeader(name,value)",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "method",
    "signature": "public void addHeader(String name, String value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addHeader(name, value);\n\t\t\t\t}\n\t\t\t}",
    "query": "Design a RESTful endpoint that processes user authentication and ensures that each successful login response includes a custom security token in the HTTP headers. How would you implement this to efficiently manage header manipulation within the response lifecycle?",
    "function_signature": "public void handleUserLogin(AuthenticationRequest request, ServerResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.ResourceRegionHttpMessageConverter#writeInternal(object,type,outputMessage)",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "method",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "query": "Develop a REST controller method that efficiently serves specific segments of a large media file in response to HTTP range requests, optimizing bandwidth and performance for clients requesting partial content.",
    "function_signature": "protected void handlePartialMedia(Object mediaSegment, @Nullable Type type, HttpOutputMessage outputMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.PropertySourcesPlaceholderConfigurer#getAppliedPropertySources()",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "method",
    "signature": "public PropertySources getAppliedPropertySources()",
    "documentation": "\t/**\n\t * Return the property sources that were actually applied during\n\t * {@link #postProcessBeanFactory(ConfigurableListableBeanFactory) post-processing}.\n\t * @return the property sources that were applied\n\t * @throws IllegalStateException if the property sources have not yet been applied\n\t * @since 4.0\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PropertySources getAppliedPropertySources() throws IllegalStateException {\n\t\tAssert.state(this.appliedPropertySources != null, \"PropertySources have not yet been applied\");\n\t\treturn this.appliedPropertySources;\n\t}",
    "query": "Design a configuration auditing component that logs all the property sources applied during the application's startup. This tool should help developers verify the exact sources of configuration properties, ensuring transparency and aiding in troubleshooting configuration issues.",
    "function_signature": "public PropertySources auditAppliedPropertySources()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.GOING_AWAY",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "field",
    "signature": "public CloseStatus GOING_AWAY",
    "documentation": "\t/**\n\t * \"1001 indicates that an endpoint is \"going away\", such as a server going down or a\n\t * browser having navigated away from a page.\"\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final CloseStatus GOING_AWAY = new CloseStatus(1001);",
    "query": "Implement a WebSocket closure mechanism that signals when the connection is being terminated because the endpoint is going away.",
    "function_signature": "public void closeConnectionGoingAway(WebSocketSession session)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.RequestPredicates#param(name)",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "method",
    "signature": "public Optional<String> param(String name)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Optional<String> param(String name) {\n\t\t\treturn this.request.param(name);\n\t\t}",
    "query": "Develop a controller method that fetches a specific query parameter from incoming HTTP requests. The method should handle scenarios where the parameter might be absent, allowing for conditional processing based on its presence.",
    "function_signature": "public Optional<String> retrieveOptionalQueryParameter(String parameterName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.POLICY_VIOLATION",
    "from_version": "v5.3.22",
    "to_version": "v6.0.0-M6",
    "type": "field",
    "signature": "public CloseStatus POLICY_VIOLATION",
    "documentation": "\t/**\n\t * \"1008 indicates that an endpoint is terminating the connection because it has\n\t * received a message that violates its policy. This is a generic status code that can\n\t * be returned when there is no other more suitable status code (e.g., 1003 or 1009)\n\t * or if there is a need to hide specific details about the policy.\"\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final CloseStatus POLICY_VIOLATION = new CloseStatus(1008);",
    "query": "Design a WebSocket handler that monitors incoming messages for compliance with your application's security policies. When a message violates these policies, the handler should terminate the connection using an appropriate closure status to ensure the client is properly informed of the reason.",
    "function_signature": "public Mono<Void> terminateConnectionOnPolicyViolation(WebSocketSession session, WebSocketMessage message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#supportsWriteOnly(mimeType)",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "public boolean supportsWriteOnly(@Nullable MimeType mimeType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean supportsWriteOnly(@Nullable MimeType mimeType) {\n\t\t\treturn false;\n\t\t}",
    "query": "Configure a Spring service to conditionally process outgoing messages based on their MIME type, ensuring that specific data formats are exclusively handled during the write operation.",
    "function_signature": "public boolean supportsWriteOnlyOperations(@Nullable MimeType mimeType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#supportedMediaTypes()",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "public MimeType[] supportedMediaTypes()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic MimeType[] supportedMediaTypes() {\n\t\t\treturn new MimeType[]{APPLICATION_JSON};\n\t\t}",
    "query": "Create a custom message converter that efficiently handles a compact binary data format alongside JSON, enhancing your application's interoperability without sacrificing performance.",
    "function_signature": "public MimeType[] supportedMediaTypes()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#supports(clazz)",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "protected boolean supports(Class<?> clazz)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected boolean supports(Class<?> clazz) {\n\t\treturn Message.class.isAssignableFrom(clazz);\n\t}",
    "query": "Create a custom message converter within a Spring application that intelligently identifies and processes messages belonging to a particular class hierarchy. This converter should seamlessly integrate with the existing messaging infrastructure to enhance the application's ability to handle specialized message types without manual intervention.",
    "function_signature": "protected boolean supports(Class<?> clazz)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.WebClientResponseException#getMessage()",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "public String getMessage()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getMessage() {\n\t\tString message = String.valueOf(super.getMessage());\n\t\tif (shouldHintAtResponseFailure()) {\n\t\t\treturn message + \", but response failed with cause: \" + getCause();\n\t\t}\n\t\treturn message;\n\t}",
    "query": "How can you implement a reactive service method that performs an external API call and provides comprehensive error details when the response fails?",
    "function_signature": "public Mono<String> fetchExternalDataWithDetailedError()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#canConvertTo(payload,headers)",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {\n\t\tMimeType contentType = getMimeType(headers);\n\t\treturn (super.canConvertTo(payload, headers) ||\n\t\t\t\tthis.protobufFormatSupport != null && this.protobufFormatSupport.supportsWriteOnly(contentType));\n\t}",
    "query": "Implement a custom message converter that dynamically assesses incoming message payloads and headers to determine if they can be processed, thereby optimizing message handling in a high-throughput application.",
    "function_signature": "protected boolean canHandleConversion(Object payload, @Nullable MessageHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#convertToInternal(payload,headers,conversionHint)",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected Object convertToInternal(",
    "query": "How can you efficiently handle and convert incoming binary-encoded messages within a Spring application, ensuring that message headers and contextual hints are appropriately managed during the transformation process?",
    "function_signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.DEFAULT_CHARSET",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "field",
    "signature": "public Charset DEFAULT_CHARSET",
    "documentation": "\t/**\n\t * The default charset used by the converter.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;",
    "query": "Create a Spring component that sets up a message converter, ensuring all message payloads are consistently encoded and decoded using a standardized character set across the application.",
    "function_signature": "public void configureMessageConverter(Charset defaultCharset)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#merge(message,charset,contentType,extensionRegistry,builder)",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "public void merge(org.springframework.messaging.Message<?> message, Charset charset,\n\t\t\t\tMimeType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void merge(org.springframework.messaging.Message<?> message, Charset charset,",
    "query": "Design a component that efficiently combines incoming Protobuf-based network messages with existing data structures, ensuring proper character encoding and supporting custom extensions for enhanced functionality.",
    "function_signature": "public void combineProtobufMessages(Message<?> incomingMessage, Charset charset, MimeType contentType, ExtensionRegistry extensionRegistry, Message.Builder targetBuilder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.ProtobufMessageConverter#convertFromInternal(message,targetClass,conversionHint)",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "method",
    "signature": "protected Object convertFromInternal(org.springframework.messaging.Message<?> message,\n\t\t\tClass<?> targetClass, @Nullable Object conversionHint)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected Object convertFromInternal(org.springframework.messaging.Message<?> message,",
    "query": "Design a messaging service within a Spring application that efficiently processes and converts incoming Protocol Buffer messages to their corresponding domain objects, ensuring type safety and optimal performance.",
    "function_signature": "protected Object handleIncomingMessage(org.springframework.messaging.Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.PROTOBUF",
    "from_version": "v6.1.10",
    "to_version": "v6.1.11",
    "type": "field",
    "signature": "public MimeType PROTOBUF",
    "documentation": "\t/**\n\t * The mime-type for protobuf {@code application/x-protobuf}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final MimeType PROTOBUF = new MimeType(\"application\", \"x-protobuf\", DEFAULT_CHARSET);",
    "query": "Design a REST endpoint that efficiently handles binary data serialization for high-performance applications, ensuring seamless integration with clients using Protocol Buffers without manually specifying MIME types.",
    "function_signature": "public ResponseEntity<YourResponseType> processProtobufData(@RequestBody YourRequestType request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.observation.DefaultClientRequestObservationConvention#status(context)",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "protected KeyValue status(ClientRequestObservationContext context)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected KeyValue status(ClientRequestObservationContext context) {\n\t\tClientHttpResponse response = context.getResponse();\n\t\tif (response == null) {\n\t\t\treturn STATUS_CLIENT_ERROR;\n\t\t}\n\t\ttry {\n\t\t\treturn KeyValue.of(ClientHttpObservationDocumentation.LowCardinalityKeyNames.STATUS, String.valueOf(response.getStatusCode().value()));\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\treturn STATUS_IO_ERROR;\n\t\t}\n\t}",
    "query": "Design a mechanism to capture and log the status of HTTP client requests, ensuring that it gracefully handles scenarios where responses might be missing or I/O exceptions occur. Integrate this mechanism with Spring's monitoring infrastructure to provide insightful metrics for each request's outcome.",
    "function_signature": "protected KeyValue captureRequestStatus(ClientRequestObservationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.DefaultClientRequestObservationConvention#getName()",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "public String getName()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getName() {\n\t\treturn this.name;\n\t}",
    "query": "Design a configuration that assigns a specific naming strategy to your reactive web client's request observations to enhance monitoring and metrics collection.",
    "function_signature": "@Bean\npublic ClientRequestObservationConvention customClientRequestObservationConvention()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.rsocket.service.Builder",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "class",
    "signature": "public class Builder",
    "documentation": "\t/**\n\t * Builder to create an {@link RSocketServiceProxyFactory}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final class Builder {\n\n\t\t@Nullable\n\t\tprivate RSocketRequester rsocketRequester;\n\n\t\tprivate final List<RSocketServiceArgumentResolver> customArgumentResolvers = new ArrayList<>();\n\n\t\t@Nullable\n\t\tprivate StringValueResolver embeddedValueResolver;\n\n\t\tprivate ReactiveAdapterRegistry reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance();\n\n\t\t@Nullable\n\t\tprivate Duration blockTimeout = Duration.ofSeconds(5);\n\n\t\tprivate Builder() {\n\t\t}\n\n\t\t/**\n\t\t * Provide the requester to perform requests through.\n\t\t * @param requester the requester to use\n\t\t * @return the same builder instance\n\t\t */\n\t\tpublic Builder rsocketRequester(RSocketRequester requester) {\n\t\t\tthis.rsocketRequester = requester;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Register a custom argument resolver, invoked ahead of default resolvers.\n\t\t * @param resolver the resolver to add\n\t\t * @return the same builder instance\n\t\t */\n\t\tpublic Builder customArgumentResolver(RSocketServiceArgumentResolver resolver) {\n\t\t\tthis.customArgumentResolvers.add(resolver);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Set the {@link StringValueResolver} to use for resolving placeholders\n\t\t * and expressions embedded in {@link RSocketExchange#value()}.\n\t\t * @param resolver the resolver to use\n\t\t * @return this same builder instance\n\t\t */\n\t\tpublic Builder embeddedValueResolver(StringValueResolver resolver) {\n\t\t\tthis.embeddedValueResolver = resolver;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Set the {@link ReactiveAdapterRegistry} to use to support different\n\t\t * asynchronous types for HTTP service method return values.\n\t\t * <p>By default this is {@link ReactiveAdapterRegistry#getSharedInstance()}.\n\t\t * @return this same builder instance\n\t\t */\n\t\tpublic Builder reactiveAdapterRegistry(ReactiveAdapterRegistry registry) {\n\t\t\tthis.reactiveAdapterRegistry = registry;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Configure how long to wait for a response for an HTTP service method\n\t\t * with a synchronous (blocking) method signature.\n\t\t * <p>By default this is 5 seconds.\n\t\t * @param blockTimeout the timeout value\n\t\t * @return this same builder instance\n\t\t */\n\t\tpublic Builder blockTimeout(Duration blockTimeout) {\n\t\t\tthis.blockTimeout = blockTimeout;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Build the {@link RSocketServiceProxyFactory} instance.\n\t\t */\n\t\tpublic RSocketServiceProxyFactory build() {\n\t\t\tAssert.notNull(this.rsocketRequester, \"RSocketRequester is required\");\n\n\t\t\treturn new RSocketServiceProxyFactory(\n\t\t\t\t\tthis.rsocketRequester, initArgumentResolvers(),\n\t\t\t\t\tthis.embeddedValueResolver, this.reactiveAdapterRegistry,\n\t\t\t\t\t(this.blockTimeout != null ? this.blockTimeout : Duration.ofSeconds(5)));\n\t\t}\n\n\t\tprivate List<RSocketServiceArgumentResolver> initArgumentResolvers() {\n\n\t\t\t// Custom\n\t\t\tList<RSocketServiceArgumentResolver> resolvers = new ArrayList<>(this.customArgumentResolvers);\n\n\t\t\t// Annotation-based\n\t\t\tresolvers.add(new PayloadArgumentResolver(this.reactiveAdapterRegistry, false));\n\t\t\tresolvers.add(new DestinationVariableArgumentResolver());\n\n\t\t\t// Type-based\n\t\t\tresolvers.add(new MetadataArgumentResolver());\n\n\t\t\t// Fallback\n\t\t\tresolvers.add(new PayloadArgumentResolver(this.reactiveAdapterRegistry, true));\n\n\t\t\treturn resolvers;\n\t\t}\n\t}",
    "query": "Implement a component that establishes a customizable reactive communication channel, allowing for specialized argument processing and configurable response timeouts. Ensure that the solution supports dynamic value resolution within service interactions.",
    "function_signature": "public RSocketServiceProxyFactory createReactiveServiceFactory(RSocketRequester requester, Duration responseTimeout)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#setContextFailureProcessor(contextFailureProcessor)",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "public void setContextFailureProcessor(ApplicationContextFailureProcessor contextFailureProcessor)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setContextFailureProcessor(ApplicationContextFailureProcessor contextFailureProcessor) {\n\t\tthis.contextFailureProcessor = contextFailureProcessor;\n\t}",
    "query": "Design a testing strategy that allows custom handling of application context initialization failures, ensuring that specific actions are taken when the context fails to load during integration tests.",
    "function_signature": "public void setContextFailureHandler(ApplicationContextFailureProcessor failureProcessor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.observation.DefaultServerRequestObservationConvention#method(context)",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "protected KeyValue method(ServerRequestObservationContext context)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected KeyValue method(ServerRequestObservationContext context) {\n\t\treturn (context.getCarrier() != null) ? KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.METHOD, context.getCarrier().getMethod()) : METHOD_UNKNOWN;\n\t}",
    "query": "Design a feature that monitors incoming HTTP requests by capturing their methods for analytics, ensuring that unknown methods are categorized appropriately.",
    "function_signature": "protected KeyValue captureHttpMethod(ServerRequestObservationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.http.client.reactive.MockClientHttpResponse#getRawStatusCode()",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "public int getRawStatusCode()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}",
    "query": "Create a method to obtain the HTTP status from a mock client response, enhancing type safety and leveraging the latest framework optimizations.",
    "function_signature": "public HttpStatus getStatusCode()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.observation.reactive.DefaultServerRequestObservationConvention",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "class",
    "signature": "public class DefaultServerRequestObservationConvention",
    "documentation": "/**\n * Default {@link ServerRequestObservationConvention}.\n *\n * @author Brian Clozel\n * @since 6.0\n */",
    "changetype": "stabilized",
    "source_code": "public class DefaultServerRequestObservationConvention implements ServerRequestObservationConvention {\n\n\tprivate static final String DEFAULT_NAME = \"http.server.requests\";\n\n\tprivate static final KeyValue METHOD_UNKNOWN = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.METHOD, \"UNKNOWN\");\n\n\tprivate static final KeyValue STATUS_UNKNOWN = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.STATUS, \"UNKNOWN\");\n\n\tprivate static final KeyValue HTTP_OUTCOME_SUCCESS = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.OUTCOME, \"SUCCESS\");\n\n\tprivate static final KeyValue HTTP_OUTCOME_UNKNOWN = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.OUTCOME, \"UNKNOWN\");\n\n\tprivate static final KeyValue URI_UNKNOWN = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.URI, \"UNKNOWN\");\n\n\tprivate static final KeyValue URI_ROOT = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.URI, \"root\");\n\n\tprivate static final KeyValue URI_NOT_FOUND = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.URI, \"NOT_FOUND\");\n\n\tprivate static final KeyValue URI_REDIRECTION = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.URI, \"REDIRECTION\");\n\n\tprivate static final KeyValue EXCEPTION_NONE = KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.EXCEPTION, KeyValue.NONE_VALUE);\n\n\tprivate static final KeyValue HTTP_URL_UNKNOWN = KeyValue.of(ServerHttpObservationDocumentation.HighCardinalityKeyNames.HTTP_URL, \"UNKNOWN\");\n\n\tprivate final String name;\n\n\t/**\n\t * Create a convention with the default name {@code \"http.server.requests\"}.\n\t */\n\tpublic DefaultServerRequestObservationConvention() {\n\t\tthis(DEFAULT_NAME);\n\t}\n\n\t/**\n\t * Create a convention with a custom name.\n\t *\n\t * @param name the observation name\n\t */\n\tpublic DefaultServerRequestObservationConvention(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic String getContextualName(ServerRequestObservationContext context) {\n\t\treturn \"http \" + context.getCarrier().getMethod().name().toLowerCase();\n\t}\n\n\t@Override\n\tpublic KeyValues getLowCardinalityKeyValues(ServerRequestObservationContext context) {\n\t\treturn KeyValues.of(method(context), uri(context), status(context), exception(context), outcome(context));\n\t}\n\n\t@Override\n\tpublic KeyValues getHighCardinalityKeyValues(ServerRequestObservationContext context) {\n\t\treturn KeyValues.of(httpUrl(context));\n\t}\n\n\tprotected KeyValue method(ServerRequestObservationContext context) {\n\t\treturn (context.getCarrier() != null) ? KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.METHOD, context.getCarrier().getMethod().name()) : METHOD_UNKNOWN;\n\t}\n\n\tprotected KeyValue status(ServerRequestObservationContext context) {\n\t\tif (context.isConnectionAborted()) {\n\t\t\treturn STATUS_UNKNOWN;\n\t\t}\n\t\treturn (context.getResponse() != null && context.getResponse().getStatusCode() != null) ?\n\t\t\t\tKeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.STATUS, Integer.toString(context.getResponse().getStatusCode().value())) : STATUS_UNKNOWN;\n\t}\n\n\tprotected KeyValue uri(ServerRequestObservationContext context) {\n\t\tif (context.getCarrier() != null) {\n\t\t\tPathPattern pattern = context.getPathPattern();\n\t\t\tif (pattern != null) {\n\t\t\t\tif (pattern.toString().isEmpty()) {\n\t\t\t\t\treturn URI_ROOT;\n\t\t\t\t}\n\t\t\t\treturn KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.URI, pattern.toString());\n\t\t\t}\n\t\t\tif (context.getResponse() != null && context.getResponse().getStatusCode() != null) {\n\t\t\t\tHttpStatus status = HttpStatus.resolve(context.getResponse().getStatusCode().value());\n\t\t\t\tif (status != null) {\n\t\t\t\t\tif (status.is3xxRedirection()) {\n\t\t\t\t\t\treturn URI_REDIRECTION;\n\t\t\t\t\t}\n\t\t\t\t\tif (status == HttpStatus.NOT_FOUND) {\n\t\t\t\t\t\treturn URI_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn URI_UNKNOWN;\n\t}\n\n\tprotected KeyValue exception(ServerRequestObservationContext context) {\n\t\tThrowable error = context.getError();\n\t\tif (error != null) {\n\t\t\tString simpleName = error.getClass().getSimpleName();\n\t\t\treturn KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.EXCEPTION,\n\t\t\t\t\tStringUtils.hasText(simpleName) ? simpleName : error.getClass().getName());\n\t\t}\n\t\treturn EXCEPTION_NONE;\n\t}\n\n\tprotected KeyValue outcome(ServerRequestObservationContext context) {\n\t\tif (context.isConnectionAborted()) {\n\t\t\treturn HTTP_OUTCOME_UNKNOWN;\n\t\t}\n\t\tif (context.getResponse() != null && context.getResponse().getStatusCode() != null) {\n\t\t\treturn HttpOutcome.forStatus(context.getResponse().getStatusCode());\n\t\t}\n\t\treturn HTTP_OUTCOME_UNKNOWN;\n\t}\n\n\tprotected KeyValue httpUrl(ServerRequestObservationContext context) {\n\t\tif (context.getCarrier() != null) {\n\t\t\treturn KeyValue.of(ServerHttpObservationDocumentation.HighCardinalityKeyNames.HTTP_URL, context.getCarrier().getPath().toString());\n\t\t}\n\t\treturn HTTP_URL_UNKNOWN;\n\t}\n\n\tstatic class HttpOutcome {\n\n\t\tstatic KeyValue forStatus(HttpStatusCode statusCode) {\n\t\t\tif (statusCode.is2xxSuccessful()) {\n\t\t\t\treturn HTTP_OUTCOME_SUCCESS;\n\t\t\t}\n\t\t\telse if (statusCode instanceof HttpStatus status) {\n\t\t\t\treturn KeyValue.of(ServerHttpObservationDocumentation.LowCardinalityKeyNames.OUTCOME, status.series().name());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn HTTP_OUTCOME_UNKNOWN;\n\t\t\t}\n\t\t}\n\n\t}\n\n}",
    "query": "Develop a monitoring feature that automatically captures and categorizes incoming HTTP server requests by their method, URI patterns, response status, and any exceptions thrown. This feature should integrate seamlessly with Spring's reactive web stack, ensuring that all relevant metrics are consistently recorded without manual intervention.",
    "function_signature": "public void configureServerRequestMonitoring()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.observation.DefaultClientRequestObservationConvention#method(context)",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "protected KeyValue method(ClientRequestObservationContext context)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected KeyValue method(ClientRequestObservationContext context) {\n\t\tif (context.getCarrier() != null) {\n\t\t\treturn KeyValue.of(ClientHttpObservationDocumentation.LowCardinalityKeyNames.METHOD, context.getCarrier().getMethod().name());\n\t\t}\n\t\telse {\n\t\t\treturn METHOD_NONE;\n\t\t}\n\t}",
    "query": "Design a component that enriches outgoing HTTP client requests with metadata about the HTTP method used, enabling enhanced observability and monitoring of client interactions within your application.",
    "function_signature": "protected KeyValue extractHttpMethodMetadata(ClientRequestObservationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#builder(clientAdapter)",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "public Builder builder(HttpClientAdapter clientAdapter)",
    "documentation": "\t/**\n\t * Return an {@link HttpServiceProxyFactory} builder, initialized with the\n\t * given client.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static Builder builder(HttpClientAdapter clientAdapter) {\n\t\treturn new Builder().clientAdapter(clientAdapter);\n\t}",
    "query": "Design a component that generates type-safe HTTP clients based on a custom HTTP adapter to interact with external microservices seamlessly.",
    "function_signature": "public <T> T createClient(Class<T> serviceInterface, HttpClientAdapter adapter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.observation.reactive.DefaultServerRequestObservationConvention#getHighCardinalityKeyValues(context)",
    "from_version": "v6.0.0-RC1",
    "to_version": "v6.0.0-RC2",
    "type": "method",
    "signature": "public KeyValues getHighCardinalityKeyValues(ServerRequestObservationContext context)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic KeyValues getHighCardinalityKeyValues(ServerRequestObservationContext context) {\n\t\treturn KeyValues.of(httpUrl(context));\n\t}",
    "query": "Design a component that extracts detailed metrics from incoming server requests to support advanced monitoring scenarios in a reactive Spring application.",
    "function_signature": "public KeyValues extractHighCardinalityMetrics(ServerRequestObservationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.connection.JmsResourceHolder#getConnection()",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public Connection getConnection()",
    "documentation": "\t/**\n\t * Return this resource holder's default Connection,\n\t * or {@code null} if none.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic @Nullable Connection getConnection() {\n\t\treturn this.connections.peek();\n\t}",
    "query": "Design a method to acquire the current JMS connection reliably, ensuring that the connection retrieval process is streamlined and minimizes the risk of encountering null references.",
    "function_signature": "public Connection obtainCurrentConnection()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.JCacheCache#lookup(key)",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "protected Object lookup(Object key)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected @Nullable Object lookup(Object key) {\n\t\treturn this.cache.get(key);\n\t}",
    "query": "Design a method to obtain a cached object by its key, prioritizing performance and thread safety.",
    "function_signature": "protected Object get(Object key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.<unknown>#onCompleteSuccess()",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "protected void onCompleteSuccess()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\t\tprotected void onCompleteSuccess() {\n\t\t\t\t\tbyteBufferIterator.close();\n\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\tcallback.complete(null);\n\t\t\t\t}",
    "query": "Design a method to efficiently conclude a reactive server operation, ensuring that resources are properly released and callbacks are executed reliably to improve overall system performance and safety.",
    "function_signature": "protected void finalizeOperation()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.RequestEntity#getUriTemplate()",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public String getUriTemplate()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String getUriTemplate() {\n\t\t\treturn this.uriTemplate;\n\t\t}",
    "query": "Enhance your application's HTTP request handling by efficiently accessing the request's URI to improve performance and maintain thread safety.",
    "function_signature": "public URI getRequestUri(RequestEntity<?> requestEntity)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.common.LiteralExpression#getValue(expectedResultType)",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public T getValue(@Nullable Class<T> expectedResultType)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue();\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), expectedResultType);\n\t}",
    "query": "Refactor the expression evaluation to obtain a typed result efficiently, ensuring enhanced type safety and performance by utilizing the latest evaluation mechanisms.",
    "function_signature": "public <T> T resolveValue(Class<T> targetType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.object.RdbmsOperation#setDataSource(dataSource)",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public void setDataSource(DataSource dataSource)",
    "documentation": "\t/**\n\t * Set the JDBC {@link DataSource} to obtain connections from.\n\t * @see org.springframework.jdbc.core.JdbcTemplate#setDataSource\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setDataSource(DataSource dataSource) {\n\t\tthis.jdbcTemplate.setDataSource(dataSource);\n\t}",
    "query": "Create a component that manages database connections by configuring the recommended JDBC template approach to ensure optimal performance and enhanced safety.",
    "function_signature": "public void configurePreferredJdbcTemplate(DataSource dataSource)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpMethodArgumentResolver#resolve(argument,parameter,requestValues)",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean resolve(",
    "query": "Enhance the processing of HTTP request parameters in your Spring application to improve type safety and execution efficiency. Design a resolver that effectively handles various argument types without compromising performance.",
    "function_signature": "public boolean resolveArgument(Object argument, MethodParameter parameter, HttpRequestValues requestValues)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addInterceptors(interceptors)",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors)",
    "documentation": "\t/**\n\t * Add interceptors mapped to all incoming requests.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addInterceptors(HandlerInterceptor... interceptors) {\n\t\taddMappedInterceptors(null, interceptors);\n\t\treturn this;\n\t}",
    "query": "Design a test setup for your Spring MVC application that ensures each request undergoes necessary processing steps, enhancing both performance and maintainability by leveraging the most current interception mechanisms.",
    "function_signature": "public RouterFunctionMockMvcBuilder configureRequestProcessing(RequestProcessor... processors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#name()",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public String name()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String name() {\n\t\t\tStringBuilder output = new StringBuilder();\n\t\t\tfor (PathSegment segment : this.segments) {\n\t\t\t\toutput.append('/');\n\t\t\t\toutput.append(segment.name());\n\t\t\t}\n\t\t\treturn output.toString();\n\t\t}",
    "query": "Enhance the efficiency of constructing a URL path from multiple segments by utilizing a more robust and thread-safe approach.",
    "function_signature": "public String buildPathConcurrently(List<PathSegment> segments)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.FastByteArrayOutputStream#skip(n)",
    "from_version": "v7.0.0-M2",
    "to_version": "v6.1.18",
    "type": "method",
    "signature": "public long skip(long n)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic long skip(long n) throws IOException {\n\t\t\tif (n > Integer.MAX_VALUE) {\n\t\t\t\tthrow new IllegalArgumentException(\"n exceeds maximum (\" + Integer.MAX_VALUE + \"): \" + n);\n\t\t\t}\n\t\t\telse if (n == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (n < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"n must be 0 or greater: \" + n);\n\t\t\t}\n\t\t\tint len = (int) n;\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\tint bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\tthis.totalBytesRead += bytesToSkip;\n\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToSkip;\n\t\t\t\t\treturn (bytesToSkip + skip(len - bytesToSkip));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn skip(len);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Develop a byte stream handler that efficiently manages byte skipping operations with enhanced error handling and performance.",
    "function_signature": "public long skipBytesEfficiently(long byteCount) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Develop a method that initializes and manages the state of a messaging server, encompassing active sessions, destinations, and subscription registries to ensure efficient real-time communication.",
    "function_signature": "public MessagingServerState initializeMessagingServerState();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Design a mechanism to selectively apply a security interceptor to requests targeting administrative endpoints (e.g., paths starting with \"/admin/**\"), ensuring that the interceptor correctly identifies and processes complex path patterns, including those with path variables or matrix parameters.",
    "function_signature": "public boolean shouldApplySecurityInterceptor(Object requestPath, boolean isPathContainer, PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design an interceptor that dynamically adjusts its URL matching strategy based on runtime configurations, ensuring optimal request handling across diverse endpoints.",
    "function_signature": "public PathMatcher dynamicPathMatcherConfiguration(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Create a middleware component that intercepts HTTP requests and applies custom filtering logic only to URLs that match complex and non-standard patterns, requiring a specialized path matching strategy.",
    "function_signature": "public void configureCustomInterceptor(PathMatcher customMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Create a component that appends user-specific information to the response model after controller execution, but only for endpoints matching `/dashboard/**` and `/profile/**`.",
    "function_signature": "public void enrichModelWithUserData(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a Spring MVC interceptor that selectively processes incoming HTTP requests based on dynamic URL patterns, ensuring that certain endpoints are excluded from interception without affecting the overall request handling workflow.",
    "function_signature": "public MappedInterceptor registerSelectiveInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Create a performance evaluation method for a messaging system that assesses the efficiency of handling rapid subscription changes, ensuring that both registration and deregistration processes perform optimally under stress conditions.",
    "function_signature": "public void evaluateSubscriptionPerformance(ServerState serverState, SubscriptionRequests requests, Blackhole blackhole)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Design a component that dynamically assigns messaging destinations based on the current server load and subscriber distribution. Ensure that the destinations are managed efficiently to prevent bottlenecks when scaling the application.",
    "function_signature": "public void configureDynamicDestination(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Develop a backend service for a live sports update platform that dynamically handles thousands of concurrent user subscriptions to various game feeds. Ensure the system efficiently manages subscription registrations and optimizes resource usage to maintain real-time performance during peak traffic.",
    "function_signature": "public void initializeSubscriptionManagement()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.2.18.RELEASE",
    "to_version": "v5.3.12",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int sessions;",
    "query": "Design a monitoring component for your real-time chat application that tracks and returns the number of active user connections at any given moment.",
    "function_signature": "public int retrieveActiveSessionCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.HttpHeaders#getAccessControlRequestMethod()",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public HttpMethod getAccessControlRequestMethod()",
    "documentation": "\t/**\n\t * Return the value of the {@code Access-Control-Request-Method} request header.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic HttpMethod getAccessControlRequestMethod() {\n\t\tString requestMethod = getFirst(ACCESS_CONTROL_REQUEST_METHOD);\n\t\tif (requestMethod != null) {\n\t\t\treturn HttpMethod.valueOf(requestMethod);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}",
    "query": "Design a service method that handles CORS preflight requests by identifying the HTTP method the client intends to use for the actual request.",
    "function_signature": "public Optional<HttpMethod> determineRequestedHttpMethod(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.oxm.xstream.XStreamMarshaller#marshalWriter(graph,writer)",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public void marshalWriter(Object graph, Writer writer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {\n\t\tmarshalWriter(graph, writer, null);\n\t}",
    "query": "Design a Spring service method that takes a complex data structure and efficiently writes its XML representation directly to a given `Writer`, handling any potential mapping or I/O exceptions.",
    "function_signature": "public void marshalDataToXml(Object data, Writer writer) throws XmlMappingException, IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#afterPropertiesSet()",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public void afterPropertiesSet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tAssert.state(getCacheOperationSource() != null, \"The 'cacheOperationSources' property is required: \" +\n\t\t\t\t\"If there are no cacheable methods, then don't use a cache aspect.\");\n\t}",
    "query": "Design a component that validates essential caching configurations during the initialization phase, ensuring that cache operations are properly set up and preventing the application from starting if no cacheable methods are detected.",
    "function_signature": "public void initializeCacheSupport()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.EscapedErrors#getFieldErrorCount(field)",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public int getFieldErrorCount(String field)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int getFieldErrorCount(String field) {\n\t\treturn this.source.getFieldErrorCount(field);\n\t}",
    "query": "Design a controller method that processes user registration forms and efficiently provides real-time feedback on the number of validation errors present for each input field.",
    "function_signature": "public ResponseEntity<Map<String, Integer>> getValidationErrorCounts(@Valid RegistrationForm form, BindingResult result)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.json.AbstractJackson2Decoder#getMaxInMemorySize()",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public int getMaxInMemorySize()",
    "documentation": "\t/**\n\t * Return the {@link #setMaxInMemorySize configured} byte count limit.\n\t * @since 5.1.11\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic int getMaxInMemorySize() {\n\t\treturn this.maxInMemorySize;\n\t}",
    "query": "Design a REST controller method that processes incoming JSON requests with potentially large payloads, ensuring that the application efficiently manages memory usage to prevent overloads.",
    "function_signature": "public Mono<ResponseEntity<Void>> handleLargeJsonPayload(ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.filter.OncePerRequestFilter#isAsyncStarted(request)",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "protected boolean isAsyncStarted(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Whether request processing is in asynchronous mode meaning that the\n\t * response will not be committed after the current thread is exited.\n\t * @param request the current request\n\t * @since 3.2\n\t * @see WebAsyncManager#isConcurrentHandlingStarted()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected boolean isAsyncStarted(HttpServletRequest request) {\n\t\treturn WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted();\n\t}",
    "query": "Create a custom filter that conditionally executes logging logic only when a request has transitioned into asynchronous processing. This ensures that specific actions are performed exclusively during the asynchronous phase of request handling.",
    "function_signature": "protected boolean hasAsyncProcessingStarted(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ResponseCookie#httpOnly(httpOnly)",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public ResponseCookieBuilder httpOnly(boolean httpOnly)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic ResponseCookieBuilder httpOnly(boolean httpOnly) {\n\t\t\tthis.httpOnly = httpOnly;\n\t\t\treturn this;\n\t\t}",
    "query": "Ensure that cookies set by your application are inaccessible to client-side scripts by configuring them appropriately.",
    "function_signature": "public ResponseCookieBuilder setHttpOnlyFlag(String name, String value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#addIntHeader(name,value)",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public void addIntHeader(String name, int value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic void addIntHeader(String name, int value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addIntHeader(name, value);\n\t\t\t\t}\n\t\t\t}",
    "query": "Implement a REST endpoint that returns the current server status, including a custom integer-based metric in the response headers to indicate the number of active sessions.",
    "function_signature": "public void addCustomStatusHeaders(ServerResponse response, int activeSessions)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.multipart.support.StringMultipartFileEditor",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "class",
    "signature": "public class StringMultipartFileEditor",
    "documentation": "/**\n * Custom {@link java.beans.PropertyEditor} for converting\n * {@link MultipartFile MultipartFiles} to Strings.\n *\n * <p>Allows one to specify the charset to use.\n *\n * @author Juergen Hoeller\n * @since 13.10.2003\n */",
    "changetype": "stabilized",
    "source_code": "public class StringMultipartFileEditor extends PropertyEditorSupport {\n\n\t@Nullable\n\tprivate final String charsetName;\n\n\n\t/**\n\t * Create a new {@link StringMultipartFileEditor}, using the default charset.\n\t */\n\tpublic StringMultipartFileEditor() {\n\t\tthis.charsetName = null;\n\t}\n\n\t/**\n\t * Create a new {@link StringMultipartFileEditor}, using the given charset.\n\t * @param charsetName valid charset name\n\t * @see java.lang.String#String(byte[],String)\n\t */\n\tpublic StringMultipartFileEditor(String charsetName) {\n\t\tthis.charsetName = charsetName;\n\t}\n\n\n\t@Override\n\tpublic void setAsText(String text) {\n\t\tsetValue(text);\n\t}\n\n\t@Override\n\tpublic void setValue(Object value) {\n\t\tif (value instanceof MultipartFile multipartFile) {\n\t\t\ttry {\n\t\t\t\tsuper.setValue(this.charsetName != null ?\n\t\t\t\t\t\tnew String(multipartFile.getBytes(), this.charsetName) :\n\t\t\t\t\t\tnew String(multipartFile.getBytes()));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Cannot read contents of multipart file\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}\n\n}",
    "query": "Create a Spring MVC endpoint that accepts a user-uploaded text file and processes its contents as a String using a specific character encoding. Ensure that the file's byte data is seamlessly converted to a String for downstream operations without manual parsing.",
    "function_signature": "@PostMapping(\"/submitTextFile\")\npublic ResponseEntity<Void> submitTextFile(@RequestParam(\"file\") String fileContent)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.ProxyFactoryBean#isPerInstance()",
    "from_version": "v5.2.24.RELEASE",
    "to_version": "v6.0.9",
    "type": "method",
    "signature": "public boolean isPerInstance()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isPerInstance() {\n\t\t\tthrow new UnsupportedOperationException(\"Cannot invoke methods: \" + this.message);\n\t\t}",
    "query": "Ensure that your Spring-based application creates unique proxy instances for each bean to avoid shared state issues in a concurrent environment. How would you implement and verify this proxy behavior using the latest Spring Framework features?",
    "function_signature": "public boolean isProxyConfiguredPerInstance()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a configuration method for a WebSocket message broker that dynamically manages multiple client destinations, allowing easy scalability as new topics are introduced without altering the core broker setup.",
    "function_signature": "public void configureBrokerDestinations(String... destinationIds)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "In a Spring MVC application, devise a method to retrieve the specific interceptor associated with a given URL pattern to allow for dynamic configuration adjustments.",
    "function_signature": "public HandlerInterceptor getInterceptorForPath(String pathPattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Create a service that dynamically resolves the correct messaging endpoint for incoming WebSocket messages, leveraging Spring's enhanced destination resolution to route messages based on their specific attributes.",
    "function_signature": "public String resolveMessageDestination(Message<?> incomingMessage);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String session;",
    "query": "Develop a WebSocket message handler that differentiates and manages messages based on unique user session identifiers, ensuring personalized processing for each connected client.",
    "function_signature": "public void handleWebSocketMessage(String session, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String destination;",
    "query": "Create a service method that processes incoming messages by routing them to appropriate handlers based on their destination paths.",
    "function_signature": "public void routeMessageByDestination(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Develop a logging interceptor that conditionally activates based on specific attributes in the incoming HTTP request, such as custom headers or user roles.",
    "function_signature": "public boolean shouldLogRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Design a system component that intercepts and validates incoming HTTP requests targeting specific URL patterns, ensuring that only authorized requests proceed to the appropriate controllers.",
    "function_signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Create an interceptor that applies only to specific URL patterns using a tailored matching strategy, ensuring precise control over which requests are processed without relying solely on default pattern matching.",
    "function_signature": "public void configureInterceptorPathMatching(PathMatcher customMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Design a real-time notification system that efficiently manages thousands of client subscriptions with customizable caching limits and supports advanced subscription patterns. Ensure the system can handle dynamic subscription registrations and lookups with minimal latency under high concurrency.",
    "function_signature": "public void initializeSubscriptionRegistry(int cacheLimit, String subscriptionType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.2.8.RELEASE",
    "to_version": "v5.3.0-M2",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a feature that executes custom cleanup logic after processing web requests for specific URL patterns, ensuring resources are properly released or additional logging is performed.",
    "function_signature": "public void handlePostRequestCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#getJsonEncoding(contentType)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "protected JsonEncoding getJsonEncoding(@Nullable MediaType contentType)",
    "documentation": "\t/**\n\t * Determine the JSON encoding to use for the given content type.\n\t * @param contentType the media type as requested by the caller\n\t * @return the JSON encoding to use (never {@code null})\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected JsonEncoding getJsonEncoding(@Nullable MediaType contentType) {\n\t\tif (contentType != null && contentType.getCharset() != null) {\n\t\t\tCharset charset = contentType.getCharset();\n\t\t\tJsonEncoding encoding = ENCODINGS.get(charset.name());\n\t\t\tif (encoding != null) {\n\t\t\t\treturn encoding;\n\t\t\t}\n\t\t}\n\t\treturn JsonEncoding.UTF8;\n\t}",
    "query": "Design a RESTful API endpoint that automatically selects the most efficient JSON encoding based on the client's `Content-Type` header, enhancing compatibility with diverse character sets without manual intervention.",
    "function_signature": "public ResponseEntity<String> respondWithOptimizedJson(@RequestHeader(\"Content-Type\") MediaType contentType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#cookies()",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public Cookie> cookies()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic MultiValueMap<String, Cookie> cookies() {\n\t\t\treturn this.cookies;\n\t\t}",
    "query": "Design a server-side endpoint that extracts and logs all cookies from incoming HTTP requests to monitor user sessions effectively.",
    "function_signature": "public void logIncomingCookies(ServerRequest request, MultiValueMap<String, Cookie> cookies)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.ClassLoaderData#wrapCachedClass(klass)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "protected T wrapCachedClass(Class klass)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected T wrapCachedClass(Class klass) {\n\t\treturn (T) new WeakReference(klass);\n\t}",
    "query": "Optimize memory management in a high-load Spring application by implementing a mechanism that safely caches dynamically loaded classes, ensuring that unused classes are eligible for garbage collection without manual intervention.",
    "function_signature": "protected <T> WeakReference<T> manageCachedClass(Class<T> clazz)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Constants#getFieldCache()",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "protected Object> getFieldCache()",
    "documentation": "\t/**\n\t * Exposes the field cache to subclasses:\n\t * a Map from String field name to object value.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final Map<String, Object> getFieldCache() {\n\t\treturn this.fieldCache;\n\t}",
    "query": "Develop a subclass that optimizes access to shared constant values by utilizing an inherited field caching mechanism.",
    "function_signature": "protected Map<String, Object> accessFieldCache()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelAndViewResolvers()",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public List<ModelAndViewResolver> getModelAndViewResolvers()",
    "documentation": "\t/**\n\t * Return the configured {@link ModelAndViewResolver ModelAndViewResolvers}, or {@code null}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic List<ModelAndViewResolver> getModelAndViewResolvers() {\n\t\treturn this.modelAndViewResolvers;\n\t}",
    "query": "Design a feature in your Spring MVC application that allows dynamic customization of how views are resolved based on specific business logic. Ensure your implementation seamlessly integrates with the existing view resolution process without altering the core request handling mechanism.",
    "function_signature": "public void customizeModelAndViewResolvers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#getSession(sessionId)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public SessionInfo getSession(String sessionId)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic SessionInfo getSession(String sessionId) {\n\t\t\treturn this.sessions.get(sessionId);\n\t\t}",
    "query": "How can you implement a feature that allows monitoring of individual user sessions by retrieving detailed session information using a session identifier within your Spring-based messaging application?",
    "function_signature": "public SessionInfo retrieveSessionDetails(String sessionId)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.FrameworkServlet#setDispatchTraceRequest(dispatchTraceRequest)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public void setDispatchTraceRequest(boolean dispatchTraceRequest)",
    "documentation": "\t/**\n\t * Set whether this servlet should dispatch an HTTP TRACE request to\n\t * the {@link #doService} method.\n\t * <p>Default is \"false\", applying {@link jakarta.servlet.http.HttpServlet}'s\n\t * default behavior (i.e. reflecting the message received back to the client).\n\t * <p>Turn this flag on if you prefer TRACE requests to go through the\n\t * regular dispatching chain, just like other HTTP requests. This usually\n\t * means that your controllers will receive those requests; make sure\n\t * that those endpoints are actually able to handle a TRACE request.\n\t * <p>Note that HttpServlet's default TRACE processing will be applied\n\t * in any case if your controllers happen to not generate a response\n\t * of content type 'message/http' (as required for a TRACE response).\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setDispatchTraceRequest(boolean dispatchTraceRequest) {\n\t\tthis.dispatchTraceRequest = dispatchTraceRequest;\n\t}",
    "query": "Design a Spring MVC configuration that routes HTTP TRACE requests through your application's controller layer, allowing for custom processing or logging of these requests.",
    "function_signature": "public void enableTraceRequestDispatching(boolean dispatchTrace)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.StringUtils#unqualify(qualifiedName)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public String unqualify(String qualifiedName)",
    "documentation": "\t/**\n\t * Unqualify a string qualified by a '.' dot character. For example,\n\t * \"this.name.is.qualified\", returns \"qualified\".\n\t * @param qualifiedName the qualified name\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String unqualify(String qualifiedName) {\n\t\treturn unqualify(qualifiedName, '.');\n\t}",
    "query": "Implement a Spring service method that processes fully qualified property names and retrieves only the final property segment for logging purposes.",
    "function_signature": "public String extractFinalPropertySegment(String qualifiedPropertyName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.support.RequestContext#getThemeMessage(code,defaultMessage)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public String getThemeMessage(String code, String defaultMessage)",
    "documentation": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}",
    "query": "Develop a feature that dynamically retrieves theme-related resource identifiers based on a unique key, ensuring a fallback option is provided when the key does not correspond to any existing resource.",
    "function_signature": "public String fetchThemeResource(String identifier, String fallbackResource);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.standard.SpelCompiler#compile(expression)",
    "from_version": "v5.3.37",
    "to_version": "v6.0.22",
    "type": "method",
    "signature": "public boolean compile(Expression expression)",
    "documentation": "\t/**\n\t * Request that an attempt is made to compile the specified expression.\n\t * It may fail if components of the expression are not suitable for compilation\n\t * or the data types involved are not suitable for compilation. Used for testing.\n\t * @param expression the expression to compile\n\t * @return {@code true} if the expression was successfully compiled,\n\t * {@code false} otherwise\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static boolean compile(Expression expression) {\n\t\treturn (expression instanceof SpelExpression spelExpression && spelExpression.compileExpression());\n\t}",
    "query": "Implement a functionality in a high-throughput application that dynamically processes user-defined expressions. Ensure that these expressions are pre-optimized to improve execution speed where possible, falling back gracefully if optimization isn't feasible.",
    "function_signature": "public boolean tryCompileExpression(Expression expression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Develop a method to efficiently handle the dynamic subscription lifecycle in a scalable messaging application, ensuring that client subscriptions are registered and unregistered seamlessly under high-load conditions.",
    "function_signature": "public void handleSubscriptionLifecycle(ServerState serverState, SubscriptionRequest request, LoadTester tester)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "How can you implement a feature that exposes the internal subscription registry of the message broker to allow for customized subscription management and monitoring?",
    "function_signature": "public SubscriptionRegistry getSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Design a component that can inspect incoming HTTP requests and determine whether they should proceed to the designated handler based on custom authentication logic.",
    "function_signature": "public boolean authenticateAndProceed(HttpServletRequest request, HttpServletResponse response, Object handler);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int sessions;",
    "query": "Implement a monitoring service that periodically retrieves and logs the number of active messaging sessions in your Spring-based application. Ensure that your solution efficiently accesses the session count using the latest enhancements in Spring's messaging infrastructure.",
    "function_signature": "public int fetchActiveSessionCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#find(serverState,request)",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "method",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}",
    "query": "Design a component that efficiently retrieves multiple user subscriptions based on specific messaging destinations and criteria within a real-time communication system.",
    "function_signature": "public MultiValueMap<String, String> fetchSubscriptions(ServerState serverState, FindRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Design a feature for a real-time collaborative application that efficiently tracks and manages active user sessions and their subscriptions to various collaborative documents. Ensure the solution can handle dynamic scaling of sessions and destinations while maintaining optimal performance.",
    "function_signature": "public void initializeCollaborativeSessionTracking(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Design a method to efficiently handle and register user subscriptions that may include wildcard patterns, ensuring optimized message routing in a real-time messaging application.",
    "function_signature": "public void registerUserSubscriptions(String sessionId, String destinationPattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Implement a component that logs detailed information about each HTTP request and ensures that specific cleanup operations are performed after the request has been fully processed, regardless of its outcome.",
    "function_signature": "public void finalizeRequestProcessing(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Design a middleware component that selectively intercepts HTTP requests by applying a bespoke pattern matching mechanism for URL paths, allowing for dynamic inclusion and exclusion criteria based on customized matching rules.",
    "function_signature": "public void initializeInterceptorWithCustomMatcher(CustomPathMatcher matcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.2.11.RELEASE",
    "to_version": "v5.3.1",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String session;",
    "query": "Develop a WebSocket controller that assigns and tracks messages based on unique user sessions to maintain consistent communication states across client interactions.",
    "function_signature": "public void processSessionMessage(String session, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.DefaultListableBeanFactory#clearMetadataCache()",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public void clearMetadataCache()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void clearMetadataCache() {\n\t\tsuper.clearMetadataCache();\n\t\tthis.mergedBeanDefinitionHolders.clear();\n\t\tclearByTypeCache();\n\t}",
    "query": "Enhance the stability and performance of your Spring application by implementing a strategy that efficiently manages bean metadata, ensuring optimal resource utilization and reducing potential memory overhead.",
    "function_signature": "public void refreshBeanMetadata();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer#setThrowingName(throwingName)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public void setThrowingName(@Nullable String throwingName)",
    "documentation": "\t/**\n\t * If {@code afterThrowing} advice binds the thrown value, the\n\t * {@code throwing} variable name must be specified.\n\t * @param throwingName the name of the throwing variable\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setThrowingName(@Nullable String throwingName) {\n\t\tthis.throwingName = throwingName;\n\t}",
    "query": "Develop an aspect that efficiently binds and handles exceptions thrown by target methods, ensuring enhanced type safety and streamlined exception management within your application.",
    "function_signature": "public void initializeExceptionHandling(String exceptionIdentifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.observation.DefaultServerRequestObservationConvention#getLowCardinalityKeyValues(context)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public KeyValues getLowCardinalityKeyValues(ServerRequestObservationContext context)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic KeyValues getLowCardinalityKeyValues(ServerRequestObservationContext context) {\n\t\t// Make sure that KeyValues entries are already sorted by name for better performance\n\t\treturn KeyValues.of(exception(context), method(context), outcome(context), status(context), uri(context));\n\t}",
    "query": "Enhance the server request observation by implementing a method that efficiently retrieves essential key values, ensuring optimal performance and streamlined data handling.",
    "function_signature": "public KeyValues retrieveOptimizedKeyValues(ServerRequestObservationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.agent.<unknown>#visitMethodInsn(opcode,owner,name,descriptor,isInterface)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n\t\t\tif (isOpcodeSupported(opcode) && shouldRecordMethodCall(owner, name)) {\n\t\t\t\tString instrumentedMethodName = rewriteMethodName(owner, name);\n\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, INSTRUMENTED_CLASS, instrumentedMethodName,\n\t\t\t\t\t\trewriteDescriptor(opcode, owner, name, descriptor), false);\n\t\t\t\tisTransformed = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n\t\t\t}\n\t\t}",
    "query": "Enhance your Spring application by implementing a method that efficiently manages method invocation instructions, ensuring improved performance and adherence to modern best practices for method instrumentation.",
    "function_signature": "public void handleMethodInvocation(int opcode, String owner, String methodName, String descriptor, boolean isInterface)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.ServletRequestPathUtils#getCachedPathValue(request)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public String getCachedPathValue(ServletRequest request)",
    "documentation": "\t/**\n\t * Variant of {@link #getCachedPath(ServletRequest)} that returns the path\n\t * for request mapping as a String.\n\t * <p>If the cached path is a {@link #parseAndCache(HttpServletRequest)\n\t * pre-parsed} {@code RequestPath} then the returned String path value is\n\t * encoded and with path parameters removed.\n\t * <p>If the cached path is a {@link UrlPathHelper#resolveAndCacheLookupPath\n\t * pre-resolved} String lookupPath, then the returned String path value\n\t * depends on how {@link UrlPathHelper} that resolved is configured.\n\t * @param request the current request\n\t * @return the full request mapping path as a String\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static String getCachedPathValue(ServletRequest request) {\n\t\tObject path = getCachedPath(request);\n\t\tif (path instanceof PathContainer pathContainer) {\n\t\t\tString value = pathContainer.value();\n\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(value);\n\t\t}\n\t\treturn (String) path;\n\t}",
    "query": "Enhance the retrieval of the request's mapping path to ensure better performance and thread safety within your servlet handling logic.",
    "function_signature": "public String getCachedPath(ServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.ReflectUtils#newInstance(type)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public Object newInstance(Class type)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static Object newInstance(Class type) {\n\t\treturn newInstance(type, Constants.EMPTY_CLASS_ARRAY, null);\n\t}",
    "query": "Create a utility method that efficiently instantiates objects of a given class, ensuring type safety and improved performance compared to traditional instantiation approaches.",
    "function_signature": "public static <T> T instantiateClass(Class<T> clazz)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.convert.TypeDescriptor#upcast(superType)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public TypeDescriptor upcast(@Nullable Class<?> superType)",
    "documentation": "\t/**\n\t * Cast this {@link TypeDescriptor} to a superclass or implemented interface\n\t * preserving annotations and nested type context.\n\t * @param superType the supertype to cast to (can be {@code null})\n\t * @return a new TypeDescriptor for the up-cast type\n\t * @throws IllegalArgumentException if this type is not assignable to the super-type\n\t * @since 3.2\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic TypeDescriptor upcast(@Nullable Class<?> superType) {\n\t\tif (superType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.isAssignable(superType, getType());\n\t\treturn new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations());\n\t}",
    "query": "Enhance the type conversion mechanism by implementing a method that efficiently adapts a `TypeDescriptor` to a specified superclass or interface, ensuring type safety and maintaining annotation integrity throughout the conversion process.",
    "function_signature": "public TypeDescriptor adaptToSuperType(Class<?> targetSuperType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.TypeUtils#add(t1,t2)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public Type[] add(Type[] t1, Type[] t2)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "    public static Type[] add(Type[] t1, Type[] t2) {\n        // TODO: set semantics?\n        Type[] all = new Type[t1.length + t2.length];\n        System.arraycopy(t1, 0, all, 0, t1.length);\n        System.arraycopy(t2, 0, all, t1.length, t2.length);\n        return all;\n    }",
    "query": "Design a method to efficiently merge two arrays of `Type` objects, ensuring optimal performance and type safety.",
    "function_signature": "public Type[] mergeTypes(Type[] first, Type[] second)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter#getFormWriter()",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "public String>> getFormWriter()",
    "documentation": "\t/**\n\t * Return the configured form writer.\n\t * @since 5.1.13\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HttpMessageWriter<MultiValueMap<String, String>> getFormWriter() {\n\t\treturn this.formWriter;\n\t}",
    "query": "Create a component that efficiently manages the serialization of form data within HTTP responses, ensuring enhanced performance and thread safety.",
    "function_signature": "public HttpMessageWriter<MultiValueMap<String, String>> configureFormHttpMessageWriter();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.core.GenericMessagingTemplate#doSend(channel,message)",
    "from_version": "v6.1.0-M1",
    "to_version": "v5.2.25.RELEASE",
    "type": "method",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message) {\n\t\tdoSend(channel, message, sendTimeout(message));\n\t}",
    "query": "Refactor the messaging component to ensure messages are sent with a specified timeout, enhancing control over message delivery and system responsiveness.",
    "function_signature": "protected void sendMessage(MessageChannel channel, Message<?> message, long timeout)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.ConfigurationClassPostProcessor#processAheadOfTime(registeredBean)",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean) {\n\t\tObject configClassAttr = registeredBean.getMergedBeanDefinition()\n\t\t\t\t.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE);\n\t\tif (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) {\n\t\t\tClass<?> proxyClass = registeredBean.getBeanType().toClass();\n\t\t\treturn BeanRegistrationAotContribution.withCustomCodeFragments(codeFragments ->\n\t\t\t\t\tnew ConfigurationClassProxyBeanRegistrationCodeFragments(codeFragments, proxyClass));\n\t\t}\n\t\treturn null;\n\t}",
    "query": "Optimize the bean registration process to enhance performance and ensure thread safety by utilizing the latest recommended approach for processing registered beans in your Spring configuration.",
    "function_signature": "public BeanRegistrationAotContribution optimizeBeanProcessing(RegisteredBean registeredBean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.DataBinder#getInternalBindingResult()",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "protected AbstractPropertyBindingResult getInternalBindingResult()",
    "documentation": "\t/**\n\t * Return the internal BindingResult held by this DataBinder,\n\t * as an AbstractPropertyBindingResult.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected AbstractPropertyBindingResult getInternalBindingResult() {\n\t\tif (this.bindingResult == null) {\n\t\t\tthis.bindingResult = (this.directFieldAccess ?\n\t\t\t\t\tcreateDirectFieldBindingResult(): createBeanPropertyBindingResult());\n\t\t}\n\t\treturn this.bindingResult;\n\t}",
    "query": "Implement a method that retrieves the current binding results from a DataBinder instance in a thread-safe manner, ensuring optimal performance and enhanced usability for validation error handling.",
    "function_signature": "public BindingResult fetchCurrentBindingResult()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jndi.JndiObjectFactoryBean#setExposeAccessContext(exposeAccessContext)",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public void setExposeAccessContext(boolean exposeAccessContext)",
    "documentation": "\t/**\n\t * Set whether to expose the JNDI environment context for all access to the target\n\t * object, i.e. for all method invocations on the exposed object reference.\n\t * <p>Default is \"false\", i.e. to only expose the JNDI context for object lookup.\n\t * Switch this flag to \"true\" in order to expose the JNDI environment (including\n\t * the authorization context) for each method invocation, as needed by WebLogic\n\t * for JNDI-obtained factories (e.g. JDBC DataSource, JMS ConnectionFactory)\n\t * with authorization requirements.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setExposeAccessContext(boolean exposeAccessContext) {\n\t\tthis.exposeAccessContext = exposeAccessContext;\n\t}",
    "query": "Design a JNDI object factory configuration that minimizes performance overhead and enhances security by efficiently managing environment contexts during object access.",
    "function_signature": "public void configureEfficientJndiObjectFactory(EnvironmentContextManager contextManager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.AbstractNestablePropertyAccessor#isWritableProperty(propertyName)",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public boolean isWritableProperty(String propertyName)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isWritableProperty(String propertyName) {\n\t\ttry {\n\t\t\tPropertyHandler ph = getPropertyHandler(propertyName);\n\t\t\tif (ph != null) {\n\t\t\t\treturn ph.isWritable();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Maybe an indexed/mapped property...\n\t\t\t\tgetPropertyValue(propertyName);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (InvalidPropertyException ex) {\n\t\t\t// Cannot be evaluated, so can't be writable.\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Create a utility method that checks if a specific attribute of a bean can be safely altered, prioritizing performance and reliability in property manipulation.",
    "function_signature": "public boolean canAlterProperty(String attributeName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getAttributeNames()",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public Enumeration<String> getAttributeNames()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Enumeration<String> getAttributeNames() {\n\t\tcheckActive();\n\t\treturn Collections.enumeration(new LinkedHashSet<>(this.attributes.keySet()));\n\t}",
    "query": "Design a method to obtain all attribute identifiers from a simulated HTTP request in a type-safe and performant manner, enhancing usability compared to legacy iteration techniques.",
    "function_signature": "public List<String> retrieveAttributeIdentifiers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.ObjectOptimisticLockingFailureException#getIdentifier()",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public Object getIdentifier()",
    "documentation": "\t/**\n\t * Return the identifier of the object for which the locking failed.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Object getIdentifier() {\n\t\treturn this.identifier;\n\t}",
    "query": "Improve exception handling by retrieving the unique identifier of the entity involved in an optimistic locking failure using a more robust and type-safe approach.",
    "function_signature": "public <T> void handleOptimisticLockingFailure(ObjectOptimisticLockingFailureException ex, Class<T> entityType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.SpecificityComparator",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "class",
    "signature": "public class SpecificityComparator",
    "documentation": "\t/**\n\t * Comparator to sort {@link MimeType MimeTypes} in order of specificity.\n\t *\n\t * @param <T> the type of mime types that may be compared by this comparator\n\t * @deprecated As of 6.0, with no direct replacement\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static class SpecificityComparator<T extends MimeType> implements Comparator<T> {\n\n\t\t@Override\n\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}\n\t}",
    "query": "Improve the efficiency and reliability of MIME type sorting by implementing a method that prioritizes more specific types over general ones.",
    "function_signature": "public void sortMimeTypesBySpecificity(List<MimeType> mimeTypes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.DestinationPatternsMessageCondition#getMatchingCondition(message)",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public DestinationPatternsMessageCondition getMatchingCondition(Message<?> message)",
    "documentation": "\t/**\n\t * Check if any of the patterns match the given Message destination and return an instance\n\t * that is guaranteed to contain matching patterns, sorted via\n\t * {@link org.springframework.util.PathMatcher#getPatternComparator(String)}.\n\t * @param message the message to match to\n\t * @return the same instance if the condition contains no patterns;\n\t * or a new condition with sorted matching patterns;\n\t * or {@code null} either if a destination can not be extracted or there is no match\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic DestinationPatternsMessageCondition getMatchingCondition(Message<?> message) {\n\t\tObject destination = message.getHeaders().get(LOOKUP_DESTINATION_HEADER);\n\t\tif (destination == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.patterns.isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tList<String> matches = null;\n\t\tfor (String pattern : this.patterns) {\n\t\t\tif (pattern.equals(destination) || matchPattern(pattern, destination)) {\n\t\t\t\tif (matches == null) {\n\t\t\t\t\tmatches = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (CollectionUtils.isEmpty(matches)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tmatches.sort(getPatternComparator(destination));\n\t\treturn new DestinationPatternsMessageCondition(new LinkedHashSet<>(matches), this.routeMatcher);\n\t}",
    "query": "Create a method that efficiently identifies and retrieves the appropriate message handling condition based on the destination within a message. Ensure that the implementation enhances performance and type safety, providing a more robust and user-friendly approach compared to previous strategies.",
    "function_signature": "public OptimizedMessageCondition resolveCondition(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#setDestinationPrefixes(prefixes)",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public void setDestinationPrefixes(@Nullable Collection<String> prefixes)",
    "documentation": "\t/**\n\t * {@inheritDoc}\n\t * <p>Destination prefixes are expected to be slash-separated Strings and\n\t * therefore a slash is automatically appended where missing to ensure a\n\t * proper prefix-based match (i.e. matching complete segments).\n\t * <p>Note however that the remaining portion of a destination after the\n\t * prefix may use a different separator (e.g. commonly \".\" in messaging)\n\t * depending on the configured {@code PathMatcher}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setDestinationPrefixes(@Nullable Collection<String> prefixes) {\n\t\tsuper.setDestinationPrefixes(appendSlashes(prefixes));\n\t}",
    "query": "Configure a message handler to manage destination prefixes efficiently, ensuring automatic handling of path separators and compatibility with custom path matchers for enhanced reliability.",
    "function_signature": "public void initializeDestinationConfiguration(@Nullable Collection<String> prefixes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.agent.RecordedInvocation#getArgumentTypes(index)",
    "from_version": "v6.0.8",
    "to_version": "v5.3.27",
    "type": "method",
    "signature": "public List<TypeReference> getArgumentTypes(int index)",
    "documentation": "\t/**\n\t * Return the types of the arguments used for the current reflection invocation,\n\t * starting from the given index.\n\t * @return the argument types, starting at the given index\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic List<TypeReference> getArgumentTypes(int index) {\n\t\treturn Arrays.stream(this.arguments).skip(index).map(param -> TypeReference.of(param.getClass())).toList();\n\t}",
    "query": "Implement a method to efficiently retrieve argument type information from a specific position within invocation records, ensuring improved performance and safety.",
    "function_signature": "public List<TypeReference> retrieveArgumentTypes(int startIndex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.DependencyDescriptor#isNullable(field)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public boolean isNullable(Field field)",
    "documentation": "\t\t/**\n\t\t * Check whether the specified {@link Field} represents a nullable Kotlin type or not.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic static boolean isNullable(Field field) {\n\t\t\tKProperty<?> property = ReflectJvmMapping.getKotlinProperty(field);\n\t\t\treturn (property != null && property.getReturnType().isMarkedNullable());\n\t\t}",
    "query": "In a Kotlin-based Spring application, ensure that your dependency injection logic correctly identifies and handles nullable properties within your beans. How would you implement a method that determines the nullability of a given bean property to manage optional dependencies effectively?",
    "function_signature": "public boolean isFieldNullableForDependencyInjection(Field field)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.BodyInserters#fromValue(body,bodyType)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType)",
    "documentation": "\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object, ParameterizedTypeReference)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param bodyType the type of the body, used to capture the generic type\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, ParameterizedTypeReference)} or\n\t * {@link #fromProducer(Object, ParameterizedTypeReference)} should be used.\n\t * @since 6.2\n\t * @see #fromPublisher(Publisher, ParameterizedTypeReference)\n\t * @see #fromProducer(Object, ParameterizedTypeReference)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.notNull(bodyType, \"'bodyType' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forType(bodyType), null);\n\t}",
    "query": "Design a reactive service method that processes a user-submitted data object with generic type information, ensuring that the response body accurately retains the generic type details for downstream consumers.",
    "function_signature": "public Mono<ServerResponse> processUserData(UserData inputData, ParameterizedTypeReference<ResultData> resultType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,",
    "query": "Optimize the reactive HTTP client setup to enhance performance and ensure thread safety when establishing connections to external services.",
    "function_signature": "public Mono<ClientHttpResponse> establishConnection(HttpMethod method, URI uri, Consumer<ClientHttpRequest> requestConfigurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#remoteAddress(remoteAddress)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public B remoteAddress(String remoteAddress)",
    "documentation": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic B remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn self();\n\t}",
    "query": "Design a unit test to verify that your API correctly restricts access when requests originate from unauthorized IP addresses by simulating various client IPs.",
    "function_signature": "public void shouldRejectAccessWhenRemoteAddressIsUnauthorized()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#close()",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public void close()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic void close() {\n\t\t\t\tthis.delegate.close();\n\t\t\t\tthis.chunk.release();\n\t\t\t}",
    "query": "Design a component that ensures efficient termination of HTTP connections, minimizing resource leaks and enhancing overall application stability.",
    "function_signature": "public void terminateConnectionsGracefully()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#copyToUriComponentsBuilder(builder)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "protected void copyToUriComponentsBuilder(UriComponentsBuilder builder)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tprotected void copyToUriComponentsBuilder(UriComponentsBuilder builder) {\n\t\tif (getScheme() != null) {\n\t\t\tbuilder.scheme(getScheme());\n\t\t}\n\t\tif (getSchemeSpecificPart() != null) {\n\t\t\tbuilder.schemeSpecificPart(getSchemeSpecificPart());\n\t\t}\n\t\tif (getFragment() != null) {\n\t\t\tbuilder.fragment(getFragment());\n\t\t}\n\t}",
    "query": "Create a method that populates a `UriComponentsBuilder` with the current object's URI details, ensuring that the scheme, scheme-specific part, and fragment are accurately transferred.",
    "function_signature": "protected void populateUriBuilder(UriComponentsBuilder builder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#replacePlaceholders(value,placeholderResolver)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver)",
    "documentation": "\t/**\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\tParsedValue parsedValue = parse(value);\n\t\tPartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver,\n\t\t\t\tthis.prefix, this.suffix, this.ignoreUnresolvablePlaceholders,\n\t\t\t\tcandidate -> parse(candidate, false));\n\t\treturn parsedValue.resolve(resolutionContext);\n\t}",
    "query": "Design a component that processes configuration files containing dynamic placeholders, replacing each placeholder with appropriate runtime values while allowing for custom resolution strategies.",
    "function_signature": "public String processConfiguration(String configTemplate, PlaceholderResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#cookie(cookies)",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder cookie(Cookie... cookies)",
    "documentation": "\t/**\n\t * Add the given cookies to the request. Cookies are always added.\n\t * @param cookies the cookies to add\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic MockHttpServletRequestBuilder cookie(Cookie... cookies) {\n\t\tAssert.notEmpty(cookies, \"'cookies' must not be empty\");\n\t\tthis.cookies.addAll(Arrays.asList(cookies));\n\t\treturn this;\n\t}",
    "query": "Enhance your mock HTTP request setup by incorporating a more efficient and secure approach to managing cookies. Ensure that the solution improves performance and maintains better usability within your testing framework.",
    "function_signature": "public MockHttpServletRequestBuilder addCookies(Cookie... cookies)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.SpringWebBlockHoundIntegration",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "class",
    "signature": "public class SpringWebBlockHoundIntegration",
    "documentation": "\t/**\n\t * {@code BlockHoundIntegration} for spring-web classes.\n\t * @since 5.3.6\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static class SpringWebBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}\n\t}",
    "query": "Enhance your Spring Web application's responsiveness by implementing a streamlined BlockHound configuration that minimizes structural dependencies and optimizes performance.",
    "function_signature": "public void initializeOptimizedBlockHound(BlockHound.Builder builder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#hashCode()",
    "from_version": "v6.1.12",
    "to_version": "v6.2.0-M7",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int hashCode() {\n\t\treturn JCacheOperationSourcePointcut.class.hashCode();\n\t}",
    "query": "Design a mechanism to generate unique identifiers for cache operations that enhances reliability and consistency across your application.",
    "function_signature": "public int generateCacheOperationId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.AbstractNestablePropertyAccessor#getMapKeyType(nestingLevel)",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public TypeDescriptor getMapKeyType(int nestingLevel)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic TypeDescriptor getMapKeyType(int nestingLevel) {\n\t\t\treturn TypeDescriptor.valueOf(getResolvableType().getNested(nestingLevel).asMap().resolveGeneric(0));\n\t\t}",
    "query": "Optimize the retrieval of a map's key type within nested structures to enhance type safety and performance, utilizing the latest recommended approach.",
    "function_signature": "public TypeDescriptor determineMapKeyType(int depthLevel)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.WebExchangeDataBinder#construct(exchange)",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public Mono<Void> construct(ServerWebExchange exchange)",
    "documentation": "\t/**\n\t * Use a default or single data constructor to create the target by\n\t * binding request parameters, multipart files, or parts to constructor args.\n\t * <p>After the call, use {@link #getBindingResult()} to check for bind errors.\n\t * If there are none, the target is set, and {@link #bind} can be called for\n\t * further initialization via setters.\n\t * @param exchange the request to bind\n\t * @return a {@code Mono<Void>} that completes when the target is created\n\t * @since 6.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Mono<Void> construct(ServerWebExchange exchange) {\n\t\treturn getValuesToBind(exchange)\n\t\t\t\t.doOnNext(map -> construct(new MapValueResolver(map)))\n\t\t\t\t.then();\n\t}",
    "query": "Refactor the data binding process to enhance performance and ensure safer handling of request parameters within your web application. Implement a method that efficiently initializes the target object by leveraging the latest binding mechanisms provided by the framework.",
    "function_signature": "public Mono<Void> initializeBinding(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.HandlerMethod#getMethod()",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public Method getMethod()",
    "documentation": "\t/**\n\t * Return the method for this handler method.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}",
    "query": "Create a feature that intercepts incoming web requests and logs detailed information about the handler methods, including their signatures and annotations, to facilitate advanced debugging and analytics.",
    "function_signature": "public void logHandlerMethodDetails(HandlerMethod handlerMethod)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.CompoundExpression#getValueInternal(state)",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public TypedValue getValueInternal(ExpressionState state)",
    "documentation": "\t/**\n\t * Evaluates a compound expression. This involves evaluating each piece in turn and the\n\t * return value from each piece is the active context object for the subsequent piece.\n\t * @param state the state in which the expression is being evaluated\n\t * @return the final value from the last piece of the compound expression\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tValueRef ref = getValueRef(state);\n\t\tTypedValue result = ref.getValue();\n\t\tthis.exitTypeDescriptor = this.children[this.children.length - 1].exitTypeDescriptor;\n\t\treturn result;\n\t}",
    "query": "Design a feature that processes a sequence of dependent configuration settings, where each setting's value is determined based on the evaluation of the previous ones. Ensure that the implementation efficiently handles the chaining of these evaluations to produce the final configuration result.",
    "function_signature": "public TypedValue resolveSequentialConfigurations(ExpressionState state)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#loadContext(mergedConfig)",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public ApplicationContext loadContext(MergedContextConfiguration mergedConfig)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic ApplicationContext loadContext(MergedContextConfiguration mergedConfig) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tApplicationContext context = this.contextCache.get(mergedConfig);\n\t\t\ttry {\n\t\t\t\tif (context == null) {\n\t\t\t\t\tInteger failureCount = this.contextCache.getFailureCount(mergedConfig);\n\t\t\t\t\tif (failureCount >= this.failureThreshold) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\t\t\tApplicationContext failure threshold (%d) exceeded: \\\n\t\t\t\t\t\t\t\tskipping repeated attempt to load context for %s\"\"\"\n\t\t\t\t\t\t\t\t\t.formatted(this.failureThreshold, mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (mergedConfig instanceof AotMergedContextConfiguration aotMergedConfig) {\n\t\t\t\t\t\t\tcontext = loadContextInAotMode(aotMergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontext = loadContextInternal(mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Storing ApplicationContext [%s] in cache under key %s\".formatted(\n\t\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.put(mergedConfig, context);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Incrementing ApplicationContext failure count for \" + mergedConfig);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.contextCache.incrementFailureCount(mergedConfig);\n\t\t\t\t\t\tThrowable cause = ex;\n\t\t\t\t\t\tif (ex instanceof ContextLoadException cle) {\n\t\t\t\t\t\t\tcause = cle.getCause();\n\t\t\t\t\t\t\tfor (ApplicationContextFailureProcessor contextFailureProcessor : this.contextFailureProcessors) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcontextFailureProcessor.processLoadFailure(cle.getApplicationContext(), cause);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignoring exception thrown from ApplicationContextFailureProcessor [%s]: %s\"\n\t\t\t\t\t\t\t\t\t\t\t\t.formatted(contextFailureProcessor, throwable));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Failed to load ApplicationContext for \" + mergedConfig, cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Retrieved ApplicationContext [%s] from cache with key %s\".formatted(\n\t\t\t\t\t\t\t\tSystem.identityHashCode(context), mergedConfig));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.contextCache.logStatistics();\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\t}",
    "query": "Design a component that efficiently initializes the application context using the most recent Spring testing utilities, ensuring enhanced performance and reliability during context loading.",
    "function_signature": "public ApplicationContext initializeApplicationContext(TestConfiguration configuration)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.RequestPredicates#bind(bindType,dataBinderCustomizer)",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\treturn this.request.bind(bindType, dataBinderCustomizer);\n\t\t}",
    "query": "Create a handler that efficiently maps incoming request data to a specific model class, ensuring enhanced validation and customizable binding configurations for improved reliability.",
    "function_signature": "public <T> T mapRequestToModel(Class<T> modelClass, Consumer<CustomDataBinder> binderConfigurer) throws BindingException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.<unknown>#list()",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public List<T> list()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic List<T> list() {\n\t\t\t\treturn namedParamOps.query(sql, namedParamSource, this.rowMapper);\n\t\t\t}",
    "query": "Refactor the data access layer to enhance performance by implementing a method that executes a SQL query with named parameters and maps the results to a list of objects.",
    "function_signature": "public List<T> executeQueryWithParameters()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.PREFIX_TIMEOUT",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "field",
    "signature": "public String PREFIX_TIMEOUT",
    "documentation": "\t/** Prefix for transaction timeout values in description strings. */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final String PREFIX_TIMEOUT = \"timeout_\";",
    "query": "Create a method to establish transaction timeouts using modern conventions that enhance clarity and reduce potential errors.",
    "function_signature": "public void configureTransactionTimeout(TransactionManager transactionManager, Duration timeout)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.r2dbc.core.BeanPropertyRowMapper#apply(readable)",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public T apply(Readable readable)",
    "documentation": "\t/**\n\t * Extract the values for the current {@link Readable}: all columns in case\n\t * of a {@link Row} or all parameters in case of an {@link OutParameters}.\n\t * <p>Utilizes public setters and derives meta-data from the concrete type.\n\t * @throws IllegalArgumentException in case the concrete type is neither\n\t * {@code Row} nor {@code OutParameters}\n\t * @see RowMetadata\n\t * @see OutParametersMetadata\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic T apply(Readable readable) {\n\t\tif (readable instanceof Row row) {\n\t\t\treturn mapForReadable(row, row.getMetadata().getColumnMetadatas());\n\t\t}\n\t\tif (readable instanceof OutParameters out) {\n\t\t\treturn mapForReadable(out, out.getMetadata().getParameterMetadatas());\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Can only map Readable Row or OutParameters, got \" + readable.getClass().getName());\n\t}",
    "query": "Enhance the data retrieval process by implementing a mapping function that ensures type safety and optimizes performance when converting `Readable` data sources to domain entities.",
    "function_signature": "public T mapToEntity(Readable readable)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty5HeadersAdapter#values()",
    "from_version": "v6.1.0-M5",
    "to_version": "v6.0.13",
    "type": "method",
    "signature": "public Collection<List<String>> values()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}",
    "query": "Enhance the component to obtain all header values using a more efficient and scalable approach.",
    "function_signature": "public Stream<String> getHeaderValuesStream()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.support.SimpleValueWrapper#hashCode()",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\treturn Objects.hashCode(this.value);\n\t}",
    "query": "Develop a caching service that stores and retrieves user session data. Ensure that the service can efficiently manage and compare cached session entries to prevent duplication and optimize memory usage.",
    "function_signature": "public int computeSessionCacheHash(ValueWrapper sessionWrapper)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#attribute(name,value)",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}",
    "query": "Develop a utility that streamlines the configuration of request attributes, enhancing type safety and performance when constructing HTTP request bodies with Spring's WebClient.",
    "function_signature": "public RequestBodySpec configureAttributes(Map<String, Object> attributes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.config.WebSocketMessageBrokerStats#afterSingletonsInstantiated()",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public void afterSingletonsInstantiated()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterSingletonsInstantiated() {\n\t\tthis.stompSubProtocolHandler = initStompSubProtocolHandler();\n\t\tthis.loggingTask = initLoggingTask(TimeUnit.MINUTES.toMillis(1));\n\t}",
    "query": "Implement a Spring component that executes custom setup procedures immediately after all singleton beans are initialized, specifically configuring a message handler and scheduling a recurring logging task.",
    "function_signature": "public void executePostInitializationTasks()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.support.SimpleValueWrapper#get()",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public Object get()",
    "documentation": "\t/**\n\t * Simply returns the value as given at construction time.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Object get() {\n\t\treturn this.value;\n\t}",
    "query": "Create a service method that retrieves raw data from the cache system, ensuring that the returned value is exactly as it was stored without any transformation or processing.",
    "function_signature": "public Object fetchRawCachedData(String cacheKey)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.support.SimpleValueWrapper",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "class",
    "signature": "public class SimpleValueWrapper",
    "documentation": "/**\n * Straightforward implementation of {@link org.springframework.cache.Cache.ValueWrapper},\n * simply holding the value as given at construction and returning it from {@link #get()}.\n *\n * @author Costin Leau\n * @since 3.1\n */",
    "changetype": "stabilized",
    "source_code": "public class SimpleValueWrapper implements ValueWrapper {\n\n\t@Nullable\n\tprivate final Object value;\n\n\n\t/**\n\t * Create a new SimpleValueWrapper instance for exposing the given value.\n\t * @param value the value to expose (may be {@code null})\n\t */\n\tpublic SimpleValueWrapper(@Nullable Object value) {\n\t\tthis.value = value;\n\t}\n\n\n\t/**\n\t * Simply returns the value as given at construction time.\n\t */\n\t@Override\n\t@Nullable\n\tpublic Object get() {\n\t\treturn this.value;\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof ValueWrapper wrapper && Objects.equals(get(), wrapper.get())));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hashCode(this.value);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ValueWrapper for [\" + this.value + \"]\";\n\t}\n\n}",
    "query": "Design a method that fetches product details from the cache and ensures a consistent response structure, even when the product is absent. This approach should simplify handling cached values and streamline null checks in your service layer.",
    "function_signature": "public Cache.ValueWrapper retrieveCachedProductDetails(String productId)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#findInCaches(context,cache,key)",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(context.getMethod().getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tCompletableFuture<?> cachedFuture = cache.retrieve(key);\n\t\t\t\tif (cachedFuture == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(cachedFuture))\n\t\t\t\t\t\t\t.flatMap(v -> (v instanceof Iterable<?> iv ? Flux.fromIterable(iv) : Flux.just(v))));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(cachedFuture));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}",
    "query": "Create a method to retrieve cached data in a reactive manner, optimizing for non-blocking operations and seamless integration with reactive streams.",
    "function_signature": "public Mono<Object> fetchCacheDataReactive(CacheOperationContext context, Cache cache, Object key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#performCachePut(value)",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public void performCachePut(@Nullable Object value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void performCachePut(@Nullable Object value) {\n\t\t\tif (this.context.canPutToCache(value)) {\n\t\t\t\tObject key = generateKey(this.context, value);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Creating cache entry for key '\" + key + \"' in cache(s) \" +\n\t\t\t\t\t\t\tthis.context.getCacheNames());\n\t\t\t\t}\n\t\t\t\tfor (Cache cache : this.context.getCaches()) {\n\t\t\t\t\tdoPut(cache, key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Ensure that any changes to customer data are automatically synchronized across all caching layers to maintain data consistency without additional manual cache management.",
    "function_signature": "public void updateCustomerData(Customer customer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#findInCaches(context,cache,key,invoker,method,contexts)",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key,\n\t\t\t\tCacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key,",
    "query": "Design a service method that efficiently retrieves product information by sequentially searching through multiple cache layers before executing a fallback database query.",
    "function_signature": "public Object getProductInfo(CacheOperationContext context, Cache cache, Object key, CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.support.SimpleValueWrapper#toString()",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn \"ValueWrapper for [\" + this.value + \"]\";\n\t}",
    "query": "How can I implement detailed logging for cache retrievals that includes descriptive information about each cached value?",
    "function_signature": "public String logCacheRetrievalDetails(String cacheKey)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)",
    "from_version": "v6.1.0",
    "to_version": "v6.1.1",
    "type": "method",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}",
    "query": "Refactor the request configuration to utilize a more type-safe and performant approach when setting custom attributes for the request body.",
    "function_signature": "public RequestBodySpec withAttributes(Function<Map<String, Object>, Map<String, Object>> attributeConfigurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.MergedContextConfiguration#getParent()",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public MergedContextConfiguration getParent()",
    "documentation": "\t/**\n\t * Get the {@link MergedContextConfiguration} for the parent application context\n\t * in a context hierarchy.\n\t * @return the parent configuration or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParentApplicationContext()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MergedContextConfiguration getParent() {\n\t\treturn this.parent;\n\t}",
    "query": "Create a test setup that leverages shared configurations from a base application context to streamline multiple integration tests, ensuring consistency and reducing redundancy.",
    "function_signature": "public MergedContextConfiguration obtainInheritedTestConfiguration()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.config.ScheduledTaskRegistrar#setObservationRegistry(observationRegistry)",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public void setObservationRegistry(@Nullable ObservationRegistry observationRegistry)",
    "documentation": "\t/**\n\t * Configure an {@link ObservationRegistry} to record observations for scheduled tasks.\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setObservationRegistry(@Nullable ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t}",
    "query": "Design a system component that automatically monitors and logs the execution metrics of all scheduled tasks in your application, enabling comprehensive observability and performance analysis.",
    "function_signature": "public void configureScheduledTaskObservability(@Nullable ObservationRegistry observationRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.MapSqlParameterSource#hasValues()",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public boolean hasValues()",
    "documentation": "\t/**\n\t * Return whether this parameter source has been configured with any values.\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean hasValues() {\n\t\treturn !this.values.isEmpty();\n\t}",
    "query": "Design a repository method that fetches records based on a set of optional filtering parameters. Ensure the method first validates whether any filters have been provided to prevent executing queries without criteria, thereby enhancing efficiency and avoiding unnecessary database interactions.",
    "function_signature": "public List<Product> findProductsByFilters(MapSqlParameterSource filterParameters)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#handleResolvedValue(arg,name,parameter,message)",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Message<?> message)",
    "documentation": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param message the message\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void handleResolvedValue(",
    "query": "Design a custom message argument resolver that processes incoming messages by extracting specific headers and performing additional validation or transformation on the resolved argument before it is passed to the handler method.",
    "function_signature": "protected void processResolvedArgument(@Nullable Object arg, String name, MethodParameter parameter, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.xml.Jaxb2XmlEncoder#getMarshallerProcessor()",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public Marshaller> getMarshallerProcessor()",
    "documentation": "\t/**\n\t * Return the configured processor for customizing Marshaller instances.\n\t * @since 5.1.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Function<Marshaller, Marshaller> getMarshallerProcessor() {\n\t\treturn this.marshallerProcessor;\n\t}",
    "query": "Design a Spring WebFlux component that modifies the JAXB marshaller to include a custom namespace during XML serialization of API responses.",
    "function_signature": "public void configureCustomNamespaceProcessor(Function<Marshaller, Marshaller> namespaceProcessor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.DefaultLifecycleProcessor#registerResource()",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public Object registerResource()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Object registerResource() {\n\t\t\tlogger.debug(\"Registering JVM checkpoint/restore callback for Spring-managed lifecycle beans\");\n\t\t\tCracResourceAdapter resourceAdapter = new CracResourceAdapter();\n\t\t\torg.crac.Core.getGlobalContext().register(resourceAdapter);\n\t\t\treturn resourceAdapter;\n\t\t}",
    "query": "In a microservices architecture, implement a mechanism within your Spring application to register lifecycle resources that support JVM checkpointing and restore functionality, ensuring high availability and state consistency.",
    "function_signature": "public Object registerResourceForCheckpointing()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.HandlerMethod#formatArgumentError(param,message)",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}",
    "query": "Create a method that constructs comprehensive error messages when a method parameter fails to resolve, optimizing for better performance and clearer diagnostics in your messaging handlers.",
    "function_signature": "protected String buildParameterResolutionError(MethodParameter parameter, String detail)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.TestPropertySourceUtils#addPropertySourcesToEnvironment(environment,resourceLoader,descriptors)",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)",
    "documentation": "\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,",
    "query": "Design a Spring component that programmatically incorporates multiple property sources into the applications environment during integration tests, ensuring that any placeholders within resource locations are properly resolved.",
    "function_signature": "public void integrateCustomPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.ClassFilters#negate(classFilter)",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "public ClassFilter negate(ClassFilter classFilter)",
    "documentation": "\t/**\n\t * Return a class filter that represents the logical negation of the specified\n\t * filter instance.\n\t * @param classFilter the {@link ClassFilter} to negate\n\t * @return a filter that represents the logical negation of the specified filter\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static ClassFilter negate(ClassFilter classFilter) {\n\t\tAssert.notNull(classFilter, \"ClassFilter must not be null\");\n\t\treturn new NegateClassFilter(classFilter);\n\t}",
    "query": "Configure an aspect to apply transaction management to all service classes except those designated as read-only.",
    "function_signature": "public void configureTransactionManagementForWritableServices()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleHandlerMethodValidationException(ex,headers,status,request)",
    "from_version": "v6.0.19",
    "to_version": "v6.1.6",
    "type": "method",
    "signature": "protected ResponseEntity<Object> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "documentation": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected ResponseEntity<Object> handleHandlerMethodValidationException(",
    "query": "Design a global exception handler that intercepts validation failures specifically occurring within controller methods, allowing for customized HTTP responses that include detailed error information and appropriate status codes.",
    "function_signature": "protected ResponseEntity<Object> handleControllerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain(handler,request)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request)",
    "documentation": "\t/**\n\t * Build a {@link HandlerExecutionChain} for the given handler, including\n\t * applicable interceptors.\n\t * <p>The default implementation builds a standard {@link HandlerExecutionChain}\n\t * with the given handler, the common interceptors of the handler mapping, and any\n\t * {@link MappedInterceptor MappedInterceptors} matching to the current request URL. Interceptors\n\t * are added in the order they were registered. Subclasses may override this\n\t * in order to extend/rearrange the list of interceptors.\n\t * <p><b>NOTE:</b> The passed-in handler object may be a raw handler or a\n\t * pre-built {@link HandlerExecutionChain}. This method should handle those\n\t * two cases explicitly, either building a new {@link HandlerExecutionChain}\n\t * or extending the existing chain.\n\t * <p>For simply adding an interceptor in a custom subclass, consider calling\n\t * {@code super.getHandlerExecutionChain(handler, request)} and invoking\n\t * {@link HandlerExecutionChain#addInterceptor} on the returned chain object.\n\t * @param handler the resolved handler instance (never {@code null})\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain (never {@code null})\n\t * @see #getAdaptedInterceptors()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n\t\tHandlerExecutionChain chain = (handler instanceof HandlerExecutionChain handlerExecutionChain ?\n\t\t\t\thandlerExecutionChain : new HandlerExecutionChain(handler));\n\n\t\tfor (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n\t\t\tif (interceptor instanceof MappedInterceptor mappedInterceptor) {\n\t\t\t\tif (mappedInterceptor.matches(request)) {\n\t\t\t\t\tchain.addInterceptor(mappedInterceptor.getInterceptor());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchain.addInterceptor(interceptor);\n\t\t\t}\n\t\t}\n\t\treturn chain;\n\t}",
    "query": "Design a Spring MVC component that dynamically appends interceptors to the processing chain when certain conditions in the incoming HTTP request are met.",
    "function_signature": "protected HandlerExecutionChain assembleExecutionChain(Object handler, HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.AbstractDelegatingSmartContextLoader#loadContextForAotRuntime(mergedConfig,initializer)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer)",
    "documentation": "\t/**\n\t * Delegates to an appropriate candidate {@code SmartContextLoader} to load\n\t * an {@link ApplicationContext} for AOT run-time execution.\n\t * <p>Delegation is based on explicit knowledge of the implementations of the\n\t * default loaders. See {@link #loadContext(MergedContextConfiguration)} for\n\t * details.\n\t * @param mergedConfig the merged context configuration to use to load the application context\n\t * @param initializer the {@code ApplicationContextInitializer} that should\n\t * be applied to the context in order to recreate bean definitions\n\t * @return a new application context\n\t * @throws IllegalStateException if neither candidate loader is capable of loading an\n\t * {@code ApplicationContext} from the supplied merged context configuration\n\t * @since 6.0\n\t * @see AotContextLoader#loadContextForAotRuntime(MergedContextConfiguration, ApplicationContextInitializer)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,",
    "query": "Design a utility function that configures an `ApplicationContext` for optimal performance during Ahead-of-Time execution, utilizing a merged context configuration and a context initializer.",
    "function_signature": "public ApplicationContext configureAotRuntimeContext(MergedContextConfiguration mergedConfig, ApplicationContextInitializer<ConfigurableApplicationContext> initializer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.test.tools.<unknown>#equals(other)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof DynamicFiles<?> that && this.files.equals(that.files)));\n\t}",
    "query": "Design a method that verifies the equality of dynamically generated resource files during testing to ensure consistency across test runs.",
    "function_signature": "public boolean areResourcesConsistent(DynamicFiles<?> otherResources)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(method,annotationType)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public A findAnnotation(Method method, @Nullable Class<A> annotationType)",
    "documentation": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\n\t\t\treturn method.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}",
    "query": "Implement a utility that retrieves a particular annotation from a method, ensuring that annotations present on overridden methods or inherited through meta-annotations are accurately detected.",
    "function_signature": "public <A extends Annotation> A retrieveAnnotation(Method method, Class<A> annotationClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.SingleColumnRowMapper#mapRow(rs,rowNum)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "documentation": "\t/**\n\t * Extract a value for the single column in the current row.\n\t * <p>Validates that there is only one column selected,\n\t * then delegates to {@code getColumnValue()} and also\n\t * {@code convertValueToRequiredType}, if necessary.\n\t * @see java.sql.ResultSetMetaData#getColumnCount()\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t * @see #convertValueToRequiredType(Object, Class)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t// Validate column count.\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint nrOfColumns = rsmd.getColumnCount();\n\t\tif (nrOfColumns != 1) {\n\t\t\tthrow new IncorrectResultSetColumnCountException(1, nrOfColumns);\n\t\t}\n\n\t\t// Extract column value from JDBC ResultSet.\n\t\tObject result = getColumnValue(rs, 1, this.requiredType);\n\t\tif (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {\n\t\t\t// Extracted value does not match already: try to convert it.\n\t\t\ttry {\n\t\t\t\treturn (T) convertValueToRequiredType(result, this.requiredType);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Type mismatch affecting row number \" + rowNum + \" and column type '\" +\n\t\t\t\t\t\trsmd.getColumnTypeName(1) + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}",
    "query": "Implement a repository function that fetches the unique identifiers of all pending orders, ensuring the query retrieves only the ID field and efficiently maps each ID to its corresponding Java type.",
    "function_signature": "public List<Long> getPendingOrderIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.config.ResourceHandlerRegistry#setOrder(order)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public ResourceHandlerRegistry setOrder(int order)",
    "documentation": "\t/**\n\t * Specify the order to use for resource handling relative to other\n\t * {@code HandlerMapping}s configured in the Spring configuration.\n\t * <p>The default value used is {@code Integer.MAX_VALUE-1}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ResourceHandlerRegistry setOrder(int order) {\n\t\tthis.order = order;\n\t\treturn this;\n\t}",
    "query": "In a reactive Spring application, how can you adjust the precedence of serving static resources to ensure they are handled before other dynamic request mappings?",
    "function_signature": "public void configureResourceHandling(ResourceHandlerRegistry registry) {\n    registry.setOrder(/* appropriate order value */);\n    // additional configuration\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setCustomArgumentResolvers(argumentResolvers)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers)",
    "documentation": "\t/**\n\t * Provide resolvers for custom argument types. Custom resolvers are ordered\n\t * after built-in ones. To override the built-in support for argument\n\t * resolution use {@link #setArgumentResolvers} instead.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tthis.customArgumentResolvers = argumentResolvers;\n\t}",
    "query": "Implement a centralized error handling strategy in your Spring MVC application that allows injecting specialized contextual data into your exception handler methods. Ensure that your solution accommodates custom parameter types seamlessly during the resolution process.",
    "function_signature": "public void registerCustomExceptionArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.expression.ExpressionKey",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "class",
    "signature": "protected class ExpressionKey",
    "documentation": "\t/**\n\t * An expression key.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected static class ExpressionKey implements Comparable<ExpressionKey> {\n\n\t\tprivate final AnnotatedElementKey element;\n\n\t\tprivate final String expression;\n\n\t\tprotected ExpressionKey(AnnotatedElementKey element, String expression) {\n\t\t\tAssert.notNull(element, \"AnnotatedElementKey must not be null\");\n\t\t\tAssert.notNull(expression, \"Expression must not be null\");\n\t\t\tthis.element = element;\n\t\t\tthis.expression = expression;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof ExpressionKey that &&\n\t\t\t\t\tthis.element.equals(that.element) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.expression, that.expression)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.element.hashCode() * 29 + this.expression.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.element + \" with expression \\\"\" + this.expression + \"\\\"\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(ExpressionKey other) {\n\t\t\tint result = this.element.toString().compareTo(other.element.toString());\n\t\t\tif (result == 0) {\n\t\t\t\tresult = this.expression.compareTo(other.expression);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}",
    "query": "Implement a caching strategy for expression evaluations linked to specific annotated elements to reduce redundant processing in a Spring application.",
    "function_signature": "public ExpressionResult resolveCachedExpression(AnnotatedElement element, String expression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.client.WebSocketConnectionManager#getOrigin()",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "public String getOrigin()",
    "documentation": "\t/**\n\t * Return the configured origin.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String getOrigin() {\n\t\treturn this.headers.getOrigin();\n\t}",
    "query": "Design a WebSocket client that retrieves and logs the origin configured for establishing connections to ensure compliance with security policies.",
    "function_signature": "public String getConfiguredWebSocketOrigin()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.SimpMessagingTemplate#doSend(destination,message)",
    "from_version": "v5.3.35",
    "to_version": "v6.0.20",
    "type": "method",
    "signature": "protected void doSend(String destination, Message<?> message)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void doSend(String destination, Message<?> message) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSimpMessageHeaderAccessor simpAccessor =\n\t\t\t\tMessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class);\n\n\t\tif (simpAccessor != null) {\n\t\t\tif (simpAccessor.isMutable()) {\n\t\t\t\tsimpAccessor.setDestination(destination);\n\t\t\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\t\t\tsimpAccessor.setImmutable();\n\t\t\t\tsendInternal(message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try and keep the original accessor type\n\t\t\t\tsimpAccessor = (SimpMessageHeaderAccessor) MessageHeaderAccessor.getMutableAccessor(message);\n\t\t\t\tinitHeaders(simpAccessor);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsimpAccessor = SimpMessageHeaderAccessor.wrap(message);\n\t\t\tinitHeaders(simpAccessor);\n\t\t}\n\n\t\tsimpAccessor.setDestination(destination);\n\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), simpAccessor.getMessageHeaders());\n\t\tsendInternal(message);\n\t}",
    "query": "Enhance the messaging service to preprocess and modify outbound messages, allowing dynamic adjustment of message headers before they are dispatched to their designated destinations.",
    "function_signature": "protected void preprocessAndDispatch(String destination, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Improve the efficiency and reliability of handling subscription lifecycle events by implementing a robust subscription management mechanism that ensures optimal resource utilization and thread-safe operations.",
    "function_signature": "public void manageSubscriptionLifecycle(SubscriptionHandler handler, SubscriptionRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#find(serverState,request)",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "method",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}",
    "query": "Develop a method to efficiently access current subscription mappings based on the server's state and specific query parameters, ensuring enhanced performance and thread safety.",
    "function_signature": "public MultiValueMap<String, String> retrieveSubscriptions(ServerState state, SubscriptionRequest query)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String session;",
    "query": "Develop a method to access the current users session details, utilizing the frameworks enhanced session management features to ensure better reliability and scalability.",
    "function_signature": "public CurrentSession getCurrentSessionDetails()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Refactor the component to utilize a more efficient and secure subscription management mechanism, enhancing overall system performance and maintainability.",
    "function_signature": "public SubscriptionRegistry getSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int sessions;",
    "query": "Develop a feature that efficiently tracks and retrieves the number of active messaging sessions, ensuring scalability and thread safety in a high-load Spring application.",
    "function_signature": "public int fetchActiveSessionCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Design a messaging component that handles dynamic subscription patterns and ensures efficient resource management. The existing implementation struggles with scalability and may not perform optimally under heavy load.",
    "function_signature": "public void configureSubscriptionHandler(SubscriptionConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Improve the application's request handling efficiency by registering interceptors with the enhanced path matching strategies provided by the latest framework features.",
    "function_signature": "public void configureInterceptorsWithPathPattern(InterceptorRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Optimize your application's URL handling by implementing a strategy that leverages advanced parsing techniques, ensuring efficient request processing and enhanced type safety.",
    "function_signature": "public void configureAdvancedPathHandling(PathProcessor pathProcessor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Enhance your web interceptor's configuration to improve pattern matching efficiency and ensure thread-safe operations. Update the setup to leverage the latest recommended approach for defining path matchers.",
    "function_signature": "public void configurePathMatcher(PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.3.11",
    "to_version": "v5.2.18.RELEASE",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design an initialization method for managing message subscriptions that optimizes resource utilization and supports advanced filtering criteria for enhanced scalability.",
    "function_signature": "public void initializeOptimizedSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty4HeadersAdapter#clear()",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public void clear()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void clear() {\n\t\tthis.headers.clear();\n\t}",
    "query": "Create a method that ensures all existing HTTP headers are removed from a server response before it is dispatched to the client, guaranteeing a clean set of headers.",
    "function_signature": "public void sanitizeResponseHeaders(ServerHttpResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.server.RequestPredicates#of(requestPredicate)",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public RequestModifyingPredicate of(RequestPredicate requestPredicate)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}",
    "query": "Design a server route that dynamically adjusts request handling logic by wrapping existing predicates, enabling enhanced request filtering in a reactive Spring application.",
    "function_signature": "public RequestModifyingPredicate enhanceRequestPredicate(RequestPredicate predicate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#writeSuccess()",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public void writeSuccess()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void writeSuccess() {\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}",
    "query": "Refactor the WebSocket session to utilize a reactive approach for indicating readiness to send messages, enhancing performance and seamless integration with reactive streams.",
    "function_signature": "public Mono<Void> signalReadyToSend()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#remove()",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public void remove()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void remove() {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}",
    "query": "Design a Spring component that processes incoming HTTP requests and conditionally removes specific headers to enhance security. Ensure that header removal is handled efficiently, leveraging the latest framework capabilities.",
    "function_signature": "public void secureRequestHeaders(ServerHttpRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener#afterTestClass(testContext)",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public void afterTestClass(TestContext testContext)",
    "documentation": "\t/**\n\t * Execute SQL scripts configured via {@link Sql @Sql} for the supplied\n\t * {@link TestContext} once per test class <em>after</em> all test methods\n\t * have been run.\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\texecuteClassLevelSqlScripts(testContext, ExecutionPhase.AFTER_TEST_CLASS);\n\t}",
    "query": "Design a testing utility that automatically runs a set of SQL cleanup scripts after all test methods within a test class have executed, ensuring the database returns to a consistent state for subsequent tests.",
    "function_signature": "public void executeSqlAfterTestClass(TestContext testContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.beanvalidation.MethodValidationAdapter#setParameterNameDiscoverer(parameterNameDiscoverer)",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer)",
    "documentation": "\t/**\n\t * Set the {@code ParameterNameDiscoverer} to discover method parameter names\n\t * with to create error codes for {@link MessageSourceResolvable}. Used only\n\t * when {@link MethodParameter}s are not passed into\n\t * {@link #validateArguments} or {@link #validateReturnValue}.\n\t * <p>Default is {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}",
    "query": "Design a component that enhances validation error reporting by incorporating method parameter names, even when parameter metadata is unavailable through standard reflection techniques.",
    "function_signature": "public void configureParameterNames(ParameterNameDiscoverer discoverer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.SimpleErrors#reject(errorCode,errorArgs,defaultMessage)",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.globalErrors.add(new ObjectError(getObjectName(), new String[] {errorCode}, errorArgs, defaultMessage));\n\t}",
    "query": "In a Spring MVC application, implement a mechanism to capture and register overarching validation issues that affect the entire form submission. Ensure that each error can be identified by a unique code, supports dynamic message arguments, and provides a fallback default message for clarity.",
    "function_signature": "public void registerGlobalValidationError(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#beforeExecute(thread,task)",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "documentation": "\t/**\n\t * A before-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param thread the thread to run the task\n\t * @param task the task to be executed\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#beforeExecute(Thread, Runnable)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.beforeExecute(thread);\n\t\t}\n\t}",
    "query": "Design a custom thread pool component that allows for executing specific actions automatically before each task begins, enabling enhanced control over task lifecycle management.",
    "function_signature": "protected void preExecute(Thread thread, Runnable task)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.HttpComponentsHeadersAdapter#size()",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public int size()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic int size() {\n\t\t\t\treturn HttpComponentsHeadersAdapter.this.size();\n\t\t\t}",
    "query": "Create a Spring service method that assesses incoming HTTP requests to determine if the number of headers surpasses a specified security threshold, thereby preventing potential header-related vulnerabilities.",
    "function_signature": "public int retrieveHeaderSize(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.MergedContextConfiguration#getParentApplicationContext()",
    "from_version": "v6.0.13",
    "to_version": "v6.1.0-RC1",
    "type": "method",
    "signature": "public ApplicationContext getParentApplicationContext()",
    "documentation": "\t/**\n\t * Get the parent {@link ApplicationContext} for the context defined by this\n\t * {@code MergedContextConfiguration} from the context cache.\n\t * <p>If the parent context has not yet been loaded, it will be loaded, stored\n\t * in the cache, and then returned.\n\t * @return the parent {@code ApplicationContext} or {@code null} if there is no parent\n\t * @since 3.2.2\n\t * @see #getParent()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ApplicationContext getParentApplicationContext() {\n\t\tif (this.parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.state(this.cacheAwareContextLoaderDelegate != null,\n\t\t\t\t\"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate\");\n\t\treturn this.cacheAwareContextLoaderDelegate.loadContext(this.parent);\n\t}",
    "query": "Design a testing utility method that efficiently retrieves and manages a shared parent application context for multiple test configurations, ensuring optimal context caching and reuse across different test scenarios.",
    "function_signature": "public ApplicationContext fetchSharedParentContext()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.hibernate5.LocalSessionFactoryBean#getMetadataSources()",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public MetadataSources getMetadataSources()",
    "documentation": "\t/**\n\t * Determine the Hibernate {@link MetadataSources} to use.\n\t * <p>Can also be externally called to initialize and pre-populate a {@link MetadataSources}\n\t * instance which is then going to be used for {@link SessionFactory} building.\n\t * @return the MetadataSources to use (never {@code null})\n\t * @since 4.3\n\t * @see LocalSessionFactoryBuilder#LocalSessionFactoryBuilder(DataSource, ResourceLoader, MetadataSources)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic MetadataSources getMetadataSources() {\n\t\tthis.metadataSourcesAccessed = true;\n\t\tif (this.metadataSources == null) {\n\t\t\tBootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\t\tif (this.resourcePatternResolver != null) {\n\t\t\t\tbuilder = builder.applyClassLoader(this.resourcePatternResolver.getClassLoader());\n\t\t\t}\n\t\t\tif (this.hibernateIntegrators != null) {\n\t\t\t\tfor (Integrator integrator : this.hibernateIntegrators) {\n\t\t\t\t\tbuilder = builder.applyIntegrator(integrator);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.metadataSources = new MetadataSources(builder.build());\n\t\t}\n\t\treturn this.metadataSources;\n\t}",
    "query": "Design a method to configure Hibernate's metadata efficiently, leveraging Spring's latest integration features to enhance application performance and maintainability.",
    "function_signature": "public MetadataBuilder configureMetadataSources()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getMethod()",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public String getMethod()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getMethod() {\n\t\treturn this.method;\n\t}",
    "query": "Improve the robustness of your request handling by retrieving the HTTP method in a type-safe manner, ensuring better maintainability and reducing potential errors.",
    "function_signature": "public HttpMethod retrieveHttpMethod(RequestContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.ResolvableType#forField(field,nestingLevel)",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public ResolvableType forField(Field field, int nestingLevel)",
    "documentation": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with the\n\t * given nesting level.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @see #forField(Field)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\treturn forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\n\t}",
    "query": "Develop a utility method that extracts the generic type information of a class field, emphasizing simplicity and reducing complexity by eliminating the need to manage nesting levels manually.",
    "function_signature": "public ResolvableType determineFieldType(Field field)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionIsolationLevel()",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public Integer getCurrentTransactionIsolationLevel()",
    "documentation": "\t/**\n\t * Return the isolation level for the current transaction, if any.\n\t * To be called by resource management code when preparing a newly\n\t * created resource (for example, a JDBC Connection).\n\t * @return the currently exposed isolation level, according to the\n\t * JDBC Connection constants (equivalent to the corresponding Spring\n\t * TransactionDefinition constants), or {@code null} if none\n\t * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED\n\t * @see java.sql.Connection#TRANSACTION_READ_COMMITTED\n\t * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ\n\t * @see java.sql.Connection#TRANSACTION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ\n\t * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE\n\t * @see org.springframework.transaction.TransactionDefinition#getIsolationLevel()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static Integer getCurrentTransactionIsolationLevel() {\n\t\treturn currentTransactionIsolationLevel.get();\n\t}",
    "query": "Optimize your resource handling by implementing a method that retrieves the active transaction's isolation level using a more robust and type-safe approach.",
    "function_signature": "public Optional<TransactionIsolationLevel> determineCurrentTransactionIsolation()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.multipart.support.MultipartFilter#lookupMultipartResolver(request)",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "protected MultipartResolver lookupMultipartResolver(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Look up the MultipartResolver that this filter should use,\n\t * taking the current HTTP request as argument.\n\t * <p>The default implementation delegates to the {@code lookupMultipartResolver}\n\t * without arguments.\n\t * @return the MultipartResolver to use\n\t * @see #lookupMultipartResolver()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected MultipartResolver lookupMultipartResolver(HttpServletRequest request) {\n\t\treturn lookupMultipartResolver();\n\t}",
    "query": "Refactor the multipart resolution process to eliminate reliance on the current HTTP request, thereby enhancing performance and simplifying configuration.",
    "function_signature": "protected MultipartResolver resolveMultipartResolver()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#handle(request,response,handler)",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Enhance the application's request handling mechanism to improve performance and maintainability by adopting a more streamlined approach for processing incoming HTTP requests within the Spring Framework.",
    "function_signature": "public ModelAndView processHttpRequest(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.support.MessageHeaderAccessor#getAccessor(message)",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public MessageHeaderAccessor getAccessor(Message<?> message)",
    "documentation": "\t/**\n\t * Return the original {@code MessageHeaderAccessor} used to create the headers\n\t * of the given {@code Message}, or {@code null} if that's not available or if\n\t * its type does not match the required type.\n\t * <p>This is for cases where the existence of an accessor is strongly expected\n\t * (followed up with an assertion) or where an accessor will be created otherwise.\n\t * @param message the message to get an accessor for\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 5.1.19\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static MessageHeaderAccessor getAccessor(Message<?> message) {\n\t\treturn getAccessor(message.getHeaders(), null);\n\t}",
    "query": "Design a method that efficiently accesses and manages the metadata of a given message, ensuring type safety and minimizing the risk of null-related issues during header manipulation.",
    "function_signature": "public MetadataHandler obtainMetadataHandler(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.support.ModelAndViewContainer#getViewName()",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public String getViewName()",
    "documentation": "\t/**\n\t * Return the view name to be resolved by the DispatcherServlet via a\n\t * ViewResolver, or {@code null} if a View object is set.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String getViewName() {\n\t\treturn (this.view instanceof String viewName ? viewName : null);\n\t}",
    "query": "Enhance the controller's view handling mechanism to leverage a more efficient and type-safe approach, ensuring better maintainability and performance.",
    "function_signature": "public Optional<String> resolveViewName()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.view.RequestContext#setDefaultHtmlEscape(defaultHtmlEscape)",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public void setDefaultHtmlEscape(boolean defaultHtmlEscape)",
    "documentation": "\t/**\n\t * (De)activate default HTML escaping for messages and errors, for the scope\n\t * of this RequestContext.\n\t * <p>TODO: currently no application-wide setting ...\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setDefaultHtmlEscape(boolean defaultHtmlEscape) {\n\t\tthis.defaultHtmlEscape = defaultHtmlEscape;\n\t}",
    "query": "Enhance the security and consistency of your application's message rendering by ensuring that HTML escaping is uniformly enabled across all request processing. Optimize performance and maintainability by configuring this behavior at the application level rather than handling it within individual request contexts.",
    "function_signature": "public void enableGlobalHtmlEscaping(boolean enable)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.ui.ConcurrentModel#mergeAttributes(Map<String,attributes)",
    "from_version": "v6.2.0-M3",
    "to_version": "v5.3.37",
    "type": "method",
    "signature": "public ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes)",
    "documentation": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}",
    "query": "Create a method that efficiently incorporates a collection of attributes into a model, ensuring existing entries remain unchanged and optimizing for better performance and thread safety.",
    "function_signature": "public ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.transport.session.disconnectedClientLogger",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "field",
    "signature": "protected Log disconnectedClientLogger",
    "documentation": "\t/**\n\t * Separate logger to use on network IO failure after a client has gone away.\n\t * @see #DISCONNECTED_CLIENT_LOG_CATEGORY\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected static final Log disconnectedClientLogger = LogFactory.getLog(DISCONNECTED_CLIENT_LOG_CATEGORY);",
    "query": "Design a WebSocket handler that distinctly logs instances when a client unexpectedly disconnects, ensuring these events are tracked separately from other connection activities.",
    "function_signature": "public void handleClientDisconnection(Session session, Exception exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty4HeadersAdapter#values()",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "public Collection<List<String>> values()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.names().stream()\n\t\t\t\t.map(this.headers::getAll).toList();\n\t}",
    "query": "Develop a method to efficiently retrieve all HTTP header collections, ensuring optimal performance and enhanced type safety.",
    "function_signature": "public Collection<List<String>> fetchAllHeaderCollections()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#stop()",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "public void stop()",
    "documentation": "\t/**\n\t * Pause this executor, not waiting for tasks to complete.\n\t * @since 6.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void stop() {\n\t\tif (this.lifecycleDelegate != null && !this.lateShutdown) {\n\t\t\tthis.lifecycleDelegate.stop();\n\t\t}\n\t}",
    "query": "Develop a method to gracefully shut down the executor service, ensuring that all active tasks are allowed to complete before termination.",
    "function_signature": "public void shutdownExecutorGracefully()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#capacity(capacity)",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "public DataBuffer capacity(int capacity)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DataBuffer capacity(int capacity) {\n\t\t\tthis.delegate.capacity(capacity);\n\t\t\treturn this;\n\t\t}",
    "query": "Optimize the handling of data buffers in a reactive HTTP client to enhance performance and ensure thread safety.",
    "function_signature": "public DataBuffer configureBufferCapacity(int desiredCapacity)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#initiateEarlyShutdown()",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "protected void initiateEarlyShutdown()",
    "documentation": "\t/**\n\t * Early shutdown signal: do not trigger further tasks, let existing tasks complete\n\t * before hitting the actual destruction step in the {@link #shutdown()} method.\n\t * This goes along with a {@link #stop(Runnable) coordinated lifecycle stop phase}.\n\t * <p>Called from {@link #onApplicationEvent(ContextClosedEvent)} if no\n\t * indications for a late shutdown have been determined, that is, if the\n\t * {@link #setAcceptTasksAfterContextClose \"acceptTasksAfterContextClose} and\n\t * {@link #setWaitForTasksToCompleteOnShutdown \"waitForTasksToCompleteOnShutdown\"}\n\t * flags have not been set.\n\t * <p>The default implementation calls {@link #initiateShutdown()}.\n\t * @since 6.1.4\n\t * @see #initiateShutdown()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected void initiateEarlyShutdown() {\n\t\tinitiateShutdown();\n\t}",
    "query": "Optimize the executor's termination process to ensure all active tasks complete gracefully while preventing the submission of new tasks, thereby enhancing application stability during shutdown.",
    "function_signature": "protected void initiateShutdown()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "class",
    "signature": "public class ModelAttributeMethodProcessor",
    "documentation": "/**\n * Resolve {@code @ModelAttribute} annotated method arguments and handle\n * return values from {@code @ModelAttribute} annotated methods.\n *\n * <p>Model attributes are obtained from the model or created with a default\n * constructor (and then added to the model). Once created the attribute is\n * populated via data binding to Servlet request parameters. Validation may be\n * applied if the argument is annotated with {@code @jakarta.validation.Valid}.\n * or Spring's own {@code @org.springframework.validation.annotation.Validated}.\n *\n * <p>When this handler is created with {@code annotationNotRequired=true}\n * any non-simple type argument and return value is regarded as a model\n * attribute with or without the presence of an {@code @ModelAttribute}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Vladislav Kisel\n * @since 3.1\n */",
    "changetype": "stabilized",
    "source_code": "public class ModelAttributeMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final boolean annotationNotRequired;\n\n\n\t/**\n\t * Class constructor.\n\t * @param annotationNotRequired if \"true\", non-simple method arguments and\n\t * return values are considered model attributes with or without a\n\t * {@code @ModelAttribute} annotation\n\t */\n\tpublic ModelAttributeMethodProcessor(boolean annotationNotRequired) {\n\t\tthis.annotationNotRequired = annotationNotRequired;\n\t}\n\n\n\t/**\n\t * Returns {@code true} if the parameter is annotated with\n\t * {@link ModelAttribute} or, if in default resolution mode, for any\n\t * method parameter that is not a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn (parameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));\n\t}\n\n\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */\n\t@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAttributeMethodProcessor requires ModelAndViewContainer\");\n\t\tAssert.state(binderFactory != null, \"ModelAttributeMethodProcessor requires WebDataBinderFactory\");\n\n\t\tString name = ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann != null) {\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t}\n\n\t\tObject attribute = null;\n\t\tBindingResult bindingResult = null;\n\n\t\tif (mavContainer.containsAttribute(name)) {\n\t\t\tattribute = mavContainer.getModel().get(name);\n\t\t}\n\t\telse {\n\t\t\t// Create attribute instance\n\t\t\ttry {\n\t\t\t\tattribute = createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t}\n\t\t\tcatch (MethodArgumentNotValidException ex) {\n\t\t\t\tif (isBindExceptionRequired(parameter)) {\n\t\t\t\t\t// No BindingResult parameter -> fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Otherwise, expose null/empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\t\t\tattribute = Optional.empty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattribute = ex.getTarget();\n\t\t\t\t}\n\t\t\t\tbindingResult = ex.getBindingResult();\n\t\t\t}\n\t\t}\n\n\t\tif (bindingResult == null) {\n\t\t\t// Bean property binding and validation;\n\t\t\t// skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() != null) {\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) {\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t}\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) {\n\t\t\t\tattribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t}\n\t\t\tbindingResult = binder.getBindingResult();\n\t\t}\n\n\t\t// Add resolved attribute and BindingResult at the end of the model\n\t\tMap<String, Object> bindingResultModel = bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */\n\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\ttry {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\tcatch (BeanInstantiationException ex) {\n\t\t\tif (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) &&\n\t\t\t\t\tex.getCause() instanceof NullPointerException cause) {\n\t\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\t\tObjectError error = new ObjectError(ctor.getName(), cause.getMessage());\n\t\t\t\tresult.addError(error);\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */\n\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}\n\n\t@Nullable\n\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */\n\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */\n\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */\n\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}\n\n\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @since 5.0\n\t */\n\tprotected boolean isBindExceptionRequired(MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}\n\n\t/**\n\t * Return {@code true} if there is a method-level {@code @ModelAttribute}\n\t * or, in default resolution mode, for any return value type that is not\n\t * a simple type.\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(ModelAttribute.class) ||\n\t\t\t\t(this.annotationNotRequired && !BeanUtils.isSimpleProperty(returnType.getParameterType())));\n\t}\n\n\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t * @since 5.1\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate final String parameterName;\n\n\t\t@Nullable\n\t\tprivate volatile Annotation[] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, String parameterName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = parameterName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(this.parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}\n\t}\n\n}",
    "query": "Design a Spring MVC controller method to handle the submission of a comprehensive user profile form. The method should automatically bind the incoming form data to a `UserProfile` object, perform validation on the input data, and handle any validation errors appropriately.",
    "function_signature": "public String submitUserProfile(@Valid @ModelAttribute UserProfile userProfile, BindingResult bindingResult)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver#supportsParameter(parameter)",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "public boolean supportsParameter(MethodParameter parameter)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\tif (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (this.useDefaultResolution) {\n\t\t\treturn checkParameterType(parameter, type -> !BeanUtils.isSimpleProperty(type));\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Develop a RESTful endpoint that receives comprehensive customer details from a frontend application, automatically mapping the incoming data to a `CustomerProfile` object to streamline processing and validation.",
    "function_signature": "public Mono<ResponseEntity<String>> submitCustomerProfile(@ModelAttribute CustomerProfile profile)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#remove()",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "public void remove()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void remove() {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}",
    "query": "Develop a method to remove a specific header from an HTTP response, ensuring the operation is safe and avoids unintended side effects.",
    "function_signature": "public void removeHeader(String headerName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.ModuleResource",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "class",
    "signature": "public class ModuleResource",
    "documentation": "/**\n * {@link Resource} implementation for {@link java.lang.Module} resolution,\n * performing {@link #getInputStream()} access via {@link Module#getResourceAsStream}.\n *\n * <p>Alternatively, consider accessing resources in a module path layout via\n * {@link ClassPathResource} for exported resources, or specifically relative to\n * a {@code Class} via {@link ClassPathResource#ClassPathResource(String, Class)}\n * for local resolution within the containing module of that specific class.\n * In common scenarios, module resources will simply be transparently visible as\n * classpath resources and therefore do not need any special treatment at all.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @see Module#getResourceAsStream\n * @see ClassPathResource\n */",
    "changetype": "deprecated",
    "source_code": "public class ModuleResource extends AbstractResource {\n\n\tprivate final Module module;\n\n\tprivate final String path;\n\n\n\t/**\n\t * Create a new {@code ModuleResource} for the given {@link Module}\n\t * and the given resource path.\n\t * @param module the runtime module to search within\n\t * @param path the resource path within the module\n\t */\n\tpublic ModuleResource(Module module, String path) {\n\t\tAssert.notNull(module, \"Module must not be null\");\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tthis.module = module;\n\t\tthis.path = path;\n\t}\n\n\n\t/**\n\t * Return the {@link Module} for this resource.\n\t */\n\tpublic final Module getModule() {\n\t\treturn this.module;\n\t}\n\n\t/**\n\t * Return the path for this resource.\n\t */\n\tpublic final String getPath() {\n\t\treturn this.path;\n\t}\n\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\tInputStream is = this.module.getResourceAsStream(this.path);\n\t\tif (is == null) {\n\t\t\tthrow new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n\t\t}\n\t\treturn is;\n\t}\n\n\t@Override\n\tpublic Resource createRelative(String relativePath) {\n\t\tString pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n\t\treturn new ModuleResource(this.module, pathToUse);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic String getFilename() {\n\t\treturn StringUtils.getFilename(this.path);\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object obj) {\n\t\treturn (this == obj || (obj instanceof ModuleResource that &&\n\t\t\t\tthis.module.equals(that.module) && this.path.equals(that.path)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}\n\n}",
    "query": "Implement a utility method that efficiently retrieves a resource from the classpath relative to a specific class. Ensure the method handles resource paths correctly and provides clear error messages when resources are missing.",
    "function_signature": "public Resource loadResource(String resourcePath, Class<?> relativeToClass) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.xml.<unknown>#getElementText()",
    "from_version": "v6.1.4",
    "to_version": "v6.0.17",
    "type": "method",
    "signature": "public String getElementText()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getElementText() throws XMLStreamException {\n\t\tcheckIfClosed();\n\t\tif (this.currentEvent == null || !this.currentEvent.isStartElement()) {\n\t\t\tthrow new XMLStreamException(\"Not at START_ELEMENT: \" + this.currentEvent);\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder();\n\t\twhile (true) {\n\t\t\tXMLEvent event = nextEvent();\n\t\t\tif (event.isEndElement()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (!event.isCharacters()) {\n\t\t\t\tthrow new XMLStreamException(\"Unexpected non-text event: \" + event);\n\t\t\t}\n\t\t\tCharacters characters = event.asCharacters();\n\t\t\tif (!characters.isIgnorableWhiteSpace()) {\n\t\t\t\tbuilder.append(event.asCharacters().getData());\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}",
    "query": "Design a method to efficiently extract the textual content from the current position within an XML stream. Ensure that the implementation robustly handles different XML event types and minimizes unnecessary processing overhead.",
    "function_signature": "public String extractTextContent() throws XMLStreamException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.PropertyValue#getValue()",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public Object getValue()",
    "documentation": "\t/**\n\t * Return the value of the property.\n\t * <p>Note that type conversion will <i>not</i> have occurred here.\n\t * It is the responsibility of the BeanWrapper implementation to\n\t * perform type conversion.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Object getValue() {\n\t\treturn this.value;\n\t}",
    "query": "Design a service that intercepts bean initialization to log each property's assigned value before any type conversion occurs.",
    "function_signature": "public Object fetchUnconvertedPropertyValue(String propertyName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.convert.support.GenericConversionService#matches(sourceType,targetType)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tboolean matches = true;\n\t\t\tif (this.converterFactory instanceof ConditionalConverter conditionalConverter) {\n\t\t\t\tmatches = conditionalConverter.matches(sourceType, targetType);\n\t\t\t}\n\t\t\tif (matches) {\n\t\t\t\tConverter<?, ?> converter = this.converterFactory.getConverter(targetType.getType());\n\t\t\t\tif (converter instanceof ConditionalConverter conditionalConverter) {\n\t\t\t\t\tmatches = conditionalConverter.matches(sourceType, targetType);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matches;\n\t\t}",
    "query": "Design a service method that verifies the compatibility between incoming data types and the application's internal models before initiating a transformation process. This ensures that only supported conversions are attempted, enhancing reliability and preventing runtime errors.",
    "function_signature": "public boolean canConvertData(TypeDescriptor incomingType, TypeDescriptor internalModelType);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.weaving.LoadTimeWeaverAwareProcessor#postProcessBeforeInitialization(bean,beanName)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof LoadTimeWeaverAware loadTimeWeaverAware) {\n\t\t\tLoadTimeWeaver ltw = this.loadTimeWeaver;\n\t\t\tif (ltw == null) {\n\t\t\t\tAssert.state(this.beanFactory != null,\n\t\t\t\t\t\t\"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n\t\t\t\tltw = this.beanFactory.getBean(\n\t\t\t\t\t\tConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n\t\t\t}\n\t\t\tloadTimeWeaverAware.setLoadTimeWeaver(ltw);\n\t\t}\n\t\treturn bean;\n\t}",
    "query": "Design a component that automatically detects beans requiring runtime class enhancement and configures them appropriately before the Spring container initializes them. This ensures that any necessary bytecode weaving is applied seamlessly during the application startup.",
    "function_signature": "public Object configureRuntimeEnhancements(Object bean, String beanName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.TypeUtils#isFinal(access)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public boolean isFinal(int access)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "    public static boolean isFinal(int access) {\n        return (Constants.ACC_FINAL & access) != 0;\n    }",
    "query": "Implement a verification method to ensure that critical utility classes cannot be subclassed, thereby maintaining their intended behavior.",
    "function_signature": "public boolean isUtilityClassFinal(Class<?> utilityClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#get(key)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public List<V> get(Object key)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic List<V> get(Object key) {\n\t\tList<V> result = this.delegate.get(key);\n\t\treturn (result != null ? Collections.unmodifiableList(result) : null);\n\t}",
    "query": "Develop a feature that retrieves all associated discount codes for a specific customer, ensuring the returned list cannot be modified by external components to maintain data integrity.",
    "function_signature": "public List<String> getCustomerDiscountCodes(Object customerId);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ResponseCookie#secure(secure)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public ResponseCookieBuilder secure(boolean secure)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic ResponseCookieBuilder secure(boolean secure) {\n\t\t\tthis.secure = secure;\n\t\t\treturn this;\n\t\t}",
    "query": "Design a controller method that issues a session cookie, ensuring the cookie is transmitted only over secure HTTPS connections.",
    "function_signature": "public ResponseCookie createSecureSessionCookie(String sessionId)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.RequestPredicates#attribute(name)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public Optional<Object> attribute(String name)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Optional<Object> attribute(String name) {\n\t\t\treturn this.request.attribute(name);\n\t\t}",
    "query": "Create a route that exclusively handles HTTP requests when a specified custom attribute is present in the incoming request. This ensures that the handler processes only those requests that meet the attribute condition, enhancing request filtering based on metadata.",
    "function_signature": "public RouterFunction<ServerResponse> routeWithCustomAttribute()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.json.Jackson2CodecSupport#getParameter(type)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "protected MethodParameter getParameter(ResolvableType type)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected MethodParameter getParameter(ResolvableType type) {\n\t\treturn (type.getSource() instanceof MethodParameter methodParameter ? methodParameter : null);\n\t}",
    "query": "Design a component that dynamically retrieves metadata about controller method parameters during JSON encoding, ensuring compatibility with complex generic types.",
    "function_signature": "protected MethodParameter resolveMethodParameter(ResolvableType type)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions#basicAuthentication()",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public ExchangeFilterFunction basicAuthentication()",
    "documentation": "\t/**\n\t * Variant of {@link #basicAuthentication(String, String)} that looks up\n\t * the {@link Credentials Credentials} in a\n\t * {@link #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE request attribute}.\n\t * @return the filter to use\n\t * @see Credentials\n\t * @deprecated as of Spring 5.1 in favor of using\n\t * {@link HttpHeaders#setBasicAuth(String, String)} while building the request.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication() {\n\t\treturn (request, next) -> {\n\t\t\tObject attr = request.attributes().get(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE);\n\t\t\tif (attr instanceof Credentials cred) {\n\t\t\t\treturn next.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(cred.username, cred.password))\n\t\t\t\t\t\t.build());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn next.exchange(request);\n\t\t\t}\n\t\t};\n\t}",
    "query": "Develop a reactive HTTP client that automatically injects basic authentication headers by retrieving user credentials from the request's contextual attributes for each outgoing request.",
    "function_signature": "public WebClient configureClientWithAttributeBasedAuth()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.support.JmsUtils#buildExceptionMessage(ex)",
    "from_version": "v5.3.39",
    "to_version": "v6.0.23",
    "type": "method",
    "signature": "public String buildExceptionMessage(JMSException ex)",
    "documentation": "\t/**\n\t * Build a descriptive exception message for the given JMSException,\n\t * incorporating a linked exception's message if appropriate.\n\t * @param ex the JMSException to build a message for\n\t * @return the descriptive message String\n\t * @see jakarta.jms.JMSException#getLinkedException()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String buildExceptionMessage(JMSException ex) {\n\t\tString message = ex.getMessage();\n\t\tException linkedEx = ex.getLinkedException();\n\t\tif (linkedEx != null) {\n\t\t\tif (message == null) {\n\t\t\t\tmessage = linkedEx.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString linkedMessage = linkedEx.getMessage();\n\t\t\t\tif (linkedMessage != null && !message.contains(linkedMessage)) {\n\t\t\t\t\tmessage = message + \"; nested exception is \" + linkedEx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}",
    "query": "Design a method that processes JMS operations and ensures that any encountered exceptions include comprehensive details from linked causes, enhancing the clarity of error logs for troubleshooting.",
    "function_signature": "public String createEnhancedExceptionMessage(JMSException exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory#shutdownDatabase()",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "protected void shutdownDatabase()",
    "documentation": "\t/**\n\t * Hook to shut down the embedded database. Subclasses may call this method\n\t * to force shutdown.\n\t * <p>After calling, {@link #getDataSource()} returns {@code null}.\n\t * <p>Does nothing if no embedded database has been initialized.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected void shutdownDatabase() {\n\t\tif (this.dataSource != null) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tif (this.dataSource instanceof SimpleDriverDataSource) {\n\t\t\t\t\tlogger.info(String.format(\"Shutting down embedded database: url='%s'\",\n\t\t\t\t\t\t((SimpleDriverDataSource) this.dataSource).getUrl()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.info(String.format(\"Shutting down embedded database '%s'\", this.databaseName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.databaseConfigurer != null) {\n\t\t\t\tthis.databaseConfigurer.shutdown(this.dataSource, this.databaseName);\n\t\t\t}\n\t\t\tthis.dataSource = null;\n\t\t}\n\t}",
    "query": "Ensure that the embedded database connection is properly terminated during application shutdown to enhance resource management and application stability.",
    "function_signature": "public void terminateEmbeddedDatabaseConnection()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#hasCharacteristics(characteristics)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public boolean hasCharacteristics(int characteristics)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic boolean hasCharacteristics(int characteristics) {\n\t\t\t\treturn this.delegate.hasCharacteristics(characteristics);\n\t\t\t}",
    "query": "Enhance the efficiency and type safety of your utility by implementing a method that checks for multiple characteristics using a more robust parameter type.",
    "function_signature": "public boolean hasCharacteristics(Characteristic... characteristics)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport#setBeanFactory(beanFactory)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "documentation": "\t/**\n\t * Set the {@link BeanFactory} to be used when looking up executors by qualifier\n\t * or when relying on the default executor lookup algorithm.\n\t * @see #findQualifiedExecutor(BeanFactory, String)\n\t * @see #getDefaultExecutor(BeanFactory)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t}",
    "query": "Configure asynchronous method execution in a Spring application by setting up executor resolution using modern dependency injection techniques to improve performance and ensure thread safety.",
    "function_signature": "public void configureAsyncExecutor(Executor executor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scripting.support.StandardScriptFactory",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "class",
    "signature": "public class StandardScriptFactory",
    "documentation": "/**\n * {@link org.springframework.scripting.ScriptFactory} implementation based\n * on the JSR-223 script engine abstraction (as included in Java).\n * Supports JavaScript, Groovy, JRuby, and other JSR-223 compliant engines.\n *\n * <p>Typically used in combination with a\n * {@link org.springframework.scripting.support.ScriptFactoryPostProcessor};\n * see the latter's javadoc for a configuration example.\n *\n * @author Juergen Hoeller\n * @since 4.2\n * @see ScriptFactoryPostProcessor\n */",
    "changetype": "deprecated",
    "source_code": "public class StandardScriptFactory implements ScriptFactory, BeanClassLoaderAware {\n\n\t@Nullable\n\tprivate final String scriptEngineName;\n\n\tprivate final String scriptSourceLocator;\n\n\t@Nullable\n\tprivate final Class<?>[] scriptInterfaces;\n\n\t@Nullable\n\tprivate ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();\n\n\t@Nullable\n\tprivate volatile ScriptEngine scriptEngine;\n\n\n\t/**\n\t * Create a new StandardScriptFactory for the given script source.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t */\n\tpublic StandardScriptFactory(String scriptSourceLocator) {\n\t\tthis(null, scriptSourceLocator, (Class<?>[]) null);\n\t}\n\n\t/**\n\t * Create a new StandardScriptFactory for the given script source.\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * @param scriptInterfaces the Java interfaces that the scripted object\n\t * is supposed to implement\n\t */\n\tpublic StandardScriptFactory(String scriptSourceLocator, Class<?>... scriptInterfaces) {\n\t\tthis(null, scriptSourceLocator, scriptInterfaces);\n\t}\n\n\t/**\n\t * Create a new StandardScriptFactory for the given script source.\n\t * @param scriptEngineName the name of the JSR-223 ScriptEngine to use\n\t * (explicitly given instead of inferred from the script source)\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t */\n\tpublic StandardScriptFactory(String scriptEngineName, String scriptSourceLocator) {\n\t\tthis(scriptEngineName, scriptSourceLocator, (Class<?>[]) null);\n\t}\n\n\t/**\n\t * Create a new StandardScriptFactory for the given script source.\n\t * @param scriptEngineName the name of the JSR-223 ScriptEngine to use\n\t * (explicitly given instead of inferred from the script source)\n\t * @param scriptSourceLocator a locator that points to the source of the script.\n\t * Interpreted by the post-processor that actually creates the script.\n\t * @param scriptInterfaces the Java interfaces that the scripted object\n\t * is supposed to implement\n\t */\n\tpublic StandardScriptFactory(\n\t\t\t@Nullable String scriptEngineName, String scriptSourceLocator, @Nullable Class<?>... scriptInterfaces) {\n\n\t\tAssert.hasText(scriptSourceLocator, \"'scriptSourceLocator' must not be empty\");\n\t\tthis.scriptEngineName = scriptEngineName;\n\t\tthis.scriptSourceLocator = scriptSourceLocator;\n\t\tthis.scriptInterfaces = scriptInterfaces;\n\t}\n\n\n\t@Override\n\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\tthis.beanClassLoader = classLoader;\n\t}\n\n\t@Override\n\tpublic String getScriptSourceLocator() {\n\t\treturn this.scriptSourceLocator;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?>[] getScriptInterfaces() {\n\t\treturn this.scriptInterfaces;\n\t}\n\n\t@Override\n\tpublic boolean requiresConfigInterface() {\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * Load and parse the script via JSR-223's ScriptEngine.\n\t */\n\t@Override\n\t@Nullable\n\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tObject script = evaluateScript(scriptSource);\n\n\t\tif (!ObjectUtils.isEmpty(actualInterfaces)) {\n\t\t\tboolean adaptationRequired = false;\n\t\t\tfor (Class<?> requestedIfc : actualInterfaces) {\n\t\t\t\tif (script instanceof Class ? !requestedIfc.isAssignableFrom((Class<?>) script) :\n\t\t\t\t\t\t!requestedIfc.isInstance(script)) {\n\t\t\t\t\tadaptationRequired = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (adaptationRequired) {\n\t\t\t\tscript = adaptToInterfaces(script, scriptSource, actualInterfaces);\n\t\t\t}\n\t\t}\n\n\t\tif (script instanceof Class) {\n\t\t\tClass<?> scriptClass = (Class<?>) script;\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"No default constructor on script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Unable to instantiate script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not access script constructor: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"Failed to invoke script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}\n\n\tprotected Object evaluateScript(ScriptSource scriptSource) {\n\t\ttry {\n\t\t\tScriptEngine scriptEngine = this.scriptEngine;\n\t\t\tif (scriptEngine == null) {\n\t\t\t\tscriptEngine = retrieveScriptEngine(scriptSource);\n\t\t\t\tif (scriptEngine == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Could not determine script engine for \" + scriptSource);\n\t\t\t\t}\n\t\t\t\tthis.scriptEngine = scriptEngine;\n\t\t\t}\n\t\t\treturn scriptEngine.eval(scriptSource.getScriptAsString());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t}\n\t}\n\n\t@Nullable\n\tprotected ScriptEngine retrieveScriptEngine(ScriptSource scriptSource) {\n\t\tScriptEngineManager scriptEngineManager = new ScriptEngineManager(this.beanClassLoader);\n\n\t\tif (this.scriptEngineName != null) {\n\t\t\treturn StandardScriptUtils.retrieveEngineByName(scriptEngineManager, this.scriptEngineName);\n\t\t}\n\n\t\tif (scriptSource instanceof ResourceScriptSource) {\n\t\t\tString filename = ((ResourceScriptSource) scriptSource).getResource().getFilename();\n\t\t\tif (filename != null) {\n\t\t\t\tString extension = StringUtils.getFilenameExtension(filename);\n\t\t\t\tif (extension != null) {\n\t\t\t\t\tScriptEngine engine = scriptEngineManager.getEngineByExtension(extension);\n\t\t\t\t\tif (engine != null) {\n\t\t\t\t\t\treturn engine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprotected Object adaptToInterfaces(\n\t\t\t@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces) {\n\n\t\tClass<?> adaptedIfc;\n\t\tif (actualInterfaces.length == 1) {\n\t\t\tadaptedIfc = actualInterfaces[0];\n\t\t}\n\t\telse {\n\t\t\tadaptedIfc = ClassUtils.createCompositeInterface(actualInterfaces, this.beanClassLoader);\n\t\t}\n\n\t\tif (adaptedIfc != null) {\n\t\t\tScriptEngine scriptEngine = this.scriptEngine;\n\t\t\tif (!(scriptEngine instanceof Invocable invocable)) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\"ScriptEngine must implement Invocable in order to adapt it to an interface: \" + scriptEngine);\n\t\t\t}\n\t\t\tif (script != null) {\n\t\t\t\tscript = invocable.getInterface(script, adaptedIfc);\n\t\t\t}\n\t\t\tif (script == null) {\n\t\t\t\tscript = invocable.getInterface(adaptedIfc);\n\t\t\t\tif (script == null) {\n\t\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\t\"Could not adapt script to interface [\" + adaptedIfc.getName() + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Class<?> getScriptedObjectType(ScriptSource scriptSource)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean requiresScriptedObjectRefresh(ScriptSource scriptSource) {\n\t\treturn scriptSource.isModified();\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"StandardScriptFactory: script source locator [\" + this.scriptSourceLocator + \"]\";\n\t}\n\n}",
    "query": "Develop a component that initializes script processing using Spring's current scripting infrastructure, ensuring enhanced performance and streamlined integration without manual engine configuration.",
    "function_signature": "public class ScriptInitializationConfigurer implements ScriptProcessorConfigurer"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ResponseEntity#varyBy(requestHeaders)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public BodyBuilder varyBy(String... requestHeaders)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic BodyBuilder varyBy(String... requestHeaders) {\n\t\t\tthis.headers.setVary(Arrays.asList(requestHeaders));\n\t\t\treturn this;\n\t\t}",
    "query": "Optimize HTTP response handling by specifying relevant request headers that should influence caching strategies, ensuring improved performance and maintainability.",
    "function_signature": "public BodyBuilder configureVaryHeaders(String... headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor#registerReflectionHints(hints,element)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHint(hints, type);\n\t\t}\n\t\telse if (element instanceof Constructor<?> constructor) {\n\t\t\tregisterConstructorHint(hints, constructor);\n\t\t}\n\t\telse if (element instanceof Field field) {\n\t\t\tregisterFieldHint(hints, field);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHint(hints, method);\n\t\t}\n\t}",
    "query": "Enhance your application's reflection configuration to achieve better performance and type safety by utilizing the most recent reflection hinting mechanisms.",
    "function_signature": "public void applyEnhancedReflectionHints(AdvancedReflectionHints hints, AnnotatedElement element)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ContentDisposition#getCharset()",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public Charset getCharset()",
    "documentation": "\t/**\n\t * Return the charset defined in {@literal filename*} parameter, or {@code null} if not defined.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Charset getCharset() {\n\t\treturn this.charset;\n\t}",
    "query": "Develop a method to extract the character set from a `ContentDisposition` instance, ensuring that the implementation handles the absence of charset information gracefully to improve overall code reliability.",
    "function_signature": "public Optional<Charset> determineCharset(ContentDisposition contentDisposition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setRequestBodyAdvice(requestBodyAdvice)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public void setRequestBodyAdvice(@Nullable List<RequestBodyAdvice> requestBodyAdvice)",
    "documentation": "\t/**\n\t * Add one or more {@code RequestBodyAdvice} instances to intercept the\n\t * request before it is read and converted for {@code @RequestBody} and\n\t * {@code HttpEntity} method arguments.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setRequestBodyAdvice(@Nullable List<RequestBodyAdvice> requestBodyAdvice) {\n\t\tif (requestBodyAdvice != null) {\n\t\t\tthis.requestResponseBodyAdvice.addAll(requestBodyAdvice);\n\t\t}\n\t}",
    "query": "Design a feature that intercepts and modifies incoming request bodies with improved performance and type safety before they are processed by controller methods.",
    "function_signature": "public void registerCustomRequestBodyAdvice(@Nullable List<RequestBodyAdvice> advice)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.support.RequestContextUtils#saveOutputFlashMap(location,request,response)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "public void saveOutputFlashMap(String location, HttpServletRequest request, HttpServletResponse response)",
    "documentation": "\t/**\n\t * Convenience method that retrieves the {@link #getOutputFlashMap \"output\"\n\t * FlashMap}, updates it with the path and query params of the target URL,\n\t * and then saves it using the {@link #getFlashMapManager FlashMapManager}.\n\t * @param location the target URL for the redirect\n\t * @param request the current request\n\t * @param response the current response\n\t * @since 5.0\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static void saveOutputFlashMap(String location, HttpServletRequest request, HttpServletResponse response) {\n\t\tFlashMap flashMap = getOutputFlashMap(request);\n\t\tif (CollectionUtils.isEmpty(flashMap)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUriComponents uriComponents = UriComponentsBuilder.fromUriString(location).build();\n\t\tflashMap.setTargetRequestPath(uriComponents.getPath());\n\t\tflashMap.addTargetRequestParams(uriComponents.getQueryParams());\n\n\t\tFlashMapManager manager = getFlashMapManager(request);\n\t\tAssert.state(manager != null, \"No FlashMapManager. Is this a DispatcherServlet handled request?\");\n\t\tmanager.saveOutputFlashMap(flashMap, request, response);\n\t}",
    "query": "Refactor the mechanism for managing flash attributes during redirects to enhance performance and ensure thread safety within your Spring MVC application.",
    "function_signature": "public void manageFlashAttributes(RedirectAttributes redirectAttributes, HttpServletRequest request, HttpServletResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.MethodParameter#findParameterIndex(parameter)",
    "from_version": "v6.0.0-M5",
    "to_version": "v5.3.22",
    "type": "method",
    "signature": "protected int findParameterIndex(Parameter parameter)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected static int findParameterIndex(Parameter parameter) {\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tParameter[] allParams = executable.getParameters();\n\t\t// Try first with identity checks for greater performance.\n\t\tfor (int i = 0; i < allParams.length; i++) {\n\t\t\tif (parameter == allParams[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t// Potentially try again with object equality checks in order to avoid race\n\t\t// conditions while invoking java.lang.reflect.Executable.getParameters().\n\t\tfor (int i = 0; i < allParams.length; i++) {\n\t\t\tif (parameter.equals(allParams[i])) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Given parameter [\" + parameter +\n\t\t\t\t\"] does not match any parameter in the declaring executable\");\n\t}",
    "query": "Enhance the efficiency of determining a parameter's position within a method signature, ensuring thread-safe operations and minimizing reflection overhead.",
    "function_signature": "public int locateParameterIndex(Executable executable, Parameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.Indexer#isNullSafe()",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public boolean isNullSafe()",
    "documentation": "\t/**\n\t * Does this node represent a null-safe index operation?\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}",
    "query": "Design a component that processes user-defined SpEL expressions to retrieve values from complex nested objects. Ensure that the retrieval mechanism gracefully handles scenarios where intermediary collections or maps might be null, preventing potential `NullPointerException`s during expression evaluation.",
    "function_signature": "public Object fetchNestedValueSafely(Object rootObject, String spelExpression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.SpelNodeImpl#isCompilable()",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public boolean isCompilable()",
    "documentation": "\t/**\n\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n\t * be different but will typically involve checking whether the exit type descriptor\n\t * of the node is known and any relevant child nodes are compilable.\n\t * @return {@code true} if this node can be compiled to bytecode\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isCompilable() {\n\t\treturn false;\n\t}",
    "query": "Determine if an expression node qualifies for the latest bytecode generation process to improve execution speed and maintainability.",
    "function_signature": "public boolean qualifiesForBytecodeGeneration()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#addDefaultRollbackRule(rollbackRule)",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule)",
    "documentation": "\t/**\n\t * Add a default rollback rule, to be applied to all rule-based\n\t * transaction attributes returned by this source.\n\t * <p>By default, a rollback will be triggered on unchecked exceptions\n\t * but not on checked exceptions. A default rule may override this\n\t * while still respecting any custom rules in the transaction attribute.\n\t * @param rollbackRule a rollback rule overriding the default behavior,\n\t * e.g. {@link RollbackRuleAttribute#ROLLBACK_ON_ALL_EXCEPTIONS}\n\t * @since 6.2\n\t * @see RuleBasedTransactionAttribute#getRollbackRules()\n\t * @see EnableTransactionManagement#rollbackOn()\n\t * @see Transactional#rollbackFor()\n\t * @see Transactional#noRollbackFor()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void addDefaultRollbackRule(RollbackRuleAttribute rollbackRule) {\n\t\tif (this.defaultRollbackRules == null) {\n\t\t\tthis.defaultRollbackRules = new LinkedHashSet<>();\n\t\t}\n\t\tthis.defaultRollbackRules.add(rollbackRule);\n\t}",
    "query": "In a Spring Boot application, ensure that all transactional methods automatically roll back when a specific checked exception is thrown, without specifying the rollback behavior on each `@Transactional` annotation.",
    "function_signature": "public void configureGlobalRollbackBehavior(RollbackRuleAttribute rollbackRule)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#execute(task)",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public void execute(Runnable task)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void execute(Runnable task) {\n\t\tsuper.execute(TaskUtils.decorateTaskWithErrorHandler(task, this.errorHandler, false));\n\t}",
    "query": "Create a service component that handles incoming operations by running them asynchronously, ensuring that any runtime exceptions are automatically captured and managed without requiring explicit error handling in each task.",
    "function_signature": "public void execute(Runnable task)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.FieldError#hashCode()",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}",
    "query": "Implement a feature that efficiently identifies and manages distinct validation issues across multiple form submissions, ensuring that each unique error is tracked without redundancy.",
    "function_signature": "public Set<FieldError> trackUniqueValidationErrors(List<FieldError> errors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.LOCALE_CONTEXT_RESOLVER_BEAN_NAME",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "field",
    "signature": "public String LOCALE_CONTEXT_RESOLVER_BEAN_NAME",
    "documentation": "\t/** Well-known name for the LocaleContextResolver in the bean factory. */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final String LOCALE_CONTEXT_RESOLVER_BEAN_NAME = \"localeContextResolver\";",
    "query": "Improve the configuration of your web server by adopting a more type-safe approach for accessing the locale resolution mechanism, thereby minimizing the risks associated with string-based bean identifiers.",
    "function_signature": "public LocaleContextResolver retrieveLocaleContextResolver(ApplicationContext applicationContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.DependencyDescriptor#getResolvableType()",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public ResolvableType getResolvableType()",
    "documentation": "\t/**\n\t * Build a {@link ResolvableType} object for the wrapped parameter/field.\n\t * @since 4.0\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ResolvableType getResolvableType() {\n\t\tResolvableType resolvableType = this.resolvableType;\n\t\tif (resolvableType == null) {\n\t\t\tresolvableType = (this.field != null ?\n\t\t\t\t\tResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :\n\t\t\t\t\tResolvableType.forMethodParameter(obtainMethodParameter()));\n\t\t\tthis.resolvableType = resolvableType;\n\t\t}\n\t\treturn resolvableType;\n\t}",
    "query": "Design a component that automatically determines and injects the appropriate generic type dependencies into your service classes, enhancing type safety and reducing boilerplate code.",
    "function_signature": "public void resolveAndInjectDependencies(ResolvableType targetType, Object beanInstance)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.MockMvcTester#withHttpMessageConverters(httpMessageConverters)",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters)",
    "documentation": "\t/**\n\t * Return a new {@link MockMvcTester} instance using the specified\n\t * {@linkplain HttpMessageConverter message converters}.\n\t * <p>If none are specified, only basic assertions on the response body can\n\t * be performed. Consider registering a suitable JSON converter for asserting\n\t * against JSON data structures.\n\t * @param httpMessageConverters the message converters to use\n\t * @return a new instance using the specified converters\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MockMvcTester withHttpMessageConverters(Iterable<HttpMessageConverter<?>> httpMessageConverters) {\n\t\treturn new MockMvcTester(this.mockMvc, findJsonMessageConverter(httpMessageConverters));\n\t}",
    "query": "Design a test case for a Spring MVC application that needs to validate JSON responses with complex nested structures. Ensure that your testing setup can accurately deserialize and assert the JSON content returned by the controller.",
    "function_signature": "public MockMvcTester configureCustomJsonConverters(Iterable<HttpMessageConverter<?>> converters)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.RequestEntity#method(method,uriTemplate,uriVariables)",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables)",
    "documentation": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}",
    "query": "Develop a utility method that constructs HTTP requests using customizable HTTP methods and dynamically parameterized URI templates, facilitating seamless interactions with external RESTful services.",
    "function_signature": "public <T> RequestEntity<T> buildHttpRequest(HttpMethod method, String uriTemplate, Object... uriVariables)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#hostString()",
    "from_version": "v6.1.8",
    "to_version": "v6.2.0-M3",
    "type": "method",
    "signature": "public String hostString()",
    "documentation": "\t\t/**\n\t\t *The host getter steps are:\n\t\t * Let url be thiss URL.\n\t\t * If urls host is null, then return the empty string.\n\t\t * If urls port is null, return urls host, serialized.\n\t\t * Return urls host, serialized, followed by U+003A (:) and urls port, serialized.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic String hostString() {\n\t\t\tif (host() == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tStringBuilder builder = new StringBuilder(hostname());\n\t\t\tPort port = port();\n\t\t\tif (port != null) {\n\t\t\t\tbuilder.append(':');\n\t\t\t\tbuilder.append(port);\n\t\t\t}\n\t\t\treturn builder.toString();\n\t\t}",
    "query": "Design a feature that logs the full host information from incoming HTTP requests, ensuring that the port number is included when available. Create a method that efficiently extracts this host string from a given URL.",
    "function_signature": "public String retrieveHostAsString()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument(parameter,mavContainer,webRequest,binderFactory)",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "documentation": "\t/**\n\t * Resolve the argument from the model or if not found instantiate it with\n\t * its default if it is available. The model attribute is then populated\n\t * with request values via data binding and optionally validated\n\t * if {@code @java.validation.Valid} is present on the argument.\n\t * @throws BindException if data binding and validation result in an error\n\t * and the next method parameter is not of type {@link Errors}\n\t * @throws Exception if WebDataBinder initialization fails\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,",
    "query": "Develop a component to seamlessly bind incoming request data to your application's model attributes, ensuring enhanced performance and type safety within your Spring MVC controllers.",
    "function_signature": "public Object processModelAttribute(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n                                   NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedConfig,hierarchyMode)",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}",
    "query": "Design a testing utility that ensures all application contexts, including those with parent-child relationships, are properly terminated after test execution to prevent resource leaks and ensure isolation between tests.",
    "function_signature": "public void terminateApplicationContext(TestConfiguration configuration, @Nullable ContextHierarchyMode hierarchyMode)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesRequestAttributes",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "class",
    "signature": "public class FacesRequestAttributes",
    "documentation": "/**\n * {@link RequestAttributes} adapter for a JSF {@link jakarta.faces.context.FacesContext}.\n * Used as default in a JSF environment, wrapping the current FacesContext.\n *\n * <p><b>NOTE:</b> In contrast to {@link ServletRequestAttributes}, this variant does\n * <i>not</i> support destruction callbacks for scoped attributes, neither for the\n * request scope nor for the session scope. If you rely on such implicit destruction\n * callbacks, consider defining a Spring {@link RequestContextListener} in your\n * {@code web.xml}.\n *\n * <p>Requires JSF 2.0 or higher, as of Spring 4.0.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n * @see jakarta.faces.context.FacesContext#getExternalContext()\n * @see jakarta.faces.context.ExternalContext#getRequestMap()\n * @see jakarta.faces.context.ExternalContext#getSessionMap()\n * @see RequestContextHolder#currentRequestAttributes()\n */",
    "changetype": "stabilized",
    "source_code": "public class FacesRequestAttributes implements RequestAttributes {\n\n\t/**\n\t * We'll create a lot of these objects, so we don't want a new logger every time.\n\t */\n\tprivate static final Log logger = LogFactory.getLog(FacesRequestAttributes.class);\n\n\tprivate final FacesContext facesContext;\n\n\n\t/**\n\t * Create a new FacesRequestAttributes adapter for the given FacesContext.\n\t * @param facesContext the current FacesContext\n\t * @see jakarta.faces.context.FacesContext#getCurrentInstance()\n\t */\n\tpublic FacesRequestAttributes(FacesContext facesContext) {\n\t\tAssert.notNull(facesContext, \"FacesContext must not be null\");\n\t\tthis.facesContext = facesContext;\n\t}\n\n\n\t/**\n\t * Return the JSF FacesContext that this adapter operates on.\n\t */\n\tprotected final FacesContext getFacesContext() {\n\t\treturn this.facesContext;\n\t}\n\n\t/**\n\t * Return the JSF ExternalContext that this adapter operates on.\n\t * @see jakarta.faces.context.FacesContext#getExternalContext()\n\t */\n\tprotected final ExternalContext getExternalContext() {\n\t\treturn getFacesContext().getExternalContext();\n\t}\n\n\t/**\n\t * Return the JSF attribute Map for the specified scope.\n\t * @param scope constant indicating request or session scope\n\t * @return the Map representation of the attributes in the specified scope\n\t * @see #SCOPE_REQUEST\n\t * @see #SCOPE_SESSION\n\t */\n\tprotected Map<String, Object> getAttributeMap(int scope) {\n\t\tif (scope == SCOPE_REQUEST) {\n\t\t\treturn getExternalContext().getRequestMap();\n\t\t}\n\t\telse {\n\t\t\treturn getExternalContext().getSessionMap();\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Object getAttribute(String name, int scope) {\n\t\treturn getAttributeMap(scope).get(name);\n\t}\n\n\t@Override\n\tpublic void setAttribute(String name, Object value, int scope) {\n\t\tgetAttributeMap(scope).put(name, value);\n\t}\n\n\t@Override\n\tpublic void removeAttribute(String name, int scope) {\n\t\tgetAttributeMap(scope).remove(name);\n\t}\n\n\t@Override\n\tpublic String[] getAttributeNames(int scope) {\n\t\treturn StringUtils.toStringArray(getAttributeMap(scope).keySet());\n\t}\n\n\t@Override\n\tpublic void registerDestructionCallback(String name, Runnable callback, int scope) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Could not register destruction callback [\" + callback + \"] for attribute '\" + name +\n\t\t\t\t\t\"' because FacesRequestAttributes does not support such callbacks\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object resolveReference(String key) {\n\t\treturn switch (key) {\n\t\t\tcase REFERENCE_REQUEST -> getExternalContext().getRequest();\n\t\t\tcase REFERENCE_SESSION -> getExternalContext().getSession(true);\n\t\t\tcase \"application\" -> getExternalContext().getContext();\n\t\t\tcase \"requestScope\" -> getExternalContext().getRequestMap();\n\t\t\tcase \"sessionScope\" -> getExternalContext().getSessionMap();\n\t\t\tcase \"applicationScope\" -> getExternalContext().getApplicationMap();\n\t\t\tcase \"facesContext\" -> getFacesContext();\n\t\t\tcase \"cookie\" -> getExternalContext().getRequestCookieMap();\n\t\t\tcase \"header\" -> getExternalContext().getRequestHeaderMap();\n\t\t\tcase \"headerValues\" -> getExternalContext().getRequestHeaderValuesMap();\n\t\t\tcase \"param\" -> getExternalContext().getRequestParameterMap();\n\t\t\tcase \"paramValues\" -> getExternalContext().getRequestParameterValuesMap();\n\t\t\tcase \"initParam\" -> getExternalContext().getInitParameterMap();\n\t\t\tcase \"view\" -> getFacesContext().getViewRoot();\n\t\t\tcase \"viewScope\" -> getFacesContext().getViewRoot().getViewMap();\n\t\t\tcase \"flash\" -> getExternalContext().getFlash();\n\t\t\tcase \"resource\" -> getFacesContext().getApplication().getResourceHandler();\n\t\t\tdefault -> null;\n\t\t};\n\t}\n\n\t@Override\n\tpublic String getSessionId() {\n\t\tObject session = getExternalContext().getSession(true);\n\t\ttry {\n\t\t\t// HttpSession has a getId() method.\n\t\t\tMethod getIdMethod = session.getClass().getMethod(\"getId\");\n\t\t\treturn String.valueOf(ReflectionUtils.invokeMethod(getIdMethod, session));\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(\"Session object [\" + session + \"] does not have a getId() method\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getSessionMutex() {\n\t\t// Enforce presence of a session first to allow listeners to create the mutex attribute\n\t\tExternalContext externalContext = getExternalContext();\n\t\tObject session = externalContext.getSession(true);\n\t\tObject mutex = externalContext.getSessionMap().get(WebUtils.SESSION_MUTEX_ATTRIBUTE);\n\t\tif (mutex == null) {\n\t\t\tmutex = (session != null ? session : externalContext);\n\t\t}\n\t\treturn mutex;\n\t}\n\n}",
    "query": "Design a Spring-managed service that retrieves user-specific settings from a JSF-based web application's session scope, ensuring thread safety and seamless integration with the JSF lifecycle without relying on traditional servlet attributes.",
    "function_signature": "public UserSettings getUserSettings()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#hasNext()",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public boolean hasNext()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}",
    "query": "Implement a method that determines whether there are additional HTTP headers to process in a client's request, facilitating efficient header management.",
    "function_signature": "public boolean hasNextHeader()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#canWrite(clazz,mediaType)",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}",
    "query": "Design a controller method that determines if a specific object can be serialized into the client's requested media type before sending the response.",
    "function_signature": "public boolean isSerializableResponse(Class<?> responseType, @Nullable MediaType requestedMediaType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,",
    "query": "Design a configuration component that dynamically creates optimized suppliers for beans, taking into account the generation context and bean registration specifics, while allowing for shortcut optimizations when feasible.",
    "function_signature": "public CodeBlock createOptimizedBeanSupplier(GenerationContext context, BeanRegistrationCode registration, boolean enableShortcut)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.RequestMappingInfo#getPatternParserToUse()",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public PathPatternParser getPatternParserToUse()",
    "documentation": "\t\t/**\n\t\t * Return the {@code PathPatternParser} to use, the one set explicitly\n\t\t * or falling back on a default instance if both {@code PathPatternParser}\n\t\t * and {@code PathMatcher} are not set.\n\t\t * @since 6.1.2\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic PathPatternParser getPatternParserToUse() {\n\t\t\tif (this.patternParser == null && this.pathMatcher == null) {\n\t\t\t\treturn defaultPatternParser;\n\t\t\t}\n\t\t\treturn this.patternParser;\n\t\t}",
    "query": "Create a configuration component that intelligently selects the most suitable path pattern parser based on the application's current settings, optimizing URL matching performance without modifying existing route definitions.",
    "function_signature": "public PathPatternParser chooseAppropriatePathParser()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.event.<unknown>#beforeCommit(readOnly)",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public Mono<Void> beforeCommit(boolean readOnly)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Mono<Void> beforeCommit(boolean readOnly) {\n\t\t\tif (getTransactionPhase() == TransactionPhase.BEFORE_COMMIT) {\n\t\t\t\treturn Mono.fromRunnable(this::processEventWithCallbacks);\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}",
    "query": "Create a reactive service that performs necessary cleanup operations right before a database transaction is committed. Ensure that the service intelligently skips cleanup if the transaction is marked as read-only to enhance performance.",
    "function_signature": "public Mono<Void> performCleanupBeforeCommit(boolean readOnly)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.SseEmitter#build()",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public Set<DataWithMediaType> build()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Set<DataWithMediaType> build() {\n\t\t\tif (!StringUtils.hasLength(this.sb) && this.dataToSend.isEmpty()) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tappend('\\n');\n\t\t\tsaveAppendedText();\n\t\t\treturn this.dataToSend;\n\t\t}",
    "query": "Implement a REST controller method that efficiently aggregates and prepares various types of real-time data updates for clients subscribing to server-sent events, ensuring each data piece is correctly typed for client-side processing.",
    "function_signature": "public Set<DataWithMediaType> aggregateRealTimeUpdates()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder(webRequest,target,objectName)",
    "from_version": "v6.0.16",
    "to_version": "v6.1.4",
    "type": "method",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)",
    "documentation": "\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final WebDataBinder createBinder(",
    "query": "Implement a feature in your Spring MVC application that initializes and customizes data binding for a form object, ensuring it gracefully handles optional parameters and integrates seamlessly with the current web request context.",
    "function_signature": "public WebDataBinder initializeCustomBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.reactive.server.<unknown>#uri(Function<UriBuilder,uriFunction)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\tthis.uriTemplate = null;\n\t\t\treturn uri(uriFunction.apply(DefaultWebTestClient.this.uriBuilderFactory.builder()));\n\t\t}",
    "query": "Create a test scenario for a reactive REST controller where the endpoint's URI needs to be dynamically constructed based on varying query parameters or path variables.",
    "function_signature": "public RequestBodySpec configureDynamicEndpoint(Function<UriBuilder, URI> uriFunction)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.object.SqlQuery#findObjectByNamedParam(Map<String,paramMap,Map<?,context)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context)",
    "documentation": "\t/**\n\t * Generic object finder method for named parameters.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = executeByNamedParam(paramMap, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}",
    "query": "Craft a method to retrieve a single order from the database using a flexible set of filtering criteria, while also allowing for additional contextual data to tailor the mapping of the result.",
    "function_signature": "public @Nullable Order fetchOrderByParameters(Map<String, ?> filters, @Nullable Map<?, ?> context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.BeanRegistryAdapter#description(description)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public Spec<T> description(String description)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Spec<T> description(String description) {\n\t\t\tthis.beanDefinition.setDescription(description);\n\t\t\treturn this;\n\t\t}",
    "query": "Design a configuration setup where each bean is accompanied by a meaningful explanation, enhancing clarity for future maintenance and documentation.",
    "function_signature": "public BeanConfigurator withDescription(String description)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver#shouldApplyTo(request,handler)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "documentation": "\t/**\n\t * Check whether this resolver is supposed to apply to the given handler.\n\t * <p>The default implementation checks against the configured\n\t * {@linkplain #setMappedHandlerPredicate(Predicate) handlerPredicate}\n\t * {@linkplain #setMappedHandlers handlers} and\n\t * {@linkplain #setMappedHandlerClasses handler classes}, if any.\n\t * @param request current HTTP request\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return whether this resolved should proceed with resolving the exception\n\t * for the given request and handler\n\t * @see #setMappedHandlers\n\t * @see #setMappedHandlerClasses\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif (this.mappedHandlerPredicate != null) {\n\t\t\treturn this.mappedHandlerPredicate.test(handler);\n\t\t}\n\t\tif (handler != null) {\n\t\t\tif (this.mappedHandlers != null && this.mappedHandlers.contains(handler)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.mappedHandlerClasses != null) {\n\t\t\t\tfor (Class<?> handlerClass : this.mappedHandlerClasses) {\n\t\t\t\t\tif (handlerClass.isInstance(handler)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !hasHandlerMappings();\n\t}",
    "query": "Implement a mechanism within your Spring MVC application that ensures certain exception resolvers are only activated for designated controllers or handler classes, enhancing targeted error handling strategies.",
    "function_signature": "protected boolean shouldActivateResolver(HttpServletRequest request, @Nullable Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.common.ExpressionUtils#toDouble(typeConverter,typedValue)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public double toDouble(TypeConverter typeConverter, TypedValue typedValue)",
    "documentation": "\t/**\n\t * Attempt to convert a typed value to a double using the supplied type converter.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static double toDouble(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Double.class);\n\t}",
    "query": "Design a service method that accurately converts various configuration inputs into double values for precise numerical processing within your application.",
    "function_signature": "public double convertConfigValue(TypeConverter typeConverter, TypedValue typedValue)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesWebRequest#getParameterNames()",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public Iterator<String> getParameterNames()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Iterator<String> getParameterNames() {\n\t\treturn getExternalContext().getRequestParameterNames();\n\t}",
    "query": "Develop a Spring service method that accesses and iterates through all parameter names supplied in a user's web request to perform custom validation logic.",
    "function_signature": "public Iterator<String> getAllRequestParameterNames()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.FastByteArrayOutputStream#writeTo(out)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public void writeTo(OutputStream out)",
    "documentation": "\t/**\n\t * Write the contents of this {@code FastByteArrayOutputStream} to the given\n\t * {@link OutputStream}.\n\t * @param out the OutputStream to write to\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void writeTo(OutputStream out) throws IOException {\n\t\tIterator<byte[]> it = this.buffers.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tbyte[] bytes = it.next();\n\t\t\tif (it.hasNext()) {\n\t\t\t\tout.write(bytes, 0, bytes.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.write(bytes, 0, this.index);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Provide a Spring service method that streams generated content directly to an `OutputStream`, ensuring high performance and efficient memory management during the transfer process.",
    "function_signature": "public void writeContentTo(OutputStream out) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.JCacheCache",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "class",
    "signature": "public class JCacheCache",
    "documentation": "/**\n * {@link org.springframework.cache.Cache} implementation on top of a\n * {@link Cache javax.cache.Cache} instance.\n *\n * <p>Note: This class has been updated for JCache 1.0, as of Spring 4.0.\n *\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.2\n * @see JCacheCacheManager\n */",
    "changetype": "stabilized",
    "source_code": "public class JCacheCache extends AbstractValueAdaptingCache {\n\n\tprivate final Cache<Object, Object> cache;\n\n\tprivate final ValueLoaderEntryProcessor valueLoaderEntryProcessor;\n\n\n\t/**\n\t * Create a {@code JCacheCache} instance.\n\t * @param jcache backing JCache Cache instance\n\t */\n\tpublic JCacheCache(Cache<Object, Object> jcache) {\n\t\tthis(jcache, true);\n\t}\n\n\t/**\n\t * Create a {@code JCacheCache} instance.\n\t * @param jcache backing JCache Cache instance\n\t * @param allowNullValues whether to accept and convert null values for this cache\n\t */\n\tpublic JCacheCache(Cache<Object, Object> jcache, boolean allowNullValues) {\n\t\tsuper(allowNullValues);\n\t\tAssert.notNull(jcache, \"Cache must not be null\");\n\t\tthis.cache = jcache;\n\t\tthis.valueLoaderEntryProcessor = new ValueLoaderEntryProcessor(\n\t\t\t\tthis::fromStoreValue, this::toStoreValue);\n\t}\n\n\n\t@Override\n\tpublic final String getName() {\n\t\treturn this.cache.getName();\n\t}\n\n\t@Override\n\tpublic final Cache<Object, Object> getNativeCache() {\n\t\treturn this.cache;\n\t}\n\n\t@Override\n\tprotected @Nullable Object lookup(Object key) {\n\t\treturn this.cache.get(key);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn (T) this.cache.invoke(key, this.valueLoaderEntryProcessor, valueLoader);\n\t\t}\n\t\tcatch (EntryProcessorException ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex.getCause());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}\n\n\t@Override\n\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject previous = this.cache.invoke(key, PutIfAbsentEntryProcessor.INSTANCE, toStoreValue(value));\n\t\treturn (previous != null ? toValueWrapper(previous) : null);\n\t}\n\n\t@Override\n\tpublic void evict(Object key) {\n\t\tthis.cache.remove(key);\n\t}\n\n\t@Override\n\tpublic boolean evictIfPresent(Object key) {\n\t\treturn this.cache.remove(key);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.cache.removeAll();\n\t}\n\n\t@Override\n\tpublic boolean invalidate() {\n\t\tboolean notEmpty = this.cache.iterator().hasNext();\n\t\tthis.cache.removeAll();\n\t\treturn notEmpty;\n\t}\n\n\n\tprivate static class PutIfAbsentEntryProcessor implements EntryProcessor<Object, Object, Object> {\n\n\t\tprivate static final PutIfAbsentEntryProcessor INSTANCE = new PutIfAbsentEntryProcessor();\n\n\t\t@Override\n\t\t@SuppressWarnings(\"NullAway\") // Overridden method does not define nullness\n\t\tpublic @Nullable Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments) throws EntryProcessorException {\n\t\t\tObject existingValue = entry.getValue();\n\t\t\tif (existingValue == null) {\n\t\t\t\tentry.setValue(arguments[0]);\n\t\t\t}\n\t\t\treturn existingValue;\n\t\t}\n\t}\n\n\n\tprivate static final class ValueLoaderEntryProcessor implements EntryProcessor<Object, Object, Object> {\n\n\t\tprivate final Function<Object, @Nullable Object> fromStoreValue;\n\n\t\tprivate final Function<Object, Object> toStoreValue;\n\n\t\tprivate ValueLoaderEntryProcessor(Function<Object, @Nullable Object> fromStoreValue,\n\t\t\t\tFunction<Object, Object> toStoreValue) {\n\n\t\t\tthis.fromStoreValue = fromStoreValue;\n\t\t\tthis.toStoreValue = toStoreValue;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\",\"NullAway\"}) // Overridden method does not define nullness\n\t\tpublic @Nullable Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments) throws EntryProcessorException {\n\t\t\tCallable<Object> valueLoader = (Callable<Object>) arguments[0];\n\t\t\tif (entry.exists()) {\n\t\t\t\treturn this.fromStoreValue.apply(Objects.requireNonNull(entry.getValue()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject value;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = Objects.requireNonNull(valueLoader).call();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new EntryProcessorException(\"Value loader '\" + valueLoader + \"' failed \" +\n\t\t\t\t\t\t\t\"to compute value for key '\" + entry.getKey() + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tentry.setValue(this.toStoreValue.apply(value));\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n\n}",
    "query": "Design a caching mechanism for a product catalog service where retrieving a product by its ID should first check the cache. If the product isn't cached, it should atomically fetch the product from the database and store it in the cache to avoid redundant database calls during concurrent requests.",
    "function_signature": "public Product fetchProductById(Long productId, Callable<Product> productLoader)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#setValues(ps,i)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}",
    "query": "Develop a method that assigns parameter values to a `PreparedStatement` for each entry in a batch processing scenario. The method should efficiently map each object's properties to the corresponding SQL statement indices, ensuring optimal performance during bulk database operations.",
    "function_signature": "public void assignBatchParameters(PreparedStatement ps, int batchIndex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter#print(message,output,contentType,charset)",
    "from_version": "v6.2.6",
    "to_version": "v7.0.0-M4",
    "type": "method",
    "signature": "public void print(Message message, OutputStream output, MediaType contentType, Charset charset)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void print(Message message, OutputStream output, MediaType contentType, Charset charset)",
    "query": "Design a REST endpoint that efficiently serializes a Protocol Buffers message and streams it directly to the client with the appropriate media type and character encoding. Ensure that the implementation handles large messages without excessive memory consumption.",
    "function_signature": "public void streamProtobufMessage(Message protobufMessage, OutputStream clientOutput, MediaType responseType, Charset encoding) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ProblemDetail#setProperties(Map<String,properties)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public void setProperties(@Nullable Map<String, Object> properties)",
    "documentation": "\t/**\n\t * Setter for the {@link #getProperties() properties map}.\n\t * <p>By default, this is not set.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param properties the properties map\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setProperties(@Nullable Map<String, Object> properties) {\n\t\tthis.properties = properties;\n\t}",
    "query": "Design a global exception handler for a RESTful service that enriches error responses with additional contextual information, ensuring that these details are seamlessly integrated into the JSON output regardless of the underlying JSON processing library.",
    "function_signature": "public void enrichErrorResponse(Exception ex, HttpServletResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.BeanWrapperImpl#nested(level)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public TypeDescriptor nested(int level)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic TypeDescriptor nested(int level) {\n\t\t\treturn TypeDescriptor.nested(property(this.pd), level);\n\t\t}",
    "query": "Enhance the mechanism for obtaining nested type information to achieve better performance and reliability within your bean manipulation logic.",
    "function_signature": "public TypeDescriptor fetchNestedTypeDescriptor(int depth)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.NameMatchMethodPointcut#addMethodName(mappedNamePattern)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public NameMatchMethodPointcut addMethodName(String mappedNamePattern)",
    "documentation": "\t/**\n\t * Add another method name pattern, in addition to those already configured.\n\t * <p>Like the \"set\" methods, this method is for use when configuring proxies,\n\t * before a proxy is used.\n\t * <p><b>NOTE:</b> This method does not work after the proxy is in use, since\n\t * advice chains will be cached.\n\t * @param mappedNamePattern the additional method name pattern\n\t * @return this pointcut to allow for method chaining\n\t * @see #setMappedNames(String...)\n\t * @see #setMappedName(String)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic NameMatchMethodPointcut addMethodName(String mappedNamePattern) {\n\t\tthis.mappedNamePatterns.add(mappedNamePattern);\n\t\treturn this;\n\t}",
    "query": "Create an aspect that targets various service layer methods based on specific naming conventions, and ensure it can dynamically incorporate additional method name patterns during its configuration phase.",
    "function_signature": "public NameMatchMethodPointcut includeMethodPattern(String pattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.BeanWrapperImpl#getResolvableType()",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public ResolvableType getResolvableType()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic ResolvableType getResolvableType() {\n\t\t\treturn this.typeDescriptor.getResolvableType();\n\t\t}",
    "query": "Enhance the bean processing logic by implementing a method that retrieves the bean's class type using the current recommended approach to improve type safety and performance.",
    "function_signature": "public Class<?> getBeanClass(Object bean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder#addFilter(filter,Map<String,initParams,dispatcherTypes,urlPatterns)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public T addFilter(Filter filter, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic <T extends B> T addFilter(",
    "query": "Streamline your MockMvc configuration by integrating a custom filter, eliminating the need for manual initialization parameters and dispatcher type settings.",
    "function_signature": "public T addFilter(Filter filter, String... urlPatterns)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.TypedStringValue#compareTo(o)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public int compareTo(@Nullable TypedStringValue o)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int compareTo(@Nullable TypedStringValue o) {\n\t\treturn Comparator.comparing(TypedStringValue::getValue).compare(this, o);\n\t}",
    "query": "Implement a sorting mechanism for configuration properties that ensures they are ordered based on their string values, facilitating consistent processing during application initialization.",
    "function_signature": "public int sortConfigurationProperties(TypedStringValue propertyA, TypedStringValue propertyB);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.NameMatchMethodPointcut#addMethodName(name)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public NameMatchMethodPointcut addMethodName(String name)",
    "documentation": "\t/**\n\t * Add another eligible method name, in addition to those already named.\n\t * Like the set methods, this method is for use when configuring proxies,\n\t * before a proxy is used.\n\t * <p><b>NB:</b> This method does not work after the proxy is in\n\t * use, as advice chains will be cached.\n\t * @param name the name of the additional method that will match\n\t * @return this pointcut to allow for multiple additions in one line\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic NameMatchMethodPointcut addMethodName(String name) {\n\t\tthis.mappedNames.add(name);\n\t\treturn this;\n\t}",
    "query": "Develop a configuration method that efficiently registers multiple method identifiers for proxy eligibility, ensuring consistent behavior and optimal performance throughout the application's runtime.",
    "function_signature": "public EnhancedMethodPointcut registerMethodIdentifiers(String... identifiers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.ControlFlowPointcut#incrementEvaluationCount()",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "protected void incrementEvaluationCount()",
    "documentation": "\t/**\n\t * Increment the {@link #getEvaluations() evaluation count}.\n\t * @since 6.1\n\t * @see #matches(Method, Class, Object...)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final void incrementEvaluationCount() {\n\t\tthis.evaluationCount.incrementAndGet();\n\t}",
    "query": "Design an aspect that monitors how frequently specific business methods are invoked within certain execution flows, enabling performance analysis without manually tracking each invocation.",
    "function_signature": "public void monitorMethodInvocationFlow(Method method, Class<?> targetClass);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.BeanWrapperImpl#createNotWritablePropertyException(propertyName)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "protected NotWritablePropertyException createNotWritablePropertyException(String propertyName)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {\n\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n\t\tthrow new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t}",
    "query": "Design a method to handle scenarios where a property cannot be modified. The implementation should provide comprehensive error details and leverage the latest framework enhancements to ensure optimal performance and reliability.",
    "function_signature": "protected PropertyModificationException handleImmutableProperty(String propertyName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.resource.ResourceWebHandler#setEtagGenerator(Function<Resource,etagGenerator)",
    "from_version": "v6.1.0-RC1",
    "to_version": "v6.1.0-RC2",
    "type": "method",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "documentation": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServerWebExchange#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}",
    "query": "Design a resource handler that generates custom ETags for static resources based on their content to enhance caching mechanisms.",
    "function_signature": "public void customizeResourceEtagGeneration()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#configure(errorHandler,keyGenerator,cacheResolver,cacheManager)",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public void configure(@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager)",
    "documentation": "\t/**\n\t * Configure this aspect with the given error handler, key generator and cache resolver/manager\n\t * suppliers, applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void configure(",
    "query": "Design a caching strategy for a high-traffic REST API that gracefully handles caching failures, custom key generation, and dynamic cache resolution based on runtime conditions.",
    "function_signature": "public void setupAdvancedCaching(@Nullable Supplier<CacheErrorHandler> errorHandlerSupplier,\n                                 @Nullable Supplier<KeyGenerator> keyGenSupplier,\n                                 @Nullable Supplier<CacheResolver> cacheResolverSupplier,\n                                 @Nullable Supplier<CacheManager> cacheManagerSupplier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.event.AbstractApplicationEventMulticaster#setBeanFactory(beanFactory)",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tif (!(beanFactory instanceof ConfigurableBeanFactory cbf)) {\n\t\t\tthrow new IllegalStateException(\"Not running in a ConfigurableBeanFactory: \" + beanFactory);\n\t\t}\n\t\tthis.beanFactory = cbf;\n\t\tif (this.beanClassLoader == null) {\n\t\t\tthis.beanClassLoader = this.beanFactory.getBeanClassLoader();\n\t\t}\n\t}",
    "query": "Design a custom event dispatcher that seamlessly integrates with the application's dependency injection mechanism, ensuring all necessary beans are accessible during event handling.",
    "function_signature": "public void setBeanFactory(BeanFactory beanFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.ui.ModelMap#mergeAttributes(Map<String,attributes)",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public ModelMap mergeAttributes(@Nullable Map<String, ?> attributes)",
    "documentation": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ModelMap mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}",
    "query": "Design a controller method that consolidates user-specific preferences with application-wide defaults, ensuring that any overlapping settings provided by the user remain unchanged.",
    "function_signature": "public ModelMap consolidatePreferences(Map<String, ?> defaultPreferences, Map<String, ?> userPreferences)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.listener.AbstractMessageListenerContainer#getDestination()",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public Destination getDestination()",
    "documentation": "\t/**\n\t * Return the destination to receive messages from. Will be {@code null}\n\t * if the configured destination is not an actual {@link Destination} type;\n\t * c.f. {@link #setDestinationName(String) when the destination is a String}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Destination getDestination() {\n\t\treturn (this.destination instanceof Destination _destination ? _destination : null);\n\t}",
    "query": "How can you create a Spring component that retrieves the active JMS destination from its message listener container for runtime analysis?",
    "function_signature": "public Destination getActiveJmsDestination()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService#start()",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public void start()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tfor (TransportHandler handler : this.handlers.values()) {\n\t\t\t\tif (handler instanceof Lifecycle lifecycle) {\n\t\t\t\t\tlifecycle.start();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Design a method that initializes a WebSocket service with custom SockJS transport handlers, ensuring that all handlers are properly started when the service begins running.",
    "function_signature": "public void initializeAndStartSockJsService();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.tags.form.AbstractDataBoundFormElementTag#doFinally()",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public void doFinally()",
    "documentation": "\t/**\n\t * Disposes of the {@link BindStatus} instance.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void doFinally() {\n\t\tsuper.doFinally();\n\t\tthis.bindStatus = null;\n\t}",
    "query": "Ensure that your custom form tag implementation properly disposes of binding status information after rendering to maintain application performance.",
    "function_signature": "public void cleanUpAfterRendering()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#writeReplace()",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "protected Object writeReplace()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected Object writeReplace() throws ObjectStreamException {\n\t\tif (this.beanFactory != null && this.beanName != null) {\n\t\t\treturn new SerializedEntityManagerFactoryBeanReference(this.beanFactory, this.beanName);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotSerializableException(\"EntityManagerFactoryBean does not run within a BeanFactory\");\n\t\t}\n\t}",
    "query": "Implement serialization support for a Spring-managed JPA `EntityManagerFactoryBean` that maintains its association with the surrounding `BeanFactory`, ensuring consistent behavior during the serialization and deserialization processes.",
    "function_signature": "protected Object replaceEntityManagerFactoryBeanForSerialization()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.oxm.jaxb.Jaxb2Marshaller#getPackagesToScan()",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public String[] getPackagesToScan()",
    "documentation": "\t/**\n\t * Return the packages to search for JAXB2 annotations.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String[] getPackagesToScan() {\n\t\treturn this.packagesToScan;\n\t}",
    "query": "Design a JAXB marshaller that automatically detects and binds classes with JAXB annotations by scanning specified packages within the application.",
    "function_signature": "public Jaxb2Marshaller configureAutoScanningMarshaller()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getPart(name)",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public Part getPart(String name)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Part getPart(String name) throws IOException, ServletException {\n\t\treturn this.parts.getFirst(name);\n\t}",
    "query": "Create a testing utility that isolates and retrieves a designated segment from a mock HTTP request, facilitating the verification of file upload functionality in your application's unit tests.",
    "function_signature": "public Part extractFilePart(MockHttpServletRequest mockRequest, String partName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.config.SimpleBeanFactoryAwareAspectInstanceFactory#getAspectClassLoader()",
    "from_version": "v5.3.36",
    "to_version": "v6.0.21",
    "type": "method",
    "signature": "public ClassLoader getAspectClassLoader()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic ClassLoader getAspectClassLoader() {\n\t\tif (this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\treturn cbf.getBeanClassLoader();\n\t\t}\n\t\telse {\n\t\t\treturn ClassUtils.getDefaultClassLoader();\n\t\t}\n\t}",
    "query": "Implement a Spring service that dynamically loads and applies custom aspects to beans, ensuring that the correct class loader is utilized based on the application's bean factory configuration.",
    "function_signature": "public void configureDynamicAspects(ClassLoader aspectLoader)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.AbstractReactiveWebInitializer#onStartup(servletContext)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public void onStartup(ServletContext servletContext)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void onStartup(ServletContext servletContext) throws ServletException {\n\t\tString servletName = getServletName();\n\t\tAssert.hasLength(servletName, \"getServletName() must not return null or empty\");\n\n\t\tApplicationContext applicationContext = createApplicationContext();\n\t\tAssert.notNull(applicationContext, \"createApplicationContext() must not return null\");\n\n\t\trefreshApplicationContext(applicationContext);\n\t\tregisterCloseListener(servletContext, applicationContext);\n\n\t\tHttpHandler httpHandler = WebHttpHandlerBuilder.applicationContext(applicationContext).build();\n\t\tServletHttpHandlerAdapter servlet = new ServletHttpHandlerAdapter(httpHandler);\n\n\t\tServletRegistration.Dynamic registration = servletContext.addServlet(servletName, servlet);\n\t\tif (registration == null) {\n\t\t\tthrow new IllegalStateException(\"Failed to register servlet with name '\" + servletName + \"'. \" +\n\t\t\t\t\t\"Check if there is another servlet registered under the same name.\");\n\t\t}\n\n\t\tregistration.setLoadOnStartup(1);\n\t\tregistration.addMapping(getServletMapping());\n\t\tregistration.setAsyncSupported(true);\n\t}",
    "query": "Design a servlet initializer that streamlines application context setup and leverages modern asynchronous capabilities to enhance the responsiveness and scalability of your web application.",
    "function_signature": "public void configureServletContext(ServletContext servletContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectivePropertyAccessor#equals(other)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(other instanceof PropertyCacheKey otherKey)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (this.clazz == otherKey.clazz && this.property.equals(otherKey.property) &&\n\t\t\t\t\tthis.targetIsClass == otherKey.targetIsClass);\n\t\t}",
    "query": "Enhance the component responsible for comparing property handlers to ensure optimal performance and type safety by adopting the latest Spring Framework best practices.",
    "function_signature": "public boolean verifyPropertyHandlerEquivalence(PropertyHandler handler1, PropertyHandler handler2)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectivePropertyAccessor#read(context,target,name)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Optimize property access in your Spring application to enhance performance and ensure type safety. Refactor the existing implementation to utilize a more efficient and secure mechanism for retrieving property values without relying on reflection.",
    "function_signature": "public TypedValue fetchProperty(EvaluationContext context, Object target, String propertyName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseReplacedMethodSubElements(beanEle,overrides)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)",
    "documentation": "\t/**\n\t * Parse replaced-method sub-elements of the given bean element.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {\n\t\t\t\tElement replacedMethodEle = (Element) node;\n\t\t\t\tString name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n\t\t\t\tReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n\t\t\t\t// Look for arg-type match elements.\n\t\t\t\tList<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n\t\t\t\tfor (Element argTypeEle : argTypeEles) {\n\t\t\t\t\tString match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n\t\t\t\t\tmatch = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));\n\t\t\t\t\tif (StringUtils.hasText(match)) {\n\t\t\t\t\t\treplaceOverride.addTypeIdentifier(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treplaceOverride.setSource(extractSource(replacedMethodEle));\n\t\t\t\toverrides.addOverride(replaceOverride);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Optimize the bean parsing process by handling method overrides more efficiently, ensuring better performance and enhanced safety when processing bean definitions.",
    "function_signature": "public void handleMethodOverrides(Element beanElement, MethodOverrideRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mail.SimpleMailMessage#getFrom()",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public String getFrom()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getFrom() {\n\t\treturn this.from;\n\t}",
    "query": "Design a utility method to obtain the sender's email address in a manner that ensures better type safety and aligns with the latest email handling practices.",
    "function_signature": "public Optional<InternetAddress> getSenderEmailAddress()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.AbstractNestablePropertyAccessor#getAutoGrowCollectionLimit()",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public int getAutoGrowCollectionLimit()",
    "documentation": "\t/**\n\t * Return the limit for array and collection auto-growing.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic int getAutoGrowCollectionLimit() {\n\t\treturn this.autoGrowCollectionLimit;\n\t}",
    "query": "Enhance the performance of your data binding process by implementing a configurable strategy that manages how collections expand dynamically, ensuring scalability and resource optimization.",
    "function_signature": "public void setCollectionExpansionStrategy(CollectionExpansionStrategy strategy)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader#registerBeanDefinitions(rb)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public int registerBeanDefinitions(ResourceBundle rb)",
    "documentation": "\t/**\n\t * Register bean definitions contained in a resource bundle,\n\t * using all property keys (i.e. not filtering by prefix).\n\t * @param rb the ResourceBundle to load from\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(java.util.ResourceBundle, String)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic int registerBeanDefinitions(ResourceBundle rb) throws BeanDefinitionStoreException {\n\t\treturn registerBeanDefinitions(rb, null);\n\t}",
    "query": "Enhance the bean registration process to allow selective loading of bean definitions using a specific prefix, thereby improving configuration management and performance.",
    "function_signature": "public int registerBeanDefinitions(ResourceBundle rb, String prefix) throws BeanDefinitionStoreException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getParameterValues(name)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public String[] getParameterValues(String name)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getParameterValues(String name) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\treturn this.parameters.get(name);\n\t}",
    "query": "Enhance the handling of HTTP request parameters to improve type safety and streamline data processing within your application.",
    "function_signature": "public List<String> fetchParameterValues(String parameterName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#setTaskExecutor(taskExecutor)",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public void setTaskExecutor(AsyncTaskExecutor taskExecutor)",
    "documentation": "\t/**\n\t * Set the default {@link AsyncTaskExecutor} to use when a controller method\n\t * return a {@link Callable}. Controller methods can override this default on\n\t * a per-request basis by returning an {@link WebAsyncTask}.\n\t * <p>By default a {@link SimpleAsyncTaskExecutor} instance is used.\n\t * It's recommended to change that default in production as the simple executor\n\t * does not re-use threads.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n\t\tthis.taskExecutor = taskExecutor;\n\t}",
    "query": "Design a configuration method that enhances the efficiency of handling asynchronous controller responses by utilizing a thread pool, ensuring optimal resource management in a production setting.",
    "function_signature": "public void configureAsyncExecution(ThreadPoolTaskExecutor taskExecutor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#isSingleton()",
    "from_version": "v6.0.0-M4",
    "to_version": "v5.3.21",
    "type": "method",
    "signature": "public boolean isSingleton()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}",
    "query": "Optimize the bean configuration by implementing a method that accurately represents the singleton nature of the entity manager, ensuring improved performance and alignment with current best practices.",
    "function_signature": "public boolean isEntityManagerSingleton()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#getCondition(element)",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "protected CompositeMessageCondition getCondition(AnnotatedElement element)",
    "documentation": "\t/**\n\t * Determine the mapping condition for the given annotated element.\n\t * @param element the element to check\n\t * @return the condition, or {@code null}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected CompositeMessageCondition getCondition(AnnotatedElement element) {\n\t\tMessageMapping ann = AnnotatedElementUtils.findMergedAnnotation(element, MessageMapping.class);\n\t\tif (ann == null || ann.value().length == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tString[] patterns = processDestinations(ann.value());\n\t\treturn new CompositeMessageCondition(\n\t\t\t\tnew DestinationPatternsMessageCondition(patterns, obtainRouteMatcher()));\n\t}",
    "query": "Create a reactive messaging component that intelligently routes incoming messages to appropriate handlers by evaluating custom annotations for dynamic destination patterns. Ensure that the routing logic can seamlessly integrate complex conditions based on the annotated metadata of each message.",
    "function_signature": "protected CompositeMessageCondition evaluateRoutingConditions(AnnotatedElement element)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#obtainRouteMatcher()",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "protected RouteMatcher obtainRouteMatcher()",
    "documentation": "\t/**\n\t * Obtain the {@code RouteMatcher} for actual use.\n\t * @return the RouteMatcher (never {@code null})\n\t * @throws IllegalStateException in case of no RouteMatcher set\n\t * @since 5.0\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected RouteMatcher obtainRouteMatcher() {\n\t\tRouteMatcher routeMatcher = getRouteMatcher();\n\t\tAssert.state(routeMatcher != null, \"No RouteMatcher set\");\n\t\treturn routeMatcher;\n\t}",
    "query": "Design a reactive message handler method that utilizes a centralized routing strategy to efficiently determine the appropriate processing path for each incoming message, enhancing scalability and maintainability of the messaging system.",
    "function_signature": "protected void routeMessageUsingStrategy(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#afterPropertiesSet()",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "public void afterPropertiesSet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterPropertiesSet() {\n\n\t\t// Initialize RouteMatcher before parent initializes handler mappings\n\t\tif (this.routeMatcher == null) {\n\t\t\tAntPathMatcher pathMatcher = new AntPathMatcher();\n\t\t\tpathMatcher.setPathSeparator(\".\");\n\t\t\tthis.routeMatcher = new SimpleRouteMatcher(pathMatcher);\n\t\t}\n\n\t\tsuper.afterPropertiesSet();\n\t}",
    "query": "Design a reactive message handler that efficiently routes incoming messages based on hierarchical topics separated by dots, ensuring seamless integration with nested message structures.",
    "function_signature": "public void configureHierarchicalMessageRouting()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#processDestinations(destinations)",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "protected String[] processDestinations(String[] destinations)",
    "documentation": "\t/**\n\t * Resolve placeholders in the given destinations.\n\t * @param destinations the destinations\n\t * @return new array with the processed destinations or the same array\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected String[] processDestinations(String[] destinations) {\n\t\tif (this.valueResolver != null) {\n\t\t\tdestinations = Arrays.stream(destinations)\n\t\t\t\t\t.map(s -> this.valueResolver.resolveStringValue(s))\n\t\t\t\t\t.toArray(String[]::new);\n\t\t}\n\t\treturn destinations;\n\t}",
    "query": "Create a reactive messaging component that dynamically interprets and adjusts destination paths using runtime configurations, ensuring messages are accurately directed even as destination parameters evolve.",
    "function_signature": "protected String[] resolveDynamicDestinations(String[] destinations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DefaultDataBuffer#toString(index,length,charset)",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "public String toString(int index, int length, Charset charset)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString(int index, int length, Charset charset) {\n\t\tcheckIndex(index, length);\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tbyte[] bytes;\n\t\tint offset;\n\n\t\tif (this.byteBuffer.hasArray()) {\n\t\t\tbytes = this.byteBuffer.array();\n\t\t\toffset = this.byteBuffer.arrayOffset() + index;\n\t\t}\n\t\telse {\n\t\t\tbytes = new byte[length];\n\t\t\toffset = 0;\n\t\t\tByteBuffer duplicate = this.byteBuffer.duplicate();\n\t\t\tduplicate.clear().position(index).limit(index + length);\n\t\t\tduplicate.get(bytes, 0, length);\n\t\t}\n\t\treturn new String(bytes, offset, length, charset);\n\t}",
    "query": "Design a utility function that retrieves a substring from a binary data source starting at a given position with a defined length, decoding it using a specified character encoding.",
    "function_signature": "public String retrieveSubstring(DataBuffer dataBuffer, int startPosition, int substringLength, Charset encoding)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setHandlers(handlers)",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "public void setHandlers(List<Object> handlers)",
    "documentation": "\t/**\n\t * Manually configure handlers to check for {@code @MessageMapping} methods.\n\t * <p><strong>Note:</strong> the given handlers are not required to be\n\t * annotated with {@code @Controller}. Consider also using\n\t * {@link #setAutoDetectDisabled()} if the intent is to use these handlers\n\t * instead of, and not in addition to {@code @Controller} classes. Or\n\t * alternatively use {@link #setHandlerPredicate(Predicate)} to select a\n\t * different set of beans based on a different criteria.\n\t * @param handlers the handlers to register\n\t * @see #setAutoDetectDisabled()\n\t * @see #setHandlerPredicate(Predicate)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setHandlers(List<Object> handlers) {\n\t\tfor (Object handler : handlers) {\n\t\t\tdetectHandlerMethods(handler);\n\t\t}\n\t\t// Disable auto-detection..\n\t\tthis.handlerPredicate = null;\n\t}",
    "query": "Design a configuration method that selectively registers message handlers by applying specific criteria, enhancing the application's performance and maintainability without manual handler management.",
    "function_signature": "public void configureSelectiveMessageHandlers(Predicate<Object> handlerFilter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setAutoDetectDisabled()",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "public void setAutoDetectDisabled()",
    "documentation": "\t/**\n\t * Disable auto-detection of {@code @MessageMapping} methods, e.g. in\n\t * {@code @Controller}s, by setting {@link #setHandlerPredicate(Predicate)\n\t * setHandlerPredicate(null)}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setAutoDetectDisabled() {\n\t\tthis.handlerPredicate = null;\n\t}",
    "query": "Optimize your message handling setup by explicitly defining handler predicates to manage message mappings, thereby avoiding the drawbacks of automatic method detection in your controllers.",
    "function_signature": "public void setHandlerPredicate(Predicate<Message<?>> predicate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setHandlerPredicate(handlerPredicate)",
    "from_version": "v5.2.0.M3",
    "to_version": "v5.2.0.RC1",
    "type": "method",
    "signature": "public void setHandlerPredicate(@Nullable Predicate<Class<?>> handlerPredicate)",
    "documentation": "\t/**\n\t * Configure the predicate to use for selecting which Spring beans to check\n\t * for {@code @MessageMapping} methods. When set to {@code null},\n\t * auto-detection is turned off which is what\n\t * {@link #setAutoDetectDisabled()} does internally.\n\t * <p>The predicate used by default selects {@code @Controller} classes.\n\t * @see #setHandlers(List)\n\t * @see #setAutoDetectDisabled()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setHandlerPredicate(@Nullable Predicate<Class<?>> handlerPredicate) {\n\t\tthis.handlerPredicate = handlerPredicate;\n\t}",
    "query": "Enhance your message processing setup by explicitly defining handler beans to improve clarity and performance.",
    "function_signature": "public void setMessageHandlers(@Nullable List<Object> handlers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.SCOPE_REQUEST",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "field",
    "signature": "public String SCOPE_REQUEST",
    "documentation": "\t/** Constant identifying the request scope. */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String SCOPE_REQUEST = \"request\";",
    "query": "Configure a bean that should be instantiated anew for each HTTP request to handle user-specific operations without shared state across requests.",
    "function_signature": "@Bean\n@Scope(\"request\")\npublic UserService userService()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#release()",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "public boolean release()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean release() {\n\t\t\tif (this.delegate instanceof PooledDataBuffer pooledDelegate) {\n\t\t\t\tpooledDelegate.release();\n\t\t\t}\n\t\t\tthis.chunk.release();\n\t\t\tint refCount = this.refCount.updateAndGet(c -> {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\treturn c - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"already released \" + this);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn refCount == 0;\n\t\t}",
    "query": "Design a reactive service that communicates with an external API, ensuring that all underlying resources are automatically released after each interaction to maintain optimal performance and resource utilization.",
    "function_signature": "public Mono<Boolean> communicateWithExternalApiAndReleaseResources(String apiUrl, HttpMethod method, Object payload);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.<unknown>#getBody()",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "public InputStream getBody()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic InputStream getBody() throws IOException {\n\t\treturn this.body;\n\t}",
    "query": "Design a service method that efficiently handles large file downloads by streaming the response directly to the client, ensuring minimal memory consumption on the server.",
    "function_signature": "public InputStream streamFileDownload(HttpServletResponse response) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.target.SingletonTargetSource#releaseTarget(target)",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "public void releaseTarget(Object target)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void releaseTarget(Object target) {\n\t\t// nothing to do\n\t}",
    "query": "Refactor the management of singleton targets to enhance resource efficiency and ensure thread safety within the application context.",
    "function_signature": "public void manageSingletonTargetLifecycle(Object target)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.RequestPartArgumentResolver",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "class",
    "signature": "public class RequestPartArgumentResolver",
    "documentation": "/**\n * {@link HttpServiceArgumentResolver} for {@link RequestPart @RequestPart}\n * annotated arguments.\n *\n * <p>The argument may be:\n * <ul>\n * <li>String -- form field\n * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n * <li>{@link MultipartFile} -- uploaded file\n * <li>Object -- content to be encoded (e.g. to JSON)\n * <li>{@link HttpEntity} -- part content and headers although generally it's\n * easier to add headers through the returned builder\n * <li>{@link Part} -- a part from a server request\n * <li>{@link Publisher} of any of the above\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @since 6.0\n */",
    "changetype": "stabilized",
    "source_code": "public class RequestPartArgumentResolver extends AbstractNamedValueArgumentResolver {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", RequestPartArgumentResolver.class.getClassLoader());\n\n\n\t@Nullable\n\tprivate final ReactiveAdapterRegistry reactiveAdapterRegistry;\n\n\n\t/**\n\t * Constructor with a {@link HttpExchangeAdapter}, for access to config settings.\n\t * @since 6.1\n\t */\n\tpublic RequestPartArgumentResolver(HttpExchangeAdapter exchangeAdapter) {\n\t\tif (REACTOR_PRESENT) {\n\t\t\tthis.reactiveAdapterRegistry =\n\t\t\t\t\t(exchangeAdapter instanceof ReactorHttpExchangeAdapter reactorAdapter ?\n\t\t\t\t\t\t\treactorAdapter.getReactiveAdapterRegistry() :\n\t\t\t\t\t\t\tReactiveAdapterRegistry.getSharedInstance());\n\t\t}\n\t\telse {\n\t\t\tthis.reactiveAdapterRegistry = null;\n\t\t}\n\t}\n\n\n\t@Override\n\t@Nullable\n\tprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {\n\t\tRequestPart annot = parameter.getParameterAnnotation(RequestPart.class);\n\t\tboolean isMultiPartFile = parameter.nestedIfOptional().getNestedParameterType().equals(MultipartFile.class);\n\t\tString label = (isMultiPartFile ? \"MultipartFile\" : \"request part\");\n\n\t\tif (annot != null) {\n\t\t\treturn new NamedValueInfo(annot.name(), annot.required(), null, label, true);\n\t\t}\n\t\telse if (isMultiPartFile) {\n\t\t\treturn new NamedValueInfo(\"\", true, null, label, true);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\tClass<?> type = parameter.getParameterType();\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(type);\n\t\t\tif (adapter != null) {\n\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\tString message = \"Async type for @RequestPart should produce value(s)\";\n\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveValues) {\n\t\t\t\t\treactiveValues.addRequestPartPublisher(\n\t\t\t\t\t\t\tname, adapter.toPublisher(value), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"RequestPart with a reactive type is only supported with reactive client\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (value instanceof MultipartFile multipartFile) {\n\t\t\tvalue = toHttpEntity(name, multipartFile);\n\t\t}\n\n\t\trequestValues.addRequestPart(name, value);\n\t}\n\n\tprivate static ParameterizedTypeReference<Object> asParameterizedTypeRef(MethodParameter nestedParam) {\n\t\treturn ParameterizedTypeReference.forType(nestedParam.getNestedGenericParameterType());\n\t}\n\n\tprivate static Object toHttpEntity(String name, MultipartFile multipartFile) {\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tif (multipartFile.getOriginalFilename() != null) {\n\t\t\theaders.setContentDispositionFormData(name, multipartFile.getOriginalFilename());\n\t\t}\n\t\tif (multipartFile.getContentType() != null) {\n\t\t\theaders.add(HttpHeaders.CONTENT_TYPE, multipartFile.getContentType());\n\t\t}\n\t\treturn new HttpEntity<>(multipartFile.getResource(), headers);\n\t}\n\n}",
    "query": "Design a REST endpoint that accepts a multipart form submission containing both textual data and file uploads. Ensure that the endpoint can handle reactive streams for processing large files efficiently without blocking the server. Implement the controller method to seamlessly bind the multipart parts to method parameters, facilitating asynchronous processing and scalability.",
    "function_signature": "public Mono<ResponseEntity<Void>> uploadUserProfile(@RequestPart(\"user\") Mono<User> user, @RequestPart(\"avatar\") Mono<MultipartFile> avatar)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.aot.<unknown>#generateCollectionOf(collection,collectionType,elementType)",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "protected CodeBlock generateCollectionOf(Collection<?> collection,\n\t\t\t\tClass<?> collectionType, ResolvableType elementType)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tprotected final CodeBlock generateCollectionOf(Collection<?> collection,",
    "query": "Enhance the efficiency and type safety of your collection handling within the AOT processing by implementing a method that generates optimized code blocks for various collection types.",
    "function_signature": "protected CodeBlock createOptimizedCollection(Collection<?> items, Class<?> type, ResolvableType elementType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeineSpec(caffeineSpec)",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "public void setCaffeineSpec(CaffeineSpec caffeineSpec)",
    "documentation": "\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}",
    "query": "Design a method to configure the cache manager with custom specifications for each individual cache instance to optimize caching behavior.",
    "function_signature": "public void setCustomCacheSpecifications(CaffeineSpec cacheSpec)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.<unknown>#executeInternal(headers,body)",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\tHttpClient.RequestSender requestSender = this.httpClient\n\t\t\t\t.request(io.netty.handler.codec.http.HttpMethod.valueOf(this.method.name()));\n\n\t\trequestSender = (this.uri.isAbsolute() ? requestSender.uri(this.uri) : requestSender.uri(this.uri.toString()));\n\n\t\ttry {\n\t\t\tReactorNettyClientResponse result = requestSender.send((reactorRequest, nettyOutbound) ->\n\t\t\t\t\tsend(headers, body, reactorRequest, nettyOutbound))\n\t\t\t\t\t.responseConnection((reactorResponse, connection) ->\n\t\t\t\t\t\t\tMono.just(new ReactorNettyClientResponse(reactorResponse, connection, this.readTimeout)))\n\t\t\t\t\t.next()\n\t\t\t\t\t.block(this.exchangeTimeout);\n\n\t\t\tif (result == null) {\n\t\t\t\tthrow new IOException(\"HTTP exchange resulted in no result\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tthrow convertException(ex);\n\t\t}\n\t}",
    "query": "Create a specialized HTTP client component within a Spring application that can handle custom HTTP headers and an optional request body, ensuring proper management of the clients response for further processing.",
    "function_signature": "protected ClientHttpResponse handleCustomExecution(HttpHeaders headers, @Nullable Body body) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.MethodArgumentNotValidException#resolveErrorMessages(messageSource,locale)",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "documentation": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}",
    "query": "Design a utility that efficiently aggregates and retrieves user-friendly validation error messages based on the application's locale, enhancing performance and type safety during error handling.",
    "function_signature": "public List<String> fetchLocalizedValidationMessages(MessageSource messageSource, Locale locale)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration#getValidator()",
    "from_version": "v6.0.22",
    "to_version": "v6.1.9",
    "type": "method",
    "signature": "public Validator getValidator()",
    "documentation": "\t/**\n\t * Override this method to provide a custom {@link Validator}.\n\t * @since 4.0.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Validator getValidator() {\n\t\treturn null;\n\t}",
    "query": "Create a configuration for your messaging system that enforces custom validation rules on incoming messages to ensure they meet your application's specific requirements before being processed.",
    "function_signature": "public Validator getValidator()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.SimpleServletPostProcessor#getInitParameterNames()",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public Enumeration<String> getInitParameterNames()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Enumeration<String> getInitParameterNames() {\n\t\t\treturn Collections.enumeration(Collections.emptySet());\n\t\t}",
    "query": "Design a Spring MVC handler that retrieves and processes initialization parameter names from a servlet during the application's configuration phase.",
    "function_signature": "public Enumeration<String> retrieveServletInitParameterNames()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scripting.support.ScriptFactoryPostProcessor#setDefaultRefreshCheckDelay(defaultRefreshCheckDelay)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public void setDefaultRefreshCheckDelay(long defaultRefreshCheckDelay)",
    "documentation": "\t/**\n\t * Set the delay between refresh checks, in milliseconds.\n\t * Default is -1, indicating no refresh checks at all.\n\t * <p>Note that an actual refresh will only happen when\n\t * the {@link org.springframework.scripting.ScriptSource} indicates\n\t * that it has been modified.\n\t * @see org.springframework.scripting.ScriptSource#isModified()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setDefaultRefreshCheckDelay(long defaultRefreshCheckDelay) {\n\t\tthis.defaultRefreshCheckDelay = defaultRefreshCheckDelay;\n\t}",
    "query": "Design a mechanism within your Spring application that periodically checks for updates in script-based configurations, allowing the system to refresh them efficiently based on a customizable time interval.",
    "function_signature": "public void configureScriptRefreshInterval(long refreshIntervalMillis)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.oxm.support.AbstractMarshaller#marshalSaxResult(graph,saxResult)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "protected void marshalSaxResult(Object graph, SAXResult saxResult)",
    "documentation": "\t/**\n\t * Template method for handling {@code SAXResult}s.\n\t * <p>This implementation delegates to {@code marshalSaxHandlers}.\n\t * @param graph the root of the object graph to marshal\n\t * @param saxResult the {@code SAXResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @see #marshalSaxHandlers(Object, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void marshalSaxResult(Object graph, SAXResult saxResult) throws XmlMappingException {\n\t\tContentHandler contentHandler = saxResult.getHandler();\n\t\tAssert.notNull(contentHandler, \"ContentHandler not set on SAXResult\");\n\t\tLexicalHandler lexicalHandler = saxResult.getLexicalHandler();\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}",
    "query": "Design a method that transforms a given domain object into XML and streams it directly to a SAXResult for integration with an existing SAX-based XML processing pipeline.",
    "function_signature": "void streamObjectToSaxResult(Object domainObject, SAXResult saxResult)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#supportsReturnType(returnType)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public boolean supportsReturnType(MethodParameter returnType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (returnType.hasMethodAnnotation(SendTo.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(returnType.getDeclaringClass(), SendTo.class) ||\n\t\t\t\treturnType.hasMethodAnnotation(SendToUser.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(returnType.getDeclaringClass(), SendToUser.class) ||\n\t\t\t\t!this.annotationRequired);\n\t}",
    "query": "Create a WebSocket handler method that automatically sends its return value to a designated user-specific destination, ensuring personalized message delivery without manual routing.",
    "function_signature": "@SendToUser(\"/queue/notifications\")\npublic Notification sendUserNotification(NotificationRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.NettyDataBuffer#read(destination)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public NettyDataBuffer read(byte[] destination)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic NettyDataBuffer read(byte[] destination) {\n\t\tthis.byteBuf.readBytes(destination);\n\t\treturn this;\n\t}",
    "query": "Create a service method that efficiently transfers data from a reactive buffer into a provided byte array for immediate processing in a high-performance application.",
    "function_signature": "public NettyDataBuffer transferToByteArray(byte[] destination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.client.WebSocketTransport#afterConnectionClosed(webSocketSession,status)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status) throws Exception {\n\t\t\tthis.sockJsSession.afterTransportClosed(status);\n\t\t}",
    "query": "Develop a callback mechanism that triggers essential cleanup operations right after a WebSocket session ends, ensuring resources are properly released and any necessary logging is performed.",
    "function_signature": "public void handleWebSocketClosure(WebSocketSession session, CloseStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.support.TaskUtils",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "class",
    "signature": "public class TaskUtils",
    "documentation": "/**\n * Utility methods for decorating tasks with error handling.\n *\n * <p><b>NOTE:</b> This class is intended for internal use by Spring's scheduler\n * implementations. It is only public so that it may be accessed from impl classes\n * within other packages. It is <i>not</i> intended for general use.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public abstract class TaskUtils {\n\n\t/**\n\t * An ErrorHandler strategy that will log the Exception but perform\n\t * no further handling. This will suppress the error so that\n\t * subsequent executions of the task will not be prevented.\n\t */\n\tpublic static final ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER = new LoggingErrorHandler();\n\n\t/**\n\t * An ErrorHandler strategy that will log at error level and then\n\t * re-throw the Exception. Note: this will typically prevent subsequent\n\t * execution of a scheduled task.\n\t */\n\tpublic static final ErrorHandler LOG_AND_PROPAGATE_ERROR_HANDLER = new PropagatingErrorHandler();\n\n\n\t/**\n\t * Decorate the task for error handling. If the provided {@link ErrorHandler}\n\t * is not {@code null}, it will be used. Otherwise, repeating tasks will have\n\t * errors suppressed by default whereas one-shot tasks will have errors\n\t * propagated by default since those errors may be expected through the\n\t * returned {@link Future}. In both cases, the errors will be logged.\n\t */\n\tpublic static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(\n\t\t\tRunnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask) {\n\n\t\tif (task instanceof DelegatingErrorHandlingRunnable dehRunnable) {\n\t\t\treturn dehRunnable;\n\t\t}\n\t\tErrorHandler eh = (errorHandler != null ? errorHandler : getDefaultErrorHandler(isRepeatingTask));\n\t\treturn new DelegatingErrorHandlingRunnable(task, eh);\n\t}\n\n\t/**\n\t * Return the default {@link ErrorHandler} implementation based on the boolean\n\t * value indicating whether the task will be repeating or not. For repeating tasks\n\t * it will suppress errors, but for one-time tasks it will propagate. In both\n\t * cases, the error will be logged.\n\t */\n\tpublic static ErrorHandler getDefaultErrorHandler(boolean isRepeatingTask) {\n\t\treturn (isRepeatingTask ? LOG_AND_SUPPRESS_ERROR_HANDLER : LOG_AND_PROPAGATE_ERROR_HANDLER);\n\t}\n\n\n\t/**\n\t * An {@link ErrorHandler} implementation that logs the Throwable at error\n \t * level. It does not perform any additional error handling. This can be\n \t * useful when suppression of errors is the intended behavior.\n\t */\n\tprivate static class LoggingErrorHandler implements ErrorHandler {\n\n\t\tprivate final Log logger = LogFactory.getLog(LoggingErrorHandler.class);\n\n\t\t@Override\n\t\tpublic void handleError(Throwable t) {\n\t\t\tlogger.error(\"Unexpected error occurred in scheduled task\", t);\n\t\t}\n\t}\n\n\n\t/**\n\t * An {@link ErrorHandler} implementation that logs the Throwable at error\n\t * level and then propagates it.\n\t */\n\tprivate static class PropagatingErrorHandler extends LoggingErrorHandler {\n\n\t\t@Override\n\t\tpublic void handleError(Throwable t) {\n\t\t\tsuper.handleError(t);\n\t\t\tReflectionUtils.rethrowRuntimeException(t);\n\t\t}\n\t}\n\n}",
    "query": "Implement a background service that periodically executes data synchronization tasks. Ensure that any runtime exceptions are logged appropriately without halting future executions. Structure your method to seamlessly integrate advanced error handling mechanisms introduced in the latest Spring utilities.",
    "function_signature": "public void configureDataSyncTask(Runnable syncTask, boolean isRepeating)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor#onApplicationEvent(event)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public void onApplicationEvent(ContextRefreshedEvent event)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\t// Running in an ApplicationContext -> register tasks this late...\n\t\t\t// giving other ContextRefreshedEvent listeners a chance to perform\n\t\t\t// their work at the same time (e.g. Spring Batch's job registration).\n\t\t\tfinishRegistration();\n\t\t}\n\t}",
    "query": "Design a component that initializes scheduled tasks only after the Spring application context has fully refreshed, ensuring that all other initialization processes are complete before task registration begins.",
    "function_signature": "public void initializeScheduledTasks(ContextRefreshedEvent event)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.config.annotation.InterceptorRegistry#addInterceptor(interceptor)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public InterceptorRegistration addInterceptor(HandlerInterceptor interceptor)",
    "documentation": "\t/**\n\t * Adds the provided {@link HandlerInterceptor}.\n\t * @param interceptor the interceptor to add\n\t * @return an {@link InterceptorRegistration} that allows you optionally configure the\n\t * registered interceptor further for example adding URL patterns it should apply to.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic InterceptorRegistration addInterceptor(HandlerInterceptor interceptor) {\n\t\tInterceptorRegistration registration = new InterceptorRegistration(interceptor);\n\t\tthis.registrations.add(registration);\n\t\treturn registration;\n\t}",
    "query": "Configure a Spring MVC application to dynamically add a custom interceptor that monitors and logs specific HTTP request patterns, enabling conditional processing based on the request attributes.",
    "function_signature": "public InterceptorRegistration registerCustomMonitoringInterceptor(HandlerInterceptor monitoringInterceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler#setDefaultUserDestinationPrefix(prefix)",
    "from_version": "v6.0.6",
    "to_version": "v6.0.7",
    "type": "method",
    "signature": "public void setDefaultUserDestinationPrefix(String prefix)",
    "documentation": "\t/**\n\t * Configure a default prefix to add to message destinations in cases where a\n\t * method is annotated with {@link SendToUser @SendToUser} but does not specify\n\t * any destinations through the annotation's value attribute.\n\t * <p>By default, the prefix is set to \"/queue\".\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setDefaultUserDestinationPrefix(String prefix) {\n\t\tthis.defaultUserDestinationPrefix = prefix;\n\t}",
    "query": "Design a WebSocket messaging configuration that ensures all user-specific destinations automatically include a custom prefix, eliminating the need to specify the prefix manually in each `@SendToUser` annotation.",
    "function_signature": "public void customizeUserDestinationPrefix(String prefix)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.Builder",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "interface",
    "signature": "public interface Builder",
    "documentation": "\t/**\n\t * Defines a builder for creating a RequestMappingInfo.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic interface Builder {\n\n\t\t/**\n\t\t * Set the path patterns.\n\t\t */\n\t\tBuilder paths(String... paths);\n\n\t\t/**\n\t\t * Set the request method conditions.\n\t\t */\n\t\tBuilder methods(RequestMethod... methods);\n\n\t\t/**\n\t\t * Set the request param conditions.\n\t\t */\n\t\tBuilder params(String... params);\n\n\t\t/**\n\t\t * Set the header conditions.\n\t\t * <p>By default this is not set.\n\t\t */\n\t\tBuilder headers(String... headers);\n\n\t\t/**\n\t\t * Set the consumes conditions.\n\t\t */\n\t\tBuilder consumes(String... consumes);\n\n\t\t/**\n\t\t * Set the produces conditions.\n\t\t */\n\t\tBuilder produces(String... produces);\n\n\t\t/**\n\t\t * Set the mapping name.\n\t\t */\n\t\tBuilder mappingName(String name);\n\n\t\t/**\n\t\t * Set a custom condition to use.\n\t\t */\n\t\tBuilder customCondition(RequestCondition<?> condition);\n\n\t\t/**\n\t\t * Provide additional configuration needed for request mapping purposes.\n\t\t */\n\t\tBuilder options(BuilderConfiguration options);\n\n\t\t/**\n\t\t * Build the RequestMappingInfo.\n\t\t */\n\t\tRequestMappingInfo build();\n\t}",
    "query": "Develop a service method that programmatically constructs complex request mappings incorporating various conditions like URL patterns, HTTP methods, and custom headers to streamline dynamic routing within your application.",
    "function_signature": "public RequestMappingInfo createDynamicRequestMapping()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.HttpHeaders#setIfMatch(ifMatch)",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "public void setIfMatch(String ifMatch)",
    "documentation": "\t/**\n\t * Set the (new) value of the {@code If-Match} header.\n\t * @since 4.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setIfMatch(String ifMatch) {\n\t\tset(IF_MATCH, ifMatch);\n\t}",
    "query": "Implement a REST endpoint that updates a user profile only if the client's provided version matches the current server version, preventing accidental overwrites due to concurrent modifications.",
    "function_signature": "public ResponseEntity<Void> updateUserProfile(@RequestHeader(\"If-Match\") String ifMatch, @RequestBody UserProfile profile)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.TransactionTemplate#afterPropertiesSet()",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "public void afterPropertiesSet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterPropertiesSet() {\n\t\tif (this.transactionManager == null) {\n\t\t\tthrow new IllegalArgumentException(\"Property 'transactionManager' is required\");\n\t\t}\n\t}",
    "query": "Create a Spring-managed component that validates the presence of a transaction manager during its initialization phase to ensure reliable transaction handling across the application.",
    "function_signature": "public void initializeTransactionSupport()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.support.AbstractSockJsService#handleTransportRequest(request,response,webSocketHandler,sessionId,transport)",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport)",
    "documentation": "\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,",
    "query": "Design a service component that efficiently manages transport-specific requests in a real-time chat application using SockJS, ensuring seamless handling of various transport protocols and session management.",
    "function_signature": "protected void manageTransportRequest(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler chatHandler, String sessionId, String transportType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.EmitUtils",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "class",
    "signature": "public class EmitUtils",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class EmitUtils {\n    private static final Signature CSTRUCT_NULL =\n      TypeUtils.parseConstructor(\"\");\n    private static final Signature CSTRUCT_THROWABLE =\n      TypeUtils.parseConstructor(\"Throwable\");\n\n    private static final Signature GET_NAME =\n      TypeUtils.parseSignature(\"String getName()\");\n    private static final Signature HASH_CODE =\n      TypeUtils.parseSignature(\"int hashCode()\");\n    private static final Signature EQUALS =\n      TypeUtils.parseSignature(\"boolean equals(Object)\");\n    private static final Signature STRING_LENGTH =\n      TypeUtils.parseSignature(\"int length()\");\n    private static final Signature STRING_CHAR_AT =\n      TypeUtils.parseSignature(\"char charAt(int)\");\n    private static final Signature FOR_NAME =\n      TypeUtils.parseSignature(\"Class forName(String)\");\n    private static final Signature DOUBLE_TO_LONG_BITS =\n      TypeUtils.parseSignature(\"long doubleToLongBits(double)\");\n    private static final Signature FLOAT_TO_INT_BITS =\n      TypeUtils.parseSignature(\"int floatToIntBits(float)\");\n    private static final Signature TO_STRING =\n      TypeUtils.parseSignature(\"String toString()\");\n    private static final Signature APPEND_STRING =\n      TypeUtils.parseSignature(\"StringBuffer append(String)\");\n    private static final Signature APPEND_INT =\n      TypeUtils.parseSignature(\"StringBuffer append(int)\");\n    private static final Signature APPEND_DOUBLE =\n      TypeUtils.parseSignature(\"StringBuffer append(double)\");\n    private static final Signature APPEND_FLOAT =\n      TypeUtils.parseSignature(\"StringBuffer append(float)\");\n    private static final Signature APPEND_CHAR =\n      TypeUtils.parseSignature(\"StringBuffer append(char)\");\n    private static final Signature APPEND_LONG =\n      TypeUtils.parseSignature(\"StringBuffer append(long)\");\n    private static final Signature APPEND_BOOLEAN =\n      TypeUtils.parseSignature(\"StringBuffer append(boolean)\");\n    private static final Signature LENGTH =\n      TypeUtils.parseSignature(\"int length()\");\n    private static final Signature SET_LENGTH =\n      TypeUtils.parseSignature(\"void setLength(int)\");\n    private static final Signature GET_DECLARED_METHOD =\n      TypeUtils.parseSignature(\"java.lang.reflect.Method getDeclaredMethod(String, Class[])\");\n\n\n\n    public static final ArrayDelimiters DEFAULT_DELIMITERS = new ArrayDelimiters(\"{\", \", \", \"}\");\n\n    private EmitUtils() {\n    }\n\n    public static void factory_method(ClassEmitter ce, Signature sig) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        e.new_instance_this();\n        e.dup();\n        e.load_args();\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        e.return_value();\n        e.end_method();\n    }\n\n    public static void null_constructor(ClassEmitter ce) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\n        e.load_this();\n        e.super_invoke_constructor();\n        e.return_value();\n        e.end_method();\n    }\n\n    /**\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     */\n    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }\n\n    /**\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     */\n    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array1 = e.make_local();\n        Local array2 = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array1);\n        e.store_local(array2);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array1);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        e.load_local(array2);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array1);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }\n\n    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n        try {\n            switch (switchStyle) {\n            case Constants.SWITCH_STYLE_TRIE:\n                string_switch_trie(e, strings, callback);\n                break;\n            case Constants.SWITCH_STYLE_HASH:\n                string_switch_hash(e, strings, callback, false);\n                break;\n            case Constants.SWITCH_STYLE_HASHONLY:\n                string_switch_hash(e, strings, callback, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n            }\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void string_switch_trie(final CodeEmitter e,\n                                           String[] strings,\n                                           final ObjectSwitchCallback callback) throws Exception {\n        final Label def = e.make_label();\n        final Label end = e.make_label();\n        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> ((String)value).length());\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING, STRING_LENGTH);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n                @Override\n                public void processCase(int key, Label ignore_end) throws Exception {\n                    List bucket = (List)buckets.get(key);\n                    stringSwitchHelper(e, bucket, callback, def, end, 0);\n                }\n                @Override\n                public void processDefault() {\n                    e.goTo(def);\n                }\n            });\n        e.mark(def);\n        e.pop();\n        callback.processDefault();\n        e.mark(end);\n    }\n\n    private static void stringSwitchHelper(final CodeEmitter e,\n                                           List strings,\n                                           final ObjectSwitchCallback callback,\n                                           final Label def,\n                                           final Label end,\n                                           final int index) throws Exception {\n        final int len = ((String)strings.get(0)).length();\n        final Map buckets = CollectionUtils.bucket(strings, value -> ((String)value).charAt(index));\n        e.dup();\n        e.push(index);\n        e.invoke_virtual(Constants.TYPE_STRING, STRING_CHAR_AT);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n                @Override\n                public void processCase(int key, Label ignore_end) throws Exception {\n                    List bucket = (List)buckets.get(key);\n                    if (index + 1 == len) {\n                        e.pop();\n                        callback.processCase(bucket.get(0), end);\n                    } else {\n                        stringSwitchHelper(e, bucket, callback, def, end, index + 1);\n                    }\n                }\n                @Override\n                public void processDefault() {\n                    e.goTo(def);\n                }\n            });\n    }\n\n    static int[] getSwitchKeys(Map buckets) {\n        int[] keys = new int[buckets.size()];\n        int index = 0;\n        for (Iterator it = buckets.keySet().iterator(); it.hasNext();) {\n            keys[index++] = ((Integer)it.next());\n        }\n        Arrays.sort(keys);\n        return keys;\n    }\n\n    private static void string_switch_hash(final CodeEmitter e,\n                                           final String[] strings,\n                                           final ObjectSwitchCallback callback,\n                                           final boolean skipEquals) throws Exception {\n        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> value.hashCode());\n        final Label def = e.make_label();\n        final Label end = e.make_label();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label ignore_end) throws Exception {\n                List bucket = (List)buckets.get(key);\n                Label next = null;\n                if (skipEquals && bucket.size() == 1) {\n                    if (skipEquals) {\n\t\t\t\t\t\te.pop();\n\t\t\t\t\t}\n                    callback.processCase(bucket.get(0), end);\n                } else {\n                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n                        String string = (String)it.next();\n                        if (next != null) {\n                            e.mark(next);\n                        }\n                        if (it.hasNext()) {\n                            e.dup();\n                        }\n                        e.push(string);\n                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                        if (it.hasNext()) {\n                            e.if_jump(CodeEmitter.EQ, next = e.make_label());\n                            e.pop();\n                        } else {\n                            e.if_jump(CodeEmitter.EQ, def);\n                        }\n                        callback.processCase(string, end);\n                    }\n                }\n            }\n            @Override\n            public void processDefault() {\n                e.pop();\n            }\n        });\n        e.mark(def);\n        callback.processDefault();\n        e.mark(end);\n    }\n\n    public static void load_class_this(CodeEmitter e) {\n        load_class_helper(e, e.getClassEmitter().getClassType());\n    }\n\n    public static void load_class(CodeEmitter e, Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                throw new IllegalArgumentException(\"cannot load void type\");\n            }\n            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n        } else {\n            load_class_helper(e, type);\n        }\n    }\n\n    private static void load_class_helper(CodeEmitter e, final Type type) {\n        if (e.isStaticHook()) {\n            // have to fall back on non-optimized load\n            e.push(TypeUtils.emulateClassGetName(type));\n            e.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n        } else {\n            ClassEmitter ce = e.getClassEmitter();\n            String typeName = TypeUtils.emulateClassGetName(type);\n\n            // TODO: can end up with duplicated field names when using chained transformers; incorporate static hook # somehow\n            String fieldName = \"CGLIB$load_class$\" + TypeUtils.escapeType(typeName);\n            if (!ce.isFieldDeclared(fieldName)) {\n                ce.declare_field(Constants.PRIVATE_FINAL_STATIC, fieldName, Constants.TYPE_CLASS, null);\n                CodeEmitter hook = ce.getStaticHook();\n                hook.push(typeName);\n                hook.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n                hook.putstatic(ce.getClassType(), fieldName, Constants.TYPE_CLASS);\n            }\n            e.getfield(fieldName);\n        }\n    }\n\n    public static void push_array(CodeEmitter e, Object[] array) {\n        e.push(array.length);\n        e.newarray(Type.getType(remapComponentType(array.getClass().getComponentType())));\n        for (int i = 0; i < array.length; i++) {\n            e.dup();\n            e.push(i);\n            push_object(e, array[i]);\n            e.aastore();\n        }\n    }\n\n    private static Class remapComponentType(Class componentType) {\n        if (componentType.equals(Type.class)) {\n\t\t\treturn Class.class;\n\t\t}\n        return componentType;\n    }\n\n    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */\n    @Deprecated\n    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\n        if (TypeUtils.isArray(type)) {\n            hash_array(e, type, multiplier, registry);\n        } else {\n            e.swap(Type.INT_TYPE, type);\n            e.push(multiplier);\n            e.math(CodeEmitter.MUL, Type.INT_TYPE);\n            e.swap(type, Type.INT_TYPE);\n            if (TypeUtils.isPrimitive(type)) {\n                hash_primitive(e, type);\n            } else {\n                hash_object(e, type, registry);\n            }\n            e.math(CodeEmitter.ADD, Type.INT_TYPE);\n        }\n    }\n\n    private static void hash_array(final CodeEmitter e, Type type, final int multiplier, final CustomizerRegistry registry) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        e.dup();\n        e.ifnull(skip);\n        EmitUtils.process_array(e, type, type1 -> hash_code(e, type1, multiplier, registry));\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.mark(end);\n    }\n\n    private static void hash_object(CodeEmitter e, Type type, CustomizerRegistry registry) {\n        // (f == null) ? 0 : f.hashCode();\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        e.dup();\n        e.ifnull(skip);\n        boolean customHashCode = false;\n        for (HashCodeCustomizer customizer : registry.get(HashCodeCustomizer.class)) {\n            if (customizer.customize(e, type)) {\n                customHashCode = true;\n                break;\n            }\n        }\n        if (!customHashCode) {\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(0);\n        e.mark(end);\n    }\n\n    private static void hash_primitive(CodeEmitter e, Type type) {\n        switch (type.getSort()) {\n        case Type.BOOLEAN:\n            // f ? 0 : 1\n            e.push(1);\n            e.math(CodeEmitter.XOR, Type.INT_TYPE);\n            break;\n        case Type.FLOAT:\n            // Float.floatToIntBits(f)\n            e.invoke_static(Constants.TYPE_FLOAT, FLOAT_TO_INT_BITS);\n            break;\n        case Type.DOUBLE:\n            // Double.doubleToLongBits(f), hash_code(Long.TYPE)\n            e.invoke_static(Constants.TYPE_DOUBLE, DOUBLE_TO_LONG_BITS);\n            // fall through\n        case Type.LONG:\n            hash_long(e);\n        }\n    }\n\n    private static void hash_long(CodeEmitter e) {\n        // (int)(f ^ (f >>> 32))\n        e.dup2();\n        e.push(32);\n        e.math(CodeEmitter.USHR, Type.LONG_TYPE);\n        e.math(CodeEmitter.XOR, Type.LONG_TYPE);\n        e.cast_numeric(Type.LONG_TYPE, Type.INT_TYPE);\n    }\n\n//     public static void not_equals(CodeEmitter e, Type type, Label notEquals) {\n//         not_equals(e, type, notEquals, null);\n//     }\n\n    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */\n    @Deprecated\n    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }\n\n    /**\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     */\n    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\n        (new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                not_equals_helper(e, type, notEquals, registry, this);\n            }\n        }).processElement(type);\n    }\n\n    private static void not_equals_helper(CodeEmitter e,\n                                          Type type,\n                                          Label notEquals,\n                                          CustomizerRegistry registry,\n                                          ProcessArrayCallback callback) {\n        if (TypeUtils.isPrimitive(type)) {\n            e.if_cmp(type, CodeEmitter.NE, notEquals);\n        } else {\n            Label end = e.make_label();\n            nullcmp(e, notEquals, end);\n            if (TypeUtils.isArray(type)) {\n                Label checkContents = e.make_label();\n                e.dup2();\n                e.arraylength();\n                e.swap();\n                e.arraylength();\n                e.if_icmp(CodeEmitter.EQ, checkContents);\n                e.pop2();\n                e.goTo(notEquals);\n                e.mark(checkContents);\n                EmitUtils.process_arrays(e, type, callback);\n            } else {\n                List<Customizer> customizers = registry.get(Customizer.class);\n                if (!customizers.isEmpty()) {\n                    for (Customizer customizer : customizers) {\n                        customizer.customize(e, type);\n                    }\n                    e.swap();\n                    for (Customizer customizer : customizers) {\n                        customizer.customize(e, type);\n                    }\n                }\n                e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                e.if_jump(CodeEmitter.EQ, notEquals);\n            }\n            e.mark(end);\n        }\n    }\n\n    /**\n     * If both objects on the top of the stack are non-null, does nothing.\n     * If one is null, or both are null, both are popped off and execution\n     * branches to the respective label.\n     * @param oneNull label to branch to if only one of the objects is null\n     * @param bothNull label to branch to if both of the objects are null\n     */\n    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n        e.dup2();\n        Label nonNull = e.make_label();\n        Label oneNullHelper = e.make_label();\n        Label end = e.make_label();\n        e.ifnonnull(nonNull);\n        e.ifnonnull(oneNullHelper);\n        e.pop2();\n        e.goTo(bothNull);\n\n        e.mark(nonNull);\n        e.ifnull(oneNullHelper);\n        e.goTo(end);\n\n        e.mark(oneNullHelper);\n        e.pop2();\n        e.goTo(oneNull);\n\n        e.mark(end);\n    }\n\n    /*\n    public static void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry) {\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\n        e.dup();\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n        e.swap();\n        append_string(e, type, delims, registry);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n    }\n    */\n\n    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */\n    @Deprecated\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }\n\n    private static void append_string_helper(CodeEmitter e,\n                                             Type type,\n                                             ArrayDelimiters delims,\n                                             CustomizerRegistry registry,\n                                             ProcessArrayCallback callback) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n                break;\n            case Type.DOUBLE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n                break;\n            case Type.FLOAT:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n                break;\n            case Type.LONG:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n                break;\n            case Type.BOOLEAN:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n                break;\n            case Type.CHAR:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n                break;\n            }\n        } else if (TypeUtils.isArray(type)) {\n            e.dup();\n            e.ifnull(skip);\n            e.swap();\n            if (delims != null && delims.before != null && !\"\".equals(delims.before)) {\n                e.push(delims.before);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                e.swap();\n            }\n            EmitUtils.process_array(e, type, callback);\n            shrinkStringBuffer(e, 2);\n            if (delims != null && delims.after != null && !\"\".equals(delims.after)) {\n                e.push(delims.after);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        } else {\n            e.dup();\n            e.ifnull(skip);\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(\"null\");\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        e.mark(end);\n    }\n\n    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n        e.dup();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n        e.push(amt);\n        e.math(CodeEmitter.SUB, Type.INT_TYPE);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n    }\n\n    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }\n\n    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }\n\n    private interface ParameterTyper {\n        Type[] getParameterTypes(MethodInfo member);\n    }\n\n    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }\n\n    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }\n\n    private static void member_switch_helper(final CodeEmitter e,\n                                             List members,\n                                             final ObjectSwitchCallback callback,\n                                             boolean useName) {\n        try {\n            final Map cache = new HashMap();\n            final ParameterTyper cached = member -> {\n                Type[] types = (Type[]) cache.get(member);\n                if (types == null) {\n                    cache.put(member, types = member.getSignature().getArgumentTypes());\n                }\n                return types;\n            };\n            final Label def = e.make_label();\n            final Label end = e.make_label();\n            if (useName) {\n                e.swap();\n                final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo)value).getSignature().getName());\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                        @Override\n                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n                        }\n                        @Override\n                        public void processDefault() throws Exception {\n                            e.goTo(def);\n                        }\n                    });\n            } else {\n                member_helper_size(e, members, callback, cached, def, end);\n            }\n            e.mark(def);\n            e.pop();\n            callback.processDefault();\n            e.mark(end);\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void member_helper_size(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end) throws Exception {\n        final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo)value).length);\n        e.dup();\n        e.arraylength();\n        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label dontUseEnd) throws Exception {\n                List bucket = (List)buckets.get(key);\n                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n            }\n            @Override\n            public void processDefault() throws Exception {\n                e.goTo(def);\n            }\n        });\n    }\n\n    private static void member_helper_type(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end,\n                                           final BitSet checked) throws Exception {\n        if (members.size() == 1) {\n            MethodInfo member = (MethodInfo)members.get(0);\n            Type[] types = typer.getParameterTypes(member);\n            // need to check classes that have not already been checked via switches\n            for (int i = 0; i < types.length; i++) {\n                if (checked == null || !checked.get(i)) {\n                    e.dup();\n                    e.aaload(i);\n                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n                    e.push(TypeUtils.emulateClassGetName(types[i]));\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                    e.if_jump(CodeEmitter.EQ, def);\n                }\n            }\n            e.pop();\n            callback.processCase(member, end);\n        } else {\n            // choose the index that has the best chance of uniquely identifying member\n            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n            Map buckets = null;\n            int index = -1;\n            for (int i = 0; i < example.length; i++) {\n                final int j = i;\n                Map test = CollectionUtils.bucket(members,\n                        value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]));\n                if (buckets == null || test.size() > buckets.size()) {\n                    buckets = test;\n                    index = i;\n                }\n            }\n            if (buckets == null || buckets.size() == 1) {\n                // TODO: switch by returnType\n                // must have two methods with same name, types, and different return types\n                e.goTo(def);\n            } else {\n                checked.set(index);\n\n                e.dup();\n                e.aaload(index);\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n\n                final Map fbuckets = buckets;\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                    @Override\n                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }\n                    @Override\n                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }\n                });\n            }\n        }\n    }\n\n    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }\n\n    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }\n\n    /* generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }",
    "query": "Design a component that dynamically generates optimized proxy classes for service interfaces, ensuring minimal runtime overhead and enhanced performance during method invocations.",
    "function_signature": "public <T> T createOptimizedProxy(Class<T> serviceInterface, T targetInstance);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.STATE_MIXED",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "field",
    "signature": "public int STATE_MIXED",
    "documentation": "\t/**\n\t * Mixed outcome state.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final int STATE_MIXED = 3;",
    "query": "Develop a service method that processes complex transactions which may result in both committed and rolled-back operations, ensuring the system accurately reflects the mixed outcome state for appropriate handling.",
    "function_signature": "public int evaluateMixedTransactionOutcome(TransactionDetails details);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.AbstractRegexpMethodPointcut#matches(method,targetClass)",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "documentation": "\t/**\n\t * Try to match the regular expression against the fully qualified name\n\t * of the target class as well as against the method's declaring class,\n\t * plus the name of the method.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (matchesPattern(ClassUtils.getQualifiedMethodName(method, targetClass)) ||\n\t\t\t\t(targetClass != method.getDeclaringClass() &&\n\t\t\t\t\t\tmatchesPattern(ClassUtils.getQualifiedMethodName(method, method.getDeclaringClass()))));\n\t}",
    "query": "Create an aspect that conditionally applies transaction management to methods only when both the method name and its containing class name match predefined naming conventions.",
    "function_signature": "public boolean isTransactionalMethod(Method method, Class<?> targetClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource#setDefaultTargetDataSource(defaultTargetDataSource)",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "public void setDefaultTargetDataSource(Object defaultTargetDataSource)",
    "documentation": "\t/**\n\t * Specify the default target DataSource, if any.\n\t * <p>The mapped value can either be a corresponding {@link javax.sql.DataSource}\n\t * instance or a data source name String (to be resolved via a\n\t * {@link #setDataSourceLookup DataSourceLookup}).\n\t * <p>This DataSource will be used as target if none of the keyed\n\t * {@link #setTargetDataSources targetDataSources} match the\n\t * {@link #determineCurrentLookupKey()} current lookup key.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setDefaultTargetDataSource(Object defaultTargetDataSource) {\n\t\tthis.defaultTargetDataSource = defaultTargetDataSource;\n\t}",
    "query": "Design a routing mechanism for database operations that delegates to multiple data sources based on context, ensuring that a primary data source is used when no specific target is identified.",
    "function_signature": "public void initializeRoutingDataSourceWithDefault(DataSource defaultDataSource)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseSetElement(collectionEle,bd)",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "public Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "documentation": "\t/**\n\t * Parse a set element.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedSet<Object> target = new ManagedSet<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}",
    "query": "Implement a method that parses and manages set elements from custom XML configurations, ensuring they are correctly registered within the Spring application context.",
    "function_signature": "public Set<Object> parseAndRegisterSetConfiguration(Element collectionElement, @Nullable BeanDefinition beanDefinition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.view.script.ScriptTemplateView#setCharset(charset)",
    "from_version": "v5.3.28",
    "to_version": "v6.0.10",
    "type": "method",
    "signature": "public void setCharset(Charset charset)",
    "documentation": "\t/**\n\t * See {@link ScriptTemplateConfigurer#setCharset(Charset)} documentation.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setCharset(Charset charset) {\n\t\tthis.charset = charset;\n\t}",
    "query": "Ensure that your Spring MVC application correctly handles international characters in script-based views by configuring the appropriate character encoding.",
    "function_signature": "public void configureScriptViewCharset(Charset charset)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Develop a component that can retrieve all active WebSocket session identifiers to enable targeted messaging or manage user sessions effectively.",
    "function_signature": "public String[] getActiveSessionIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Design a Spring configuration that allows dynamic retrieval and modification of an existing interceptor within a mapped set of interceptors, enabling conditional behavior based on runtime criteria.",
    "function_signature": "public HandlerInterceptor retrieveInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Develop a mechanism to efficiently handle and configure WebSocket subscription and unsubscription messages, optimizing for scenarios where subscriptions may contend for the same destination or session.",
    "function_signature": "public void manageSubscriptionRequests(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Create a feature that allows administrators to monitor and manage all active WebSocket client subscriptions in real-time, ensuring efficient oversight and control over user connections.",
    "function_signature": "public Map<String, SubscriptionDetails> monitorActiveSubscriptions(SubscriptionRegistry subscriptionRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a component that efficiently manages and caches client subscriptions for a high-throughput WebSocket messaging application, ensuring optimal performance and scalability when handling numerous simultaneous connections and destinations.",
    "function_signature": "public void initializeSubscriptionManager(int cacheSizeLimit, int numberOfDestinations, int numberOfSessions)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Implement a request interceptor that selectively processes URLs following a complex pattern, ensuring that only requests matching these intricate criteria are intercepted.",
    "function_signature": "public void configureSelectiveInterceptor(CustomPathMatcher customPathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String destination;",
    "query": "Design a feature in your real-time application that directs user notifications to specific channels based on user preferences, ensuring messages reach the correct audience efficiently.",
    "function_signature": "public void dispatchNotification(String userId, String notificationContent, String destination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Implement a monitoring feature for a real-time messaging service that tracks active user sessions, subscribed channels, and dynamically adjusts resource allocation based on current load and subscription patterns.",
    "function_signature": "public void configureMessagingServer(int sessionLimit, int destinationLimit, String specializationMode)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PathPattern[] includePatterns;\n\n\t@Nullable\n\tprivate final PathPattern[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\t@Nullable\n\tprivate static PathPattern[] initPatterns(\n\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\treturn null;\n\t\t}\n\t\tparser = (parser != null ? parser : PathPatternParser.defaultInstance);\n\t\treturn Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchPattern(Object path, boolean isPathContainer, PathPattern pattern) {\n\t\treturn (isPathContainer ?\n\t\t\t\tpattern.matches((PathContainer) path) :\n\t\t\t\tthis.pathMatcher.match(pattern.getPatternString(), (String) path));\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n}",
    "query": "Design a request handling mechanism that applies a specific interceptor only to designated URL patterns, while excluding others, to optimize processing and maintain clean separation of concerns in your Spring application.",
    "function_signature": "public MappedInterceptor configurePatternBasedInterceptor(String[] includePatterns, String[] excludePatterns, HandlerInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.2.12.RELEASE",
    "to_version": "v5.3.3",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Design a service method that dynamically selects messaging destinations based on criteria such as subscriber presence and destination overlap to optimize message routing.",
    "function_signature": "public void selectOptimalDestination(DestinationSelectionCriteria criteria);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#domain()",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public String domain()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String domain() {\n\t\t\treturn this.domain;\n\t\t}",
    "query": "Create a utility function that retrieves the application's domain in a thread-safe manner, optimizing for performance and ensuring ease of maintenance.",
    "function_signature": "public Optional<String> fetchDomain()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#appendToUsername(s)",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public void appendToUsername(String s)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void appendToUsername(String s) {\n\t\t\tif (this.username == null) {\n\t\t\t\tthis.username = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.username.append(s);\n\t\t\t}\n\t\t}",
    "query": "Develop a method that extends a user's name with a provided string, leveraging immutable data structures for improved performance and safety.",
    "function_signature": "public String extendUserName(String suffix)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.MockMvcTester#assertThat()",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public MvcTestResultAssert assertThat()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic MvcTestResultAssert assertThat() {\n\t\t\treturn new MvcTestResultAssert(exchange(), MockMvcTester.this.jsonMessageConverter);\n\t\t}",
    "query": "Enhance your MockMvc testing suite by implementing a more reliable assertion mechanism that offers improved readability and maintainability.",
    "function_signature": "public EnhancedMvcTestResultAssert verifyTestResults()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.MockReset#withSettings(reset)",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public MockSettings withSettings(MockReset reset)",
    "documentation": "\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}",
    "query": "Refactor your mock configuration to enhance test reliability and maintainability by adopting the latest settings approach provided by the framework.",
    "function_signature": "public MockSettings configureMockBehavior()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#cookie(cookies)",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder cookie(Cookie... cookies)",
    "documentation": "\t/**\n\t * Add the given cookies to the request. Cookies are always added.\n\t * @param cookies the cookies to add\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MockHttpServletRequestBuilder cookie(Cookie... cookies) {\n\t\tAssert.notEmpty(cookies, \"'cookies' must not be empty\");\n\t\tthis.cookies.addAll(Arrays.asList(cookies));\n\t\treturn this;\n\t}",
    "query": "Design a unit test for a Spring MVC endpoint that processes user preferences, ensuring that the request includes necessary authentication cookies.",
    "function_signature": "public MockHttpServletRequestBuilder addAuthCookies(UserPreferences prefs)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#compareTo(o)",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public int compareTo(Delayed o)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int compareTo(Delayed o) {\n\t\t\treturn this.future.compareTo(o);\n\t\t}",
    "query": "Refactor the task scheduling component to implement a more efficient and reliable method for determining task order, enhancing overall performance and thread safety.",
    "function_signature": "public int prioritizeTaskExecution(Delayed task)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#self()",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "protected B self()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected B self() {\n\t\treturn (B) this;\n\t}",
    "query": "Develop a method to configure a mock HTTP servlet request that ensures enhanced type safety and streamlined method chaining, avoiding potential performance overheads and casting issues associated with previous implementation approaches.",
    "function_signature": "protected MockHttpServletRequestBuilder configureRequestBuilder()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.KEY",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "field",
    "signature": "public String KEY",
    "documentation": "\t/**\n\t * Key under which this accessor is registered in\n\t * {@link io.micrometer.context.ContextRegistry}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final String KEY = RequestAttributesThreadLocalAccessor.class.getName() + \".KEY\";",
    "query": "Refactor the component responsible for managing request-scoped data to enhance thread safety and improve performance by utilizing the latest context management utilities provided by Spring.",
    "function_signature": "public void updateRequestContext(ContextManager contextManager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.AsyncServerResponse",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "interface",
    "signature": "public interface AsyncServerResponse",
    "documentation": "/**\n * Asynchronous subtype of {@link ServerResponse} that exposes the future\n * response.\n *\n * @author Arjen Poutsma\n * @since 5.3.2\n * @see ServerResponse#async(Object)\n */",
    "changetype": "deprecated",
    "source_code": "public interface AsyncServerResponse extends ServerResponse {\n\n\t/**\n\t * Blocks indefinitely until the future response is obtained.\n\t */\n\tServerResponse block();\n\n\n\t// Static creation methods\n\n\t/**\n\t * Create a {@code AsyncServerResponse} with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse) {\n\t\treturn createInternal(asyncResponse, null);\n\t}\n\n\t/**\n\t * Create a (built) response with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @param timeout maximum time period to wait for before timing out\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse, Duration timeout) {\n\t\treturn createInternal(asyncResponse, timeout);\n\t}\n\n\tprivate static AsyncServerResponse createInternal(Object asyncResponse, @Nullable Duration timeout) {\n\t\tAssert.notNull(asyncResponse, \"AsyncResponse must not be null\");\n\n\t\tCompletableFuture<ServerResponse> futureResponse = toCompletableFuture(asyncResponse);\n\t\tif (futureResponse.isDone() &&\n\t\t\t\t!futureResponse.isCancelled() &&\n\t\t\t\t!futureResponse.isCompletedExceptionally()) {\n\n\t\t\ttry {\n\t\t\t\tServerResponse completedResponse = futureResponse.get();\n\t\t\t\treturn new CompletedAsyncServerResponse(completedResponse);\n\t\t\t}\n\t\t\tcatch (InterruptedException | ExecutionException ignored) {\n\t\t\t\t// fall through to use DefaultAsyncServerResponse\n\t\t\t}\n\t\t}\n\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static CompletableFuture<ServerResponse> toCompletableFuture(Object obj) {\n\t\tif (obj instanceof CompletableFuture<?> futureResponse) {\n\t\t\treturn (CompletableFuture<ServerResponse>) futureResponse;\n\t\t}\n\t\telse if (DefaultAsyncServerResponse.reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\treturn (CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}\n\n}",
    "query": "Create a controller method that handles HTTP requests asynchronously, optimizing for non-blocking operations to enhance application performance and scalability.",
    "function_signature": "public Mono<ServerResponse> processAsyncRequest(ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#setMessageConverters(HttpMessageConverter<?>...messageConverters)",
    "from_version": "v6.2.0-M4",
    "to_version": "v6.1.10",
    "type": "method",
    "signature": "public RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters)",
    "documentation": "\t/**\n\t * Set the message converters to use in argument resolvers and in return value\n\t * handlers, which support reading and/or writing to the body of the request\n\t * and response. If no message converters are added to the list, a default\n\t * list of converters is added instead.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder setMessageConverters(HttpMessageConverter<?>...messageConverters) {\n\t\tthis.messageConverters = Arrays.asList(messageConverters);\n\t\treturn this;\n\t}",
    "query": "Enhance your MockMvc setup to efficiently manage HTTP message conversion by applying the updated configuration strategy for request and response processing.",
    "function_signature": "public RouterFunctionMockMvcBuilder configureMessageConverters(List<HttpMessageConverter<?>> converters)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.reactive.MessageMappingMessageHandler",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "class",
    "signature": "public class MessageMappingMessageHandler",
    "documentation": "/**\n * Extension of {@link AbstractMethodMessageHandler} for reactive, non-blocking\n * handling of messages via {@link MessageMapping @MessageMapping} methods.\n * By default such methods are detected in {@code @Controller} Spring beans but\n * that can be changed via {@link #setHandlerPredicate(Predicate)}.\n *\n * <p>Payloads for incoming messages are decoded through the configured\n * {@link #setDecoders(List)} decoders, with the help of\n * {@link PayloadMethodArgumentResolver}.\n *\n * <p>There is no default handling for return values but\n * {@link #setReturnValueHandlerConfigurer} can be used to configure custom\n * return value handlers. Sub-classes may also override\n * {@link #initReturnValueHandlers()} to set up default return value handlers.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n * @see AbstractEncoderMethodReturnValueHandler\n */",
    "changetype": "deprecated",
    "source_code": "public class MessageMappingMessageHandler extends AbstractMethodMessageHandler<CompositeMessageCondition>",
    "query": "Refactor the message processing setup to enhance non-blocking operations and leverage the latest configuration capabilities for handling message mappings within Spring controllers.",
    "function_signature": "public void configureReactiveMessageProcessing()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.reactive.MessageMappingMessageHandler#getMatchingMapping(mapping,message)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "protected CompositeMessageCondition getMatchingMapping(CompositeMessageCondition mapping, Message<?> message)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected CompositeMessageCondition getMatchingMapping(CompositeMessageCondition mapping, Message<?> message) {\n\t\treturn mapping.getMatchingCondition(message);\n\t}",
    "query": "Optimize the retrieval of message conditions in a reactive message handler to enhance performance and maintainability.",
    "function_signature": "protected CompositeMessageCondition determineApplicableCondition(CompositeMessageCondition condition, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.reactive.MessageMappingMessageHandler#getDestination(message)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "protected String getDestination(Message<?> message)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected String getDestination(Message<?> message) {\n\t\treturn (String) message.getHeaders().get(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER);\n\t}",
    "query": "Improve the message handling mechanism to enhance performance and ensure safer extraction of destination information from incoming messages. Implement a method that utilizes the latest best practices in the Spring Framework for retrieving destination details.",
    "function_signature": "protected Mono<String> resolveDestination(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#handleMatch(mapping,handlerMethod,message)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "protected Mono<Void> handleMatch(CompositeMessageCondition mapping, HandlerMethod handlerMethod, Message<?> message)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected Mono<Void> handleMatch(CompositeMessageCondition mapping, HandlerMethod handlerMethod, Message<?> message) {\n\t\tSet<String> patterns = mapping.getCondition(DestinationPatternsMessageCondition.class).getPatterns();\n\t\tif (!CollectionUtils.isEmpty(patterns)) {\n\t\t\tString pattern = patterns.iterator().next();\n\t\t\tString destination = getDestination(message);\n\t\t\tAssert.state(destination != null, \"Missing destination header\");\n\t\t\tMap<String, String> vars = getPathMatcher().extractUriTemplateVariables(pattern, destination);\n\t\t\tif (!CollectionUtils.isEmpty(vars)) {\n\t\t\t\tMessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\t\t\tAssert.state(mha != null && mha.isMutable(), \"Mutable MessageHeaderAccessor required\");\n\t\t\t\tmha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);\n\t\t\t}\n\t\t}\n\t\treturn super.handleMatch(mapping, handlerMethod, message);\n\t}",
    "query": "Design a reactive service that routes incoming WebSocket messages to specific handler methods based on dynamic message conditions, ensuring efficient non-blocking processing.",
    "function_signature": "protected Mono<Void> routeMessage(CompositeMessageCondition condition, HandlerMethod method, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.reactive.MessageMappingMessageHandler#setEmbeddedValueResolver(resolver)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "public void setEmbeddedValueResolver(StringValueResolver resolver)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setEmbeddedValueResolver(StringValueResolver resolver) {\n\t\tthis.valueResolver = resolver;\n\t}",
    "query": "Optimize the message handling process by implementing a modern resolver strategy that improves type safety and performance.",
    "function_signature": "public void configureValueResolver(ValueResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.reactive.MessageMappingMessageHandler#getMappingForMethod(method,handlerType)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "protected CompositeMessageCondition getMappingForMethod(Method method, Class<?> handlerType)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected CompositeMessageCondition getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tCompositeMessageCondition methodCondition = getCondition(method);\n\t\tif (methodCondition != null) {\n\t\t\tCompositeMessageCondition typeCondition = getCondition(handlerType);\n\t\t\tif (typeCondition != null) {\n\t\t\t\treturn typeCondition.combine(methodCondition);\n\t\t\t}\n\t\t}\n\t\treturn methodCondition;\n\t}",
    "query": "Optimize the message handling mechanism to enhance performance and maintainability by updating the method responsible for retrieving message mappings based on the handler's type and method. Ensure that the new implementation leverages the latest best practices for condition combination.",
    "function_signature": "protected CompositeMessageCondition resolveMessageMapping(Method method, Class<?> handlerType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.reactive.MessageMappingMessageHandler#getConversionService()",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "public ConversionService getConversionService()",
    "documentation": "\t/**\n\t * Return the configured ConversionService.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}",
    "query": "Refactor the message handling mechanism to utilize the enhanced type conversion approach, ensuring improved performance and safer payload transformations in a reactive environment.",
    "function_signature": "public Mono<Void> handleMessageWithEnhancedConversion(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setDecoders(decoders)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "public void setDecoders(List<? extends Decoder<?>> decoders)",
    "documentation": "\t/**\n\t * Configure the decoders to use for incoming payloads.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setDecoders(List<? extends Decoder<?>> decoders) {\n\t\tthis.decoders.addAll(decoders);\n\t}",
    "query": "Implement a reactive WebSocket handler that efficiently processes diverse incoming message formats by integrating custom payload decoders.",
    "function_signature": "public void configureCustomDecoders(List<? extends Decoder<?>> decoders)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setHandlers(handlers)",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "public void setHandlers(List<Object> handlers)",
    "documentation": "\t/**\n\t * Manually configure handlers to check for {@code @MessageMapping} methods.\n\t * <p><strong>Note:</strong> the given handlers are not required to be\n\t * annotated with {@code @Controller}. Consider also using\n\t * {@link #setAutoDetectDisabled()} if the intent is to use these handlers\n\t * instead of, and not in addition to {@code @Controller} classes. Or\n\t * alternatively use {@link #setHandlerPredicate(Predicate)} to select a\n\t * different set of beans based on a different criteria.\n\t * @param handlers the handlers to register\n\t * @see #setAutoDetectDisabled()\n\t * @see #setHandlerPredicate(Predicate)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setHandlers(List<Object> handlers) {\n\t\tfor (Object handler : handlers) {\n\t\t\tdetectHandlerMethods(handler);\n\t\t}\n\t\t// Disable auto-detection..\n\t\tthis.handlerPredicate = null;\n\t}",
    "query": "Design a reactive messaging component that processes incoming messages using custom handler classes not annotated with `@Controller`. Ensure that only the specified handlers are used for message mapping, disabling any automatic detection of controller classes.",
    "function_signature": "public void configureCustomMessageHandlers(List<Object> customHandlers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#getConversionService()",
    "from_version": "v5.2.0.M1",
    "to_version": "v5.2.0.M2",
    "type": "method",
    "signature": "public ConversionService getConversionService()",
    "documentation": "\t/**\n\t * Return the configured ConversionService.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ConversionService getConversionService() {\n\t\treturn this.conversionService;\n\t}",
    "query": "Develop a reactive messaging component that automatically transforms incoming message payloads to specific domain objects based on configurable criteria, enhancing type safety and processing efficiency within your application.",
    "function_signature": "public ConversionService getConfiguredConversionService()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.BeanWrapperImpl#newNestedPropertyAccessor(object,nestedPath)",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "protected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {\n\t\treturn new BeanWrapperImpl(object, nestedPath, this);\n\t}",
    "query": "Implement a utility that efficiently manages nested property access within bean instances, ensuring enhanced performance and type safety. The current approach may lead to potential bottlenecks and increased complexity when handling deeply nested structures.",
    "function_signature": "public PropertyAccessor createNestedPropertyAccessor(Object bean, String propertyPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.<unknown>#singleRow()",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "public Object> singleRow()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic Map<String, Object> singleRow() {\n\t\t\t\treturn namedParamOps.queryForMap(sql, namedParamSource);\n\t\t\t}",
    "query": "Create a repository method that efficiently retrieves the configuration settings for a given application environment, ensuring that only one configuration set is returned to maintain consistency.",
    "function_signature": "public Map<String, Object> getConfigurationSettings(String environment)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.metadata.supportedDatabaseProductsForProcedures",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "field",
    "signature": "public List<String> supportedDatabaseProductsForProcedures",
    "documentation": "\t/** List of supported database products for procedure calls. */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final List<String> supportedDatabaseProductsForProcedures = List.of(",
    "query": "Implement a method to retrieve the list of databases that support stored procedure calls within your application's data access layer.",
    "function_signature": "public List<String> getSupportedProcedureDatabases()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setEnterMessage(enterMessage)",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "public void setEnterMessage(String enterMessage)",
    "documentation": "\t/**\n\t * Set the template used for method entry log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * </ul>\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setEnterMessage(String enterMessage) throws IllegalArgumentException {\n\t\tAssert.hasText(enterMessage, \"enterMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(enterMessage);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_EXCEPTION);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_INVOCATION_TIME);\n\t\tthis.enterMessage = enterMessage;\n\t}",
    "query": "Design a Spring service that logs detailed information each time a business method is invoked. Ensure that the log messages include the class name, method name, and the arguments passed to the method without manually formatting these details within each service method.",
    "function_signature": "public void configureMethodEntryLogging(String logTemplate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.DefaultListableBeanFactoryBenchmark#prototypeCreation(state)",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "public Object prototypeCreation(PrototypeCreationState state)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object prototypeCreation(PrototypeCreationState state) {\n\t\treturn state.beanFactory.getBean(\"test\");\n\t}",
    "query": "Implement a feature in your application that dynamically generates independent instances of a reporting service for each user request, ensuring that each instance operates with its own separate configuration without interfering with others.",
    "function_signature": "public ReportService createReportService(ReportServiceState state);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.comparator.NullSafeComparator#compare(o1,o2)",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "public int compare(@Nullable T o1, @Nullable T o2)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int compare(@Nullable T o1, @Nullable T o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (o1 == null) {\n\t\t\treturn (this.nullsLow ? -1 : 1);\n\t\t}\n\t\tif (o2 == null) {\n\t\t\treturn (this.nullsLow ? 1 : -1);\n\t\t}\n\t\treturn this.nonNullComparator.compare(o1, o2);\n\t}",
    "query": "Develop a method to efficiently compare two objects that might be null, ensuring consistent ordering and enhanced reliability.",
    "function_signature": "public int safeCompare(T first, T second)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.config.TaskSchedulerRouter#determineDefaultScheduler()",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "protected TaskScheduler determineDefaultScheduler()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected TaskScheduler determineDefaultScheduler() {\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to find default scheduler\");\n\t\ttry {\n\t\t\t// Search for TaskScheduler bean...\n\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false);\n\t\t}\n\t\tcatch (NoUniqueBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find unique TaskScheduler bean - attempting to resolve by name: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"More than one TaskScheduler bean exists within the context, and \" +\n\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\tex.getBeanNamesFound());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \" +\n\t\t\t\t\t\tex.getMessage());\n\t\t\t}\n\t\t\t// Search for ScheduledExecutorService bean next...\n\t\t\ttry {\n\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false));\n\t\t\t}\n\t\t\tcatch (NoUniqueBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn new ConcurrentTaskScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true));\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex3) {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"More than one ScheduledExecutorService bean exists within the context, and \" +\n\t\t\t\t\t\t\t\t\"none is named 'taskScheduler'. Mark one of them as primary or name it 'taskScheduler' \" +\n\t\t\t\t\t\t\t\t\"(possibly as an alias); or implement the SchedulingConfigurer interface and call \" +\n\t\t\t\t\t\t\t\t\"ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \" +\n\t\t\t\t\t\t\t\tex2.getBeanNamesFound());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex2) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Could not find default ScheduledExecutorService bean - falling back to default: \" +\n\t\t\t\t\t\t\tex2.getMessage());\n\t\t\t\t}\n\t\t\t\tlogger.info(\"No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\");\n\t\t\t}\n\t\t}\n\t\tScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n\t\tthis.localExecutor = localExecutor;\n\t\treturn new ConcurrentTaskScheduler(localExecutor);\n\t}",
    "query": "Design a Spring service that manages scheduled tasks for processing incoming user data. Ensure that the service intelligently selects the most suitable scheduler from the application context, handling scenarios where multiple schedulers are present without requiring explicit scheduler configuration.",
    "function_signature": "protected TaskScheduler selectOptimalScheduler()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.DefaultTransactionDefinition#setTimeout(timeout)",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "public void setTimeout(int timeout)",
    "documentation": "\t/**\n\t * Set the timeout to apply, as number of seconds.\n\t * Default is TIMEOUT_DEFAULT (-1).\n\t * <p>Exclusively designed for use with {@link #PROPAGATION_REQUIRED} or\n\t * {@link #PROPAGATION_REQUIRES_NEW} since it only applies to newly started\n\t * transactions.\n\t * <p>Note that a transaction manager that does not support timeouts will throw\n\t * an exception when given any other timeout than {@link #TIMEOUT_DEFAULT}.\n\t * @see #TIMEOUT_DEFAULT\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final void setTimeout(int timeout) {\n\t\tif (timeout < TIMEOUT_DEFAULT) {\n\t\t\tthrow new IllegalArgumentException(\"Timeout must be a non-negative integer or TIMEOUT_DEFAULT\");\n\t\t}\n\t\tthis.timeout = timeout;\n\t}",
    "query": "Create a service method that processes financial transactions, ensuring each transaction completes within a defined period to maintain system responsiveness and reliability.",
    "function_signature": "public void processFinancialTransaction(TransactionData data, int timeoutSeconds)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.server.RequestPredicates#value()",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "method",
    "signature": "public boolean value()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}",
    "query": "Create a routing configuration that directs HTTP requests to a handler only when a particular request attribute equals a specified value, utilizing the newest enhancements in Spring's request predicate functionality.",
    "function_signature": "public RouterFunction<ServerResponse> routeUsingValuePredicate()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.PREFERRED_CONSTRUCTORS_ATTRIBUTE",
    "from_version": "v6.0.20",
    "to_version": "v6.1.7",
    "type": "field",
    "signature": "public String PREFERRED_CONSTRUCTORS_ATTRIBUTE",
    "documentation": "\t/**\n\t * The name of an attribute that can be\n\t * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a\n\t * {@link org.springframework.beans.factory.config.BeanDefinition} so that\n\t * bean definitions can indicate one or more preferred constructors. This is\n\t * analogous to {@code @Autowired} annotated constructors on the bean class.\n\t * <p>The attribute value may be a single {@link java.lang.reflect.Constructor}\n\t * reference or an array thereof.\n\t * @since 6.1\n\t * @see org.springframework.beans.factory.annotation.Autowired\n\t * @see org.springframework.beans.factory.support.RootBeanDefinition#getPreferredConstructors()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String PREFERRED_CONSTRUCTORS_ATTRIBUTE = \"preferredConstructors\";",
    "query": "Design a bean configuration method that allows specifying preferred constructors for a bean, ensuring that Spring selects the appropriate constructor during instantiation without using explicit annotations.",
    "function_signature": "public void configurePreferredConstructors(BeanDefinitionRegistry registry, String beanName, Constructor<?>... constructors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Design a configuration method for setting up a message broker that efficiently handles subscriber management and destination resolution, ensuring optimal performance and scalability.",
    "function_signature": "public void configureOptimizedMessageBroker(MessageBrokerConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Create a method to efficiently handle subscription registrations for user sessions, ensuring scalability and thread safety when managing destination patterns.",
    "function_signature": "public void handleSessionSubscriptions(String sessionId, String destinationPattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Optimize the initialization process for managing server subscriptions to enhance performance and ensure thread-safe operations under high concurrency scenarios.",
    "function_signature": "public void initializeSubscriptions(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a method to initialize and manage subscription registries that ensures high performance and thread safety. Leverage the latest best practices and recommended components to handle subscription caching and selector configurations efficiently.",
    "function_signature": "public void initializeSubscriptionManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Enhance your messaging system by implementing a method that accurately resolves the appropriate destination for each incoming message, ensuring improved performance and reliability.",
    "function_signature": "public String resolveMessageDestination(String messageContent)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Create a method to determine if an incoming `HttpServletRequest` should be processed by an interceptor, ensuring optimal performance and leveraging the latest path pattern utilities for enhanced routing capabilities.",
    "function_signature": "public boolean shouldProcessRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Create a component that assigns unique identifiers to incoming messages, optimizing for thread safety and scalability in a high-concurrency environment.",
    "function_signature": "public String generateUniqueMessageId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Optimize the management of active message destinations within a broker to enhance thread safety and resource efficiency in a Spring application.",
    "function_signature": "public void configureActiveDestinations()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a component that efficiently determines whether an incoming HTTP request should be intercepted based on its characteristics. Ensure that your solution integrates smoothly with the existing request handling process and optimizes pattern matching for better performance and maintainability.",
    "function_signature": "public boolean matches(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.3.0",
    "to_version": "v5.2.11.RELEASE",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a component that efficiently handles post-request processing, ensuring optimal performance and thread safety without relying on outdated callback mechanisms.",
    "function_signature": "public void handlePostRequest(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Throwable exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(contexts,result)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, result)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}",
    "query": "Design a caching mechanism that efficiently manages the removal of cache entries after successful operations, ensuring compatibility with reactive programming paradigms and enhancing overall performance.",
    "function_signature": "public Object executeCacheRemoval(List<CacheOperationContext> contexts, @Nullable Object result)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(array,delimiter)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter)",
    "documentation": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the delimiter\n\t * providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the {@code Properties}.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n\t\treturn splitArrayElementsIntoProperties(array, delimiter, null);\n\t}",
    "query": "Create a method that efficiently converts an array of delimited strings into a `Properties` object, ensuring robust error handling and optimized performance for large datasets.",
    "function_signature": "public Properties parseStringArrayToProperties(String[] elements, String delimiter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.codec.Decoder",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "interface",
    "signature": "public interface Decoder",
    "documentation": "/**\n * Strategy for decoding a {@link DataBuffer} input stream into an output stream\n * of elements of type {@code <T>}.\n *\n * @author Sebastien Deleuze\n * @author Rossen Stoyanchev\n * @since 5.0\n * @param <T> the type of elements in the output stream\n */",
    "changetype": "deprecated",
    "source_code": "public interface Decoder<T> {\n\n\t/**\n\t * Whether the decoder supports the given target element type and the MIME\n\t * type of the source stream.\n\t * @param elementType the target element type for the output stream\n\t * @param mimeType the mime type associated with the stream to decode\n\t * (can be {@code null} if not specified)\n\t * @return {@code true} if supported, {@code false} otherwise\n\t */\n\tboolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType);\n\n\t/**\n\t * Decode a {@link DataBuffer} input stream into a Flux of {@code T}.\n\t * @param inputStream the {@code DataBuffer} input stream to decode\n\t * @param elementType the expected type of elements in the output stream;\n\t * this type must have been previously passed to the {@link #canDecode}\n\t * method and it must have returned {@code true}.\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do decode\n\t * @return the output stream with decoded elements\n\t */\n\tFlux<T> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);\n\n\t/**\n\t * Decode a {@link DataBuffer} input stream into a Mono of {@code T}.\n\t * @param inputStream the {@code DataBuffer} input stream to decode\n\t * @param elementType the expected type of elements in the output stream;\n\t * this type must have been previously passed to the {@link #canDecode}\n\t * method and it must have returned {@code true}.\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do decode\n\t * @return the output stream with the decoded element\n\t */\n\tMono<T> decodeToMono(Publisher<DataBuffer> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);\n\n\t/**\n\t * Decode a data buffer to an Object of type T. This is useful for scenarios,\n\t * that distinct messages (or events) are decoded and handled individually,\n\t * in fully aggregated form.\n\t * @param buffer the {@code DataBuffer} to decode\n\t * @param targetType the expected output type\n\t * @param mimeType the MIME type associated with the data\n\t * @param hints additional information about how to do decode\n\t * @return the decoded value, possibly {@code null}\n\t * @since 5.2\n\t */\n\t@Nullable\n\tdefault T decode(DataBuffer buffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {\n\n\t\tCompletableFuture<T> future = decodeToMono(Mono.just(buffer), targetType, mimeType, hints).toFuture();\n\t\tAssert.state(future.isDone(), \"DataBuffer decoding should have completed.\");\n\n\t\tThrowable failure;\n\t\ttry {\n\t\t\treturn future.get();\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tfailure = ex.getCause();\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tthrow (failure instanceof CodecException codecException ? codecException :\n\t\t\t\tnew DecodingException(\"Failed to decode: \" + failure.getMessage(), failure));\n\t}\n\n\t/**\n\t * Return the list of MIME types supported by this Decoder. The list may not\n\t * apply to every possible target element type and calls to this method\n\t * should typically be guarded via {@link #canDecode(ResolvableType, MimeType)\n\t * canDecode(elementType, null)}. The list may also exclude MIME types\n\t * supported only for a specific element type. Alternatively, use\n\t * {@link #getDecodableMimeTypes(ResolvableType)} for a more precise list.\n\t * @return the list of supported MIME types\n\t */\n\tList<MimeType> getDecodableMimeTypes();\n\n\t/**\n\t * Return the list of MIME types supported by this Decoder for the given type\n\t * of element. This list may differ from {@link #getDecodableMimeTypes()}\n\t * if the Decoder doesn't support the given element type or if it supports\n\t * it only for a subset of MIME types.\n\t * @param targetType the type of element to check for decoding\n\t * @return the list of MIME types supported for the given target type\n\t * @since 5.3.4\n\t */\n\tdefault List<MimeType> getDecodableMimeTypes(ResolvableType targetType) {\n\t\treturn (canDecode(targetType, null) ? getDecodableMimeTypes() : Collections.emptyList());\n\t}\n\n}",
    "query": "Design a service that efficiently converts incoming data streams into reactive sequences of domain-specific objects, prioritizing type safety and optimal performance. Ensure the chosen approach leverages the latest decoding mechanisms to enhance scalability and maintainability.",
    "function_signature": "public Mono<YourDomainObject> transformDataStream(Publisher<DataBuffer> dataStream, ResolvableType targetType, @Nullable MimeType mimeType, @Nullable Map<String, Object> decodingHints);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.DefaultDataBinderFactory#initBinder(binder,parameter)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Develop a method to initialize data binding that optimizes validator usage and enhances annotation processing efficiency.",
    "function_signature": "public void configureDataBinder(DataBinder binder, BindingMethodParameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.filter.OncePerRequestFilter#shouldNotFilter(request)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "protected boolean shouldNotFilter(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Can be overridden in subclasses for custom filtering control,\n\t * returning {@code true} to avoid filtering of the given request.\n\t * <p>The default implementation always returns {@code false}.\n\t * @param request current HTTP request\n\t * @return whether the given request should <i>not</i> be filtered\n\t * @throws ServletException in case of errors\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {\n\t\treturn false;\n\t}",
    "query": "Create a custom filter that efficiently determines whether to process incoming HTTP requests based on specific criteria, enhancing both security and performance of your application.",
    "function_signature": "protected boolean shouldFilterRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.config.SimpleBeanFactoryAwareAspectInstanceFactory#setBeanFactory(beanFactory)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tAssert.notNull(this.aspectBeanName, \"'aspectBeanName' is required\");\n\t}",
    "query": "Enhance your aspect instance factory to efficiently manage bean dependencies without manual factory assignments, ensuring better performance and safer bean handling.",
    "function_signature": "public AspectInstanceFactory(BeanFactory beanFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.StaticListableBeanFactory#getObject(args)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public T getObject(Object... args)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tString[] beanNames = getBeanNamesForType(requiredType);\n\t\t\t\tif (beanNames.length == 1) {\n\t\t\t\t\treturn (T) getBean(beanNames[0], args);\n\t\t\t\t}\n\t\t\t\telse if (beanNames.length > 1) {\n\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, beanNames);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t}",
    "query": "Develop a method to obtain a single bean instance by its required type from the application context. Ensure that the implementation efficiently handles scenarios where multiple beans of the same type exist, providing clear feedback to avoid ambiguity and enhance type safety.",
    "function_signature": "public <T> T retrieveBeanByType(Class<T> requiredType) throws BeansException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.converter.CompositeMessageConverter#fromMessage(message,targetClass,conversionHint)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tfor (MessageConverter converter : getConverters()) {\n\t\t\tObject result = (converter instanceof SmartMessageConverter smartMessageConverter ?\n\t\t\t\t\tsmartMessageConverter.fromMessage(message, targetClass, conversionHint) :\n\t\t\t\t\tconverter.fromMessage(message, targetClass));\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}",
    "query": "Develop a method to efficiently transform incoming messages into their corresponding target objects, ensuring enhanced type safety and streamlined processing.",
    "function_signature": "public Object transformMessage(Message<?> message, Class<?> targetClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.json.AbstractJackson2Encoder#getJsonEncoding(mimeType)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "protected JsonEncoding getJsonEncoding(@Nullable MimeType mimeType)",
    "documentation": "\t/**\n\t * Determine the JSON encoding to use for the given mime type.\n\t * @param mimeType the mime type as requested by the caller\n\t * @return the JSON encoding to use (never {@code null})\n\t * @since 5.0.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected JsonEncoding getJsonEncoding(@Nullable MimeType mimeType) {\n\t\tif (mimeType != null && mimeType.getCharset() != null) {\n\t\t\tCharset charset = mimeType.getCharset();\n\t\t\tJsonEncoding result = ENCODINGS.get(charset.name());\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn JsonEncoding.UTF8;\n\t}",
    "query": "Optimize the JSON encoding determination process by implementing a method that efficiently selects the appropriate encoding based on the provided MIME type. Ensure the solution enhances performance and maintains robustness without relying on legacy encoding checks.",
    "function_signature": "public JsonEncoding resolveJsonEncoding(MimeType mimeType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#setHandlerExceptionResolvers(exceptionResolvers)",
    "from_version": "v6.1.5",
    "to_version": "v5.3.34",
    "type": "method",
    "signature": "public StandaloneMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers)",
    "documentation": "\t/**\n\t * Set the HandlerExceptionResolver types to use as an array.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic StandaloneMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);\n\t\treturn this;\n\t}",
    "query": "Configure MockMvc to utilize a streamlined approach for handling exceptions, enhancing test performance and reliability.",
    "function_signature": "public StandaloneMockMvcBuilder useExceptionResolver(HandlerExceptionResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a thread-safe component for generating unique message identifiers within the messaging broker, optimizing for high concurrency and minimal latency.",
    "function_signature": "public UniqueIdGenerator createMessageIdGenerator();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Design a method that efficiently handles the lifecycle of client subscriptions, ensuring optimal performance and thread safety without relying on outdated registration mechanisms.",
    "function_signature": "public void manageClientSubscriptions(ClientState clientState, SubscriptionRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Develop a request handling strategy that efficiently determines interceptor applicability, enhancing performance and simplifying pattern management for incoming HTTP requests.",
    "function_signature": "public boolean isInterceptorApplicable(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Design a method to handle subscription registrations in a messaging application, ensuring enhanced performance and thread safety by leveraging the latest subscription management approach.",
    "function_signature": "public void configureSubscriptionManager(SubscriptionManager subscriptionManager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by subclasses of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Design a mechanism to efficiently apply custom logic to specific HTTP requests by matching predefined URL patterns, ensuring optimal performance and maintainability in your web application.",
    "function_signature": "public CustomRequestHandler(String[] includePatterns, HandlerInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Enhance the efficiency of managing client subscriptions in your Spring application by implementing a robust subscription handler. Ensure that the solution scales seamlessly with increasing client connections and maintains high performance under load.",
    "function_signature": "public void handleClientSubscriptions(SubscriptionHandler handler, SubscriptionRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Ensure that your interceptor management leverages the latest configuration practices for improved scalability.",
    "function_signature": "public void configureInterceptors(InterceptorRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean -&gt;\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Enhance your reactive Spring Messaging application by implementing a robust global exception handling mechanism that ensures type safety and improves maintainability without relying on outdated configuration methods.",
    "function_signature": "public void configureGlobalExceptionHandling(ControllerAdviceAdapter adapter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Optimize the messaging broker configuration to enhance scalability and ensure thread-safe destination handling without relying on outdated setup mechanisms.",
    "function_signature": "public void configureAdvancedDestinationResolver(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.26",
    "to_version": "v5.2.23.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Optimize the retrieval and management of messaging destinations to enhance scalability and ensure type safety within your Spring-based application.",
    "function_signature": "public Collection<String> fetchActiveDestinationIds();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver#getReturnTypeForFactoryMethod(rbd,descriptor)",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "protected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor) {\n\t\t// Should typically be set for any kind of factory method, since the BeanFactory\n\t\t// pre-resolves them before reaching out to the AutowireCandidateResolver...\n\t\tResolvableType returnType = rbd.factoryMethodReturnType;\n\t\tif (returnType == null) {\n\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\treturnType = ResolvableType.forMethodReturnType(factoryMethod);\n\t\t\t}\n\t\t}\n\t\tif (returnType != null) {\n\t\t\tClass<?> resolvedClass = returnType.resolve();\n\t\t\tif (resolvedClass != null && descriptor.getDependencyType().isAssignableFrom(resolvedClass)) {\n\t\t\t\t// Only use factory method metadata if the return type is actually expressive enough\n\t\t\t\t// for our dependency. Otherwise, the returned instance type may have matched instead\n\t\t\t\t// in case of a singleton instance having been registered with the container already.\n\t\t\t\treturn returnType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}",
    "query": "In a Spring application where bean factory methods return parameterized types, implement a strategy to accurately resolve the specific generic types to ensure proper autowiring and dependency injection.",
    "function_signature": "protected ResolvableType resolveFactoryMethodGenericReturnType(RootBeanDefinition beanDef, DependencyDescriptor descriptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockPageContext#getPage()",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "public Object getPage()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object getPage() {\n\t\treturn this;\n\t}",
    "query": "Design a unit test for a Spring MVC application that simulates a JSP environment, enabling access to and verification of the current page object without deploying to a real servlet container.",
    "function_signature": "public Object initializeMockJspPageContextForTest()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#getServletConfig()",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "public ServletConfig getServletConfig()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic ServletConfig getServletConfig() {\n\t\treturn this.servletConfig;\n\t}",
    "query": "Create a Spring-managed bean that accesses servlet initialization parameters to customize the application's request processing behavior.",
    "function_signature": "public ServletConfig fetchServletConfiguration();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.EntityManagerFactoryUtils#releaseResource(resourceHolder,resourceKey)",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "protected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tprotected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey) {\n\t\t\tcloseEntityManager(resourceHolder.getEntityManager());\n\t\t}",
    "query": "Design a component that ensures EntityManager instances are correctly released and cleaned up once a transactional operation concludes, preventing potential resource leaks in a JPA-based application.",
    "function_signature": "protected void cleanUpEntityManagerResources(EntityManagerHolder resourceHolder, EntityManagerFactory factory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ACCESS_CONTROL_MAX_AGE",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "field",
    "signature": "public String ACCESS_CONTROL_MAX_AGE",
    "documentation": "\t/**\n\t * The CORS {@code Access-Control-Max-Age} response header field name.\n\t * @see <a href=\"https://www.w3.org/TR/cors/\">CORS W3C recommendation</a>\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String ACCESS_CONTROL_MAX_AGE = \"Access-Control-Max-Age\";",
    "query": "Define a CORS policy in your Spring Boot application that determines how long the results of a preflight request can be cached by clients, improving efficiency for repeated cross-origin requests.",
    "function_signature": "public void setCorsPreflightMaxAge(CorsConfiguration config)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.handler.AbstractWebSocketHandler#handlePongMessage(session,message)",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "protected void handlePongMessage(WebSocketSession session, PongMessage message)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception {\n\t}",
    "query": "Design a WebSocket handler method that processes incoming pong messages to verify active client connections and maintain optimal communication.",
    "function_signature": "protected void handlePongMessage(WebSocketSession session, PongMessage message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.ChannelSendOperator#onNext(aVoid)",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "public void onNext(Void aVoid)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void onNext(Void aVoid) {\n\t\t}",
    "query": "Design a reactive endpoint that triggers a server-side event without transmitting any payload to the client, ensuring efficient resource utilization and seamless integration with the reactive stream processing.",
    "function_signature": "public void onEvent(Void aVoid)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#setHandlerExceptionResolvers(exceptionResolvers)",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "public StandaloneMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers)",
    "documentation": "\t/**\n\t * Set the HandlerExceptionResolver types to use as an array.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic StandaloneMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {\n\t\tthis.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);\n\t\treturn this;\n\t}",
    "query": "Design a testing setup for your Spring MVC application that allows you to inject multiple custom strategies for handling exceptions during mock HTTP requests.",
    "function_signature": "public StandaloneMockMvcBuilder applyCustomExceptionResolvers(HandlerExceptionResolver... resolvers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler#isHandler(beanType)",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "method",
    "signature": "protected boolean isHandler(Class<?> beanType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected boolean isHandler(Class<?> beanType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);\n\t}",
    "query": "Create a custom message handler that filters and processes only beans annotated with controller stereotypes to manage real-time WebSocket communications efficiently.",
    "function_signature": "@Override\nprotected boolean isHandler(Class<?> beanType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.HandlerExecutionChain",
    "from_version": "v5.3.31",
    "to_version": "v6.0.14",
    "type": "class",
    "signature": "public class HandlerExecutionChain",
    "documentation": "/**\n * Handler execution chain, consisting of handler object and any handler interceptors.\n * Returned by HandlerMapping's {@link HandlerMapping#getHandler} method.\n *\n * @author Juergen Hoeller\n * @since 20.06.2003\n * @see HandlerInterceptor\n */",
    "changetype": "stabilized",
    "source_code": "public class HandlerExecutionChain {\n\n\tprivate static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);\n\n\tprivate final Object handler;\n\n\tprivate final List<HandlerInterceptor> interceptorList = new ArrayList<>();\n\n\tprivate int interceptorIndex = -1;\n\n\n\t/**\n\t * Create a new HandlerExecutionChain.\n\t * @param handler the handler object to execute\n\t */\n\tpublic HandlerExecutionChain(Object handler) {\n\t\tthis(handler, (HandlerInterceptor[]) null);\n\t}\n\n\t/**\n\t * Create a new HandlerExecutionChain.\n\t * @param handler the handler object to execute\n\t * @param interceptors the array of interceptors to apply\n\t * (in the given order) before the handler itself executes\n\t */\n\tpublic HandlerExecutionChain(Object handler, @Nullable HandlerInterceptor... interceptors) {\n\t\tthis(handler, (interceptors != null ? Arrays.asList(interceptors) : Collections.emptyList()));\n\t}\n\n\t/**\n\t * Create a new HandlerExecutionChain.\n\t * @param handler the handler object to execute\n\t * @param interceptorList the list of interceptors to apply\n\t * (in the given order) before the handler itself executes\n\t * @since 5.3\n\t */\n\tpublic HandlerExecutionChain(Object handler, List<HandlerInterceptor> interceptorList) {\n\t\tif (handler instanceof HandlerExecutionChain originalChain) {\n\t\t\tthis.handler = originalChain.getHandler();\n\t\t\tthis.interceptorList.addAll(originalChain.interceptorList);\n\t\t}\n\t\telse {\n\t\t\tthis.handler = handler;\n\t\t}\n\t\tthis.interceptorList.addAll(interceptorList);\n\t}\n\n\n\t/**\n\t * Return the handler object to execute.\n\t */\n\tpublic Object getHandler() {\n\t\treturn this.handler;\n\t}\n\n\t/**\n\t * Add the given interceptor to the end of this chain.\n\t */\n\tpublic void addInterceptor(HandlerInterceptor interceptor) {\n\t\tthis.interceptorList.add(interceptor);\n\t}\n\n\t/**\n\t * Add the given interceptor at the specified index of this chain.\n\t * @since 5.2\n\t */\n\tpublic void addInterceptor(int index, HandlerInterceptor interceptor) {\n\t\tthis.interceptorList.add(index, interceptor);\n\t}\n\n\t/**\n\t * Add the given interceptors to the end of this chain.\n\t */\n\tpublic void addInterceptors(HandlerInterceptor... interceptors) {\n\t\tCollectionUtils.mergeArrayIntoCollection(interceptors, this.interceptorList);\n\t}\n\n\t/**\n\t * Return the array of interceptors to apply (in the given order).\n\t * @return the array of HandlerInterceptors instances (may be {@code null})\n\t */\n\t@Nullable\n\tpublic HandlerInterceptor[] getInterceptors() {\n\t\treturn (!this.interceptorList.isEmpty() ? this.interceptorList.toArray(new HandlerInterceptor[0]) : null);\n\t}\n\n\t/**\n\t * Return the list of interceptors to apply (in the given order).\n\t * @return the list of HandlerInterceptors instances (potentially empty)\n\t * @since 5.3\n\t */\n\tpublic List<HandlerInterceptor> getInterceptorList() {\n\t\treturn (!this.interceptorList.isEmpty() ? Collections.unmodifiableList(this.interceptorList) :\n\t\t\t\tCollections.emptyList());\n\t}\n\n\n\t/**\n\t * Apply preHandle methods of registered interceptors.\n\t * @return {@code true} if the execution chain should proceed with the\n\t * next interceptor or the handler itself. Else, DispatcherServlet assumes\n\t * that this interceptor has already dealt with the response itself.\n\t */\n\tboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tfor (int i = 0; i < this.interceptorList.size(); i++) {\n\t\t\tHandlerInterceptor interceptor = this.interceptorList.get(i);\n\t\t\tif (!interceptor.preHandle(request, response, this.handler)) {\n\t\t\t\ttriggerAfterCompletion(request, response, null);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.interceptorIndex = i;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Apply postHandle methods of registered interceptors.\n\t */\n\tvoid applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)\n\t\t\tthrows Exception {\n\n\t\tfor (int i = this.interceptorList.size() - 1; i >= 0; i--) {\n\t\t\tHandlerInterceptor interceptor = this.interceptorList.get(i);\n\t\t\tinterceptor.postHandle(request, response, this.handler, mv);\n\t\t}\n\t}\n\n\t/**\n\t * Trigger afterCompletion callbacks on the mapped HandlerInterceptors.\n\t * Will just invoke afterCompletion for all interceptors whose preHandle invocation\n\t * has successfully completed and returned true.\n\t */\n\tvoid triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) {\n\t\tfor (int i = this.interceptorIndex; i >= 0; i--) {\n\t\t\tHandlerInterceptor interceptor = this.interceptorList.get(i);\n\t\t\ttry {\n\t\t\t\tinterceptor.afterCompletion(request, response, this.handler, ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex2) {\n\t\t\t\tlogger.error(\"HandlerInterceptor.afterCompletion threw exception\", ex2);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Apply afterConcurrentHandlerStarted callback on mapped AsyncHandlerInterceptors.\n\t */\n\tvoid applyAfterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response) {\n\t\tfor (int i = this.interceptorList.size() - 1; i >= 0; i--) {\n\t\t\tHandlerInterceptor interceptor = this.interceptorList.get(i);\n\t\t\tif (interceptor instanceof AsyncHandlerInterceptor asyncInterceptor) {\n\t\t\t\ttry {\n\t\t\t\t\tasyncInterceptor.afterConcurrentHandlingStarted(request, response, this.handler);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Interceptor [\" + interceptor + \"] failed in afterConcurrentHandlingStarted\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Delegates to the handler's {@code toString()} implementation.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn \"HandlerExecutionChain with [\" + getHandler() + \"] and \" + this.interceptorList.size() + \" interceptors\";\n\t}\n\n}",
    "query": "Develop a component that assembles a primary request handler alongside a customizable sequence of processing steps. This setup should allow each processing step to execute actions before and after the main handler processes the request, facilitating tasks such as logging, authentication, or request modification in a flexible manner.",
    "function_signature": "public HandlerExecutionChain createHandlerChain(Object handler, List<HandlerInterceptor> interceptors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.UriUtils#encodeUriVariables(Map<String,uriVariables)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "public String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables)",
    "documentation": "\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static Map<String, String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tMap<String, String> result = CollectionUtils.newLinkedHashMap(uriVariables.size());\n\t\turiVariables.forEach((key, value) -> {\n\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\tresult.put(key, encode(stringValue, StandardCharsets.UTF_8));\n\t\t});\n\t\treturn result;\n\t}",
    "query": "Implement a utility that sanitizes a map of URI parameters by encoding each value to ensure safe inclusion in HTTP requests.",
    "function_signature": "public Map<String, String> sanitizeUriParameters(Map<String, ? extends Object> uriParams)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.util.XpathExpectationsHelper#doesNotExist(content,encoding)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "public void doesNotExist(byte[] content, @Nullable String encoding)",
    "documentation": "\t/**\n\t * Apply the XPath expression and assert the resulting content does not exist.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void doesNotExist(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNull(\"XPath \" + this.expression + \" exists\", node);\n\t}",
    "query": "Design a test case to confirm that a particular XML tag is missing from the response returned by your REST API endpoint. Implement a method that takes the response content and its encoding to perform this verification.",
    "function_signature": "public void assertXmlElementMissing(byte[] responseContent, @Nullable String charset)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.AbstractJdbcInsert#doExecuteBatch(batch)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "protected int[] doExecuteBatch(SqlParameterSource... batch)",
    "documentation": "\t/**\n\t * Delegate method that executes a batch insert using the passed-in\n\t * {@link SqlParameterSource SqlParameterSources}.\n\t * @param batch parameter sources with names and values to be used in the batch insert\n\t * @return an array of number of rows affected\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected int[] doExecuteBatch(SqlParameterSource... batch) {\n\t\tcheckCompiled();\n\t\tList<List<Object>> batchValues = new ArrayList<>(batch.length);\n\t\tfor (SqlParameterSource parameterSource : batch) {\n\t\t\tbatchValues.add(matchInParameterValuesWithInsertColumns(parameterSource));\n\t\t}\n\t\treturn executeBatchInternal(batchValues);\n\t}",
    "query": "Imagine you're developing a feature that needs to efficiently add a large number of product entries to your inventory system. How can you design a method that handles multiple product records in a single operation, ensuring each product's details are correctly mapped and inserted into the database?",
    "function_signature": "public int[] insertProductBatch(SqlParameterSource... productDetails)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getLastModifiedInternal(request,handlerMethod)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "documentation": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}",
    "query": "Develop a controller method that efficiently handles client-side caching by accurately determining resource modification times and responding appropriately to cache validation requests.",
    "function_signature": "protected ResponseEntity<?> processResourceUpdate(HttpServletRequest request, WebRequest webRequest)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter#determineDatabaseDialectName(database)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "protected String determineDatabaseDialectName(Database database)",
    "documentation": "\t/**\n\t * Determine the Hibernate database dialect class name for the given target database.\n\t * <p>The default implementation covers the common community dialect for Derby.\n\t * @param database the target database\n\t * @return the Hibernate database dialect class name, or {@code null} if none found\n\t * @since 7.0\n\t * @see #determineDatabaseDialectClass\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected @Nullable String determineDatabaseDialectName(Database database) {\n\t\treturn switch (database) {\n\t\t\tcase DERBY -> \"org.hibernate.community.dialect.DerbyDialect\";\n\t\t\tdefault -> null;\n\t\t};\n\t}",
    "query": "Design a component that dynamically selects the appropriate Hibernate dialect based on the target database to optimize ORM performance and compatibility.",
    "function_signature": "protected String selectOptimalHibernateDialect(Database targetDatabase)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jmx.access.NotificationListenerRegistrar#setServer(server)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "public void setServer(MBeanServerConnection server)",
    "documentation": "\t/**\n\t * Set the {@code MBeanServerConnection} used to connect to the\n\t * MBean which all invocations are routed to.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setServer(MBeanServerConnection server) {\n\t\tthis.server = server;\n\t}",
    "query": "Create a method that establishes a connection to an MBean server, enabling your Spring application to effectively handle JMX notifications.",
    "function_signature": "public void configureMBeanServer(MBeanServerConnection server)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.codec.Netty5BufferEncoder#canEncode(type,mimeType)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "public boolean canEncode(ResolvableType type, @Nullable MimeType mimeType)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tClass<?> clazz = type.toClass();\n\t\treturn super.canEncode(type, mimeType) && Buffer.class.isAssignableFrom(clazz);\n\t}",
    "query": "Enhance the buffer encoding mechanism to improve performance and ensure compatibility with various MIME types by determining if a specific type can be efficiently encoded using the latest encoding strategies.",
    "function_signature": "public boolean isEncodableType(ResolvableType type, @Nullable MimeType mimeType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.support.lob.<unknown>#setBinaryStream(pos)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "public OutputStream setBinaryStream(long pos)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic OutputStream setBinaryStream(long pos) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}",
    "query": "Develop a service method that enables efficient streaming of extensive binary files directly into a database's BLOB field, ensuring minimal memory usage and optimal performance for large data transfers.",
    "function_signature": "public OutputStream streamLargeBinaryData(long recordId) throws SQLException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.view.script.ScriptTemplateView#renderInternal(Map<String,model,contentType,exchange)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected Mono<Void> renderInternal(",
    "query": "Develop a reactive view renderer for a Spring WebFlux application that dynamically processes templates based on the client's media type, ensuring seamless integration with the server exchange context.",
    "function_signature": "protected Mono<Void> renderTemplate(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.tags.EvalTag#setVar(var)",
    "from_version": "v6.2.3",
    "to_version": "v7.0.0-M2",
    "type": "method",
    "signature": "public void setVar(String var)",
    "documentation": "\t/**\n\t * Set the variable name to expose the evaluation result under.\n\t * Defaults to rendering the result to the current JspWriter.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setVar(String var) {\n\t\tthis.var = var;\n\t}",
    "query": "Design a JSP component that processes dynamic expressions provided by users and retains the evaluation results in a scoped variable for subsequent access within the page.",
    "function_signature": "public void processDynamicExpression(String expression, String scopedVarName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanDefinition#setFallback(fallback)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public void setFallback(boolean fallback)",
    "documentation": "\t/**\n\t * {@inheritDoc}\n\t * <p>The default is {@code false}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setFallback(boolean fallback) {\n\t\tthis.fallback = fallback;\n\t}",
    "query": "Implement a configuration method that designates specific bean definitions to be utilized only when primary beans are unavailable, ensuring a seamless fallback mechanism within the application context.",
    "function_signature": "public void configureBeanFallbackSupport(boolean fallbackEnabled);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.DynamicPropertyRegistrarBeanInitializer#initialize(beanFactory)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public void initialize(ListableBeanFactory beanFactory)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void initialize(ListableBeanFactory beanFactory) {\n\t\tif (this.environment == null) {\n\t\t\tthrow new IllegalStateException(\"Environment is required\");\n\t\t}\n\t\tString[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tbeanFactory, DynamicPropertyRegistrar.class);\n\t\tif (beanNames.length > 0) {\n\t\t\tDynamicValuesPropertySource propertySource = DynamicValuesPropertySource.getOrCreate(this.environment);\n\t\t\tDynamicPropertyRegistry registry = propertySource.dynamicPropertyRegistry;\n\t\t\tfor (String name : beanNames) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Eagerly initializing DynamicPropertyRegistrar bean '%s'\".formatted(name));\n\t\t\t\t}\n\t\t\t\tDynamicPropertyRegistrar registrar = beanFactory.getBean(name, DynamicPropertyRegistrar.class);\n\t\t\t\tregistrar.accept(registry);\n\t\t\t}\n\t\t}\n\t}",
    "query": "How can you set up a testing environment that automatically registers and applies custom property sources defined by specialized beans before the application context initializes?",
    "function_signature": "public void applyCustomPropertySources(ListableBeanFactory beanFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange#addUrlTransformer(Function<String,transformer)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public void addUrlTransformer(Function<String, String> transformer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}",
    "query": "Implement a solution that consistently rewrites request URLs to lowercase before processing them in your Spring WebFlux application.",
    "function_signature": "public void applyLowercaseUrlTransformer()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#protocol()",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public String protocol()",
    "documentation": "\t\t/**\n\t\t * The protocol getter steps are to return thiss URLs scheme, followed by U+003A (:).\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic String protocol() {\n\t\t\treturn scheme() + \":\";\n\t\t}",
    "query": "Design a Spring service that dynamically generates absolute URLs for resources by accurately reflecting the client's request protocol, ensuring compatibility with both HTTP and HTTPS environments.",
    "function_signature": "public String generateAbsoluteUrl(HttpServletRequest request, String resourcePath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#setContentLength(len)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public void setContentLength(int len)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void setContentLength(int len) {\n\t\t\t// ignore\n\t\t}",
    "query": "Create a REST controller method that streams real-time notifications to clients, ensuring each emitted chunk has its content length explicitly set to optimize transmission efficiency.",
    "function_signature": "public void streamNotificationsWithContentLength(HttpServletResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.http.HttpMessageContentConverter#convertViaJson(value,targetType)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public T convertViaJson(Object value, ResolvableType targetType)",
    "documentation": "\t/**\n\t * Convert the given raw value to the given {@code targetType} by writing\n\t * it first to JSON and reading it back.\n\t * @param value the value to convert\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic <T> T convertViaJson(Object value, ResolvableType targetType) throws IOException {\n\t\tMockHttpOutputMessage outputMessage = convertToJson(value, ResolvableType.forInstance(value));\n\t\treturn convert(fromHttpOutputMessage(outputMessage), JSON, targetType);\n\t}",
    "query": "Design a testing utility method that seamlessly converts a source object into a specified target type by leveraging JSON serialization and deserialization, ensuring that the conversion maintains the integrity and structure of the original data.",
    "function_signature": "public <T> T transformForTest(Object source, ResolvableType targetType) throws IOException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.MockReset#reportInvocation(methodInvocationReport)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public void reportInvocation(MethodInvocationReport methodInvocationReport)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}",
    "query": "Implement a testing mechanism that collects and reports all method invocations on mocked beans during the execution of your Spring application tests.",
    "function_signature": "public void reportMockBeanInvocations(MethodInvocationReport report)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler(urlPaths,beanName)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public void registerHandler(String[] urlPaths, String beanName)",
    "documentation": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t * @since 6.2\n\t */",
    "changetype": "signature",
    "source_code": "\tpublic void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}",
    "query": "Develop a Spring MVC configuration method that efficiently maps a single controller bean to multiple URL endpoints. The existing approach requires registering each URL individually, leading to repetitive code and potential errors. Implement a solution that streamlines this process, enhancing maintainability and scalability.",
    "function_signature": "public void configureMultipleUrlMappings(String[] endpoints, String controllerBeanName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#getHeaders()",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "public HttpHeaders getHeaders()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.setContentType(mediaType);\n\t\t\t\treturn headers;\n\t\t\t}",
    "query": "Develop a method to generate HTTP headers for mock requests that ensures optimal performance and thread safety.",
    "function_signature": "public HttpHeaders createSecureHttpHeaders()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.interceptor.TransactionAspectSupport#determineTransactionManager(txAttr,targetClass)",
    "from_version": "v6.1.18",
    "to_version": "v6.2.4",
    "type": "method",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass)",
    "documentation": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t * @param txAttr the current transaction attribute\n\t * @param targetClass the target class that the attribute has been declared on\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected TransactionManager determineTransactionManager(",
    "query": "Design a service method that dynamically selects the appropriate transaction manager based on the current transaction settings and the class of the target service. This is particularly useful in applications that interact with multiple databases or transactional resources, ensuring that each operation is managed by the correct transactional context without hardcoding the transaction manager selection logic.",
    "function_signature": "protected TransactionManager selectTransactionManager(@Nullable TransactionAttribute transactionAttributes, @Nullable Class<?> serviceClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Develop a method to efficiently manage client subscription lifecycles, ensuring optimal performance and resource utilization during high-frequency subscription changes.",
    "function_signature": "public void manageClientSubscriptions(ServerState serverState, SubscriptionRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Refactor the messaging component to efficiently retrieve and manage destination identifiers, ensuring thread safety and optimal performance.",
    "function_signature": "public List<String> fetchDestinationIdentifiers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String session;",
    "query": "Create a method to obtain the active user context within the messaging broker, ensuring enhanced security and improved scalability by utilizing the modern session handling approach.",
    "function_signature": "public UserContext retrieveActiveUserContext()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Refactor the subscription handling mechanism to efficiently manage thousands of concurrent sessions and dynamic destinations. Ensure the new implementation enhances performance and thread safety compared to the existing approach.",
    "function_signature": "public void updateSubscriptionHandler(SubscriptionRegistry newRegistry, int sessionCount, int destinationCount)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Optimize the interceptor to leverage the latest pattern handling approach, enhancing both performance and type safety in URL mapping.",
    "function_signature": "public PathPattern[] fetchMappedPathPatterns()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a method to evaluate whether an interceptor should engage with the incoming HTTP request by examining relevant request attributes. Optimize your approach to utilize the latest framework capabilities, ensuring improved performance and easier maintenance.",
    "function_signature": "public boolean matches(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Develop a subscription handler that efficiently manages session identifiers and destinations, ensuring thread safety and improved performance over legacy methods.",
    "function_signature": "public void createSubscription(String sessionId, String destination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Create a method to efficiently manage active message destinations, ensuring optimal performance and thread safety in your Spring application.",
    "function_signature": "public void configureActiveDestinations(int maxDestinations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Implement a method to access the current session identifiers in a thread-safe and efficient manner, avoiding fixed-size arrays.",
    "function_signature": "public List<String> getCurrentSessionIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.14",
    "to_version": "v5.2.19.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a thread-safe mechanism to generate unique identifiers for message processing. Ensure that the solution minimizes contention and avoids exposing internal state, enhancing both performance and usability.",
    "function_signature": "public String generateUniqueMessageId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.WebHttpHandlerBuilder#observationRegistry(observationRegistry)",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry)",
    "documentation": "\t/**\n\t * Configure an {@link ObservationRegistry} for recording server exchange observations.\n\t * By default, a {@link ObservationRegistry#NOOP no-op} registry will be configured.\n\t * @param observationRegistry the observation registry\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic WebHttpHandlerBuilder observationRegistry(ObservationRegistry observationRegistry) {\n\t\tthis.observationRegistry = observationRegistry;\n\t\treturn this;\n\t}",
    "query": "Design a server configuration that captures and analyzes comprehensive metrics of HTTP requests and responses to enhance monitoring and troubleshooting capabilities.",
    "function_signature": "public WebHttpHandlerBuilder enableHttpExchangeMonitoring(ObservationRegistry observationRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterValidationResult",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "class",
    "signature": "public class ParameterValidationResult",
    "documentation": "/**\n * Store and expose the results of method validation for a method parameter.\n * <ul>\n * <li>Validation errors directly on method parameter values are exposed as a\n * list of {@link MessageSourceResolvable}s.\n * <li>Nested validation errors on an Object method parameter are exposed as\n * {@link org.springframework.validation.Errors} by the subclass\n * {@link ParameterErrors}.\n * </ul>\n *\n * <p>When the method parameter is a container such as a {@link List}, array,\n * or {@link java.util.Map}, then a separate {@link ParameterValidationResult}\n * is created for each element with errors. In that case, the properties\n * {@link #getContainer() container}, {@link #getContainerIndex() containerIndex},\n * and {@link #getContainerKey() containerKey} provide additional context.\n *\n * @author Rossen Stoyanchev\n * @since 6.1\n */",
    "changetype": "deprecated",
    "source_code": "public class ParameterValidationResult {\n\n\tprivate final MethodParameter methodParameter;\n\n\t@Nullable\n\tprivate final Object argument;\n\n\tprivate final List<MessageSourceResolvable> resolvableErrors;\n\n\t@Nullable\n\tprivate final Object container;\n\n\t@Nullable\n\tprivate final Integer containerIndex;\n\n\t@Nullable\n\tprivate final Object containerKey;\n\n\tprivate final BiFunction<MessageSourceResolvable, Class<?>, Object> sourceLookup;\n\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t */\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key,\n\t\t\tBiFunction<MessageSourceResolvable, Class<?>, Object> sourceLookup) {\n\n\t\tAssert.notNull(param, \"MethodParameter is required\");\n\t\tAssert.notEmpty(errors, \"`resolvableErrors` must not be empty\");\n\t\tthis.methodParameter = param;\n\t\tthis.argument = arg;\n\t\tthis.resolvableErrors = List.copyOf(errors);\n\t\tthis.container = container;\n\t\tthis.containerIndex = index;\n\t\tthis.containerKey = key;\n\t\tthis.sourceLookup = sourceLookup;\n\t}\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t * @deprecated in favor of\n\t * {@link ParameterValidationResult#ParameterValidationResult(MethodParameter, Object, Collection, Object, Integer, Object, BiFunction)}\n\t */\n\t@Deprecated(since = \"6.2\", forRemoval = true)\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors,\n\t\t\t@Nullable Object container, @Nullable Integer index, @Nullable Object key) {\n\n\t\tthis(param, arg, errors, container, index, key, (error, sourceType) -> {\n\t\t\tthrow new IllegalArgumentException(\"No source object of the given type\");\n\t\t});\n\t}\n\n\t/**\n\t * Create a {@code ParameterValidationResult}.\n\t * @deprecated in favor of\n\t * {@link ParameterValidationResult#ParameterValidationResult(MethodParameter, Object, Collection, Object, Integer, Object, BiFunction)}\n\t */\n\t@Deprecated(since = \"6.1.3\", forRemoval = true)\n\tpublic ParameterValidationResult(\n\t\t\tMethodParameter param, @Nullable Object arg, Collection<? extends MessageSourceResolvable> errors) {\n\n\t\tthis(param, arg, errors, null, null, null, (error, sourceType) -> {\n\t\t\tthrow new IllegalArgumentException(\"No source object of the given type\");\n\t\t});\n\t}\n\n\n\t/**\n\t * The method parameter the validation results are for.\n\t */\n\tpublic MethodParameter getMethodParameter() {\n\t\treturn this.methodParameter;\n\t}\n\n\t/**\n\t * The method argument value that was validated.\n\t */\n\t@Nullable\n\tpublic Object getArgument() {\n\t\treturn this.argument;\n\t}\n\n\t/**\n\t * List of {@link MessageSourceResolvable} representations adapted from the\n\t * validation errors of the validation library.\n\t * <ul>\n\t * <li>For a constraints directly on a method parameter, error codes are\n\t * based on the names of the constraint annotation, the object, the method,\n\t * the parameter, and parameter type, for example,\n\t * {@code [\"Max.myObject#myMethod.myParameter\", \"Max.myParameter\", \"Max.int\", \"Max\"]}.\n\t * Arguments include the parameter itself as a {@link MessageSourceResolvable}, for example,\n\t * {@code [\"myObject#myMethod.myParameter\", \"myParameter\"]}, followed by actual\n\t * constraint annotation attributes (i.e. excluding \"message\", \"groups\" and\n\t * \"payload\") in alphabetical order of attribute names.\n\t * <li>For cascaded constraints via {@link jakarta.validation.Validator @Valid}\n\t * on a bean method parameter, this method returns\n\t * {@link org.springframework.validation.FieldError field errors} that you\n\t * can also access more conveniently through methods of the\n\t * {@link ParameterErrors} sub-class.\n\t * </ul>\n\t */\n\tpublic List<MessageSourceResolvable> getResolvableErrors() {\n\t\treturn this.resolvableErrors;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements such as\n\t * {@link java.util.Collection}, {@link java.util.Map},\n\t * {@link java.util.Optional}, and others, this method returns the container\n\t * of the validated {@link #getArgument() argument}, while\n\t * {@link #getContainerIndex()} and {@link #getContainerKey()} provide\n\t * information about the index or key if applicable.\n\t */\n\t@Nullable\n\tpublic Object getContainer() {\n\t\treturn this.container;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on an indexed container of elements such as\n\t * {@link List} or array, this method returns the index of the validated\n\t * {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Integer getContainerIndex() {\n\t\treturn this.containerIndex;\n\t}\n\n\t/**\n\t * When {@code @Valid} is declared on a container of elements referenced by\n\t * key such as {@link java.util.Map}, this method returns the key of the\n\t * validated {@link #getArgument() argument}.\n\t */\n\t@Nullable\n\tpublic Object getContainerKey() {\n\t\treturn this.containerKey;\n\t}\n\n\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!super.equals(other)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (other instanceof ParameterValidationResult otherResult &&\n\t\t\t\tgetMethodParameter().equals(otherResult.getMethodParameter()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getArgument(), otherResult.getArgument()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerIndex(), otherResult.getContainerIndex()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(getContainerKey(), otherResult.getContainerKey()));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" for \" + this.methodParameter +\n\t\t\t\t\", argument value '\" + ObjectUtils.nullSafeConciseToString(this.argument) + \"',\" +\n\t\t\t\t(this.containerIndex != null ? \"containerIndex[\" + this.containerIndex + \"],\" : \"\") +\n\t\t\t\t(this.containerKey != null ? \"containerKey['\" + this.containerKey + \"'],\" : \"\") +\n\t\t\t\t\" errors: \" + getResolvableErrors();\n\t}\n\n}",
    "query": "Design a utility that records validation results for method parameters, ensuring efficient error handling and the ability to customize error source resolution.",
    "function_signature": "public ValidationRecorder recordValidation(MethodParameter parameter, Object argument, Collection<MessageSourceResolvable> errors, Object container, Integer index, Object key, BiFunction<MessageSourceResolvable, Class<?>, Object> sourceLookup)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.DataBufferUtils#map(b,off,len)",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public DataBuffer map(byte[] b, int off, int len)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DataBuffer map(byte[] b, int off, int len) {\n\t\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(len);\n\t\t\tbuffer.write(b, off, len);\n\t\t\treturn buffer;\n\t\t}",
    "query": "Design a method that efficiently transforms a portion of a byte array into a DataBuffer, ensuring optimal performance and memory management.",
    "function_signature": "public DataBuffer createDataBuffer(byte[] source, int start, int length)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.SpelNodeImpl#isCompilable()",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public boolean isCompilable()",
    "documentation": "\t/**\n\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n\t * be different but will typically involve checking whether the exit type descriptor\n\t * of the node is known and any relevant child nodes are compilable.\n\t * @return {@code true} if this node can be compiled to bytecode\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isCompilable() {\n\t\treturn false;\n\t}",
    "query": "Design a service method that evaluates dynamic Spring Expression Language (SpEL) expressions submitted by users. Ensure that the method intelligently determines whether each expression can be compiled to bytecode for enhanced performance before execution.",
    "function_signature": "public Object evaluateOptimizedExpression(String expression, EvaluationContext context) throws ExpressionCompilationException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#header(name,values)",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder header(String name, Object... values)",
    "documentation": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic MockHttpServletRequestBuilder header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn this;\n\t}",
    "query": "Design a unit test for a REST controller that verifies the handling of multiple authentication tokens sent in the request headers. Ensure that your test can add several values for the same header seamlessly.",
    "function_signature": "public MockHttpServletRequestBuilder addAuthenticationHeaders(String headerName, Object... tokens)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#isMatchRequiringConversion()",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public boolean isMatchRequiringConversion()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}",
    "query": "Design a component that optimizes the execution of dynamic method calls by determining whether the provided arguments need type conversion before invocation. This optimization should ensure that method matching is efficient and only performs conversions when absolutely necessary.",
    "function_signature": "public boolean needsArgumentConversion(MethodInvocationContext invocationContext);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#isEmpty()",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public boolean isEmpty()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean isEmpty() {\n\t\t\treturn this.segments.isEmpty();\n\t\t}",
    "query": "Implement a method that confirms the presence of elements within a data structure, ensuring enhanced performance and improved reliability.",
    "function_signature": "public boolean isNotEmpty()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(hints,registration)",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\n\t\tfor (Class<?> target : registration.classes) {\n\t\t\tregisterReflectionHints(hints, target, registration.memberCategories);\n\t\t}\n\t}",
    "query": "Develop a component that efficiently manages reflection configurations to enhance application performance and ensure type safety during runtime.",
    "function_signature": "protected void configureReflectionHints(ReflectionHints hints)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.BindingContext#getValuesToBind(exchange)",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public Object>> getValuesToBind(ServerWebExchange exchange)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Mono<Map<String, Object>> getValuesToBind(ServerWebExchange exchange) {\n\t\t\treturn super.getValuesToBind(exchange).doOnNext(map ->\n\t\t\t\t\tmap.putAll(exchange.<Map<String, String>>getAttributeOrDefault(\n\t\t\t\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap())));\n\t\t}",
    "query": "Enhance a reactive request handler to seamlessly merge query parameters with URI path variables during data binding, ensuring comprehensive model population.",
    "function_signature": "public Mono<Map<String, Object>> mergeBindingAttributes(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.DependencyDescriptor#hashCode()",
    "from_version": "v6.2.5",
    "to_version": "v6.1.19",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int hashCode() {\n\t\treturn (31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.containingClass));\n\t}",
    "query": "Design a method that efficiently generates a unique identifier for a dependency descriptor, ensuring improved performance and reliability within a Spring application.",
    "function_signature": "public int generateUniqueIdentifier(DependencyDescriptor descriptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.HttpComponentsHeadersAdapter#iterator()",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public List<String>>> iterator()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}",
    "query": "Develop a feature that sequentially accesses each HTTP header and its associated values from an incoming request to perform comprehensive logging without relying on index-based access.",
    "function_signature": "public Iterator<Map.Entry<String, List<String>>> logAllHttpHeaders(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#post()",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public RequestBodyUriSpec post()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}",
    "query": "Create a method that enables clients to submit form data to a configurable external service, allowing for seamless specification of request bodies and dynamic URI construction within a reactive programming paradigm.",
    "function_signature": "public Mono<ResponseEntity<Void>> submitFormData(FormData formData, URI serviceUri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteCount()",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public int writableByteCount()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int writableByteCount() {\n\t\t\treturn this.delegate.writableByteCount();\n\t\t}",
    "query": "Implement a mechanism that dynamically adjusts the data transmission rate based on the current capacity of the client's write buffer to prevent overflow in a high-throughput reactive application.",
    "function_signature": "public Mono<Void> sendDataWhenWritableBytesAvailable()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty5HeadersAdapter#put(key,value)",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public List<String> put(String key, @Nullable List<String> value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic List<String> put(String key, @Nullable List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.set(key, value);\n\t\treturn previousValues;\n\t}",
    "query": "Implement a feature in your web application that allows updating multiple values of a specific HTTP header while retrieving the previously set values for potential rollback or logging purposes.",
    "function_signature": "public List<String> updateHeaderValues(String headerName, @Nullable List<String> newValues)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.NameMatchMethodPointcut#setMappedNames(mappedNames)",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public void setMappedNames(String... mappedNames)",
    "documentation": "\t/**\n\t * Set the method names defining methods to match.\n\t * Matching will be the union of all these; if any match,\n\t * the pointcut matches.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setMappedNames(String... mappedNames) {\n\t\tthis.mappedNames = new ArrayList<>(Arrays.asList(mappedNames));\n\t}",
    "query": "Design a method to configure method pointcuts using pattern expressions to enhance matching flexibility and system performance.",
    "function_signature": "public void setMethodPointcutPatterns(String... patterns)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.HandlerMethod#getBridgedMethod()",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "protected Method getBridgedMethod()",
    "documentation": "\t/**\n\t * If the bean method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}",
    "query": "Refine the request processing workflow by implementing a method that efficiently obtains the definitive method responsible for handling incoming requests, ensuring enhanced performance and type safety.",
    "function_signature": "protected Method resolveHandlerMethod()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.HttpComponentsHeadersAdapter#next()",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public List<String>> next()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.iterator.next().getName());\n\t\t}",
    "query": "Design a Spring service method that processes incoming HTTP requests by iterating through each header and performing specific actions based on header names and their associated values. Ensure the implementation efficiently handles multiple values per header without compromising performance.",
    "function_signature": "public void processRequestHeaders(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.config.TaskSchedulerRouter#setBeanFactory(beanFactory)",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public void setBeanFactory(@Nullable BeanFactory beanFactory)",
    "documentation": "\t/**\n\t * The bean factory for scheduler lookups.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setBeanFactory(@Nullable BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tthis.embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t}\n\t}",
    "query": "Design a scheduler setup that leverages the application's BeanFactory to dynamically manage scheduler instances.",
    "function_signature": "public void setupDynamicScheduler(@Nullable BeanFactory beanFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.<unknown>#set(key,value)",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public void set(String key, @Nullable String value)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}",
    "query": "Create a method to efficiently manage HTTP headers within a reactive client, ensuring thread safety and optimal performance without compromising immutability.",
    "function_signature": "public void configureHeaders(Consumer<HttpHeadersBuilder> headerConfigurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.ModuleResource#getDescription()",
    "from_version": "v6.0.14",
    "to_version": "v6.1.0",
    "type": "method",
    "signature": "public String getDescription()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getDescription() {\n\t\treturn \"module resource [\" + this.path + \"]\" +\n\t\t\t\t(this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\n\t}",
    "query": "Design a service that accesses resources within distinct application modules and returns detailed descriptions, including the originating module's name when available, to enhance logging and monitoring capabilities.",
    "function_signature": "public String retrieveModuleResourceDescription(String resourcePath);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Implement a feature that validates user authentication tokens for every incoming HTTP request before it reaches any controller in your Spring MVC application.",
    "function_signature": "public boolean validateAuthenticationToken(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Create a performance testing component for a real-time messaging system that evaluates the efficiency of handling subscription registrations and cancellations under concurrent user activity.",
    "function_signature": "public void evaluateSubscriptionPerformance(ServerState serverState, SubscriptionRequest request, Blackhole blackhole)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Implement a feature that allows for the modification of the response object after a request has been handled by a controller but before the view is rendered. This should enable dynamic adjustments based on the data within the `ModelAndView`.",
    "function_signature": "public void modifyResponse(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Create a mechanism to intercept incoming HTTP requests and apply a specialized pattern matching strategy to determine which requests should be processed by the interceptor.",
    "function_signature": "public void registerRequestInterceptorWithCustomMatcher(PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean -&gt;\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Create a method that enables the registration of a centralized handler for managing exceptions across all reactive message processing components. This handler should seamlessly intercept and process any exceptions thrown during message handling, ensuring consistent error management throughout the messaging system.",
    "function_signature": "public void registerGlobalMessagingHandler(ErrorHandlingBean handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Design a feature that restricts a logging interceptor to monitor only the administrative section of your web application, ensuring that it does not interfere with public-facing endpoints. This selective interception should optimize performance by applying the interceptor solely where necessary.",
    "function_signature": "public void configureSelectiveInterceptor(String[] adminPaths, HandlerInterceptor adminInterceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "How would you implement a method that selects an appropriate messaging destination by assessing contention scenarios such as no subscribers or duplicate destinations?",
    "function_signature": "public String selectDestination(ContentionCriteria criteria);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String destination;",
    "query": "Create a service that efficiently routes real-time notifications to specific client groups based on their designated subscription destinations, utilizing the latest enhancements in Spring's messaging framework.",
    "function_signature": "public void dispatchNotificationToDestination(String notification, String destination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "Optimize your WebSocket message broker to dynamically adjust resource allocation based on the current number of active client destinations. Ensure your implementation efficiently scales as destinations increase, maintaining high performance and reliability.",
    "function_signature": "public void adjustBrokerResources(int currentDestinationCount)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)",
    "from_version": "v5.2.17.RELEASE",
    "to_version": "v5.3.11",
    "type": "method",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(",
    "query": "Design a Spring MVC interceptor that dynamically applies to a set of URL patterns using an advanced parsing mechanism to enhance request handling flexibility.",
    "function_signature": "public PatternAdapter[] initializePatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#checkQualifiers(bdHolder,annotationsToSearch)",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "protected Boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "documentation": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t * @return {@code false} if a qualifier has been found but not matched,\n\t * {@code true} if a qualifier has been found and matched,\n\t * {@code null} if no qualifier has been found at all\n\t */",
    "changetype": "signature",
    "source_code": "\tprotected Boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tboolean qualifierFound = false;\n\t\tif (!ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\t\tif (isPlainJavaAnnotation(type)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean checkMeta = true;\n\t\t\t\tboolean fallbackToMeta = false;\n\t\t\t\tif (isQualifier(type)) {\n\t\t\t\t\tqualifierFound = true;\n\t\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcheckMeta = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (checkMeta) {\n\t\t\t\t\tboolean foundMeta = false;\n\t\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\t\tif (isPlainJavaAnnotation(metaType)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\t\tqualifierFound = true;\n\t\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (qualifierFound ? true : null);\n\t}",
    "query": "Develop a Spring component responsible for assessing and matching a set of custom annotations on bean definitions to determine their suitability for dependency injection. The solution should handle cases where some annotations may partially match, necessitating fallback mechanisms to ensure accurate bean selection.",
    "function_signature": "public Boolean evaluateCustomAnnotations(BeanDefinitionHolder beanHolder, Annotation[] annotations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.nativex.INSTANCE",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "field",
    "signature": "public ReflectionHintsWriter INSTANCE",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic static final ReflectionHintsWriter INSTANCE = new ReflectionHintsWriter();",
    "query": "Design a component that configures reflection hints for native image generation, ensuring that the configuration can be easily extended and managed within the application context.",
    "function_signature": "public void configureReflectionHints(ReflectionConfigurationBuilder builder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.SpringMockResolver",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "class",
    "signature": "public class SpringMockResolver",
    "documentation": "/**\n * A {@link MockResolver} for testing Spring applications with Mockito.\n *\n * <p>Resolves mocks by walking the Spring AOP proxy chain until the target or a\n * non-static proxy is found.\n *\n * @author Sam Brannen\n * @author Andy Wilkinson\n * @author Juergen Hoeller\n * @since 6.2\n */",
    "changetype": "stabilized",
    "source_code": "public class SpringMockResolver implements MockResolver {\n\n\tstatic final boolean springAopPresent = ClassUtils.isPresent(\n\t\t\t\"org.springframework.aop.framework.Advised\", SpringMockResolver.class.getClassLoader());\n\n\n\t@Override\n\tpublic Object resolve(Object instance) {\n\t\tif (springAopPresent) {\n\t\t\treturn getUltimateTargetObject(instance);\n\t\t}\n\t\treturn instance;\n\t}\n\n\t/**\n\t * This is a modified version of\n\t * {@link org.springframework.test.util.AopTestUtils#getUltimateTargetObject(Object)\n\t * AopTestUtils#getUltimateTargetObject()} which only checks static target sources.\n\t * @param candidate the instance to check (potentially a Spring AOP proxy;\n\t * never {@code null})\n\t * @return the target object or the {@code candidate} (never {@code null})\n\t * @throws IllegalStateException if an error occurs while unwrapping a proxy\n\t * @see Advised#getTargetSource()\n\t * @see TargetSource#isStatic()\n\t */\n\tstatic Object getUltimateTargetObject(Object candidate) {\n\t\tAssert.notNull(candidate, \"Candidate must not be null\");\n\t\ttry {\n\t\t\tif (AopUtils.isAopProxy(candidate) && candidate instanceof Advised advised) {\n\t\t\t\tTargetSource targetSource = advised.getTargetSource();\n\t\t\t\tif (targetSource.isStatic()) {\n\t\t\t\t\tObject target = targetSource.getTarget();\n\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\treturn getUltimateTargetObject(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to unwrap proxied object\", ex);\n\t\t}\n\t\treturn candidate;\n\t}\n\n}",
    "query": "Create a utility method for your testing framework that extracts the actual target object from a Spring-managed bean, even if it's wrapped with multiple AOP proxies, to enable precise Mockito-based mocking.",
    "function_signature": "public Object resolveMockTarget(Object proxiedBean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.server.<unknown>#build()",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "public Mono<RenderingResponse> build()",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic Mono<RenderingResponse> build() {\n\t\treturn Mono.just(\n\t\t\t\tnew DefaultRenderingResponse(this.status, this.headers, this.cookies, this.name, this.model));\n\t}",
    "query": "Create a request handler that efficiently generates and returns a rendering response in a non-blocking manner, ensuring compatibility with reactive processing pipelines.",
    "function_signature": "public Mono<RenderingResponse> generateResponse(ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}",
    "query": "Design a client service that interacts with an external API, ensuring that it can dynamically set multiple HTTP cookies based on user-specific settings before making each request.",
    "function_signature": "public DefaultRequestBodyUriSpec setCustomCookies(Consumer<MultiValueMap<String, String>> cookiesConfigurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#cookie(name,value)",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}",
    "query": "Create a method that sets a specific cookie with a given name and value on an HTTP request, ensuring the cookie is included in subsequent interactions to manage user sessions effectively.",
    "function_signature": "public DefaultRequestBodyUriSpec setCookie(String name, String value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#executeAndExtract(exchangeFunction)",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "public T executeAndExtract(RequestHeadersSpec.ExchangeFunction<T> exchangeFunction)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic <T> T executeAndExtract(RequestHeadersSpec.ExchangeFunction<T> exchangeFunction) {\n\t\t\treturn this.requestHeadersSpec.exchange(exchangeFunction);\n\t\t}",
    "query": "Develop a method that executes an HTTP request and processes the response using a customizable function to handle different response types seamlessly.",
    "function_signature": "public <T> T executeAndExtract(RequestHeadersSpec.ExchangeFunction<T> exchangeFunction);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleDisconnectedClientException(ex,request,response,handler)",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "protected ModelAndView handleDisconnectedClientException(Exception ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "documentation": "\t/**\n\t * Handle an Exception that indicates the client has gone away. This is\n\t * typically an {@link IOException} of a specific subtype or with a message\n\t * specific to the underlying Servlet container. Those are detected through\n\t * {@link DisconnectedClientHelper#isClientDisconnectedException(Throwable)}\n\t * <p>By default, do nothing since the response is not usable.\n\t * @param ex the {@code Exception} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty ModelAndView indicating the exception was handled\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected ModelAndView handleDisconnectedClientException(",
    "query": "Implement a global exception handler in your Spring application that detects when a client has unexpectedly disconnected during a request. Ensure that the handler performs necessary cleanup and logs the disconnection event without attempting to modify the response, maintaining server performance and reliability.",
    "function_signature": "protected ModelAndView processClientDisconnection(Exception ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.SpringMockResolver#resolve(instance)",
    "from_version": "v6.2.0-RC2",
    "to_version": "v6.2.0-RC3",
    "type": "method",
    "signature": "public Object resolve(Object instance)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object resolve(Object instance) {\n\t\tif (springAopPresent) {\n\t\t\treturn getUltimateTargetObject(instance);\n\t\t}\n\t\treturn instance;\n\t}",
    "query": "Design a unit test for a Spring-managed service that utilizes AOP proxies. Ensure that when applying Mockito mocks, the test accurately interacts with the underlying target object rather than the proxy. This setup should handle scenarios where AOP enhancements might obscure the actual bean instance.",
    "function_signature": "public Object obtainUnderlyingBean(Object proxyInstance);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "class",
    "signature": "public class HtmlFileTransportHandler",
    "documentation": "/**\n * An HTTP {@link TransportHandler} that uses a famous browser\n * {@code document.domain technique}. See <a href=\n * \"https://stackoverflow.com/questions/1481251/what-does-document-domain-document-domain-do\">\n * stackoverflow.com/questions/1481251/what-does-document-domain-document-domain-do</a>\n * for details.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "changetype": "stabilized",
    "source_code": "public class HtmlFileTransportHandler extends AbstractHttpSendingTransportHandler {\n\n\tprivate static final String PARTIAL_HTML_CONTENT;\n\n\t// Safari needs at least 1024 bytes to parse the website.\n\t// https://code.google.com/p/browsersec/wiki/Part2#Survey_of_content_sniffing_behaviors\n\tprivate static final int MINIMUM_PARTIAL_HTML_CONTENT_LENGTH = 1024;\n\n\n\tstatic {\n\t\tStringBuilder sb = new StringBuilder(\"\"\"\n\t\t\t\t<!DOCTYPE html>\n\t\t\t\t<html><head>\n\t\t\t\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n\t\t\t\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n\t\t\t\t</head><body><h2>Don't panic!</h2>\n\t\t\t\t\t<script>\n\t\t\t\t\t\tdocument.domain = document.domain;\n\t\t\t\t\t\tvar c = parent.%s;\n\t\t\t\t\t\tc.start();\n\t\t\t\t\t\tfunction p(d) {c.message(d);};\n\t\t\t\t\t\twindow.onload = function() {c.stop();};\n\t\t\t\t\t</script>\"\"\");\n\n\t\tsb.append(\" \".repeat(MINIMUM_PARTIAL_HTML_CONTENT_LENGTH - sb.length()));\n\t\tPARTIAL_HTML_CONTENT = sb.append('\\n').toString();\n\t}\n\n\n\t@Override\n\tpublic TransportType getTransportType() {\n\t\treturn TransportType.HTML_FILE;\n\t}\n\n\t@Override\n\tprotected MediaType getContentType() {\n\t\treturn new MediaType(\"text\", \"html\", StandardCharsets.UTF_8);\n\t}\n\n\t@Override\n\tpublic boolean checkSessionType(SockJsSession session) {\n\t\treturn (session instanceof HtmlFileStreamingSockJsSession);\n\t}\n\n\t@Override\n\tpublic StreamingSockJsSession createSession(\n\t\t\tString sessionId, WebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\treturn new HtmlFileStreamingSockJsSession(sessionId, getServiceConfig(), handler, attributes);\n\t}\n\n\t@Override\n\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString callback = getCallbackParam(request);\n\t\tif (!StringUtils.hasText(callback)) {\n\t\t\tresponse.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(\"\\\"callback\\\" parameter required\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to write to response\", sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.handleRequestInternal(request, response, sockJsSession);\n\t}\n\n\t@Override\n\tprotected SockJsFrameFormat getFrameFormat(ServerHttpRequest request) {\n\t\treturn new DefaultSockJsFrameFormat(\"<script>\\np(\\\"%s\\\");\\n</script>\\r\\n\") {\n\t\t\t@Override\n\t\t\tprotected String preProcessContent(String content) {\n\t\t\t\treturn JavaScriptUtils.javaScriptEscape(content);\n\t\t\t}\n\t\t};\n\t}\n\n\n\tprivate class HtmlFileStreamingSockJsSession extends StreamingSockJsSession {\n\n\t\tpublic HtmlFileStreamingSockJsSession(String sessionId, SockJsServiceConfig config,\n\t\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\t\tsuper(sessionId, config, wsHandler, attributes);\n\t\t}\n\n\t\t@Override\n\t\tprotected byte[] getPrelude(ServerHttpRequest request) {\n\t\t\t// We already validated the parameter above...\n\t\t\tString callback = getCallbackParam(request);\n\t\t\tString html = String.format(PARTIAL_HTML_CONTENT, callback);\n\t\t\treturn html.getBytes(StandardCharsets.UTF_8);\n\t\t}\n\t}\n\n}",
    "query": "Design a real-time notification system that supports legacy browsers by utilizing a transport mechanism capable of injecting necessary HTML and JavaScript to establish communication. Ensure the solution manages session types appropriately and handles callback parameters effectively to maintain compatibility across different client environments.",
    "function_signature": "public void registerLegacyCompatibleSockJsEndpoint(SockJsServiceRegistration registration)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#getTransportType()",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "public TransportType getTransportType()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic TransportType getTransportType() {\n\t\treturn TransportType.HTML_FILE;\n\t}",
    "query": "Design a WebSocket configuration that gracefully falls back to using an HTML file transport for clients that do not support native WebSockets, ensuring compatibility across a wide range of browsers.",
    "function_signature": "public TransportType determineFallbackTransport()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.support.AbstractSockJsService#handle(request,response)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "public void handle(ServerHttpRequest request, ServerHttpResponse response)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() != HttpMethod.GET) {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());\n\t\t\tbyte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\t\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\t\tDigestUtils.appendMd5DigestAsHex(contentBytes, builder);\n\t\t\tbuilder.append('\"');\n\t\t\tString etagValue = builder.toString();\n\n\t\t\tList<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();\n\t\t\tif (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_MODIFIED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"html\", StandardCharsets.UTF_8));\n\t\t\tresponse.getHeaders().setContentLength(contentBytes.length);\n\n\t\t\t// No cache in order to check every time if IFrame are authorized\n\t\t\taddNoCacheHeaders(response);\n\t\t\tresponse.getHeaders().setETag(etagValue);\n\t\t\tresponse.getBody().write(contentBytes);\n\t\t}",
    "query": "You are tasked with ensuring that your Spring application gracefully degrades WebSocket functionality for clients that lack native support. Create a method that handles the necessary HTTP requests to provide SockJS fallback options, including managing caching and ETag headers to optimize performance.",
    "function_signature": "public void handleSockJsFallbackRequest(ServerHttpRequest request, ServerHttpResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setStreamBytesLimit(streamBytesLimit)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "public void setStreamBytesLimit(int streamBytesLimit)",
    "documentation": "\t/**\n\t * Streaming transports save responses on the client side and don't free\n\t * memory used by delivered messages. Such transports need to recycle the\n\t * connection once in a while. This property sets a minimum number of bytes\n\t * that can be sent over a single HTTP streaming request before it will be\n\t * closed. After that client will open a new request. Setting this value to\n\t * one effectively disables streaming and will make streaming transports to\n\t * behave like polling transports.\n\t * <p>The default value is 128K (i.e. 128 * 1024).\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setStreamBytesLimit(int streamBytesLimit) {\n\t\tthis.streamBytesLimit = streamBytesLimit;\n\t}",
    "query": "Ensure that your WebSocket service efficiently manages client-side memory by implementing a mechanism to automatically terminate streaming connections after a specified amount of data has been transmitted.",
    "function_signature": "public void configureStreamThreshold(int byteLimit)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.annotation.<unknown>#registerMethodHints(hints,method)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}",
    "query": "Optimize a Spring web service's startup performance by implementing a mechanism that pre-registers method and parameter metadata, reducing the need for runtime reflection.",
    "function_signature": "protected void configureReflectionHints(ReflectionHints hints, Method method)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.support.AbstractSockJsService#isSessionCookieNeeded()",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "public boolean isSessionCookieNeeded()",
    "documentation": "\t/**\n\t * Return whether the JSESSIONID cookie is required for the application to function.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isSessionCookieNeeded() {\n\t\treturn this.sessionCookieNeeded;\n\t}",
    "query": "Design a WebSocket configuration that dynamically determines the necessity of session cookies for maintaining client sessions in a SockJS setup.",
    "function_signature": "public boolean requiresSessionCookie()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,request)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request)",
    "documentation": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @param request the current request\n\t * @return the created {@code ProblemDetail} instance\n\t * @since 6.0\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected ProblemDetail createProblemDetail(",
    "query": "Develop a centralized error handling mechanism that produces consistent and localized error details for exceptions not covered by existing error responses, ensuring the messages adapt based on the client's request context.",
    "function_signature": "protected ProblemDetail handleUnexpectedException(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String messageCode, @Nullable Object[] messageArgs, WebRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.transport.handler.HtmlFileTransportHandler#handleRequestInternal(request,response,sockJsSession)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "public void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,",
    "query": "Create a handler that manages SockJS HTML File transport requests, ensuring seamless session handling for clients with limited WebSocket support.",
    "function_signature": "public void manageSockJsHtmlFileRequest(ServerHttpRequest request, ServerHttpResponse response, AbstractHttpSockJsSession session)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener#beforeOrAfterTestMethod(testContext,requiredMethodMode,requiredClassMode)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "protected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode)",
    "documentation": "\t/**\n\t * Perform the actual work for {@link #beforeTestMethod} and {@link #afterTestMethod}\n\t * by dirtying the context if appropriate (i.e., according to the required modes).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredMethodMode the method mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,",
    "query": "Create a test listener that conditionally refreshes the application context before or after each test method based on the specified execution modes for both methods and classes.",
    "function_signature": "protected void manageContextLifecycle(TestContext testContext, MethodExecutionMode methodMode, ClassExecutionMode classMode)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.support.AbstractSockJsService#setSockJsClientLibraryUrl(clientLibraryUrl)",
    "from_version": "v6.0.0-RC2",
    "to_version": "v6.0.0-RC3",
    "type": "method",
    "signature": "public void setSockJsClientLibraryUrl(String clientLibraryUrl)",
    "documentation": "\t/**\n\t * Transports with no native cross-domain communication (e.g. \"eventsource\",\n\t * \"htmlfile\") must get a simple page from the \"foreign\" domain in an invisible\n\t * {@code iframe} so that code in the {@code iframe} can run from a domain\n\t * local to the SockJS server. Since the {@code iframe} needs to load the\n\t * SockJS JavaScript client library, this property allows specifying where to\n\t * load it from.\n\t * <p>By default this is set to point to\n\t * <a href=\"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\">\"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js\"</a>.\n\t * However, it can also be set to point to a URL served by the application.\n\t * <p>Note that it's possible to specify a relative URL in which case the URL\n\t * must be relative to the {@code iframe} URL. For example assuming a SockJS endpoint\n\t * mapped to \"/sockjs\", and resulting {@code iframe} URL \"/sockjs/iframe.html\", then\n\t * the relative URL must start with \"../../\" to traverse up to the location\n\t * above the SockJS mapping. In case of a prefix-based Servlet mapping one more\n\t * traversals may be needed.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setSockJsClientLibraryUrl(String clientLibraryUrl) {\n\t\tthis.clientLibraryUrl = clientLibraryUrl;\n\t}",
    "query": "Design a WebSocket configuration that ensures the client-side SockJS library is served from a custom internal endpoint, enhancing security by avoiding external CDN dependencies.",
    "function_signature": "public void configureCustomSockJsClientLibrary(String internalLibraryPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Design a component for a live streaming platform that dynamically manages viewer subscriptions to different channels. The system should efficiently handle the rapid registration and deregistration of viewers, ensuring minimal latency and optimal resource utilization during peak traffic periods.",
    "function_signature": "public void manageViewerSubscriptions(StreamState streamState, SubscriptionRequest request, PerformanceTracker tracker)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "In a Spring-based messaging system, how can you implement a method to obtain the current number of message destinations being managed by the broker efficiently?",
    "function_signature": "public int getDestinationCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Develop a component that efficiently generates unique sequential identifiers for messages in a concurrent environment, ensuring each identifier is unique without performance bottlenecks.",
    "function_signature": "public int incrementAndGetId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int sessions;",
    "query": "Design a monitoring feature that enables administrators to retrieve the current count of active user connections within the application's messaging infrastructure.",
    "function_signature": "public int getActiveUserConnections()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Create a performance testing scenario for your Spring-based messaging application that assesses how efficiently it manages a large number of client subscriptions across multiple destinations. The test should simulate varying numbers of sessions and destinations, incorporate different subscription patterns, and evaluate the impact of cache size limits on subscription handling. This will help identify scalability issues and optimize the subscription registry's performance under diverse conditions.",
    "function_signature": "public void benchmarkSubscriptionManagement(ServerState serverState, SubscriptionRequests requests, Blackhole blackhole)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String destination;",
    "query": "Configure your WebSocket message broker to use a specific prefix for all incoming and outgoing message destinations, ensuring organized and efficient routing of messages within different modules of your application.",
    "function_signature": "public void setDestinationPrefix(String prefix)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Create a monitoring service that dynamically retrieves all active messaging destinations to provide real-time analytics on message flow within the application.",
    "function_signature": "public String[] getActiveMessagingDestinations()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String session;",
    "query": "Design a WebSocket message handler that authenticates users based on their session identifiers. Ensure that each incoming message is associated with the correct user session to maintain secure and personalized communication channels.",
    "function_signature": "public void authenticateAndHandleMessage(String sessionId, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PathPattern[] includePatterns;\n\n\t@Nullable\n\tprivate final PathPattern[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\t@Nullable\n\tprivate static PathPattern[] initPatterns(\n\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\treturn null;\n\t\t}\n\t\tparser = (parser != null ? parser : PathPatternParser.defaultInstance);\n\t\treturn Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchPattern(Object path, boolean isPathContainer, PathPattern pattern) {\n\t\treturn (isPathContainer ?\n\t\t\t\tpattern.matches((PathContainer) path) :\n\t\t\t\tthis.pathMatcher.match(pattern.getPatternString(), (String) path));\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n}",
    "query": "Develop a configuration that attaches a specialized interceptor exclusively to designated API endpoints, ensuring certain paths are included while others are excluded based on defined patterns.",
    "function_signature": "public void registerSelectiveInterceptor(String[] includePatterns, String[] excludePatterns, HandlerInterceptor interceptor, PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.2.13.RELEASE",
    "to_version": "v5.3.5",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a system to efficiently handle and cache WebSocket subscriptions across numerous user sessions and destinations, optimizing for high concurrency and minimal latency.",
    "function_signature": "public void configureSubscriptionRegistry(int cacheSizeLimit, int numberOfDestinations, int numberOfSessions)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#isMatchRequiringConversion()",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public boolean isMatchRequiringConversion()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}",
    "query": "Enhance the evaluation logic to efficiently determine if an expression match necessitates type conversion using the current best practices.",
    "function_signature": "public boolean needsTypeConversion()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.support.WebClientAdapter#forClient(webClient)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public WebClientAdapter forClient(WebClient webClient)",
    "documentation": "\t/**\n\t * Create a {@link WebClientAdapter} for the given {@code WebClient} instance.\n\t * @param webClient the client to use\n\t * @return the created adapter instance\n\t * @deprecated in favor of {@link #create(WebClient)} aligning with other adapter\n\t * implementations; to be removed in 6.2.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static WebClientAdapter forClient(WebClient webClient) {\n\t\treturn new WebClientAdapter(webClient);\n\t}",
    "query": "Enhance your application's reactive HTTP client setup by implementing a more robust and maintainable adapter instantiation approach that aligns with current best practices.",
    "function_signature": "public WebClientAdapter create(WebClient webClient)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#isCloseMatch()",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public boolean isCloseMatch()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}",
    "query": "Create a utility method that determines if the provided arguments effectively align with the expected parameters, enhancing both performance and type safety.",
    "function_signature": "public boolean hasEffectiveArgumentAlignment()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.rsocket.<unknown>#metadata(metadata,mimeType)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public RequestSpec metadata(Object metadata, MimeType mimeType)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\t\tpublic RequestSpec metadata(Object metadata, MimeType mimeType) {\n\t\t\tthis.metadataEncoder.metadata(metadata, mimeType);\n\t\t\treturn this;\n\t\t}",
    "query": "Implement a feature in your Spring-based RSocket application that sends a request containing custom metadata with a specific MIME type. Ensure that the metadata encoding aligns with the desired content type to facilitate proper handling on the receiving end.",
    "function_signature": "public ResponseSpec sendCustomMetadata(Object metadataContent, MimeType contentType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#toString()",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String toString() {\n\t\t\treturn \"ArgumentsMatchInfo: \" + this.kind;\n\t\t}",
    "query": "Develop a utility method that constructs a comprehensive string representation of a given object, ensuring enhanced performance and thread safety by leveraging the latest framework capabilities.",
    "function_signature": "public String buildObjectSummary(Object target)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#builder(clientAdapter)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public Builder builder(HttpClientAdapter clientAdapter)",
    "documentation": "\t/**\n\t * Return a builder that's initialized with the given client.\n\t * @deprecated in favor of {@link #builderFor(HttpExchangeAdapter)};\n\t * to be removed in 6.2.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static Builder builder(HttpClientAdapter clientAdapter) {\n\t\treturn new Builder().exchangeAdapter(clientAdapter.asReactorExchangeAdapter());\n\t}",
    "query": "Create a factory that initializes with an exchange-optimized client adapter to enhance request handling performance.",
    "function_signature": "public static Builder builderFor(HttpExchangeAdapter exchangeAdapter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder#createServletRequest(servletContext)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "documentation": "\t/**\n\t * Create a new {@link MockMultipartHttpServletRequest} based on the\n\t * supplied {@code ServletContext} and the {@code MockMultipartFiles}\n\t * added to this builder.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\tMockMultipartHttpServletRequest request = new MockMultipartHttpServletRequest(servletContext);\n\t\tCharset defaultCharset = (request.getCharacterEncoding() != null ?\n\t\t\t\tCharset.forName(request.getCharacterEncoding()) : StandardCharsets.UTF_8);\n\n\t\tthis.files.forEach(request::addFile);\n\t\tthis.parts.values().stream().flatMap(Collection::stream).forEach(part -> {\n\t\t\trequest.addPart(part);\n\t\t\ttry {\n\t\t\t\tString name = part.getName();\n\t\t\t\tString filename = part.getSubmittedFileName();\n\t\t\t\tInputStream is = part.getInputStream();\n\t\t\t\tif (filename != null) {\n\t\t\t\t\trequest.addFile(new MockMultipartFile(name, filename, part.getContentType(), is));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInputStreamReader reader = new InputStreamReader(is, getCharsetOrDefault(part, defaultCharset));\n\t\t\t\t\tString value = FileCopyUtils.copyToString(reader);\n\t\t\t\t\trequest.addParameter(part.getName(), value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to read content for part \" + part.getName(), ex);\n\t\t\t}\n\t\t});\n\n\t\treturn request;\n\t}",
    "query": "Design a unit test for a Spring MVC controller that handles file uploads, ensuring that multiple files and form data are correctly processed. The test should efficiently simulate a multipart HTTP request with various file types and parameters.",
    "function_signature": "public void testHandleFileUpload_withMultipleFilesAndParams() throws Exception"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#reactiveAdapterRegistry(registry)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public Builder reactiveAdapterRegistry(ReactiveAdapterRegistry registry)",
    "documentation": "\t\t/**\n\t\t * Set the {@link ReactiveAdapterRegistry} to use to support different\n\t\t * asynchronous types for HTTP service method return values.\n\t\t * <p>By default this is {@link ReactiveAdapterRegistry#getSharedInstance()}.\n\t\t * @return this same builder instance\n\t\t * @deprecated in favor of setting the same directly on the {@link HttpExchangeAdapter}\n\t\t */",
    "changetype": "deprecated",
    "source_code": "\t\tpublic Builder reactiveAdapterRegistry(ReactiveAdapterRegistry registry) {\n\t\t\tif (this.exchangeAdapter instanceof AbstractReactorHttpExchangeAdapter settable) {\n\t\t\t\tsettable.setReactiveAdapterRegistry(registry);\n\t\t\t}\n\t\t\treturn this;\n\t\t}",
    "query": "Enhance the HTTP service proxy setup by integrating a customized reactive adapter configuration directly within the exchange adapter. This modification aims to improve asynchronous processing efficiency and align with the latest framework standards.",
    "function_signature": "public Builder configureExchangeAdapterReactiveRegistry(ReactiveAdapterRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterValidationResult#unwrap(error,sourceType)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public T unwrap(MessageSourceResolvable error, Class<T> sourceType)",
    "documentation": "\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}",
    "query": "During form submission, ensure that specific validation constraints are accessible for detailed logging and customized user feedback by extracting the underlying validation violations from general error messages.",
    "function_signature": "public <T> T extractValidationDetail(MessageSourceResolvable error, Class<T> sourceType);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#getTypeDifferenceWeight(paramTypes,argTypes)",
    "from_version": "v6.2.0-M5",
    "to_version": "v6.2.0-M6",
    "type": "method",
    "signature": "public int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
    "documentation": "\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}",
    "query": "Develop a utility method that accurately assesses the compatibility between a set of parameter types and argument types, prioritizing type safety and performance optimization.",
    "function_signature": "public int calculateCompatibilityScore(List<TypeDescriptor> parameterTypes, List<TypeDescriptor> argumentTypes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.<unknown>#characteristics()",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public int characteristics()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int characteristics() {\n\t\t\treturn NONNULL | IMMUTABLE;\n\t\t}",
    "query": "Design a Spring component that scans for custom annotations on service methods and optimizes caching behavior based on the annotations' immutability and nullability guarantees.",
    "function_signature": "public void optimizeMethodCaching(Class<?> serviceClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.support.SQLErrorCodes#setCannotAcquireLockCodes(cannotAcquireLockCodes)",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public void setCannotAcquireLockCodes(String... cannotAcquireLockCodes)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setCannotAcquireLockCodes(String... cannotAcquireLockCodes) {\n\t\tthis.cannotAcquireLockCodes = StringUtils.sortStringArray(cannotAcquireLockCodes);\n\t}",
    "query": "Design a robust data access layer component that gracefully handles scenarios where the application fails to acquire necessary database locks. Ensure that specific SQL error codes associated with lock acquisition failures are appropriately mapped to custom exceptions to enhance error handling and maintain application stability.",
    "function_signature": "public void configureLockAcquisitionErrorCodes(String... errorCodes)"
  },
  {
    "library": "spring-framework",
    "name": "org.apache.commons.logging.<unknown>#info(message,exception)",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public void info(Object message, Throwable exception)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}",
    "query": "Implement a method that logs informational messages and associated exceptions using a strategy that defers message construction for improved performance.",
    "function_signature": "public void logInfo(Supplier<String> messageSupplier, Throwable throwable)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.support.AbstractDispatcherServletInitializer#getServletMappings()",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "protected String[] getServletMappings()",
    "documentation": "\t/**\n\t * Specify the servlet mapping(s) for the {@code DispatcherServlet} &mdash;\n\t * for example {@code \"/\"}, {@code \"/app\"}, etc.\n\t * @see #registerDispatcherServlet(ServletContext)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected abstract String[] getServletMappings();",
    "query": "Design a Spring-based web application initializer that configures the main `DispatcherServlet` to handle requests for both the root path and a specific application context path, ensuring that these mappings are centralized and easily maintainable.",
    "function_signature": "@Override\nprotected String[] determineServletMappings()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#next()",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public V> next()",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\t\t\t\t\t\tpublic Entry<K, V> next() {\n\t\t\t\t\t\t\tEntry<K, List<V>> entry = targetIterator.next();\n\t\t\t\t\t\t\treturn new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), entry.getValue().get(0));\n\t\t\t\t\t\t}",
    "query": "Create a method that efficiently iterates over a collection of entries, each associated with a list of values, and processes only the primary value of each entry.",
    "function_signature": "public void handlePrimaryValues(Iterator<Entry<KeyType, List<ValueType>>> entryIterator)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.support.<unknown>#parseDaysOfWeek(value)",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public QuartzCronField parseDaysOfWeek(String value)",
    "documentation": "\t/**\n\t * Parse the given value into a days of week {@code QuartzCronField},\n\t * the sixth entry of a cron expression.\n\t * <p>Expects a \"L\" or \"#\" in the given value.\n\t */",
    "changetype": "signature",
    "source_code": "\tpublic static QuartzCronField parseDaysOfWeek(String value) {\n\t\tint idx = value.lastIndexOf('L');\n\t\tif (idx != -1) {\n\t\t\tif (idx != value.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unrecognized characters after 'L' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTemporalAdjuster adjuster;\n\t\t\t\tif (idx == 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"No day-of-week before 'L' in '\" + value + \"'\");\n\t\t\t\t}\n\t\t\t\telse {  // \"[0-7]L\"\n\t\t\t\t\tDayOfWeek dayOfWeek = parseDayOfWeek(value.substring(0, idx));\n\t\t\t\t\tadjuster = lastInMonth(dayOfWeek);\n\t\t\t\t}\n\t\t\t\treturn new QuartzCronField(Type.DAY_OF_WEEK, Type.DAY_OF_MONTH, adjuster, value);\n\t\t\t}\n\t\t}\n\t\tidx = value.lastIndexOf('#');\n\t\tif (idx != -1) {\n\t\t\tif (idx == 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"No day-of-week before '#' in '\" + value + \"'\");\n\t\t\t}\n\t\t\telse if (idx == value.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"No ordinal after '#' in '\" + value + \"'\");\n\t\t\t}\n\t\t\t// \"[0-7]#[0-9]+\"\n\t\t\tDayOfWeek dayOfWeek = parseDayOfWeek(value.substring(0, idx));\n\t\t\tint ordinal = Integer.parseInt(value, idx + 1, value.length(), 10);\n\t\t\tif (ordinal <= 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Ordinal '\" + ordinal + \"' in '\" + value +\n\t\t\t\t\t\t\"' must be positive number \");\n\t\t\t}\n\t\t\tTemporalAdjuster adjuster = dayOfWeekInMonth(ordinal, dayOfWeek);\n\t\t\treturn new QuartzCronField(Type.DAY_OF_WEEK, Type.DAY_OF_MONTH, adjuster, value);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"No 'L' or '#' found in '\" + value + \"'\");\n\t}",
    "query": "Develop a scheduling feature that accurately interprets and handles complex cron expressions involving the specification of the last occurrence of a weekday in a month or the nth occurrence of a specific weekday. Ensure that your implementation can parse these advanced patterns and integrate them seamlessly into the task scheduling mechanism.",
    "function_signature": "public QuartzCronField interpretAdvancedCronExpression(String cronExpression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.AbstractJdbcInsert#setGeneratedKeyName(generatedKeyName)",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public void setGeneratedKeyName(String generatedKeyName)",
    "documentation": "\t/**\n\t * Specify the name of a single generated key column.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setGeneratedKeyName(String generatedKeyName) {\n\t\tcheckIfConfigurationModificationIsAllowed();\n\t\tthis.generatedKeyNames = new String[] {generatedKeyName};\n\t}",
    "query": "Design a repository method to add a new customer to the database and obtain the auto-generated customer ID by specifying the key column name.",
    "function_signature": "public Long addNewCustomer(Customer customer, String generatedKeyName);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager#getPersistenceUnitInfo(persistenceUnitName)",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "protected MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName)",
    "documentation": "\t/**\n\t * Return the specified PersistenceUnitInfo from this manager's cache\n\t * of processed persistence units, keeping it in the cache (i.e. not\n\t * 'obtaining' it for use but rather just accessing it for post-processing).\n\t * <p>This can be used in {@link #postProcessPersistenceUnitInfo} implementations,\n\t * detecting existing persistence units of the same name and potentially merging them.\n\t * @param persistenceUnitName the name of the desired persistence unit\n\t * @return the PersistenceUnitInfo in mutable form, or {@code null} if not available\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final @Nullable MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName) {\n\t\tPersistenceUnitInfo pui = this.persistenceUnitInfos.get(persistenceUnitName);\n\t\treturn (MutablePersistenceUnitInfo) pui;\n\t}",
    "query": "Design a mechanism that enables the dynamic adjustment of JPA persistence unit settings during initialization, allowing for the seamless integration and consolidation of multiple persistence units sharing the same identifier.",
    "function_signature": "protected MutablePersistenceUnitInfo adjustPersistenceUnitConfiguration(String unitIdentifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.object.RdbmsOperation#setUpdatableResults(updatableResults)",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "method",
    "signature": "public void setUpdatableResults(boolean updatableResults)",
    "documentation": "\t/**\n\t * Set whether to use statements that are capable of returning\n\t * updatable ResultSets.\n\t * @see java.sql.Connection#prepareStatement(String, int, int)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setUpdatableResults(boolean updatableResults) {\n\t\tif (isCompiled()) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"The updatableResults flag must be set before the operation is compiled\");\n\t\t}\n\t\tthis.updatableResults = updatableResults;\n\t}",
    "query": "Implement a service method that retrieves user records from the database and allows these records to be updated directly within the ResultSet, enabling real-time modifications without additional queries.",
    "function_signature": "public void fetchAndModifyUsers(String query, boolean enableRealTimeUpdates)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.docs.integration.resthttpinterface.customresolver.CustomHttpServiceArgumentResolver",
    "from_version": "v6.2.2",
    "to_version": "v7.0.0-M1",
    "type": "class",
    "signature": "public class CustomHttpServiceArgumentResolver",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class CustomHttpServiceArgumentResolver {\n\n\t// tag::httpinterface[]\n\tinterface RepositoryService {\n\n\t\t@GetExchange(\"/repos/search\")\n\t\tList<Repository> searchRepository(Search search);\n\n\t}\n\t// end::httpinterface[]\n\n\tclass Sample {\n\n\t\tvoid sample() {\n\t\t\t// tag::usage[]\n\t\t\tRestClient restClient = RestClient.builder().baseUrl(\"https://api.github.com/\").build();\n\t\t\tRestClientAdapter adapter = RestClientAdapter.create(restClient);\n\t\t\tHttpServiceProxyFactory factory = HttpServiceProxyFactory\n\t\t\t\t\t.builderFor(adapter)\n\t\t\t\t\t.customArgumentResolver(new SearchQueryArgumentResolver())\n\t\t\t\t\t.build();\n\t\t\tRepositoryService repositoryService = factory.createClient(RepositoryService.class);\n\n\t\t\tSearch search = Search.create()\n\t\t\t\t\t.owner(\"spring-projects\")\n\t\t\t\t\t.language(\"java\")\n\t\t\t\t\t.query(\"rest\")\n\t\t\t\t\t.build();\n\t\t\tList<Repository> repositories = repositoryService.searchRepository(search);\n\t\t\t// end::usage[]\n\t\t}\n\n\t}\n\n\t// tag::argumentresolver[]\n\tstatic class SearchQueryArgumentResolver implements HttpServiceArgumentResolver {\n\t\t@Override\n\t\tpublic boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\t\t\tif (parameter.getParameterType().equals(Search.class)) {\n\t\t\t\tSearch search = (Search) argument;\n\t\t\t\trequestValues.addRequestParameter(\"owner\", search.owner());\n\t\t\t\trequestValues.addRequestParameter(\"language\", search.language());\n\t\t\t\trequestValues.addRequestParameter(\"query\", search.query());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t// end::argumentresolver[]\n\n\n\trecord Search (String query, String owner, String language) {\n\n\t\tstatic Builder create() {\n\t\t\treturn new Builder();\n\t\t}\n\n\t\tstatic class Builder {\n\n\t\t\tBuilder query(String query) { return this;}\n\n\t\t\tBuilder owner(String owner) { return this;}\n\n\t\t\tBuilder language(String language) { return this;}\n\n\t\t\tSearch build() {\n\t\t\t\treturn new Search(null, null, null);\n\t\t\t}\n\t\t}\n\n\t}\n\n\trecord Repository(String name) {\n\n\t}\n\n}",
    "query": "Design a Spring HTTP interface method to fetch a list of repositories based on dynamic search criteria encapsulated within a custom search object. Ensure that the search parameters are seamlessly translated into request parameters without manual mapping.",
    "function_signature": "List<Repository> findRepositories(SearchCriteria searchCriteria);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.CustomizableTraceInterceptor#replacePlaceholders(message,methodInvocation,returnValue,throwable,invocationTime)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "protected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime)",
    "documentation": "\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,",
    "query": "Design a logging interceptor that dynamically injects method execution detailssuch as return values, exceptions, and execution timeinto log messages. Ensure that your implementation efficiently replaces placeholders in log templates with the relevant runtime information.",
    "function_signature": "protected String customizeLogMessage(String template, MethodInvocation invocation, @Nullable Object result, @Nullable Throwable exception, long executionTime)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.<unknown>#resolveAutowiredArgument(descriptor,beanName,autowiredBeanNames,typeConverter,fallback)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "protected Object resolveAutowiredArgument(DependencyDescriptor descriptor, String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, TypeConverter typeConverter, boolean fallback)",
    "documentation": "\t/**\n\t * Template method for resolving the specified argument which is supposed to be autowired.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected Object resolveAutowiredArgument(DependencyDescriptor descriptor, String beanName,",
    "query": "Develop a method to efficiently resolve dependencies within the application context, ensuring robust type conversion and eliminating unnecessary fallback mechanisms to enhance overall performance and maintainability.",
    "function_signature": "protected Object resolveDependency(DependencyDescriptor descriptor, String beanName,\n                                    @Nullable Set<String> autowiredBeanNames, TypeConverter typeConverter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.<unknown>#hasShortcut()",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "public boolean hasShortcut()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean hasShortcut() {\n\t\t\treturn (this.shortcut != null);\n\t\t}",
    "query": "Design a component that processes bean definitions and conditionally applies additional configuration steps only if a shortcut configuration is present. Ensure that the component efficiently checks for the existence of a shortcut to determine whether to proceed with the extra configuration.",
    "function_signature": "public boolean shouldApplyAdditionalConfig(String beanName);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#execute(task)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "public void execute(Runnable task)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void execute(Runnable task) {\n\t\t\tif (taskExecutorWarning && logger.isWarnEnabled()) {\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (taskExecutorWarning) {\n\t\t\t\t\t\tlogger.warn(\"\"\"\n\t\t\t\t\t\t\t\t!!!\n\t\t\t\t\t\t\t\tPerforming asynchronous handling through the default Spring MVC SimpleAsyncTaskExecutor.\n\t\t\t\t\t\t\t\tThis executor is not suitable for production use under load.\n\t\t\t\t\t\t\t\tPlease, configure an AsyncTaskExecutor through the WebMvc config.\n\t\t\t\t\t\t\t\t-------------------------------\n\t\t\t\t\t\t\t\t!!!\"\"\");\n\t\t\t\t\t\ttaskExecutorWarning = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.execute(task);\n\t\t}",
    "query": "Design a Spring MVC controller method that handles high-throughput form submissions by delegating the processing of each submission to a separate thread, ensuring that the main request thread remains responsive. The solution should leverage the latest enhancements in Spring's request handling to efficiently manage asynchronous tasks without compromising scalability.",
    "function_signature": "public void handleHighLoadSubmission(FormData formData)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#getBean(beanName,expectedType)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "protected T getBean(String beanName, Class<T> expectedType)",
    "documentation": "\t/**\n\t * Return a bean with the specified name and type. Used to resolve services that\n\t * are referenced by name in a {@link CacheOperation}.\n\t * @param beanName the name of the bean, as defined by the operation\n\t * @param expectedType type for the bean\n\t * @return the bean matching that name\n\t * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist\n\t * @see CacheOperation#getKeyGenerator()\n\t * @see CacheOperation#getCacheManager()\n\t * @see CacheOperation#getCacheResolver()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected <T> T getBean(String beanName, Class<T> expectedType) {\n\t\tif (this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"BeanFactory must be set on cache aspect for \" + expectedType.getSimpleName() + \" retrieval\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, expectedType, beanName);\n\t}",
    "query": "Improve the cache handling mechanism by implementing a method that efficiently obtains a bean based on its identifier and expected type, ensuring enhanced performance and type safety without depending on outdated retrieval strategies.",
    "function_signature": "protected <T> T obtainBean(String beanIdentifier, Class<T> beanType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.PLACEHOLDER_RETURN_VALUE",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "field",
    "signature": "public String PLACEHOLDER_RETURN_VALUE",
    "documentation": "\t/**\n\t * The {@code $[returnValue]} placeholder.\n\t * Replaced with the {@code String} representation of the value\n\t * returned by the method invocation.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String PLACEHOLDER_RETURN_VALUE = \"$[returnValue]\";",
    "query": "Create an aspect that logs the execution of service methods, embedding the returned data within log statements using a dynamic placeholder.",
    "function_signature": "public void configureLoggingWithReturnValuePlaceholder(String logTemplate);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.CustomizableTraceInterceptor",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "class",
    "signature": "public class CustomizableTraceInterceptor",
    "documentation": "/**\n * {@code MethodInterceptor} implementation that allows for highly customizable\n * method-level tracing, using placeholders.\n *\n * <p>Trace messages are written on method entry, and if the method invocation succeeds\n * on method exit. If an invocation results in an exception, then an exception message\n * is written. The contents of these trace messages is fully customizable and special\n * placeholders are available to allow you to include runtime information in your log\n * messages. The placeholders available are:\n *\n * <p><ul>\n * <li>{@code $[methodName]} - replaced with the name of the method being invoked</li>\n * <li>{@code $[targetClassName]} - replaced with the name of the class that is\n * the target of the invocation</li>\n * <li>{@code $[targetClassShortName]} - replaced with the short name of the class\n * that is the target of the invocation</li>\n * <li>{@code $[returnValue]} - replaced with the value returned by the invocation</li>\n * <li>{@code $[argumentTypes]} - replaced with a comma-separated list of the\n * short class names of the method arguments</li>\n * <li>{@code $[arguments]} - replaced with a comma-separated list of the\n * {@code String} representation of the method arguments</li>\n * <li>{@code $[exception]} - replaced with the {@code String} representation\n * of any {@code Throwable} raised during the invocation</li>\n * <li>{@code $[invocationTime]} - replaced with the time, in milliseconds,\n * taken by the method invocation</li>\n * </ul>\n *\n * <p>There are restrictions on which placeholders can be used in which messages:\n * see the individual message properties for details on the valid placeholders.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.2\n * @see #setEnterMessage\n * @see #setExitMessage\n * @see #setExceptionMessage\n * @see SimpleTraceInterceptor\n */",
    "changetype": "stabilized",
    "source_code": "public class CustomizableTraceInterceptor extends AbstractTraceInterceptor {\n\n\t/**\n\t * The {@code $[methodName]} placeholder.\n\t * Replaced with the name of the method being invoked.\n\t */\n\tpublic static final String PLACEHOLDER_METHOD_NAME = \"$[methodName]\";\n\n\t/**\n\t * The {@code $[targetClassName]} placeholder.\n\t * Replaced with the fully-qualified name of the {@code Class}\n\t * of the method invocation target.\n\t */\n\tpublic static final String PLACEHOLDER_TARGET_CLASS_NAME = \"$[targetClassName]\";\n\n\t/**\n\t * The {@code $[targetClassShortName]} placeholder.\n\t * Replaced with the short name of the {@code Class} of the\n\t * method invocation target.\n\t */\n\tpublic static final String PLACEHOLDER_TARGET_CLASS_SHORT_NAME = \"$[targetClassShortName]\";\n\n\t/**\n\t * The {@code $[returnValue]} placeholder.\n\t * Replaced with the {@code String} representation of the value\n\t * returned by the method invocation.\n\t */\n\tpublic static final String PLACEHOLDER_RETURN_VALUE = \"$[returnValue]\";\n\n\t/**\n\t * The {@code $[argumentTypes]} placeholder.\n\t * Replaced with a comma-separated list of the argument types for the\n\t * method invocation. Argument types are written as short class names.\n\t */\n\tpublic static final String PLACEHOLDER_ARGUMENT_TYPES = \"$[argumentTypes]\";\n\n\t/**\n\t * The {@code $[arguments]} placeholder.\n\t * Replaced with a comma separated list of the argument values for the\n\t * method invocation. Relies on the {@code toString()} method of\n\t * each argument type.\n\t */\n\tpublic static final String PLACEHOLDER_ARGUMENTS = \"$[arguments]\";\n\n\t/**\n\t * The {@code $[exception]} placeholder.\n\t * Replaced with the {@code String} representation of any\n\t * {@code Throwable} raised during method invocation.\n\t */\n\tpublic static final String PLACEHOLDER_EXCEPTION = \"$[exception]\";\n\n\t/**\n\t * The {@code $[invocationTime]} placeholder.\n\t * Replaced with the time taken by the invocation (in milliseconds).\n\t */\n\tpublic static final String PLACEHOLDER_INVOCATION_TIME = \"$[invocationTime]\";\n\n\t/**\n\t * The default message used for writing method entry messages.\n\t */\n\tprivate static final String DEFAULT_ENTER_MESSAGE = \"Entering method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The default message used for writing method exit messages.\n\t */\n\tprivate static final String DEFAULT_EXIT_MESSAGE = \"Exiting method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The default message used for writing exception messages.\n\t */\n\tprivate static final String DEFAULT_EXCEPTION_MESSAGE = \"Exception thrown in method '\" +\n\t\t\tPLACEHOLDER_METHOD_NAME + \"' of class [\" + PLACEHOLDER_TARGET_CLASS_NAME + \"]\";\n\n\t/**\n\t * The {@code Pattern} used to match placeholders.\n\t */\n\tprivate static final Pattern PATTERN = Pattern.compile(\"\\\\$\\\\[\\\\p{Alpha}+]\");\n\n\t/**\n\t * The {@code Set} of allowed placeholders.\n\t */\n\tstatic final Set<String> ALLOWED_PLACEHOLDERS = Set.of(\n\t\t\tPLACEHOLDER_METHOD_NAME,\n\t\t\tPLACEHOLDER_TARGET_CLASS_NAME,\n\t\t\tPLACEHOLDER_TARGET_CLASS_SHORT_NAME,\n\t\t\tPLACEHOLDER_RETURN_VALUE,\n\t\t\tPLACEHOLDER_ARGUMENT_TYPES,\n\t\t\tPLACEHOLDER_ARGUMENTS,\n\t\t\tPLACEHOLDER_EXCEPTION,\n\t\t\tPLACEHOLDER_INVOCATION_TIME);\n\n\n\t/**\n\t * The message for method entry.\n\t */\n\tprivate String enterMessage = DEFAULT_ENTER_MESSAGE;\n\n\t/**\n\t * The message for method exit.\n\t */\n\tprivate String exitMessage = DEFAULT_EXIT_MESSAGE;\n\n\t/**\n\t * The message for exceptions during method execution.\n\t */\n\tprivate String exceptionMessage = DEFAULT_EXCEPTION_MESSAGE;\n\n\n\t/**\n\t * Set the template used for method entry log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * </ul>\n\t */\n\tpublic void setEnterMessage(String enterMessage) throws IllegalArgumentException {\n\t\tAssert.hasText(enterMessage, \"enterMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(enterMessage);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_EXCEPTION);\n\t\tAssert.doesNotContain(enterMessage, PLACEHOLDER_INVOCATION_TIME,\n\t\t\t\t\"enterMessage cannot contain placeholder \" + PLACEHOLDER_INVOCATION_TIME);\n\t\tthis.enterMessage = enterMessage;\n\t}\n\n\t/**\n\t * Set the template used for method exit log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[returnValue]}</li>\n\t * <li>{@code $[invocationTime]}</li>\n\t * </ul>\n\t */\n\tpublic void setExitMessage(String exitMessage) {\n\t\tAssert.hasText(exitMessage, \"exitMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exitMessage);\n\t\tAssert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"exitMessage cannot contain placeholder\" + PLACEHOLDER_EXCEPTION);\n\t\tthis.exitMessage = exitMessage;\n\t}\n\n\t/**\n\t * Set the template used for method exception log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[exception]}</li>\n\t * </ul>\n\t */\n\tpublic void setExceptionMessage(String exceptionMessage) {\n\t\tAssert.hasText(exceptionMessage, \"exceptionMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exceptionMessage);\n\t\tAssert.doesNotContain(exceptionMessage, PLACEHOLDER_RETURN_VALUE,\n\t\t\t\t\"exceptionMessage cannot contain placeholder \" + PLACEHOLDER_RETURN_VALUE);\n\t\tthis.exceptionMessage = exceptionMessage;\n\t}\n\n\n\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */\n\t@Override\n\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */\n\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {\n\n\t\tObject target = methodInvocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\tStringBuilder output = new StringBuilder();\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tswitch (match) {\n\t\t\t\tcase PLACEHOLDER_METHOD_NAME -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(methodInvocation.getMethod().getName()));\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_NAME -> {\n\t\t\t\t\tString className = getClassForLogging(target).getName();\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(className));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_SHORT_NAME -> {\n\t\t\t\t\tString shortName = ClassUtils.getShortName(getClassForLogging(target));\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(shortName));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_ARGUMENTS -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())));\n\t\t\t\tcase PLACEHOLDER_ARGUMENT_TYPES -> appendArgumentTypes(methodInvocation, matcher, output);\n\t\t\t\tcase PLACEHOLDER_RETURN_VALUE -> appendReturnValue(methodInvocation, matcher, output, returnValue);\n\t\t\t\tcase PLACEHOLDER_EXCEPTION -> {\n\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_INVOCATION_TIME -> matcher.appendReplacement(output, Long.toString(invocationTime));\n\t\t\t\tdefault -> {\n\t\t\t\t\t// Should not happen since placeholders are checked earlier.\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown placeholder [\" + match + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatcher.appendTail(output);\n\n\t\treturn output.toString();\n\t}\n\n\t/**\n\t * Adds the {@code String} representation of the method return value\n\t * to the supplied {@code StringBuilder}. Correctly handles\n\t * {@code null} and {@code void} results.\n\t * @param methodInvocation the {@code MethodInvocation} that returned the value\n\t * @param matcher the {@code Matcher} containing the matched placeholder\n\t * @param output the {@code StringBuilder} to write output to\n\t * @param returnValue the value returned by the method invocation.\n\t */\n\tprivate static void appendReturnValue(\n\t\t\tMethodInvocation methodInvocation, Matcher matcher, StringBuilder output, @Nullable Object returnValue) {\n\n\t\tif (methodInvocation.getMethod().getReturnType() == void.class) {\n\t\t\tmatcher.appendReplacement(output, \"void\");\n\t\t}\n\t\telse if (returnValue == null) {\n\t\t\tmatcher.appendReplacement(output, \"null\");\n\t\t}\n\t\telse {\n\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(returnValue.toString()));\n\t\t}\n\t}\n\n\t/**\n\t * Adds a comma-separated list of the short {@code Class} names of the\n\t * method argument types to the output. For example, if a method has signature\n\t * {@code put(java.lang.String, java.lang.Object)} then the value returned\n\t * will be {@code String, Object}.\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Arguments will be retrieved from the corresponding {@code Method}.\n\t * @param matcher the {@code Matcher} containing the state of the output\n\t * @param output the {@code StringBuilder} containing the output\n\t */\n\tprivate static void appendArgumentTypes(MethodInvocation methodInvocation, Matcher matcher, StringBuilder output) {\n\t\tClass<?>[] argumentTypes = methodInvocation.getMethod().getParameterTypes();\n\t\tString[] argumentTypeShortNames = new String[argumentTypes.length];\n\t\tfor (int i = 0; i < argumentTypeShortNames.length; i++) {\n\t\t\targumentTypeShortNames[i] = ClassUtils.getShortName(argumentTypes[i]);\n\t\t}\n\t\tmatcher.appendReplacement(output,\n\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(argumentTypeShortNames)));\n\t}\n\n\t/**\n\t * Checks to see if the supplied {@code String} has any placeholders\n\t * that are not specified as constants on this class and throws an\n\t * {@code IllegalArgumentException} if so.\n\t */\n\tprivate static void checkForInvalidPlaceholders(String message) throws IllegalArgumentException {\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tif (!ALLOWED_PLACEHOLDERS.contains(match)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Placeholder [\" + match + \"] is not valid\");\n\t\t\t}\n\t\t}\n\t}\n\n}",
    "query": "Enhance your application's service layer by implementing a logging mechanism that records method entry, exit, and exceptions. The logs should include dynamic details such as method names, class names, arguments, return values, and execution times, all configurable through template messages.",
    "function_signature": "@Bean\npublic MethodInterceptor customizableTraceInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.ServletServerHttpRequest#initURI(servletRequest)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "public URI initURI(HttpServletRequest servletRequest)",
    "documentation": "\t/**\n\t * Initialize a URI from the given Servlet request.\n\t * @param servletRequest the request\n\t * @return the initialized URI\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static URI initURI(HttpServletRequest servletRequest) {\n\t\tString urlString = null;\n\t\tboolean hasQuery = false;\n\t\ttry {\n\t\t\tStringBuffer url = servletRequest.getRequestURL();\n\t\t\tString query = servletRequest.getQueryString();\n\t\t\thasQuery = StringUtils.hasText(query);\n\t\t\tif (hasQuery) {\n\t\t\t\turl.append('?').append(query);\n\t\t\t}\n\t\t\turlString = url.toString();\n\t\t\treturn new URI(urlString);\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tif (!hasQuery) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not resolve HttpServletRequest as URI: \" + urlString, ex);\n\t\t\t}\n\t\t\t// Maybe a malformed query string... try plain request URL\n\t\t\ttry {\n\t\t\t\turlString = servletRequest.getRequestURL().toString();\n\t\t\t\treturn new URI(urlString);\n\t\t\t}\n\t\t\tcatch (URISyntaxException ex2) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Could not resolve HttpServletRequest as URI: \" + urlString, ex2);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Design a Spring service that processes incoming HTTP requests by extracting and validating the full request URI, including any query parameters, to ensure accurate logging and downstream processing.",
    "function_signature": "public URI extractValidatedRequestUri(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.CustomizableTraceInterceptor#setExitMessage(exitMessage)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "public void setExitMessage(String exitMessage)",
    "documentation": "\t/**\n\t * Set the template used for method exit log messages.\n\t * This template can contain any of the following placeholders:\n\t * <ul>\n\t * <li>{@code $[targetClassName]}</li>\n\t * <li>{@code $[targetClassShortName]}</li>\n\t * <li>{@code $[argumentTypes]}</li>\n\t * <li>{@code $[arguments]}</li>\n\t * <li>{@code $[returnValue]}</li>\n\t * <li>{@code $[invocationTime]}</li>\n\t * </ul>\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setExitMessage(String exitMessage) {\n\t\tAssert.hasText(exitMessage, \"exitMessage must not be empty\");\n\t\tcheckForInvalidPlaceholders(exitMessage);\n\t\tAssert.doesNotContain(exitMessage, PLACEHOLDER_EXCEPTION,\n\t\t\t\t\"exitMessage cannot contain placeholder\" + PLACEHOLDER_EXCEPTION);\n\t\tthis.exitMessage = exitMessage;\n\t}",
    "query": "Design a method to enhance service layer logging by allowing customizable exit messages that include dynamic method information and execution time.",
    "function_signature": "public void setupCustomExitLogging(String exitMessageTemplate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#logException(ex,request)",
    "from_version": "v6.1.0-M2",
    "to_version": "v6.1.0-M3",
    "type": "method",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (ex instanceof NoHandlerFoundException || ex instanceof NoResourceFoundException) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(buildLogMessage(ex, request));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.logException(ex, request);\n\t}",
    "query": "Implement a mechanism to selectively log specific types of exceptions at the debug level within your application's request handling pipeline.",
    "function_signature": "protected void handleExceptionLogging(Exception ex, HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireConstructor(beanName,mbd,ctors,explicitArgs)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs)",
    "documentation": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected BeanWrapper autowireConstructor(",
    "query": "Design a bean initialization method that facilitates constructor-based dependency injection, accommodating both type-matched and manually supplied constructor arguments to instantiate beans dynamically.",
    "function_signature": "protected BeanWrapper initializeBeanConstructor(String beanName, RootBeanDefinition beanDefinition, @Nullable Constructor<?>[] candidateConstructors, @Nullable Object[] providedArgs)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditor",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "class",
    "signature": "public class ByteArrayMultipartFileEditor",
    "documentation": "/**\n * Custom {@link java.beans.PropertyEditor} for converting\n * {@link MultipartFile MultipartFiles} to byte arrays.\n *\n * @author Juergen Hoeller\n * @since 13.10.2003\n */",
    "changetype": "stabilized",
    "source_code": "public class ByteArrayMultipartFileEditor extends ByteArrayPropertyEditor {\n\n\t@Override\n\tpublic void setValue(@Nullable Object value) {\n\t\tif (value instanceof MultipartFile multipartFile) {\n\t\t\ttry {\n\t\t\t\tsuper.setValue(multipartFile.getBytes());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Cannot read contents of multipart file\", ex);\n\t\t\t}\n\t\t}\n\t\telse if (value instanceof byte[]) {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t\telse {\n\t\t\tsuper.setValue(value != null ? value.toString().getBytes() : null);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getAsText() {\n\t\tbyte[] value = (byte[]) getValue();\n\t\treturn (value != null ? new String(value) : \"\");\n\t}\n\n}",
    "query": "Design a Spring MVC controller method that accepts a file upload and directly binds its content to a byte array parameter for streamlined processing.",
    "function_signature": "public ResponseEntity<String> uploadDocument(@RequestParam(\"file\") byte[] documentData)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.oxm.xstream.XStreamMarshaller#setUseAttributeForTypes(useAttributeForTypes)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "public void setUseAttributeForTypes(Class<?>... useAttributeForTypes)",
    "documentation": "\t/**\n\t * Set types to use XML attributes for.\n\t * @see XStream#useAttributeFor(Class)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setUseAttributeForTypes(Class<?>... useAttributeForTypes) {\n\t\tthis.useAttributeForTypes = useAttributeForTypes;\n\t}",
    "query": "You need to optimize your XML output by representing specific data types as attributes rather than elements. How would you configure your XML marshaller to achieve this customization?",
    "function_signature": "public void configureAttributeSerializationForTypes(Class<?>... types)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.DefaultNamingPolicy#equals(o)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "public boolean equals(Object o)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "    public boolean equals(Object o) {\n        return (o instanceof DefaultNamingPolicy defaultNamingPolicy) &&\n                defaultNamingPolicy.getTag().equals(getTag());\n    }",
    "query": "Develop a feature within a Spring application that ensures dynamically created proxy classes adhere to a consistent naming convention, allowing for reliable identification and comparison of these proxies across different modules.",
    "function_signature": "public boolean compareProxyNamingPolicies(Object policy)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods(handler)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "protected void detectHandlerMethods(Object handler)",
    "documentation": "\t/**\n\t * Look for handler methods in the specified handler bean.\n\t * @param handler either a bean name or an actual handler instance\n\t * @see #getMappingForMethod\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void detectHandlerMethods(Object handler) {\n\t\tClass<?> handlerType = (handler instanceof String beanName ?\n\t\t\t\tobtainApplicationContext().getType(beanName) : handler.getClass());\n\n\t\tif (handlerType != null) {\n\t\t\tClass<?> userType = ClassUtils.getUserClass(handlerType);\n\t\t\tMap<Method, T> methods = MethodIntrospector.selectMethods(userType,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<T>) method -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn getMappingForMethod(method, userType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Invalid mapping on handler class [\" +\n\t\t\t\t\t\t\t\t\tuserType.getName() + \"]: \" + method, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(formatMappings(userType, methods));\n\t\t\t}\n\t\t\telse if (mappingsLogger.isDebugEnabled()) {\n\t\t\t\tmappingsLogger.debug(formatMappings(userType, methods));\n\t\t\t}\n\t\t\tmethods.forEach((method, mapping) -> {\n\t\t\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, userType);\n\t\t\t\tregisterHandlerMethod(handler, invocableMethod, mapping);\n\t\t\t});\n\t\t}\n\t}",
    "query": "Create a Spring MVC configuration that dynamically identifies and registers all request-handling methods within a specified controller bean, ensuring that any newly added handler methods are automatically detected and mapped without additional setup.",
    "function_signature": "protected void configureDynamicHandlerDetection(Object controllerBean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.codec.NettyByteBufEncoder",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "class",
    "signature": "public class NettyByteBufEncoder",
    "documentation": "/**\n * Encoder for {@link ByteBuf ByteBufs}.\n *\n * @author Vladislav Kisel\n * @since 5.3\n */",
    "changetype": "stabilized",
    "source_code": "public class NettyByteBufEncoder extends AbstractEncoder<ByteBuf> {\n\n\tpublic NettyByteBufEncoder() {\n\t\tsuper(MimeTypeUtils.ALL);\n\t}\n\n\n\t@Override\n\tpublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tClass<?> clazz = type.toClass();\n\t\treturn super.canEncode(type, mimeType) && ByteBuf.class.isAssignableFrom(clazz);\n\t}\n\n\t@Override\n\tpublic Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(inputStream).map(byteBuffer ->\n\t\t\t\tencodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));\n\t}\n\n\t@Override\n\tpublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\n\t\t\treturn nettyDataBufferFactory.wrap(byteBuf);\n\t\t}\n\t\tbyte[] bytes = new byte[byteBuf.readableBytes()];\n\t\tbyteBuf.readBytes(bytes);\n\t\tbyteBuf.release();\n\t\treturn bufferFactory.wrap(bytes);\n\t}\n}",
    "query": "Design a reactive service that processes incoming binary data streams from a Netty-based source, ensuring efficient encoding and seamless integration with Spring's data buffering mechanisms.",
    "function_signature": "public Flux<DataBuffer> processIncomingBinaryStream(Publisher<ByteBuf> binaryStream, DataBufferFactory bufferFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.rsocket.service.RSocketServiceProxyFactory#embeddedValueResolver(resolver)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "public Builder embeddedValueResolver(StringValueResolver resolver)",
    "documentation": "\t\t/**\n\t\t * Set the {@link StringValueResolver} to use for resolving placeholders\n\t\t * and expressions embedded in {@link RSocketExchange#value()}.\n\t\t * @param resolver the resolver to use\n\t\t * @return this same builder instance\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic Builder embeddedValueResolver(StringValueResolver resolver) {\n\t\t\tthis.embeddedValueResolver = resolver;\n\t\t\treturn this;\n\t\t}",
    "query": "In a microservices architecture using RSocket, you need to ensure that message payloads can dynamically incorporate environment-specific configurations without hardcoding values. How would you configure your RSocket service proxy to resolve these placeholders at runtime?",
    "function_signature": "public Builder configurePlaceholderResolver(StringValueResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.ReflectiveMethodInvocation#getUserAttribute(key)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "public Object getUserAttribute(String key)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object getUserAttribute(String key) {\n\t\treturn (this.userAttributes != null ? this.userAttributes.get(key) : null);\n\t}",
    "query": "Develop an interceptor that retrieves and utilizes custom attributes tied to method invocations to influence the execution flow within your Spring application.",
    "function_signature": "public void interceptWithCustomAttributes(MethodInvocation invocation);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.config.ScheduledTaskRegistrar#setTriggerTasksList(triggerTasks)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "public void setTriggerTasksList(List<TriggerTask> triggerTasks)",
    "documentation": "\t/**\n\t * Specify triggered tasks as a list of {@link TriggerTask} objects. Primarily used\n\t * by {@code <task:*>} namespace parsing.\n\t * @since 3.2\n\t * @see ScheduledTasksBeanDefinitionParser\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setTriggerTasksList(List<TriggerTask> triggerTasks) {\n\t\tthis.triggerTasks = triggerTasks;\n\t}",
    "query": "Implement a service that allows for the registration of multiple scheduled operations, each with its own triggering logic, to enable dynamic and flexible task scheduling based on varying runtime conditions.",
    "function_signature": "public void registerScheduledTasks(List<TriggerTask> tasks)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.accept.ContentNegotiationManager#getStrategy(strategyType)",
    "from_version": "v5.3.25",
    "to_version": "v6.0.4",
    "type": "method",
    "signature": "public T getStrategy(Class<T> strategyType)",
    "documentation": "\t/**\n\t * Find a {@code ContentNegotiationStrategy} of the given type.\n\t * @param strategyType the strategy type\n\t * @return the first matching strategy, or {@code null} if none\n\t * @since 4.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic <T extends ContentNegotiationStrategy> T getStrategy(Class<T> strategyType) {\n\t\tfor (ContentNegotiationStrategy strategy : getStrategies()) {\n\t\t\tif (strategyType.isInstance(strategy)) {\n\t\t\t\treturn (T) strategy;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}",
    "query": "Create a Spring service method that selects and applies a specific strategy for determining response formats based on custom criteria extracted from incoming HTTP requests. This approach should allow for easily swapping out strategies without modifying the core logic of the service.",
    "function_signature": "public ResponseEntity<?> determineResponseFormat(Class<? extends ContentNegotiationStrategy> strategyType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.<unknown>#iterator()",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public Iterator<String> iterator()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.names());\n\t\t}",
    "query": "Create a method that efficiently traverses header names, ensuring optimal performance and enhanced type safety.",
    "function_signature": "public Stream<String> streamHeaderNames()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.JdbcTemplate#query(sql,rowMapper)",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}",
    "query": "Design a method to execute a SQL query that efficiently transforms the result set into a list of domain objects. Ensure that the implementation leverages the most recent enhancements in the Spring Framework to maximize performance and maintainability.",
    "function_signature": "public List<T> executeQuery(String sql, ResultSetExtractor<List<T>> extractor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.GenericXmlContextLoader",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "class",
    "signature": "public class GenericXmlContextLoader",
    "documentation": "/**\n * Concrete implementation of {@link AbstractGenericContextLoader} that reads\n * bean definitions from XML resources.\n *\n * <p>Default resource locations are detected using the suffix\n * {@code \"-context.xml\"}.\n *\n * @author Sam Brannen\n * @since 2.5\n * @see XmlBeanDefinitionReader\n * @see GenericGroovyXmlContextLoader\n * @see AnnotationConfigContextLoader\n */",
    "changetype": "deprecated",
    "source_code": "public class GenericXmlContextLoader extends AbstractGenericContextLoader {\n\n\t/**\n\t * Create a new {@link XmlBeanDefinitionReader}.\n\t * @return a new {@code XmlBeanDefinitionReader}\n\t */\n\t@Override\n\tprotected BeanDefinitionReader createBeanDefinitionReader(GenericApplicationContext context) {\n\t\treturn new XmlBeanDefinitionReader(context);\n\t}\n\n\t/**\n\t * Returns {@code \"-context.xml\"} in order to support detection of a\n\t * default XML config file.\n\t */\n\t@Override\n\tprotected String getResourceSuffix() {\n\t\treturn \"-context.xml\";\n\t}\n\n\t/**\n\t * Ensure that the supplied {@link MergedContextConfiguration} does not\n\t * contain {@link MergedContextConfiguration#getClasses() classes}.\n\t * @since 4.0.4\n\t * @see AbstractGenericContextLoader#validateMergedContextConfiguration\n\t */\n\t@Override\n\tprotected void validateMergedContextConfiguration(MergedContextConfiguration mergedConfig) {\n\t\tif (mergedConfig.hasClasses()) {\n\t\t\tString msg = \"\"\"\n\t\t\t\t\tTest class [%s] has been configured with @ContextConfiguration's 'classes' attribute %s, \\\n\t\t\t\t\tbut %s does not support annotated classes.\"\"\".formatted(mergedConfig.getTestClass().getName(),\n\t\t\t\t\t\tArrays.toString(mergedConfig.getClasses()), getClass().getSimpleName());\n\t\t\tlogger.error(msg);\n\t\t\tthrow new IllegalStateException(msg);\n\t\t}\n\t}\n\n}",
    "query": "Refactor the test configuration setup to enhance type safety and improve startup performance by leveraging the latest annotation-based context initialization approach.",
    "function_signature": "public AnnotationConfigApplicationContext initializeTestContext(Class<?>... configClasses)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#resumeReceiving()",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "protected void resumeReceiving()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected void resumeReceiving() {\n\t\tSuspendToken tokenToUse = this.suspendToken;\n\t\tthis.suspendToken = null;\n\t\tif (tokenToUse != null) {\n\t\t\ttokenToUse.resume();\n\t\t}\n\t}",
    "query": "Design a method to seamlessly handle the activation of message intake in a reactive WebSocket session, prioritizing enhanced performance and thread safety.",
    "function_signature": "protected void activateMessageIntake()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.AopUtils#isJdkDynamicProxy(object)",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public boolean isJdkDynamicProxy(@Nullable Object object)",
    "documentation": "\t/**\n\t * Check whether the given object is a JDK dynamic proxy.\n\t * <p>This method goes beyond the implementation of\n\t * {@link Proxy#isProxyClass(Class)} by additionally checking if the\n\t * given object is an instance of {@link SpringProxy}.\n\t * @param object the object to check\n\t * @see java.lang.reflect.Proxy#isProxyClass\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static boolean isJdkDynamicProxy(@Nullable Object object) {\n\t\treturn (object instanceof SpringProxy && Proxy.isProxyClass(object.getClass()));\n\t}",
    "query": "Develop a functionality to assess whether a given instance is proxied by Spring's AOP framework, considering all supported proxy types.",
    "function_signature": "public boolean isAopProxy(Object object);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.ValidationUtils#rejectIfEmptyOrWhitespace(errors,field,errorCode,defaultMessage)",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, String defaultMessage)",
    "documentation": "\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace(",
    "query": "Design a validation method that checks whether a user-provided input for a specific field is neither empty nor contains only whitespace. Ensure that the solution leverages the most recent and efficient validation practices to enhance maintainability and performance.",
    "function_signature": "public void ensureFieldIsNotBlank(Errors errors, String field, String errorCode, String defaultMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.resource.VersionResourceResolver#getURI()",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public URI getURI()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic URI getURI() throws IOException {\n\t\t\treturn this.original.getURI();\n\t\t}",
    "query": "Develop a method to efficiently obtain the URI of a resource, ensuring improved performance and reliability compared to conventional techniques.",
    "function_signature": "public URI resolveResourceURI()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.PathResource#writableChannel()",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public WritableByteChannel writableChannel()",
    "documentation": "\t/**\n\t * This implementation opens a {@link WritableByteChannel} for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic WritableByteChannel writableChannel() throws IOException {\n\t\treturn Files.newByteChannel(this.path, StandardOpenOption.WRITE);\n\t}",
    "query": "Design a method that provides a high-performance and thread-safe mechanism for writing bytes to a file, ensuring better resource management and scalability.",
    "function_signature": "public WritableByteChannel createSafeWriteChannel(Path filePath) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.CollectionUtils#findFirstMatch(source,candidates)",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "public E findFirstMatch(Collection<?> source, Collection<E> candidates)",
    "documentation": "\t/**\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\n\t\tif (isEmpty(source) || isEmpty(candidates)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (E candidate : candidates) {\n\t\t\tif (source.contains(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}",
    "query": "Develop a utility method that efficiently identifies the initial overlapping element between two collections, enhancing performance and ensuring safer handling of absent results.",
    "function_signature": "public Optional<E> retrieveInitialMatch(Collection<?> source, Collection<E> candidates)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#allowPublicMethodsOnly()",
    "from_version": "v6.0.17",
    "to_version": "v5.3.32",
    "type": "method",
    "signature": "protected boolean allowPublicMethodsOnly()",
    "documentation": "\t/**\n\t * By default, only public methods can be made transactional.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected boolean allowPublicMethodsOnly() {\n\t\treturn this.publicMethodsOnly;\n\t}",
    "query": "Design a transaction management setup that supports transactional behavior on both public and non-public methods to enhance flexibility and performance.",
    "function_signature": "protected boolean allowTransactionalNonPublicMethods()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.HandlerMappingIntrospector",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "class",
    "signature": "public class HandlerMappingIntrospector",
    "documentation": "/**\n * Helper class to get information from the {@code HandlerMapping} that would\n * serve a specific request.\n *\n * <p>Provides the following methods:\n * <ul>\n * <li>{@link #getMatchableHandlerMapping} &mdash; obtain a {@code HandlerMapping}\n * to check request-matching criteria against.\n * <li>{@link #getCorsConfiguration} &mdash; obtain the CORS configuration for the\n * request.\n * </ul>\n *\n * <p><strong>Note:</strong> This is primarily an SPI to allow Spring Security\n * to align its pattern matching with the same pattern matching that would be\n * used in Spring MVC for a given request, in order to avoid security issues.\n * Use of this introspector should be avoided for other purposes because it\n * incurs the overhead of resolving the handler for a request.\n *\n * @author Rossen Stoyanchev\n * @since 4.3.1\n */",
    "changetype": "deprecated",
    "source_code": "public class HandlerMappingIntrospector",
    "query": "Design a component that efficiently matches incoming HTTP requests to their corresponding handlers, minimizing performance overhead and ensuring compatibility with Spring Security's pattern matching. The solution should avoid unnecessary resolution steps and provide a streamlined approach for request handling.",
    "function_signature": "public HandlerResolver optimizedHandlerResolver(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory#getParameterNames(ctor)",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "public String[] getParameterNames(Constructor<?> ctor)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\t\tthrow new UnsupportedOperationException(\"Spring AOP cannot handle constructor advice\");\n\t\t}",
    "query": "Develop a utility that efficiently extracts constructor parameter names to improve the robustness and maintainability of your aspect-oriented configurations within the Spring Framework.",
    "function_signature": "public String[] resolveConstructorParameterNames(Constructor<?> constructor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters(inputMessage,parameter,targetType)",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "protected Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType)",
    "documentation": "\t/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param parameter the method parameter descriptor\n\t * @param targetType the target type, not necessarily the same as the method\n\t * parameter type, e.g. for {@code HttpEntity<String>}.\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,",
    "query": "Craft a method responsible for interpreting HTTP input messages into specific argument types, ensuring improved performance and reliability by leveraging the framework's latest message processing mechanisms.",
    "function_signature": "protected <T> Object readBody(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.oxm.jaxb.Jaxb2Marshaller#setMtomEnabled(mtomEnabled)",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "public void setMtomEnabled(boolean mtomEnabled)",
    "documentation": "\t/**\n\t * Specify whether MTOM support should be enabled or not.\n\t * Default is {@code false}: marshalling using XOP/MTOM not being enabled.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setMtomEnabled(boolean mtomEnabled) {\n\t\tthis.mtomEnabled = mtomEnabled;\n\t}",
    "query": "Enhance the marshalling process to efficiently handle binary data while improving performance and ensuring thread safety.",
    "function_signature": "public void setMarshallerProperties(Map<String, Object> marshallerProperties)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.format.number.PercentStyleFormatter#getNumberFormat(locale)",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "protected NumberFormat getNumberFormat(Locale locale)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected NumberFormat getNumberFormat(Locale locale) {\n\t\tNumberFormat format = NumberFormat.getPercentInstance(locale);\n\t\tif (format instanceof DecimalFormat decimalFormat) {\n\t\t\tdecimalFormat.setParseBigDecimal(true);\n\t\t}\n\t\treturn format;\n\t}",
    "query": "Create a method that generates a locale-specific percentage formatter with enhanced precision and thread safety.",
    "function_signature": "protected NumberFormat createLocalePercentFormatter(Locale locale)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.FunctionReference",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "class",
    "signature": "public class FunctionReference",
    "documentation": "/**\n * A function reference is of the form \"#someFunction(a,b,c)\". Functions may be defined\n * in the context prior to the expression being evaluated. Functions may also be static\n * Java methods, registered in the context prior to invocation of the expression.\n *\n * <p>Functions are very simplistic. The arguments are not part of the definition\n * (right now), so the names must be unique.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public class FunctionReference extends SpelNodeImpl {\n\n\tprivate final String name;\n\n\t// Captures the most recently used method for the function invocation *if* the method\n\t// can safely be used for compilation (i.e. no argument conversion is going on)\n\t@Nullable\n\tprivate volatile Method method;\n\n\n\tpublic FunctionReference(String functionName, int startPos, int endPos, SpelNodeImpl... arguments) {\n\t\tsuper(startPos, endPos, arguments);\n\t\tthis.name = functionName;\n\t}\n\n\n\t@Override\n\tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n\t\tTypedValue value = state.lookupVariable(this.name);\n\t\tif (value == TypedValue.NULL) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.FUNCTION_NOT_DEFINED, this.name);\n\t\t}\n\t\tObject resolvedValue = value.getValue();\n\t\tif (resolvedValue instanceof MethodHandle methodHandle) {\n\t\t\ttry {\n\t\t\t\treturn executeFunctionBoundMethodHandle(state, methodHandle);\n\t\t\t}\n\t\t\tcatch (SpelEvaluationException ex) {\n\t\t\t\tex.setPosition(getStartPosition());\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\tif (!(resolvedValue instanceof Method function)) {\n\t\t\t// Possibly a static Java method registered as a function\n\t\t\tthrow new SpelEvaluationException(\n\t\t\t\t\tSpelMessage.FUNCTION_REFERENCE_CANNOT_BE_INVOKED, this.name, value.getClass());\n\t\t}\n\n\t\ttry {\n\t\t\treturn executeFunctionJLRMethod(state, function);\n\t\t}\n\t\tcatch (SpelEvaluationException ex) {\n\t\t\tex.setPosition(getStartPosition());\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Execute a function represented as a {@code java.lang.reflect.Method}.\n\t * @param state the expression evaluation state\n\t * @param method the method to invoke\n\t * @return the return value of the invoked Java method\n\t * @throws EvaluationException if there is any problem invoking the method\n\t */\n\tprivate TypedValue executeFunctionJLRMethod(ExpressionState state, Method method) throws EvaluationException {\n\t\tObject[] functionArgs = getArguments(state);\n\n\t\tif (!method.isVarArgs()) {\n\t\t\tint declaredParamCount = method.getParameterCount();\n\t\t\tif (declaredParamCount != functionArgs.length) {\n\t\t\t\tthrow new SpelEvaluationException(SpelMessage.INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION,\n\t\t\t\t\t\tfunctionArgs.length, declaredParamCount);\n\t\t\t}\n\t\t}\n\t\tif (!Modifier.isStatic(method.getModifiers())) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(),\n\t\t\t\t\tSpelMessage.FUNCTION_MUST_BE_STATIC, ClassUtils.getQualifiedMethodName(method), this.name);\n\t\t}\n\n\t\t// Convert arguments if necessary and remap them for varargs if required\n\t\tTypeConverter converter = state.getEvaluationContext().getTypeConverter();\n\t\tboolean argumentConversionOccurred = ReflectionHelper.convertAllArguments(converter, functionArgs, method);\n\t\tif (method.isVarArgs()) {\n\t\t\tfunctionArgs = ReflectionHelper.setupArgumentsForVarargsInvocation(\n\t\t\t\t\tmethod.getParameterTypes(), functionArgs);\n\t\t}\n\t\tboolean compilable = false;\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tObject result = method.invoke(method.getClass(), functionArgs);\n\t\t\tcompilable = !argumentConversionOccurred;\n\t\t\treturn new TypedValue(result, new TypeDescriptor(new MethodParameter(method, -1)).narrow(result));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_FUNCTION_CALL,\n\t\t\t\t\tthis.name, ex.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tif (compilable) {\n\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n\t\t\t\tthis.method = method;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.exitTypeDescriptor = null;\n\t\t\t\tthis.method = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Execute a function represented as {@code java.lang.invoke.MethodHandle}.\n\t * Method types that take no arguments (fully bound handles or static methods\n\t * with no parameters) can use {@code #invoke()} which is the most efficient.\n\t * Otherwise, {@code #invokeWithArguments)} is used.\n\t * @param state the expression evaluation state\n\t * @param methodHandle the method to invoke\n\t * @return the return value of the invoked Java method\n\t * @throws EvaluationException if there is any problem invoking the method\n\t * @since 6.1\n\t */\n\tprivate TypedValue executeFunctionBoundMethodHandle(ExpressionState state, MethodHandle methodHandle) throws EvaluationException {\n\t\tObject[] functionArgs = getArguments(state);\n\t\tMethodType declaredParams = methodHandle.type();\n\t\tint spelParamCount = functionArgs.length;\n\t\tint declaredParamCount = declaredParams.parameterCount();\n\n\t\tboolean isSuspectedVarargs = declaredParams.lastParameterType().isArray();\n\n\t\tif (spelParamCount < declaredParamCount || (spelParamCount > declaredParamCount\n\t\t\t\t&& !isSuspectedVarargs)) {\n\t\t\t//incorrect number, including more arguments and not a vararg\n\t\t\tthrow new SpelEvaluationException(SpelMessage.INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION,\n\t\t\t\t\tfunctionArgs.length, declaredParamCount);\n\t\t\t//perhaps a subset of arguments was provided but the MethodHandle wasn't bound?\n\t\t}\n\n\t\t// simplest case: the MethodHandle is fully bound or represents a static method with no params:\n\t\tif (declaredParamCount == 0) {\n\t\t\t//note we consider MethodHandles not compilable\n\t\t\ttry {\n\t\t\t\treturn new TypedValue(methodHandle.invoke());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_FUNCTION_CALL,\n\t\t\t\t\t\tthis.name, ex.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.exitTypeDescriptor = null;\n\t\t\t\tthis.method = null;\n\t\t\t}\n\t\t}\n\n\t\t// more complex case, we need to look at conversion and vararg repacking\n\t\tInteger varArgPosition = null;\n\t\tif (isSuspectedVarargs) {\n\t\t\tvarArgPosition = declaredParamCount - 1;\n\t\t}\n\t\tTypeConverter converter = state.getEvaluationContext().getTypeConverter();\n\t\tReflectionHelper.convertAllMethodHandleArguments(converter, functionArgs, methodHandle, varArgPosition);\n\n\t\tif (isSuspectedVarargs && declaredParamCount == 1) {\n\t\t\t//we only repack the varargs if it is the ONLY argument\n\t\t\tfunctionArgs = ReflectionHelper.setupArgumentsForVarargsInvocation(\n\t\t\t\t\tmethodHandle.type().parameterArray(), functionArgs);\n\t\t}\n\n\t\t//note we consider MethodHandles not compilable\n\t\ttry {\n\t\t\treturn new TypedValue(methodHandle.invokeWithArguments(functionArgs));\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SpelEvaluationException(getStartPosition(), ex, SpelMessage.EXCEPTION_DURING_FUNCTION_CALL,\n\t\t\t\t\tthis.name, ex.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tthis.exitTypeDescriptor = null;\n\t\t\tthis.method = null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toStringAST() {\n\t\tStringJoiner sj = new StringJoiner(\",\", \"(\", \")\");\n\t\tfor (int i = 0; i < getChildCount(); i++) {\n\t\t\tsj.add(getChild(i).toStringAST());\n\t\t}\n\t\treturn '#' + this.name + sj;\n\t}\n\n\t/**\n\t * Compute the arguments to the function, they are the children of this expression node.\n\t * @return an array of argument values for the function call\n\t */\n\tprivate Object[] getArguments(ExpressionState state) throws EvaluationException {\n\t\t// Compute arguments to the function\n\t\tObject[] arguments = new Object[getChildCount()];\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\targuments[i] = this.children[i].getValueInternal(state).getValue();\n\t\t}\n\t\treturn arguments;\n\t}\n\n\t@Override\n\tpublic boolean isCompilable() {\n\t\tMethod method = this.method;\n\t\tif (method == null) {\n\t\t\treturn false;\n\t\t}\n\t\tint methodModifiers = method.getModifiers();\n\t\tif (!Modifier.isStatic(methodModifiers) || !Modifier.isPublic(methodModifiers) ||\n\t\t\t\t!Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (SpelNodeImpl child : this.children) {\n\t\t\tif (!child.isCompilable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tMethod method = this.method;\n\t\tAssert.state(method != null, \"No method handle\");\n\t\tString classDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn(INVOKESTATIC, classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), false);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}\n\n}",
    "query": "Improve the execution of custom functions within Spring Expression Language (SpEL) expressions by adopting a more efficient and type-safe approach. Ensure that the solution enhances performance and maintains robust error handling without relying on outdated mechanisms.",
    "function_signature": "public TypedValue executeCustomFunction(ExpressionState state, String functionName, Object... args) throws EvaluationException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getProtocolConnectionId()",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "public String getProtocolConnectionId()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\t\tpublic String getProtocolConnectionId() {\n\t\t\t\treturn MockHttpServletRequest.this.getProtocolRequestId();\n\t\t\t}",
    "query": "Enhance your mock HTTP servlet handling by adopting a more efficient approach to retrieve protocol-related identifiers, ensuring better performance and reliability in your tests.",
    "function_signature": "public String fetchProtocolRequestId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService#start()",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "public void start()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void start() {\n\t\tif (!isRunning()) {\n\t\t\tthis.running = true;\n\t\t\tdoStart();\n\t\t}\n\t}",
    "query": "Design a component responsible for initializing and managing WebSocket connections with improved performance and enhanced security. Ensure that the startup process is reliable and aligns with the latest best practices in reactive programming.",
    "function_signature": "public void initializeWebSocketService()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.BeanDefinitionHolder#getShortDescription()",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "public String getShortDescription()",
    "documentation": "\t/**\n\t * Return a friendly, short description for the bean, stating name and aliases.\n\t * @see #getBeanName()\n\t * @see #getAliases()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String getShortDescription() {\n\t\tif (this.aliases == null) {\n\t\t\treturn \"Bean definition with name '\" + this.beanName + \"'\";\n\t\t}\n\t\treturn \"Bean definition with name '\" + this.beanName + \"' and aliases [\" + StringUtils.arrayToCommaDelimitedString(this.aliases) + ']';\n\t}",
    "query": "Design a method that constructs a descriptive string for a bean by combining its primary name with any aliases, enhancing clarity and performance.",
    "function_signature": "public String buildBeanDescription(BeanDefinitionHolder holder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)",
    "from_version": "v6.1.0-M4",
    "to_version": "v5.3.30",
    "type": "method",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.uriString(uriTemplate)));\n\t\t}",
    "query": "Develop a method to configure the endpoint of an HTTP request by supplying a fully constructed URI, enhancing performance and ensuring safer URI handling.",
    "function_signature": "public RequestBodySpec setUri(URI uri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.HttpHeaders#setConnection(connection)",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public void setConnection(List<String> connection)",
    "documentation": "\t/**\n\t * Set the (new) value of the {@code Connection} header.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setConnection(List<String> connection) {\n\t\tset(CONNECTION, toCommaDelimitedString(connection));\n\t}",
    "query": "Update the HTTP headers to manage the 'Connection' directive efficiently, ensuring that only a single, well-formatted connection value is utilized for optimal performance and simplicity.",
    "function_signature": "public void setConnection(String connection)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getDefaultReturnValueHandlers()",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "protected List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers()",
    "documentation": "\t/**\n\t * Return the list of return value handlers to use including built-in and\n\t * custom handlers provided via {@link #setReturnValueHandlers}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {\n\t\tList<HandlerMethodReturnValueHandler> handlers = new ArrayList<>();\n\n\t\t// Single-purpose return value types\n\t\thandlers.add(new ModelAndViewMethodReturnValueHandler());\n\t\thandlers.add(new ModelMethodProcessor());\n\t\thandlers.add(new ViewMethodReturnValueHandler());\n\t\thandlers.add(new HttpEntityMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice,\n\t\t\t\tthis.errorResponseInterceptors));\n\n\t\t// Annotation-based return value types\n\t\thandlers.add(new ServletModelAttributeMethodProcessor(false));\n\t\thandlers.add(new RequestResponseBodyMethodProcessor(\n\t\t\t\tgetMessageConverters(), this.contentNegotiationManager, this.responseBodyAdvice,\n\t\t\t\tthis.errorResponseInterceptors));\n\n\t\t// Multi-purpose return value types\n\t\thandlers.add(new ViewNameMethodReturnValueHandler());\n\t\thandlers.add(new MapMethodProcessor());\n\n\t\t// Custom return value types\n\t\tif (getCustomReturnValueHandlers() != null) {\n\t\t\thandlers.addAll(getCustomReturnValueHandlers());\n\t\t}\n\n\t\t// Catch-all\n\t\thandlers.add(new ServletModelAttributeMethodProcessor(true));\n\n\t\treturn handlers;\n\t}",
    "query": "Optimize your web application's response processing by implementing a strategy that allows for the seamless integration and customization of return value handlers. Ensure that your solution enhances performance and maintainability by leveraging the latest framework capabilities.",
    "function_signature": "protected void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockPageContext#findAttribute(name)",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public Object findAttribute(String name)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Object findAttribute(String name) {\n\t\tObject value = getAttribute(name);\n\t\tif (value == null) {\n\t\t\tvalue = getAttribute(name, REQUEST_SCOPE);\n\t\t\tif (value == null) {\n\t\t\t\tvalue = getAttribute(name, SESSION_SCOPE);\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = getAttribute(name, APPLICATION_SCOPE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}",
    "query": "Develop a utility method to access a specific context attribute directly, ensuring streamlined performance by targeting the exact scope required.",
    "function_signature": "public Object retrieveAttribute(String name, int scope)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.ChannelSendOperator#subscribe(writeSubscriber)",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public void subscribe(Subscriber<? super T> writeSubscriber)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void subscribe(Subscriber<? super T> writeSubscriber) {\n\t\t\tsynchronized (this) {\n\t\t\t\tAssert.state(this.writeSubscriber == null, \"Only one write subscriber supported\");\n\t\t\t\tthis.writeSubscriber = writeSubscriber;\n\t\t\t\tif (this.error != null || this.completed) {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(Operators.emptySubscription());\n\t\t\t\t\temitCachedSignals();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.writeSubscriber.onSubscribe(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Refactor the reactive HTTP server component to handle multiple write subscribers efficiently, ensuring thread safety and optimal resource utilization. Address the limitations in the current implementation that hinder scalability and maintainability.",
    "function_signature": "public void registerWriteSubscriber(Subscriber<? super T> subscriber)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.EncoderHttpMessageWriter#canWrite(elementType,mediaType)",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}",
    "query": "Develop a method to verify if a specific element type and media type are supported for encoding, utilizing the most efficient encoding strategy available to enhance performance and reliability.",
    "function_signature": "public boolean canEncode(ResolvableType elementType, @Nullable MediaType mediaType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.WebClientResponseException#getRawStatusCode()",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public int getRawStatusCode()",
    "documentation": "\t/**\n\t * Return the raw HTTP status code value.\n\t * @deprecated as of 6.0, in favor of {@link #getStatusCode()}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic int getRawStatusCode() {\n\t\treturn this.statusCode.value();\n\t}",
    "query": "Enhance your application's error handling by retrieving HTTP response statuses in a manner that promotes type safety and improves code readability.",
    "function_signature": "public HttpStatus getStatusCode()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.generate.DefaultMethodReference#toString()",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String toString() {\n\t\tString methodName = this.method.name;\n\t\tif (isStatic()) {\n\t\t\treturn this.declaringClass + \"::\" + methodName;\n\t\t}\n\t\telse {\n\t\t\treturn (this.declaringClass != null ?\n\t\t\t\t\t\"<\" + this.declaringClass + \">\" : \"<instance>\") + \"::\" + methodName;\n\t\t}\n\t}",
    "query": "Design a utility that efficiently generates string representations of method references, enhancing performance and ensuring thread safety without relying on less optimal approaches.",
    "function_signature": "public String formatMethodReference(MethodReference methodRef)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar#setDateFormatter(formatter)",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public void setDateFormatter(DateTimeFormatter formatter)",
    "documentation": "\t/**\n\t * Set the formatter that will be used for objects representing date values.\n\t * <p>This formatter will be used for the {@link LocalDate} type.\n\t * When specified, the {@link #setDateStyle dateStyle} and\n\t * {@link #setUseIsoFormat useIsoFormat} properties will be ignored.\n\t * @param formatter the formatter to use\n\t * @see #setTimeFormatter\n\t * @see #setDateTimeFormatter\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setDateFormatter(DateTimeFormatter formatter) {\n\t\tthis.formatters.put(Type.DATE, formatter);\n\t}",
    "query": "Enhance date handling in your Spring application by adopting a formatting strategy that accommodates both dates and times efficiently.",
    "function_signature": "public void setDateTimeFormatter(DateTimeFormatter formatter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.connection.DelegatingConnectionFactory#shouldStop(con)",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "method",
    "signature": "public boolean shouldStop(Connection con)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean shouldStop(Connection con) {\n\t\treturn this.shouldStopConnections;\n\t}",
    "query": "Enhance your JMS application's reliability by implementing a mechanism that verifies the vitality of each connection before usage, thereby preventing potential disruptions and improving overall performance.",
    "function_signature": "public boolean isConnectionHealthy(Connection connection)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.APPLICATION_GRAPHQL_RESPONSE_VALUE",
    "from_version": "v6.2.0-M1",
    "to_version": "v5.3.35",
    "type": "field",
    "signature": "public String APPLICATION_GRAPHQL_RESPONSE_VALUE",
    "documentation": "\t/**\n\t * A String equivalent of {@link MediaType#APPLICATION_GRAPHQL_RESPONSE}.\n\t * @since 6.0.3\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final String APPLICATION_GRAPHQL_RESPONSE_VALUE = \"application/graphql-response+json\";",
    "query": "Design a service method that specifies the media type for GraphQL responses, ensuring type safety and compatibility with the latest framework standards.",
    "function_signature": "public ResponseEntity<String> createGraphQLResponse(MediaType mediaType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int sessions;",
    "query": "Create a method that efficiently provides the total number of active user sessions, ensuring thread safety and optimal performance.",
    "function_signature": "public int getActiveSessionTotal()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Design a benchmarking utility to evaluate the efficiency of managing client subscriptions across multiple channels. Ensure that the solution handles high concurrency with optimal memory usage and provides thread-safe operations for registering and unregistering subscriptions.",
    "function_signature": "public void executeSubscriptionBenchmark(SubscriptionManager subscriptionManager, BenchmarkParameters parameters);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Develop a component that efficiently verifies whether incoming request paths conform to defined patterns, enhancing performance and ensuring compatibility with the latest path matching strategies in Spring.",
    "function_signature": "public boolean matchesPath(String requestPath, PathPattern pattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Optimize the URL path matching configuration in your Spring MVC application by adopting a more efficient and type-safe mechanism that leverages the latest request parsing features.",
    "function_signature": "public void setRequestPathHandler(RequestPathHandler requestPathHandler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Enhance request interception by configuring a custom path matching strategy to improve matching efficiency and maintain thread safety.",
    "function_signature": "public void setCustomPathMatcher(PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Enhance request filtering by implementing a method that efficiently determines applicability based on the current HTTP request, leveraging the most recent request attributes for improved safety and performance.",
    "function_signature": "public boolean isApplicable(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPatternString()",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "method",
    "signature": "public String getPatternString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}",
    "query": "Refactor the interceptor configuration to utilize path pattern objects, ensuring enhanced performance and type safety when mapping web requests.",
    "function_signature": "public PathPattern getPathPattern()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Develop a method to efficiently handle client subscriptions using the recommended subscription management service, ensuring improved scalability and thread safety.",
    "function_signature": "public void manageClientSubscription(SubscriptionService subscriptionService, Client client, Topic topic)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Optimize the request handling mechanism in your Spring MVC application to enhance performance and ensure thread safety. Refactor the existing interceptor logic to utilize a more efficient approach that aligns with the latest framework best practices.",
    "function_signature": "public boolean handleRequest(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.19",
    "to_version": "v5.2.21.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Develop a component that efficiently resolves message destinations in a concurrent environment, ensuring optimal performance and thread safety.",
    "function_signature": "public DestinationResolver resolveDestination(String destinationName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.<unknown>#isHttpOnly()",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public boolean isHttpOnly()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isHttpOnly() {\n\t\t\treturn this.responseCookie.isHttpOnly();\n\t\t}",
    "query": "Create a reactive endpoint that examines all incoming cookies from a request and rejects the request if any cookie is not flagged as HTTP-only, thereby enforcing enhanced security measures.",
    "function_signature": "public Mono<ResponseEntity<Void>> enforceHttpOnlyCookies(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#remoteAddress(remoteAddress)",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder remoteAddress(String remoteAddress)",
    "documentation": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic MockHttpServletRequestBuilder remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn this;\n\t}",
    "query": "Enhance your mock HTTP request setup by specifying the client's IP address in a manner that ensures type safety and leverages the latest framework optimizations.",
    "function_signature": "public MockHttpServletRequestBuilder withClientIp(InetAddress clientIp)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractKotlinSerializationHttpMessageConverter#canWrite(type,clazz,mediaType)",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean canWrite(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!ResolvableType.NONE.equals(type) && serializer(type) != null) {\n\t\t\treturn canWrite(mediaType);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}",
    "query": "Develop a Spring component that assesses the capability to serialize various data types and media formats dynamically. This component should ensure that responses are handled efficiently based on the specific requirements of Kotlin data classes and the desired media type.",
    "function_signature": "public boolean supportsSerialization(ResolvableType type, Class<?> clazz, @Nullable MediaType mediaType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#uri(uri)",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public B uri(URI uri)",
    "documentation": "\t/**\n\t * Specify the URI using an absolute, fully constructed {@link java.net.URI}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic B uri(URI uri) {\n\t\treturn updateUri(uri, null);\n\t}",
    "query": "Create a unit test for a Spring MVC controller that needs to send a mock HTTP request using a fully constructed absolute URI, including query parameters.",
    "function_signature": "public MockHttpServletRequestBuilder buildMockRequest(URI uri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ETag#hashCode()",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\tint result = this.tag.hashCode();\n\t\tresult = 31 * result + Boolean.hashCode(this.weak);\n\t\treturn result;\n\t}",
    "query": "Create a REST endpoint that processes conditional GET requests by verifying if the client's cached version of a resource is up-to-date, thereby minimizing unnecessary data transmission.",
    "function_signature": "public ResponseEntity<Resource> fetchResourceIfUnchanged(String resourceId, String clientCacheHash)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.resource.PathResourceResolver",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "class",
    "signature": "public class PathResourceResolver",
    "documentation": "/**\n * A simple {@code ResourceResolver} that tries to find a resource under the given\n * locations matching to the request path.\n *\n * <p>This resolver does not delegate to the {@code ResourceResolverChain} and is\n * expected to be configured at the end in a chain of resolvers.\n *\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 5.0\n */",
    "changetype": "deprecated",
    "source_code": "public class PathResourceResolver extends AbstractResourceResolver {\n\n\t@Nullable\n\tprivate Resource[] allowedLocations;\n\n\n\t/**\n\t * By default, when a Resource is found, the path of the resolved resource is\n\t * compared to ensure it's under the input location where it was found.\n\t * However sometimes that may not be the case, e.g. when\n\t * {@link CssLinkResourceTransformer}\n\t * resolves public URLs of links it contains, the CSS file is the location\n\t * and the resources being resolved are css files, images, fonts and others\n\t * located in adjacent or parent directories.\n\t * <p>This property allows configuring a complete list of locations under\n\t * which resources must be so that if a resource is not under the location\n\t * relative to which it was found, this list may be checked as well.\n\t * <p>By default {@link ResourceWebHandler} initializes this property\n\t * to match its list of locations.\n\t * @param locations the list of allowed locations\n\t */\n\tpublic void setAllowedLocations(@Nullable Resource... locations) {\n\t\tthis.allowedLocations = locations;\n\t}\n\n\t@Nullable\n\tpublic Resource[] getAllowedLocations() {\n\t\treturn this.allowedLocations;\n\t}\n\n\n\t@Override\n\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, locations);\n\t}\n\n\t@Override\n\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}\n\n\tprivate Mono<Resource> getResource(String resourcePath, List<? extends Resource> locations) {\n\t\treturn Flux.fromIterable(locations)\n\t\t\t\t.concatMap(location -> getResource(resourcePath, location))\n\t\t\t\t.next();\n\t}\n\n\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */\n\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tif (!(location instanceof UrlResource)) {\n\t\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\tResource resource = location.createRelative(resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */\n\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isResourceUnderLocation(Resource resource, Resource location) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedPath(resourcePath));\n\t}\n\n\tprivate boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars...\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resolved resource path contains encoded \\\"../\\\" or \\\"..\\\\\\\": \" + resourcePath, -1, true));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// May not be possible to decode...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}",
    "query": "Implement a resource resolver that efficiently locates and serves static resources while ensuring enhanced security measures against path traversal attacks. Optimize the resolver to handle a diverse set of resource locations with minimal latency.",
    "function_signature": "public Mono<Resource> resolveSecureResource(String resourcePath, List<? extends Resource> locations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#value()",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public int value()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int value() {\n\t\t\treturn this.port;\n\t\t}",
    "query": "Develop a utility that dynamically accesses the current server port to configure endpoint URLs during application startup.",
    "function_signature": "public int fetchActiveServerPort()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange#getPrincipal()",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public Mono<T> getPrincipal()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic <T extends Principal> Mono<T> getPrincipal() {\n\t\treturn Mono.empty();\n\t}",
    "query": "Create a reactive REST controller method that asynchronously obtains the current user's authentication details to tailor the response based on their identity.",
    "function_signature": "public Mono<Principal> obtainCurrentUserPrincipal(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteBuffers()",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}",
    "query": "Create a utility that efficiently processes streaming data in a reactive HTTP client, ensuring optimal memory usage and compatibility with the latest framework updates.",
    "function_signature": "public DataStreamHandler handleStreamingData()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#hasOpaquePath()",
    "from_version": "v6.1.20",
    "to_version": "v6.2.7",
    "type": "method",
    "signature": "public boolean hasOpaquePath()",
    "documentation": "\t\t/**\n\t\t * A URL has an opaque path if its path is a URL path segment.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean hasOpaquePath() {\n\t\t\treturn path().isOpaque();\n\t\t}",
    "query": "Design a REST controller method that processes incoming URLs and determines whether each URL's path should be treated as a single opaque segment, ensuring proper handling of custom URI schemes in your application.",
    "function_signature": "public boolean isResourcePathOpaque(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.OrderComparator#getPriority(obj)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public Integer getPriority(Object obj)",
    "documentation": "\t/**\n\t * Determine a priority value for the given object, if any.\n\t * <p>The default implementation always returns {@code null}.\n\t * Subclasses may override this to give specific kinds of values a\n\t * 'priority' characteristic, in addition to their 'order' semantics.\n\t * A priority indicates that it may be used for selecting one object over\n\t * another, in addition to serving for ordering purposes in a list/array.\n\t * @param obj the object to check\n\t * @return the priority value, or {@code null} if none\n\t * @since 4.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Integer getPriority(Object obj) {\n\t\treturn null;\n\t}",
    "query": "Optimize the ordering of your application components to improve performance and ensure reliable initialization sequences.",
    "function_signature": "public int getOrder(Object bean);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.beanvalidation.SpringValidatorAdapter#requiresMessageFormat(violation)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "protected boolean requiresMessageFormat(ConstraintViolation<?> violation)",
    "documentation": "\t/**\n\t * Indicate whether this violation's interpolated message has remaining\n\t * placeholders and therefore requires {@link java.text.MessageFormat}\n\t * to be applied to it. Called for a Bean Validation defined message\n\t * (coming out {@code ValidationMessages.properties}) when rendered\n\t * as the default message in Spring's MessageSource.\n\t * <p>The default implementation considers a Spring-style \"{0}\" placeholder\n\t * for the field name as an indication for {@link java.text.MessageFormat}.\n\t * Any other placeholder or escape syntax occurrences are typically a\n\t * mismatch, coming out of regex pattern values or the like. Note that\n\t * standard Bean Validation does not support \"{0}\" style placeholders at all;\n\t * this is a feature typically used in Spring MessageSource resource bundles.\n\t * @param violation the Bean Validation constraint violation, including\n\t * BV-defined interpolation of named attribute references in its message\n\t * @return {@code true} if {@code java.text.MessageFormat} is to be applied,\n\t * or {@code false} if the violation's message should be used as-is\n\t * @since 5.1.8\n\t * @see #getArgumentsForConstraint\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected boolean requiresMessageFormat(ConstraintViolation<?> violation) {\n\t\treturn containsSpringStylePlaceholder(violation.getMessage());\n\t}",
    "query": "Refactor the validation message handling to utilize the latest formatting utilities, ensuring improved performance and enhanced compatibility with current framework standards.",
    "function_signature": "protected boolean shouldUseAdvancedFormatting(ConstraintViolation<?> violation)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#setPhase(phase)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public void setPhase(int phase)",
    "documentation": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}",
    "query": "Ensure your task scheduler integrates seamlessly with the applications startup sequence by appropriately managing its lifecycle phase.",
    "function_signature": "public class CustomTaskScheduler implements SmartLifecycle {\n    // Implement required methods to define lifecycle behavior\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "class",
    "signature": "public class HttpSessionHandshakeInterceptor",
    "documentation": "/**\n * An interceptor to copy information from the HTTP session to the \"handshake\n * attributes\" map to be made available via {@link WebSocketSession#getAttributes()}.\n *\n * <p>Copies a subset or all HTTP session attributes and/or the HTTP session ID\n * under the key {@link #HTTP_SESSION_ID_ATTR_NAME}.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n */",
    "changetype": "deprecated",
    "source_code": "public class HttpSessionHandshakeInterceptor implements HandshakeInterceptor {\n\n\t/**\n\t * The name of the attribute under which the HTTP session id is exposed when\n\t * {@link #setCopyHttpSessionId(boolean) copyHttpSessionId} is \"true\".\n\t */\n\tpublic static final String HTTP_SESSION_ID_ATTR_NAME = \"HTTP.SESSION.ID\";\n\n\n\tprivate final Collection<String> attributeNames;\n\n\tprivate boolean copyAllAttributes;\n\n\tprivate boolean copyHttpSessionId = true;\n\n\tprivate boolean createSession;\n\n\n\t/**\n\t * Default constructor for copying all HTTP session attributes and the HTTP\n\t * session id.\n\t * @see #setCopyAllAttributes\n\t * @see #setCopyHttpSessionId\n\t */\n\tpublic HttpSessionHandshakeInterceptor() {\n\t\tthis.attributeNames = Collections.emptyList();\n\t\tthis.copyAllAttributes = true;\n\t}\n\n\t/**\n\t * Constructor for copying specific HTTP session attributes and the HTTP\n\t * session id.\n\t * @param attributeNames session attributes to copy\n\t * @see #setCopyAllAttributes\n\t * @see #setCopyHttpSessionId\n\t */\n\tpublic HttpSessionHandshakeInterceptor(Collection<String> attributeNames) {\n\t\tthis.attributeNames = Collections.unmodifiableCollection(attributeNames);\n\t\tthis.copyAllAttributes = false;\n\t}\n\n\n\t/**\n\t * Return the configured attribute names to copy (read-only).\n\t */\n\tpublic Collection<String> getAttributeNames() {\n\t\treturn this.attributeNames;\n\t}\n\n\t/**\n\t * Whether to copy all attributes from the HTTP session. If set to \"true\",\n\t * any explicitly configured attribute names are ignored.\n\t * <p>By default this is set to either \"true\" or \"false\" depending on which\n\t * constructor was used (default or with attribute names respectively).\n\t * @param copyAllAttributes whether to copy all attributes\n\t */\n\tpublic void setCopyAllAttributes(boolean copyAllAttributes) {\n\t\tthis.copyAllAttributes = copyAllAttributes;\n\t}\n\n\t/**\n\t * Whether to copy all HTTP session attributes.\n\t */\n\tpublic boolean isCopyAllAttributes() {\n\t\treturn this.copyAllAttributes;\n\t}\n\n\t/**\n\t * Whether the HTTP session id should be copied to the handshake attributes\n\t * under the key {@link #HTTP_SESSION_ID_ATTR_NAME}.\n\t * <p>By default this is \"true\".\n\t * @param copyHttpSessionId whether to copy the HTTP session id.\n\t */\n\tpublic void setCopyHttpSessionId(boolean copyHttpSessionId) {\n\t\tthis.copyHttpSessionId = copyHttpSessionId;\n\t}\n\n\t/**\n\t * Whether to copy the HTTP session id to the handshake attributes.\n\t */\n\tpublic boolean isCopyHttpSessionId() {\n\t\treturn this.copyHttpSessionId;\n\t}\n\n\t/**\n\t * Whether to allow the HTTP session to be created while accessing it.\n\t * <p>By default set to {@code false}.\n\t * @see jakarta.servlet.http.HttpServletRequest#getSession(boolean)\n\t */\n\tpublic void setCreateSession(boolean createSession) {\n\t\tthis.createSession = createSession;\n\t}\n\n\t/**\n\t * Whether the HTTP session is allowed to be created.\n\t */\n\tpublic boolean isCreateSession() {\n\t\treturn this.createSession;\n\t}\n\n\n\t@Override\n\tpublic boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {\n\n\t\tHttpSession session = getSession(request);\n\t\tif (session != null) {\n\t\t\tif (isCopyHttpSessionId()) {\n\t\t\t\tattributes.put(HTTP_SESSION_ID_ATTR_NAME, session.getId());\n\t\t\t}\n\t\t\tEnumeration<String> names = session.getAttributeNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tif (isCopyAllAttributes() || getAttributeNames().contains(name)) {\n\t\t\t\t\tattributes.put(name, session.getAttribute(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Nullable\n\tprivate HttpSession getSession(ServerHttpRequest request) {\n\t\tif (request instanceof ServletServerHttpRequest serverRequest) {\n\t\t\treturn serverRequest.getServletRequest().getSession(isCreateSession());\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex) {\n\t}\n\n}",
    "query": "Design a WebSocket configuration that efficiently manages user session data, ensuring thread safety and minimizing overhead during the handshake process.",
    "function_signature": "public void setupSecureWebSocketSessionAttributes(WebSocketHandlerRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#getUri()",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public URI getUri()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic URI getUri() {\n\t\tcheckNativeSessionInitialized();\n\t\treturn this.uri;\n\t}",
    "query": "Implement a method to efficiently obtain the connection endpoint from a WebSocket session, ensuring thread safety and optimal performance. Avoid approaches that may lead to potential synchronization issues or unnecessary overhead.",
    "function_signature": "public URI retrieveConnectionEndpoint(WebSocketSession session)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.agent.RecordedInvocation#withArgument(argument)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public Builder withArgument(@Nullable Object argument)",
    "documentation": "\t\t/**\n\t\t * Use the given object as the unique argument.\n\t\t * @param argument the invocation argument\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "changetype": "deprecated",
    "source_code": "\t\tpublic Builder withArgument(@Nullable Object argument) {\n\t\t\tif (argument != null) {\n\t\t\t\tthis.arguments = new Object[] {argument};\n\t\t\t}\n\t\t\treturn this;\n\t\t}",
    "query": "Enhance the invocation recording process by allowing multiple arguments to be set efficiently, improving both performance and flexibility in method chaining.",
    "function_signature": "public Builder withArguments(@Nullable Object... arguments)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder#setCustomArgumentResolvers(argumentResolvers)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public StandaloneMockMvcBuilder setCustomArgumentResolvers(HandlerMethodArgumentResolver... argumentResolvers)",
    "documentation": "\t/**\n\t * Provide custom resolvers for controller method arguments.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic StandaloneMockMvcBuilder setCustomArgumentResolvers(HandlerMethodArgumentResolver... argumentResolvers) {\n\t\tthis.customArgumentResolvers = Arrays.asList(argumentResolvers);\n\t\treturn this;\n\t}",
    "query": "Optimize your MockMvc setup to efficiently handle custom controller arguments, enhancing both performance and type safety during tests.",
    "function_signature": "public StandaloneMockMvcBuilder configureCustomResolvers(CustomArgumentResolver... resolvers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#setHeaderInitializer(headerInitializer)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer)",
    "documentation": "\t/**\n\t * Configure a {@link MessageHeaderInitializer} to apply to the headers\n\t * of all messages sent to the client outbound channel.\n\t * <p>By default this property is not set.\n\t * @since 4.1\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setHeaderInitializer(@Nullable MessageHeaderInitializer headerInitializer) {\n\t\tthis.headerInitializer = headerInitializer;\n\t}",
    "query": "Implement a mechanism to initialize message headers for outbound client communications, ensuring optimal performance and enhanced configurability.",
    "function_signature": "public void configureMessageHeaders(@Nullable MessageHeaderConfigurer headerConfigurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "public MergedAnnotations getAnnotations()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic MergedAnnotations getAnnotations() {\n\t\treturn this.mergedAnnotations;\n\t}",
    "query": "Enhance your method metadata handling to utilize a more efficient and type-safe approach for accessing annotations within your Spring components.",
    "function_signature": "public MergedAnnotations fetchMergedAnnotations()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.event.ApplicationListenerMethodAdapter#doInvoke(args)",
    "from_version": "v6.2.0-M2",
    "to_version": "v5.3.36",
    "type": "method",
    "signature": "protected Object doInvoke(@Nullable Object... args)",
    "documentation": "\t/**\n\t * Invoke the event listener method with the given argument values.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected Object doInvoke(@Nullable Object... args) {\n\t\tObject bean = getTargetBean();\n\t\t// Detect package-protected NullBean instance through equals(null) check\n\t\tif (bean.equals(null)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tReflectionUtils.makeAccessible(this.method);\n\t\ttry {\n\t\t\tif (KotlinDetector.isSuspendingFunction(this.method)) {\n\t\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(this.method, bean, args);\n\t\t\t}\n\t\t\treturn this.method.invoke(bean, args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(this.method, bean, args);\n\t\t\tthrow new IllegalStateException(getInvocationErrorMessage(bean, ex.getMessage(), args), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new IllegalStateException(getInvocationErrorMessage(bean, ex.getMessage(), args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Throw underlying exception\n\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\tif (targetException instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString msg = getInvocationErrorMessage(bean, \"Failed to invoke event listener method\", args);\n\t\t\t\tthrow new UndeclaredThrowableException(targetException, msg);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Enhance the event processing mechanism to utilize type-safe listener methods, reducing overhead and improving reliability.",
    "function_signature": "public void processEvent(CustomApplicationEvent event)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.JettyWebSocketSession#onCompleteSuccess()",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "protected void onCompleteSuccess()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\t\t\t\tprotected void onCompleteSuccess() {\n\t\t\t\t\t\t\titerator.close();\n\t\t\t\t\t\t\tcompletable.succeed();\n\t\t\t\t\t\t}",
    "query": "Create a method in your custom WebSocket session handler that gracefully finalizes the session by releasing all associated resources and signaling successful completion when the WebSocket communication concludes without errors.",
    "function_signature": "protected void handleCompletionSuccess()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#search()",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public String search()",
    "documentation": "\t\t/**\n\t\t * The search getter steps are:\n\t\t * <ol>\n\t\t * <li>If this URLs query is either null or the empty string, then return the empty string.\n\t\t * <li>Return U+003F (?), followed by this URLs query.\n\t\t * </ol>\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic String search() {\n\t\t\tString query = query();\n\t\t\tif (query == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"?\" + query;\n\t\t\t}\n\t\t}",
    "query": "Design a Spring service method that constructs a complete request URL by appending the query parameters only when they are present, ensuring the URL remains clean and free of unnecessary characters.",
    "function_signature": "public String buildCompleteUrl(String baseUrl)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submit(task)",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public Future<T> submit(Callable<T> task)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic <T> Future<T> submit(Callable<T> task) {\n\t\treturn super.submit(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}",
    "query": "Design a service method that allows clients to initiate background computations and retrieve their results asynchronously, ensuring that each task can handle exceptions gracefully without blocking the main application flow.",
    "function_signature": "public Future<ComputationResult> initiateAsyncComputation(Callable<ComputationResult> task)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange#getFormData()",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public String>> getFormData()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Mono<MultiValueMap<String, String>> getFormData() {\n\t\treturn this.formDataMono;\n\t}",
    "query": "Design a reactive endpoint in a Spring WebFlux application that efficiently processes user-submitted form data without blocking the server thread. Ensure that the form data is accessed in a non-blocking manner to handle high concurrency scenarios gracefully.",
    "function_signature": "public Mono<MultiValueMap<String, String>> handleUserFormSubmission(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#parse(element,annotation)",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "protected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\n\t\tList<Class<?>> allClassNames = new ArrayList<>();\n\t\tallClassNames.addAll(Arrays.asList(annotation.classes()));\n\t\tallClassNames.addAll(Arrays.stream(annotation.classNames())\n\t\t\t\t.map(this::loadClass).filter(Objects::nonNull).toList());\n\t\tif (allClassNames.isEmpty()) {\n\t\t\tif (element instanceof Class<?> clazz) {\n\t\t\t\tallClassNames.add(clazz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"At least one class must be specified, \"\n\t\t\t\t\t\t+ \"could not detect target from '\" + element + \"'\");\n\t\t\t}\n\t\t}\n\t\treturn new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]),\n\t\t\t\tannotation.memberCategories());\n\t}",
    "query": "Develop a component that interprets custom annotations on your application's classes to automatically register necessary reflection metadata, enhancing compatibility with native image compilation.",
    "function_signature": "protected ReflectionRegistration handleReflectionRegistration(AnnotatedElement element, RegisterReflection annotation)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder#addMappedInterceptors(pathPatterns,interceptors)",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors)",
    "documentation": "\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,",
    "query": "Design a testing configuration for a Spring router-based application that applies authentication and logging interceptors exclusively to API endpoints matching specific URL patterns.",
    "function_signature": "public RouterFunctionMockMvcBuilder setupSelectiveInterceptors(String[] apiPathPatterns, HandlerInterceptor... interceptors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#blockTimeout(blockTimeout)",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public Builder blockTimeout(@Nullable Duration blockTimeout)",
    "documentation": "\t\t/**\n\t\t * Configure how long to block for the response of an HTTP service method\n\t\t * with a synchronous (blocking) method signature.\n\t\t * <p>By default this is not set, in which case the behavior depends on\n\t\t * connection and request timeout settings of the underlying HTTP client.\n\t\t * We recommend configuring timeout values directly on the underlying HTTP\n\t\t * client, which provides more control over such settings.\n\t\t * @param blockTimeout the timeout value\n\t\t * @return this same builder instance\n\t\t * @deprecated in favor of setting the same directly on the {@link HttpExchangeAdapter}\n\t\t */",
    "changetype": "deprecated",
    "source_code": "\t\tpublic Builder blockTimeout(@Nullable Duration blockTimeout) {\n\t\t\tif (this.exchangeAdapter instanceof AbstractReactorHttpExchangeAdapter settable) {\n\t\t\t\tsettable.setBlockTimeout(blockTimeout);\n\t\t\t}\n\t\t\treturn this;\n\t\t}",
    "query": "Optimize the configuration of your HTTP service proxy to achieve more precise control over request timeouts by directly configuring the underlying HTTP client adapter.",
    "function_signature": "public Builder httpExchangeAdapter(HttpExchangeAdapter exchangeAdapter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.format.datetime.standard.DurationFormatterUtils#print(value,style)",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public String print(Duration value, DurationFormat.Style style)",
    "documentation": "\t/**\n\t * Print the specified duration in the specified style.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @return the printed result\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style) {\n\t\treturn print(value, style, null);\n\t}",
    "query": "In a scheduling application, you need to display task durations in various formats based on user preferences. Develop a method to handle this formatting efficiently.",
    "function_signature": "public String formatTaskDuration(Duration duration, DurationFormat.Style style);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectivePropertyAccessor#hashCode()",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int hashCode() {\n\t\t\treturn (this.clazz.hashCode() * 29 + this.property.hashCode());\n\t\t}",
    "query": "Develop a property accessor that enhances performance and ensures thread-safe property resolution within Spring's expression language. Your implementation should adhere to the latest best practices for property handling to optimize efficiency and reliability.",
    "function_signature": "public class OptimizedPropertyAccessor implements PropertyAccessor {\n    // Implementation goes here\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.WebHttpHandlerBuilder#filters(consumer)",
    "from_version": "v6.1.14",
    "to_version": "v6.2.0-RC2",
    "type": "method",
    "signature": "public WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer)",
    "documentation": "\t/**\n\t * Manipulate the \"live\" list of currently configured filters.\n\t * @param consumer the consumer to use\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic WebHttpHandlerBuilder filters(Consumer<List<WebFilter>> consumer) {\n\t\tconsumer.accept(this.filters);\n\t\tupdateFilters();\n\t\treturn this;\n\t}",
    "query": "Optimize the setup of your web server by configuring multiple filters in a manner that enhances performance and ensures type safety.",
    "function_signature": "public WebHttpHandlerBuilder addWebFilters(WebFilter... filters)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.EntityManagerFactoryUtils#doGetTransactionalEntityManager(emf,Map<?,properties,synchronizedWithTransaction)",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "documentation": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(",
    "query": "Refactor the data access layer to efficiently obtain a transactional `EntityManager` that seamlessly integrates with existing transaction management, ensuring optimal performance and thread safety without manual synchronization handling.",
    "function_signature": "public EntityManager acquireTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<String, Object> properties)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.ContentDisposition#getCharset()",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public Charset getCharset()",
    "documentation": "\t/**\n\t * Return the charset defined in {@literal filename*} parameter, or {@code null} if not defined.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Charset getCharset() {\n\t\treturn this.charset;\n\t}",
    "query": "Create a method that efficiently retrieves the character encoding from a given `ContentDisposition` instance, ensuring enhanced type safety and performance when processing file metadata.",
    "function_signature": "public Optional<Charset> determineCharset(ContentDisposition contentDisposition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.AbstractApplicationContext#getBean(name)",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public Object getBean(String name)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Object getBean(String name) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name);\n\t}",
    "query": "Create a method that efficiently obtains a specific service component from the application context using its class type, ensuring compile-time type safety and minimizing the risk of casting errors.",
    "function_signature": "public <T> T fetchServiceComponent(Class<T> serviceClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.SESSION_NOT_RELIABLE",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "field",
    "signature": "public CloseStatus SESSION_NOT_RELIABLE",
    "documentation": "\t/**\n\t * A status code for use within the framework the indicate a session has\n\t * become unreliable (e.g. timed out while sending a message) and extra\n\t * care should be exercised, e.g. avoid sending any further data to the\n\t * client that may be done during normal shutdown.\n\t * @since 4.0.3\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static final CloseStatus SESSION_NOT_RELIABLE = new CloseStatus(4500);",
    "query": "Develop a WebSocket termination strategy that ensures sessions are closed reliably, minimizing the risk of resource leaks and ensuring a smooth client shutdown process.",
    "function_signature": "public CloseStatus getReliableSessionCloseStatus()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.PreparedStatementCreatorFactory#newPreparedStatementCreator(params)",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public PreparedStatementCreator newPreparedStatementCreator(@Nullable Object[] params)",
    "documentation": "\t/**\n\t * Return a new PreparedStatementCreator for the given parameters.\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic PreparedStatementCreator newPreparedStatementCreator(@Nullable Object[] params) {\n\t\treturn new PreparedStatementCreatorImpl(params != null ? Arrays.asList(params) : Collections.emptyList());\n\t}",
    "query": "Implement a method to create a `PreparedStatementCreator` utilizing a parameter collection, ensuring improved type safety and performance. Account for scenarios where the parameter list might be empty or absent.",
    "function_signature": "public PreparedStatementCreator createPreparedStatementCreator(@Nullable List<Object> params)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractGenericHttpMessageConverter#writeInternal(t,type,outputMessage)",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "protected void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "documentation": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write (may be {@code null})\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected abstract void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "query": "Create a method that efficiently transforms a given object into an HTTP response, ensuring type safety and optimal performance for scalable web applications.",
    "function_signature": "protected void serializeToHttpResponse(Object data, Type targetType, HttpOutputMessage httpMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.resource.CssLinkResourceTransformer#transform(exchange,inputResource,transformerChain)",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,",
    "query": "Enhance the processing of CSS resources within a reactive Spring application to achieve better performance and maintainability by utilizing the most recent transformation strategies.",
    "function_signature": "public Mono<Resource> optimizeCssResourceHandling(ServerWebExchange exchange, Resource inputResource, ResourceTransformerChain transformerChain)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.PropertyOrFieldReference#isNullSafe()",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public boolean isNullSafe()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}",
    "query": "Develop a utility function that assesses the reliability of property or field accesses within Spring expressions, ensuring enhanced performance and minimizing null-related exceptions.",
    "function_signature": "public boolean isPropertyAccessReliable(PropertyOrFieldReference reference)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.RequestPredicates#headers()",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "public Headers headers()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Headers headers() {\n\t\t\treturn this.request.headers();\n\t\t}",
    "query": "Design a request predicate that accurately and efficiently filters HTTP requests based on specified header criteria, enhancing performance and type safety.",
    "function_signature": "public RequestPredicate headerCondition()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.MimeType#appendTo(builder)",
    "from_version": "v6.0.0-M2",
    "to_version": "v5.3.15",
    "type": "method",
    "signature": "protected void appendTo(StringBuilder builder)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected void appendTo(StringBuilder builder) {\n\t\tbuilder.append(this.type);\n\t\tbuilder.append('/');\n\t\tbuilder.append(this.subtype);\n\t\tappendTo(this.parameters, builder);\n\t}",
    "query": "Optimize the generation of MIME type strings by adopting the framework's modern utilities, enhancing both performance and code maintainability.",
    "function_signature": "public String formatMimeType()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Create a setup routine for managing destination subscriptions that optimizes resource usage and ensures thread-safe operations under varying load conditions.",
    "function_signature": "public void configureSubscriptionManager(SystemState systemState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Implement a feature that efficiently tracks and manages active client connections and their subscribed channels, ensuring minimal memory footprint and high concurrency handling. The solution should seamlessly integrate with the messaging infrastructure to automatically update subscription states as clients connect or disconnect.",
    "function_signature": "public void initializeSubscriptionManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean ->\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t *\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Create a method to incorporate centralized controller-based exception handling into your reactive messaging setup, enhancing integration and maintainability.",
    "function_signature": "public void registerControllerExceptionHandler(ControllerAdviceWrapper wrapper)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Revamp the messaging broker configuration to implement the current best practices for managing destination counts, enhancing both performance and maintainability.",
    "function_signature": "public void configureDestinationLimit(int limit)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Optimize the request handling mechanism by implementing an interceptor that efficiently determines applicability based on request paths. Ensure that the solution leverages the most current path matching strategies to enhance performance and maintainability.",
    "function_signature": "public boolean shouldApplyInterceptor(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Develop a method to efficiently manage client subscriptions, prioritizing performance and ensuring thread safety in a concurrent environment.",
    "function_signature": "public void manageClientSubscription(String sessionId, String destinationPattern);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "method",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(",
    "query": "Design a method to set up URL patterns for intercepting HTTP requests in a Spring application. Ensure that the pattern matching mechanism you choose enhances performance and provides greater flexibility compared to traditional approaches.",
    "function_signature": "public PathPattern[] configureInterceptionPatterns(String[] patterns, PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Enhance the messaging system by implementing a robust strategy for determining message destinations, ensuring improved performance and thread safety under high load conditions.",
    "function_signature": "public DestinationStrategy determineDestination(String contentionMode);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Create a configuration component that efficiently retrieves and applies handler interceptors based on URL patterns, ensuring optimal performance and enhanced maintainability in request processing.",
    "function_signature": "public HandlerInterceptor resolveHandlerInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.6",
    "to_version": "v5.2.14.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a robust component for assigning unique identifiers to messages that ensures thread-safety and optimizes performance in high-concurrency scenarios.",
    "function_signature": "public String createUniqueMessageId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#getStatusText()",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public String getStatusText()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String getStatusText() throws IOException {\n\t\t\treturn this.delegate.getStatusText();\n\t\t}",
    "query": "Implement a method to retrieve the descriptive phrase associated with an HTTP response status, ensuring improved performance and type safety.",
    "function_signature": "public String getReasonPhrase()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(contexts,result)",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, result)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}",
    "query": "Develop a caching mechanism that seamlessly integrates with reactive data streams, ensuring efficient eviction without compromising application responsiveness.",
    "function_signature": "public Mono<Void> executeCacheEvictionAsync(List<CacheOperationContext> contexts, @Nullable Object result)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.caffeine.CaffeineCacheManager#setCaffeineSpec(caffeineSpec)",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public void setCaffeineSpec(CaffeineSpec caffeineSpec)",
    "documentation": "\t/**\n\t * Set the {@link CaffeineSpec} to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#from(CaffeineSpec)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setCaffeineSpec(CaffeineSpec caffeineSpec) {\n\t\tdoSetCaffeine(Caffeine.from(caffeineSpec));\n\t}",
    "query": "Optimize the cache manager setup to improve performance and maintainability by utilizing the latest configuration practices for Caffeine caches.",
    "function_signature": "public void configureCacheManager(Caffeine<Object, Object> caffeineBuilder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter#indexOf(predicate,fromIndex)",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}",
    "query": "Implement a method to efficiently locate the starting position of a specific condition within a sequence, ensuring optimal performance and enhanced readability.",
    "function_signature": "public OptionalInt findStartingIndex(IntPredicate condition, int startPosition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.HttpComponentsHeadersAdapter#toString()",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}",
    "query": "Develop a function that delivers a structured and efficient representation of HTTP headers, improving both readability and maintainability within your application.",
    "function_signature": "public String formatHeaders()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.transport.session.disconnectedClientLogger",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "field",
    "signature": "protected Log disconnectedClientLogger",
    "documentation": "\t/**\n\t * Separate logger to use on network IO failure after a client has gone away.\n\t * @see #DISCONNECTED_CLIENT_LOG_CATEGORY\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected static final Log disconnectedClientLogger = LogFactory.getLog(DISCONNECTED_CLIENT_LOG_CATEGORY);",
    "query": "Design a WebSocket session management method that specifically handles and logs client disconnections resulting from network IO failures, ensuring these events are tracked separately for enhanced diagnostics.",
    "function_signature": "protected void handleDisconnectedClient(Session session)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.transaction.support.DefaultTransactionDefinition#setReadOnly(readOnly)",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public void setReadOnly(boolean readOnly)",
    "documentation": "\t/**\n\t * Set whether to optimize as read-only transaction.\n\t * Default is \"false\".\n\t * <p>The read-only flag applies to any transaction context, whether backed\n\t * by an actual resource transaction ({@link #PROPAGATION_REQUIRED}/\n\t * {@link #PROPAGATION_REQUIRES_NEW}) or operating non-transactionally at\n\t * the resource level ({@link #PROPAGATION_SUPPORTS}). In the latter case,\n\t * the flag will only apply to managed resources within the application,\n\t * such as a Hibernate {@code Session}.\n\t * <p>This just serves as a hint for the actual transaction subsystem;\n\t * it will <i>not necessarily</i> cause failure of write access attempts.\n\t * A transaction manager which cannot interpret the read-only hint will\n\t * <i>not</i> throw an exception when asked for a read-only transaction.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic final void setReadOnly(boolean readOnly) {\n\t\tthis.readOnly = readOnly;\n\t}",
    "query": "Refactor the transaction management in your service layer to enhance clarity and ensure optimal resource handling. Address scenarios where transaction settings might inadvertently allow unintended write operations, potentially impacting application stability.",
    "function_signature": "public void configureTransactionSettings(boolean readOnlyMode);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#isEmpty()",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public boolean isEmpty()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}",
    "query": "Develop a method to assess whether any HTTP headers are present, leveraging an approach that improves performance and reliability over conventional size-based evaluations.",
    "function_signature": "public boolean hasAnyHeaders()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#set(key,value)",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public void set(String key, @Nullable String value)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}",
    "query": "Develop a method to efficiently handle HTTP header modifications, ensuring thread safety and optimal performance during header updates.",
    "function_signature": "public void updateHeader(String key, @Nullable String value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.HandlerMethod#toString()",
    "from_version": "v6.1.1",
    "to_version": "v6.0.15",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}",
    "query": "Create a feature that logs comprehensive details of message-handling methods to facilitate advanced debugging and monitoring in a Spring-based application.",
    "function_signature": "public void logComprehensiveHandlerDetails(HandlerMethod handlerMethod);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.DecoderHttpMessageReader#getReadHints(elementType,message)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "protected Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message)",
    "documentation": "\t/**\n\t * Get additional hints for decoding based on the input HTTP message.\n\t * @since 5.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message) {\n\t\treturn Hints.none();\n\t}",
    "query": "Design a custom HTTP message decoder that modifies its deserialization behavior based on specific attributes present in the incoming HTTP request.",
    "function_signature": "protected Map<String, Object> determineDeserializationHints(ResolvableType targetType, ReactiveHttpInputMessage request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.ServletRequestPathUtils#modifyContextPath(contextPath)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public RequestPath modifyContextPath(String contextPath)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic RequestPath modifyContextPath(String contextPath) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}",
    "query": "Design a middleware component that dynamically adjusts the application's context path based on user-specific parameters extracted from incoming HTTP requests, ensuring seamless routing for a multi-tenant architecture.",
    "function_signature": "public RequestPath adjustContextPath(String userParameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.setup.<unknown>#getStartupDate()",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public long getStartupDate()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic long getStartupDate() {\n\t\treturn this.startupDate;\n\t}",
    "query": "Implement a mechanism within your integration tests to fetch and verify the exact timestamp when the Spring application context was initialized.",
    "function_signature": "public long fetchApplicationStartupDate()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.support.WebApplicationObjectSupport#initApplicationContext(context)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "protected void initApplicationContext(ApplicationContext context)",
    "documentation": "\t/**\n\t * Calls {@link #initServletContext(jakarta.servlet.ServletContext)} if the\n\t * given ApplicationContext is a {@link WebApplicationContext}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void initApplicationContext(ApplicationContext context) {\n\t\tsuper.initApplicationContext(context);\n\t\tif (this.servletContext == null && context instanceof WebApplicationContext wac) {\n\t\t\tthis.servletContext = wac.getServletContext();\n\t\t\tif (this.servletContext != null) {\n\t\t\t\tinitServletContext(this.servletContext);\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a Spring-managed component that automatically sets up servlet-related configurations when deployed within a web application context, ensuring seamless integration with the underlying servlet environment.",
    "function_signature": "protected void configureApplicationContext(ApplicationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.apache.commons.logging.<unknown>#debug(message)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public void debug(Object message)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void debug(Object message) {\n\t\t\tlog(java.util.logging.Level.FINE, message, null);\n\t\t}",
    "query": "Develop a logging utility that captures debug messages with enhanced performance and thread safety, replacing older logging approaches.",
    "function_signature": "public void logDebugMessage(String message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.support.WebApplicationObjectSupport#getServletContext()",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "protected ServletContext getServletContext()",
    "documentation": "\t/**\n\t * Return the current ServletContext.\n\t * @throws IllegalStateException if not running within a required ServletContext\n\t * @see #isContextRequired()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final ServletContext getServletContext() throws IllegalStateException {\n\t\tif (this.servletContext != null) {\n\t\t\treturn this.servletContext;\n\t\t}\n\t\tServletContext servletContext = null;\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac != null) {\n\t\t\tservletContext = wac.getServletContext();\n\t\t}\n\t\tif (servletContext == null && isContextRequired()) {\n\t\t\tthrow new IllegalStateException(\"WebApplicationObjectSupport instance [\" + this +\n\t\t\t\t\t\"] does not run within a ServletContext. Make sure the object is fully configured!\");\n\t\t}\n\t\treturn servletContext;\n\t}",
    "query": "Design a Spring component that dynamically configures its behavior by accessing the current web application's servlet environment.",
    "function_signature": "protected ServletContext accessCurrentServletContext()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#locale(locale)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public Jackson2ObjectMapperBuilder locale(Locale locale)",
    "documentation": "\t/**\n\t * Override the default {@link Locale} to use for formatting.\n\t * Default value used is {@link Locale#getDefault()}.\n\t * @since 4.1.5\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder locale(Locale locale) {\n\t\tthis.locale = locale;\n\t\treturn this;\n\t}",
    "query": "Design a REST controller method that returns data formatted according to a user's regional settings, ensuring consistency in date and number representations.",
    "function_signature": "public ResponseEntity<String> fetchRegionalizedData(Locale userLocale)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.quartz.SchedulerFactoryBean#setApplicationContext(applicationContext)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public void setApplicationContext(ApplicationContext applicationContext)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}",
    "query": "Design a configuration method that integrates the Quartz scheduler seamlessly with the Spring application context to enable dynamic job management based on application lifecycle events.",
    "function_signature": "public void configureSchedulerIntegration(ApplicationContext applicationContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.WebHttpHandlerBuilder#applyTo(builder)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public void applyTo(BlockHound.Builder builder)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void applyTo(BlockHound.Builder builder) {\n\n\t\t\t// Avoid hard references potentially anywhere in spring-web (no need for structural dependency)\n\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.http.MediaTypeFactory\", \"<clinit>\");\n\t\t\tbuilder.allowBlockingCallsInside(\"org.springframework.web.util.HtmlUtils\", \"<clinit>\");\n\t\t}",
    "query": "Ensure your Spring Web application permits specific blocking operations within designated utility classes during initialization, optimizing performance without creating structural dependencies.",
    "function_signature": "public void configureBlockingOperations(BlockHound.Builder builder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder#visibility(accessor,visibility)",
    "from_version": "v6.0.0",
    "to_version": "v6.0.1",
    "type": "method",
    "signature": "public Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)",
    "documentation": "\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}",
    "query": "Design a configuration method that adjusts the visibility levels for JSON property auto-detection in your Spring application to ensure only desired fields are serialized.",
    "function_signature": "public Jackson2ObjectMapperBuilder setPropertyVisibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.<unknown>#get(annotationType,predicate)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,",
    "query": "Develop a feature that dynamically retrieves and evaluates specific annotations on Spring beans based on custom runtime conditions, enhancing the flexibility of annotation-driven configurations.",
    "function_signature": "public <A extends Annotation> MergedAnnotation<A> getAnnotation(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> condition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate#execute(sql,Map<String,paramMap,action)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "query": "Create a service method that runs a dynamic SQL query with named parameters and handles the result set through a customizable callback mechanism, enhancing flexibility and maintainability in database operations.",
    "function_signature": "public <T> T executeDynamicQuery(String sql, Map<String, ?> params, PreparedStatementCallback<T> callback);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.common.ExpressionUtils#toInt(typeConverter,typedValue)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public int toInt(TypeConverter typeConverter, TypedValue typedValue)",
    "documentation": "\t/**\n\t * Attempt to convert a typed value to an int using the supplied type converter.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static int toInt(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Integer.class);\n\t}",
    "query": "In a configuration management system, ensure that dynamic property values are accurately converted to integers for processing user-defined thresholds.",
    "function_signature": "public int convertTypedValueToInt(TypeConverter typeConverter, TypedValue typedValue)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.condition.ProducesRequestCondition#isEmpty()",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public boolean isEmpty()",
    "documentation": "\t/**\n\t * Whether the condition has any media type expressions.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isEmpty() {\n\t\treturn this.expressions.isEmpty();\n\t}",
    "query": "Create a Spring MVC controller method that triggers fallback processing logic when no specific response media types are defined for the incoming request.",
    "function_signature": "public boolean shouldUseFallbackProcessing(RequestMappingInfo mappingInfo)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.env.AbstractPropertyResolver#getProperty(key)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public String getProperty(String key)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic @Nullable String getProperty(String key) {\n\t\treturn getProperty(key, String.class);\n\t}",
    "query": "Implement a service method that dynamically retrieves configuration values based on a provided identifier, ensuring seamless integration with Spring's environment abstraction for flexible property management.",
    "function_signature": "public String resolveConfigurationValue(String identifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.HttpHeaders#addAll(headers)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public void addAll(HttpHeaders headers)",
    "documentation": "\t/**\n\t * Add all the values of the given {@code HttpHeaders} to the current header.\n\t * <p>As values are represented as a {@code List}, duplicate values can be\n\t * introduced. See {@link #putAll(HttpHeaders)} to replace the list of\n\t * values of each individual header name instead.\n\t * @param headers the headers to add\n\t * @since 7.0\n\t * @see #putAll(HttpHeaders)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void addAll(HttpHeaders headers) {\n\t\tthis.headers.addAll(headers.headers);\n\t}",
    "query": "Implement a feature in your web service that consolidates incoming HTTP headers from various sources into a unified set, ensuring that all header values are retained and combined appropriately without losing any existing information.",
    "function_signature": "public void mergeHeaders(HttpHeaders additionalHeaders)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.<unknown>#synthesize(condition)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition)",
    "query": "Develop a utility that extracts specific annotations from service classes only when they meet predefined criteria, facilitating conditional behavior based on annotation attributes.",
    "function_signature": "public Optional<A> extractConditionalAnnotation(Predicate<? super MergedAnnotation<A>> condition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.ErrorResponseException#getMessage()",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public String getMessage()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getMessage() {\n\t\treturn this.status + (!this.headers.isEmpty() ? \", headers=\" + this.headers : \"\") + \", \" + this.body;\n\t}",
    "query": "Design a service that compiles comprehensive error detailsincluding HTTP status codes, response headers, and body contentinto a single descriptive message for client applications.",
    "function_signature": "public String compileErrorDetails(ErrorResponseException exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.WebExchangeBindException#getPropertyEditorRegistry()",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public PropertyEditorRegistry getPropertyEditorRegistry()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic @Nullable PropertyEditorRegistry getPropertyEditorRegistry() {\n\t\treturn this.bindingResult.getPropertyEditorRegistry();\n\t}",
    "query": "In a reactive Spring application, implement a utility method that handles data binding failures by accessing the underlying registry of property editors. This will allow for dynamic customization of type conversions when processing binding errors.",
    "function_signature": "public PropertyEditorRegistry getEditorsFromBindingError(BindingException exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor#configure(executor,exceptionHandler)",
    "from_version": "v6.2.7",
    "to_version": "v7.0.0-M5",
    "type": "method",
    "signature": "public void configure(@Nullable Supplier<? extends @Nullable Executor> executor,\n\t\t\t@Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler)",
    "documentation": "\t/**\n\t * Configure this post-processor with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void configure(@Nullable Supplier<? extends @Nullable Executor> executor,",
    "query": "Design a component that manages asynchronous processing of data imports, enabling dynamic selection of thread pools and custom error handling strategies based on runtime conditions.",
    "function_signature": "public void configureDataImportAsync(Supplier<? extends Executor> executorSupplier,\n                                     Supplier<? extends AsyncUncaughtExceptionHandler> exceptionHandlerSupplier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#get(key)",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public List<V> get(Object key)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic List<V> get(Object key) {\n\t\tList<V> result = this.delegate.get(key);\n\t\treturn (result != null ? Collections.unmodifiableList(result) : null);\n\t}",
    "query": "Design a component that retrieves configuration settings based on a provided key and ensures the returned list remains immutable to prevent unintended modifications.",
    "function_signature": "public List<Configuration> fetchConfigurations(String key)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#entrySet()",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public List<V>>> entrySet()",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic Set<Entry<K, List<V>>> entrySet() {\n\t\tif (this.entrySet == null) {\n\t\t\tthis.entrySet = new UnmodifiableEntrySet<>(this.delegate.entrySet());\n\t\t}\n\t\treturn this.entrySet;\n\t}",
    "query": "Develop a component that manages product categories, where each category can include multiple products. Ensure that the method returns an unmodifiable set of category entries, preventing external modifications while allowing efficient traversal of categories and their associated product lists.",
    "function_signature": "public Set<Map.Entry<String, List<Product>>> getCategoryEntries()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.DefaultResponseErrorHandler#getCharset(response)",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "protected Charset getCharset(ClientHttpResponse response)",
    "documentation": "\t/**\n\t * Determine the charset of the response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the associated charset, or {@code null} if none\n\t * @since 4.3.8\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Charset getCharset(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType.getCharset() : null);\n\t}",
    "query": "Design a specialized error handler that retrieves and utilizes the character set from HTTP responses to enhance exception messages during client-side error processing.",
    "function_signature": "protected Charset extractResponseCharset(ClientHttpResponse response) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.DefaultResponseErrorHandler#handleError(response)",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public void handleError(ClientHttpResponse response)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void handleError(ClientHttpResponse response) throws IOException {\n\n\t\t// Called via handleError(url, method, response)\n\t\tif (response instanceof HandleErrorResponseDecorator decorator) {\n\t\t\tdecorator.setNotHandled();\n\t\t\treturn;\n\t\t}\n\n\t\t// Called directly, so do handle\n\t\thandleError(response, response.getStatusCode(), null, null);\n\t}",
    "query": "Create a mechanism to intercept HTTP client responses and conditionally handle errors, allowing certain responses to bypass the default error processing based on custom criteria.",
    "function_signature": "public void conditionalHandleError(ClientHttpResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.DefaultResponseErrorHandler#isHandled()",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public boolean isHandled()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isHandled() {\n\t\t\treturn this.handled;\n\t\t}",
    "query": "Design a component in your Spring application that intercepts HTTP responses from external services and determines whether specific error conditions have been addressed internally before deciding to propagate them further or take alternative actions.",
    "function_signature": "public boolean hasResponseBeenManaged(HttpResponse<?> response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#build()",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public EntityResponse<T> build()",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic EntityResponse<T> build() {\n\t\tif (this.entity instanceof CompletionStage completionStage) {\n\t\t\treturn new CompletionStageEntityResponse(this.status, this.headers, this.cookies,\n\t\t\t\t\tcompletionStage, this.entityType);\n\t\t}\n\t\telse if (DefaultAsyncServerResponse.reactiveStreamsPresent) {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(this.entity.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tPublisher<T> publisher = adapter.toPublisher(this.entity);\n\t\t\t\treturn new PublisherEntityResponse(this.status, this.headers, this.cookies, publisher, this.entityType);\n\t\t\t}\n\t\t}\n\t\treturn new DefaultEntityResponse<>(this.status, this.headers, this.cookies, this.entity, this.entityType);\n\t}",
    "query": "Design a handler that constructs HTTP responses capable of seamlessly managing both synchronous data and asynchronous streams, ensuring optimal performance in a reactive web application environment.",
    "function_signature": "public <T> EntityResponse<T> createHttpResponse(int status, HttpHeaders headers, T body)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#onError(onError)",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public SseBuilder onError(Consumer<Throwable> onError)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\t\tpublic SseBuilder onError(Consumer<Throwable> onError) {\n\t\t\tthis.deferredResult.onError(onError);\n\t\t\treturn this;\n\t\t}",
    "query": "Create a method to establish a server-sent events (SSE) stream that includes robust error management. The implementation should allow for custom handling of exceptions that may occur during the streaming process, ensuring that any issues are appropriately addressed without disrupting the client connection.",
    "function_signature": "public SseBuilder setupSseStreamWithCustomErrorHandler(Consumer<Throwable> errorHandler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.DefaultResponseErrorHandler",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "class",
    "signature": "public class DefaultResponseErrorHandler",
    "documentation": "/**\n * Spring's default implementation of the {@link ResponseErrorHandler} interface.\n *\n * <p>This error handler checks for the status code on the\n * {@link ClientHttpResponse}. Any code in the 4xx or 5xx series is considered\n * to be an error. This behavior can be changed by overriding\n * {@link #hasError(HttpStatusCode)}. Unknown status codes will be ignored by\n * {@link #hasError(ClientHttpResponse)}.\n *\n * <p>See {@link #handleError(URI, HttpMethod, ClientHttpResponse)}  for more\n * details on specific exception types.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.0\n * @see RestTemplate#setErrorHandler\n */",
    "changetype": "stabilized",
    "source_code": "public class DefaultResponseErrorHandler implements ResponseErrorHandler {\n\n\t@Nullable\n\tprivate List<HttpMessageConverter<?>> messageConverters;\n\n\n\t/**\n\t * For internal use from the RestTemplate, to pass the message converters\n\t * to use to decode error content.\n\t * @since 6.0\n\t */\n\tvoid setMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\tthis.messageConverters = Collections.unmodifiableList(converters);\n\t}\n\n\n\t/**\n\t * Delegates to {@link #hasError(HttpStatusCode)} with the response status code.\n\t * @see ClientHttpResponse#getStatusCode()\n\t * @see #hasError(HttpStatusCode)\n\t */\n\t@Override\n\tpublic boolean hasError(ClientHttpResponse response) throws IOException {\n\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\treturn hasError(statusCode);\n\t}\n\n\t/**\n\t * Template method called from {@link #hasError(ClientHttpResponse)}.\n\t * <p>The default implementation checks {@link HttpStatusCode#isError()}.\n\t * Can be overridden in subclasses.\n\t * @param statusCode the HTTP status code\n\t * @return {@code true} if the response indicates an error; {@code false} otherwise\n\t * @see HttpStatusCode#isError()\n\t */\n\tprotected boolean hasError(HttpStatusCode statusCode) {\n\t\treturn statusCode.isError();\n\t}\n\n\t/**\n\t * Template method called from {@link #hasError(ClientHttpResponse)}.\n\t * <p>The default implementation checks if the given status code is\n\t * {@link org.springframework.http.HttpStatus.Series#CLIENT_ERROR CLIENT_ERROR} or\n\t * {@link org.springframework.http.HttpStatus.Series#SERVER_ERROR SERVER_ERROR}.\n\t * Can be overridden in subclasses.\n\t * @param statusCode the HTTP status code as raw value\n\t * @return {@code true} if the response indicates an error; {@code false} otherwise\n\t * @since 4.3.21\n\t * @see org.springframework.http.HttpStatus.Series#CLIENT_ERROR\n\t * @see org.springframework.http.HttpStatus.Series#SERVER_ERROR\n\t * @deprecated in favor of {@link #hasError(HttpStatusCode)}\n\t */\n\t@Deprecated\n\tprotected boolean hasError(int statusCode) {\n\t\tHttpStatus.Series series = HttpStatus.Series.resolve(statusCode);\n\t\treturn (series == HttpStatus.Series.CLIENT_ERROR || series == HttpStatus.Series.SERVER_ERROR);\n\t}\n\n\t/**\n\t * Handle the error in the given response with the given resolved status code\n\t * and extra information providing access to the request URL and HTTP method.\n\t * <p>The default implementation throws:\n\t * <ul>\n\t * <li>{@link HttpClientErrorException} if the status code is in the 4xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpClientErrorException.BadRequest} and others.\n\t * <li>{@link HttpServerErrorException} if the status code is in the 5xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpServerErrorException.InternalServerError} and others.\n\t * <li>{@link UnknownHttpStatusCodeException} for error status codes not in the\n\t * {@link HttpStatus} enum range.\n\t * </ul>\n\t * @throws UnknownHttpStatusCodeException in case of an unresolvable status code\n\t * @since 6.2\n\t * @see #handleError(ClientHttpResponse, HttpStatusCode, URI, HttpMethod)\n\t */\n\t@Override\n\tpublic void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\n\t\t// For backwards compatibility try handle(response) first\n\t\tHandleErrorResponseDecorator decorator = new HandleErrorResponseDecorator(response);\n\t\thandleError(decorator);\n\t\tif (decorator.isHandled()) {\n\t\t\treturn;\n\t\t}\n\n\t\thandleError(response, response.getStatusCode(), url, method);\n\t}\n\n\t@SuppressWarnings(\"removal\")\n\t@Override\n\tpublic void handleError(ClientHttpResponse response) throws IOException {\n\n\t\t// Called via handleError(url, method, response)\n\t\tif (response instanceof HandleErrorResponseDecorator decorator) {\n\t\t\tdecorator.setNotHandled();\n\t\t\treturn;\n\t\t}\n\n\t\t// Called directly, so do handle\n\t\thandleError(response, response.getStatusCode(), null, null);\n\t}\n\n\t/**\n\t * Handle the error based on the resolved status code.\n\t * <p>The default implementation delegates to\n\t * {@link HttpClientErrorException#create} for errors in the 4xx range, to\n\t * {@link HttpServerErrorException#create} for errors in the 5xx range,\n\t * or otherwise raises {@link UnknownHttpStatusCodeException}.\n\t * @since 6.2\n\t * @see HttpClientErrorException#create\n\t * @see HttpServerErrorException#create\n\t */\n\tprotected void handleError(\n\t\t\tClientHttpResponse response, HttpStatusCode statusCode,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method) throws IOException {\n\n\t\tString statusText = response.getStatusText();\n\t\tHttpHeaders headers = response.getHeaders();\n\t\tbyte[] body = getResponseBody(response);\n\t\tCharset charset = getCharset(response);\n\t\tString message = getErrorMessage(statusCode.value(), statusText, body, charset, url, method);\n\n\t\tRestClientResponseException ex;\n\t\tif (statusCode.is4xxClientError()) {\n\t\t\tex = HttpClientErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse if (statusCode.is5xxServerError()) {\n\t\t\tex = HttpServerErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\tex = new UnknownHttpStatusCodeException(message, statusCode.value(), statusText, headers, body, charset);\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.messageConverters)) {\n\t\t\tex.setBodyConvertFunction(initBodyConvertFunction(response, body));\n\t\t}\n\n\t\tthrow ex;\n\t}\n\n\t/**\n\t * Read the body of the given response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the response body as a byte array,\n\t * or an empty byte array if the body could not be read\n\t * @since 4.3.8\n\t */\n\tprotected byte[] getResponseBody(ClientHttpResponse response) {\n\t\treturn RestClientUtils.getBody(response);\n\t}\n\n\t/**\n\t * Determine the charset of the response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the associated charset, or {@code null} if none\n\t * @since 4.3.8\n\t */\n\t@Nullable\n\tprotected Charset getCharset(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType.getCharset() : null);\n\t}\n\n\t/**\n\t * Return an error message with details from the response body. For example:\n\t * <pre>\n\t * 404 Not Found on GET request for \"https://example.com\": [{'id': 123, 'message': 'my message'}]\n\t * </pre>\n\t */\n\tprivate String getErrorMessage(\n\t\t\tint rawStatusCode, String statusText, @Nullable byte[] responseBody, @Nullable Charset charset,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method) {\n\n\t\tStringBuilder msg = new StringBuilder(rawStatusCode + \" \" + statusText);\n\t\tif (method != null) {\n\t\t\tmsg.append(\" on \").append(method).append(\" request\");\n\t\t}\n\t\tif (url != null) {\n\t\t\tmsg.append(\" for \\\"\");\n\t\t\tString urlString = url.toString();\n\t\t\tint idx = urlString.indexOf('?');\n\t\t\tif (idx != -1) {\n\t\t\t\tmsg.append(urlString, 0, idx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmsg.append(urlString);\n\t\t\t}\n\t\t\tmsg.append(\"\\\"\");\n\t\t}\n\t\tmsg.append(\": \");\n\t\tif (ObjectUtils.isEmpty(responseBody)) {\n\t\t\tmsg.append(\"[no body]\");\n\t\t}\n\t\telse {\n\t\t\tcharset = (charset != null ? charset : StandardCharsets.UTF_8);\n\t\t\tString bodyText = new String(responseBody, charset);\n\t\t\tbodyText = LogFormatUtils.formatValue(bodyText, -1, true);\n\t\t\tmsg.append(bodyText);\n\t\t}\n\t\treturn msg.toString();\n\t}\n\n\t/**\n\t * Return a function for decoding the error content. This can be passed to\n\t * {@link RestClientResponseException#setBodyConvertFunction(Function)}.\n\t * @since 6.0\n\t */\n\t@SuppressWarnings(\"NullAway\")\n\tprotected Function<ResolvableType, ?> initBodyConvertFunction(ClientHttpResponse response, byte[] body) {\n\t\tAssert.state(!CollectionUtils.isEmpty(this.messageConverters), \"Expected message converters\");\n\t\treturn resolvableType -> {\n\t\t\ttry {\n\t\t\t\tHttpMessageConverterExtractor<?> extractor =\n\t\t\t\t\t\tnew HttpMessageConverterExtractor<>(resolvableType.getType(), this.messageConverters);\n\n\t\t\t\treturn extractor.extractData(new ClientHttpResponseDecorator(response) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic InputStream getBody() {\n\t\t\t\t\t\treturn new ByteArrayInputStream(body);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new RestClientException(\n\t\t\t\t\t\t\"Error while extracting response for type [\" + resolvableType + \"]\", ex);\n\t\t\t}\n\t\t};\n\t}\n\n\n\tprivate static class HandleErrorResponseDecorator extends ClientHttpResponseDecorator {\n\n\t\tprivate boolean handled = true;\n\n\t\tpublic HandleErrorResponseDecorator(ClientHttpResponse delegate) {\n\t\t\tsuper(delegate);\n\t\t}\n\n\t\tpublic void setNotHandled() {\n\t\t\tthis.handled = false;\n\t\t}\n\n\t\tpublic boolean isHandled() {\n\t\t\treturn this.handled;\n\t\t}\n\t}\n\n}",
    "query": "Implement a service that communicates with external APIs and requires sophisticated error handling. Ensure that the error processing logic takes into account both the HTTP method and the request URI to provide more contextual exception handling.",
    "function_signature": "public RestTemplate configureRestTemplateWithContextualErrorHandler()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#iterator()",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public Iterator<List<V>> iterator()",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\t\tpublic Iterator<List<V>> iterator() {\n\t\t\tIterator<List<V>> iterator = this.delegate.iterator();\n\t\t\treturn new Iterator<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\treturn iterator.hasNext();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic List<V> next() {\n\t\t\t\t\treturn Collections.unmodifiableList(iterator.next());\n\t\t\t\t}\n\t\t\t};\n\t\t}",
    "query": "Create a Spring service that manages grouped configurations, allowing clients to iterate through each configuration group without the ability to modify the underlying lists. Ensure that the iteration mechanism enforces immutability to maintain configuration integrity.",
    "function_signature": "public Iterator<List<Configuration>> getConfigurationGroupsIterator()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.<unknown>#createHandlers(overrideAnnotation,testClass)",
    "from_version": "v6.2.1",
    "to_version": "v6.2.2",
    "type": "method",
    "signature": "public List<BeanOverrideHandler> createHandlers(Annotation overrideAnnotation, Class<?> testClass)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic List<BeanOverrideHandler> createHandlers(Annotation overrideAnnotation, Class<?> testClass) {\n\t\tif (!(overrideAnnotation instanceof MockitoBean mockitoBean)) {\n\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\t\texpected @MockitoBean on test class \"\"\" + testClass.getName());\n\t\t}\n\t\tClass<?>[] types = mockitoBean.types();\n\t\tAssert.state(types.length > 0,\n\t\t\t\t\"The @MockitoBean 'types' attribute must not be empty when declared on a class\");\n\t\tAssert.state(mockitoBean.name().isEmpty() || types.length == 1,\n\t\t\t\t\"The @MockitoBean 'name' attribute cannot be used when mocking multiple types\");\n\t\tList<BeanOverrideHandler> handlers = new ArrayList<>();\n\t\tfor (Class<?> type : types) {\n\t\t\thandlers.add(new MockitoBeanOverrideHandler(ResolvableType.forClass(type), mockitoBean));\n\t\t}\n\t\treturn handlers;\n\t}",
    "query": "How can you enhance your Spring test configuration to seamlessly override multiple bean types with Mockito mocks while ensuring each mock is correctly associated with its corresponding type?",
    "function_signature": "public List<BeanOverrideHandler> initializeMockitoOverrides(Annotation overrideAnnotation, Class<?> testClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.AbstractWebSocketMessage",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "class",
    "signature": "public class AbstractWebSocketMessage",
    "documentation": "/**\n * A message that can be handled or sent on a WebSocket connection.\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n * @param <T> the payload type\n */",
    "changetype": "stabilized",
    "source_code": "public abstract class AbstractWebSocketMessage<T> implements WebSocketMessage<T> {\n\n\tprivate final T payload;\n\n\tprivate final boolean last;\n\n\n\t/**\n\t * Create a new WebSocket message with the given payload.\n\t * @param payload the non-null payload\n\t */\n\tAbstractWebSocketMessage(T payload) {\n\t\tthis(payload, true);\n\t}\n\n\t/**\n\t * Create a new WebSocket message given payload representing the full or partial\n\t * message content. When the {@code isLast} boolean flag is set to {@code false}\n\t * the message is sent as partial content and more partial messages will be\n\t * expected until the boolean flag is set to {@code true}.\n\t * @param payload the non-null payload\n\t * @param isLast if the message is the last of a series of partial messages\n\t */\n\tAbstractWebSocketMessage(T payload, boolean isLast) {\n\t\tAssert.notNull(payload, \"payload must not be null\");\n\t\tthis.payload = payload;\n\t\tthis.last = isLast;\n\t}\n\n\n\t/**\n\t * Return the message payload (never {@code null}).\n\t */\n\t@Override\n\tpublic T getPayload() {\n\t\treturn this.payload;\n\t}\n\n\t/**\n\t * Whether this is the last part of a message sent as a series of partial messages.\n\t */\n\t@Override\n\tpublic boolean isLast() {\n\t\treturn this.last;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof AbstractWebSocketMessage<?> otherMessage)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn ObjectUtils.nullSafeEquals(this.payload, otherMessage.payload);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn ObjectUtils.nullSafeHashCode(this.payload);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" payload=[\" + toStringPayload() +\n\t\t\t\t\"], byteCount=\" + getPayloadLength() + \", last=\" + isLast() + \"]\";\n\t}\n\n\tprotected abstract String toStringPayload();\n\n}",
    "query": "Design a WebSocket service that efficiently handles large data transmissions by breaking them into manageable segments. Ensure that the service can reconstruct the complete message on the client side, recognizing when the final segment has been received.",
    "function_signature": "public void processSegmentedMessage(SegmentedPayload payload, boolean isFinalSegment)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.AbstractWebSocketMessage#hashCode()",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\treturn ObjectUtils.nullSafeHashCode(this.payload);\n\t}",
    "query": "Create a component that tracks and identifies duplicate WebSocket messages by leveraging their content to ensure each unique message is processed only once.",
    "function_signature": "public int trackUniqueWebSocketMessage(AbstractWebSocketMessage<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Conventions#getVariableNameForReturnType(method,value)",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public String getVariableNameForReturnType(Method method, @Nullable Object value)",
    "documentation": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, e.g. {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), value);\n\t}",
    "query": "Create a Spring service method that dynamically assigns a standard variable name based on the return type of a provided method. Ensure it intelligently handles generic collections and defaults appropriately when the method's return type lacks specificity.",
    "function_signature": "public String determineDynamicVariableName(Method method, @Nullable Object returnValue)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Conventions#getQualifiedAttributeName(enclosingClass,attributeName)",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName)",
    "documentation": "\t/**\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\n\t\tAssert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\treturn enclosingClass.getName() + '.' + attributeName;\n\t}",
    "query": "Implement a feature that registers custom attributes for beans, ensuring each attribute name is uniquely prefixed with its containing class's fully qualified name to avoid conflicts within the application context.",
    "function_signature": "public void registerQualifiedBeanAttribute(Class<?> beanClass, String attributeName, Object value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Conventions",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "class",
    "signature": "public class Conventions",
    "documentation": "/**\n * Provides methods to support various naming and other conventions used\n * throughout the framework. Mainly for internal use within the framework.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 2.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class Conventions {\n\n\t/**\n\t * Suffix added to names when using arrays.\n\t */\n\tprivate static final String PLURAL_SUFFIX = \"List\";\n\n\n\tprivate Conventions() {\n\t}\n\n\n\t/**\n\t * Determine the conventional variable name for the supplied {@code Object}\n\t * based on its concrete type. The convention used is to return the\n\t * un-capitalized short name of the {@code Class}, according to JavaBeans\n\t * property naming rules.\n\t * <p>For example:<br>\n\t * {@code com.myapp.Product} becomes {@code \"product\"}<br>\n\t * {@code com.myapp.MyProduct} becomes {@code \"myProduct\"}<br>\n\t * {@code com.myapp.UKProduct} becomes {@code \"UKProduct\"}<br>\n\t * <p>For arrays the pluralized version of the array component type is used.\n\t * For {@code Collection}s an attempt is made to 'peek ahead' to determine\n\t * the component type and return its pluralized version.\n\t * @param value the value to generate a variable name for\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableName(Object value) {\n\t\tAssert.notNull(value, \"Value must not be null\");\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\n\t\tif (value.getClass().isArray()) {\n\t\t\tvalueClass = value.getClass().getComponentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (value instanceof Collection<?> collection) {\n\t\t\tif (collection.isEmpty()) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for an empty Collection\");\n\t\t\t}\n\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = getClassForValue(value);\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the given parameter taking\n\t * the generic collection type, if any, into account.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param parameter the method or constructor parameter\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForParameter(MethodParameter parameter) {\n\t\tAssert.notNull(parameter, \"MethodParameter must not be null\");\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (parameter.getParameterType().isArray()) {\n\t\t\tvalueClass = parameter.getParameterType().getComponentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n\t\t\tvalueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for non-typed Collection parameter type\");\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = parameter.getParameterType();\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = parameter.nested().getNestedParameterType();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the return type of the\n\t * given method, taking the generic collection type, if any, into account.\n\t * @param method the method to generate a variable name for\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForReturnType(Method method) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), null);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, e.g. {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), value);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, e.g. {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\n\t\tif (Object.class == resolvedType) {\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for an Object return type with null value\");\n\t\t\t}\n\t\t\treturn getVariableName(value);\n\t\t}\n\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (resolvedType.isArray()) {\n\t\t\tvalueClass = resolvedType.getComponentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(resolvedType)) {\n\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tif (!(value instanceof Collection<?> collection)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and a non-Collection value\");\n\t\t\t\t}\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and an empty Collection value\");\n\t\t\t\t}\n\t\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = resolvedType;\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}\n\n\t/**\n\t * Convert {@code String}s in attribute name format (e.g. lowercase, hyphens\n\t * separating words) into property name format (camel-case). For example\n\t * {@code transaction-manager} becomes {@code \"transactionManager\"}.\n\t */\n\tpublic static String attributeNameToPropertyName(String attributeName) {\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\tif (!attributeName.contains(\"-\")) {\n\t\t\treturn attributeName;\n\t\t}\n\t\tchar[] result = new char[attributeName.length() -1]; // not completely accurate but good guess\n\t\tint currPos = 0;\n\t\tboolean upperCaseNext = false;\n\t\tfor (int i = 0; i < attributeName.length(); i++ ) {\n\t\t\tchar c = attributeName.charAt(i);\n\t\t\tif (c == '-') {\n\t\t\t\tupperCaseNext = true;\n\t\t\t}\n\t\t\telse if (upperCaseNext) {\n\t\t\t\tresult[currPos++] = Character.toUpperCase(c);\n\t\t\t\tupperCaseNext = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult[currPos++] = c;\n\t\t\t}\n\t\t}\n\t\treturn new String(result, 0, currPos);\n\t}\n\n\t/**\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t */\n\tpublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\n\t\tAssert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\treturn enclosingClass.getName() + '.' + attributeName;\n\t}\n\n\n\t/**\n\t * Determine the class to use for naming a variable containing the given value.\n\t * <p>Will return the class of the given value, except when encountering a\n\t * JDK proxy, in which case it will determine the 'primary' interface\n\t * implemented by that proxy.\n\t * @param value the value to check\n\t * @return the class to use for naming a variable\n\t */\n\tprivate static Class<?> getClassForValue(Object value) {\n\t\tClass<?> valueClass = value.getClass();\n\t\tif (Proxy.isProxyClass(valueClass)) {\n\t\t\tClass<?>[] ifcs = valueClass.getInterfaces();\n\t\t\tfor (Class<?> ifc : ifcs) {\n\t\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\t\treturn ifc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {\n\t\t\t// '$' in the class name but no inner class -\n\t\t\t// assuming it's a special subclass (e.g. by OpenJPA)\n\t\t\tvalueClass = valueClass.getSuperclass();\n\t\t}\n\t\treturn valueClass;\n\t}\n\n\t/**\n\t * Pluralize the given name.\n\t */\n\tprivate static String pluralize(String name) {\n\t\treturn name + PLURAL_SUFFIX;\n\t}\n\n\t/**\n\t * Retrieve the {@code Class} of an element in the {@code Collection}.\n\t * The exact element for which the {@code Class} is retrieved will depend\n\t * on the concrete {@code Collection} implementation.\n\t */\n\tprivate static <E> E peekAhead(Collection<E> collection) {\n\t\tIterator<E> it = collection.iterator();\n\t\tif (!it.hasNext()) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unable to peek ahead in non-empty collection - no element found\");\n\t\t}\n\t\tE value = it.next();\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unable to peek ahead in non-empty collection - only null element found\");\n\t\t}\n\t\treturn value;\n\t}\n\n}",
    "query": "Design a utility method within your Spring application that dynamically registers a collection of service instances. The method should intelligently generate distinct and conventional bean names for each instance based on their class types, automatically handling pluralization for collections to ensure consistency and ease of access within the Spring context.",
    "function_signature": "public void registerServicesDynamically(Collection<?> services)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Conventions#attributeNameToPropertyName(attributeName)",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public String attributeNameToPropertyName(String attributeName)",
    "documentation": "\t/**\n\t * Convert {@code String}s in attribute name format (e.g. lowercase, hyphens\n\t * separating words) into property name format (camel-case). For example\n\t * {@code transaction-manager} becomes {@code \"transactionManager\"}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String attributeNameToPropertyName(String attributeName) {\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\tif (!attributeName.contains(\"-\")) {\n\t\t\treturn attributeName;\n\t\t}\n\t\tchar[] result = new char[attributeName.length() -1]; // not completely accurate but good guess\n\t\tint currPos = 0;\n\t\tboolean upperCaseNext = false;\n\t\tfor (int i = 0; i < attributeName.length(); i++ ) {\n\t\t\tchar c = attributeName.charAt(i);\n\t\t\tif (c == '-') {\n\t\t\t\tupperCaseNext = true;\n\t\t\t}\n\t\t\telse if (upperCaseNext) {\n\t\t\t\tresult[currPos++] = Character.toUpperCase(c);\n\t\t\t\tupperCaseNext = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult[currPos++] = c;\n\t\t\t}\n\t\t}\n\t\treturn new String(result, 0, currPos);\n\t}",
    "query": "Design a Spring service that seamlessly converts configuration properties written in kebab-case (e.g., \"data-source\") to camelCase Java property names (e.g., \"dataSource\") to facilitate automatic binding without explicit mappings.",
    "function_signature": "public String convertKebabToCamelCase(String kebabCase)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.AbstractWebSocketMessage#toString()",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" payload=[\" + toStringPayload() +\n\t\t\t\t\"], byteCount=\" + getPayloadLength() + \", last=\" + isLast() + \"]\";\n\t}",
    "query": "Implement a monitoring feature for your WebSocket connections that records comprehensive details of each incoming and outgoing message, including its type, payload size, and whether it signifies the end of a message sequence.",
    "function_signature": "public void monitorWebSocketMessage(AbstractWebSocketMessage<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.AbstractWebSocketMessage#toStringPayload()",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "protected String toStringPayload()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected abstract String toStringPayload();",
    "query": "Implement a WebSocket service method that seamlessly transforms incoming messages into their string equivalents for real-time analytics.",
    "function_signature": "public String convertIncomingMessageToString(WebSocketMessage<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Conventions#getVariableNameForReturnType(method)",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public String getVariableNameForReturnType(Method method)",
    "documentation": "\t/**\n\t * Determine the conventional variable name for the return type of the\n\t * given method, taking the generic collection type, if any, into account.\n\t * @param method the method to generate a variable name for\n\t * @return the generated variable name\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), null);\n\t}",
    "query": "Design a service method that dynamically generates response model attribute names based on the return type of various controller methods, ensuring consistency and adherence to Spring's naming conventions.",
    "function_signature": "public Map<String, Object> prepareModelAttributes(Method controllerMethod)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.Conventions#getVariableNameForReturnType(method,resolvedType,value)",
    "from_version": "v6.0.0-M1",
    "to_version": "v6.0.0-M2",
    "type": "method",
    "signature": "public String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value)",
    "documentation": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, e.g. {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\n\t\tif (Object.class == resolvedType) {\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for an Object return type with null value\");\n\t\t\t}\n\t\t\treturn getVariableName(value);\n\t\t}\n\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (resolvedType.isArray()) {\n\t\t\tvalueClass = resolvedType.getComponentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(resolvedType)) {\n\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tif (!(value instanceof Collection<?> collection)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and a non-Collection value\");\n\t\t\t\t}\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and an empty Collection value\");\n\t\t\t\t}\n\t\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = resolvedType;\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}",
    "query": "Create a service method that processes user registrations and returns the result as a reactive type. Ensure that the method automatically generates a conventional variable name for the returned reactive stream based on its return type.",
    "function_signature": "public Mono<RegistrationResult> handleUserRegistration(UserRegistrationRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.web.WebMergedContextConfiguration#toString()",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public String toString()",
    "documentation": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}",
    "query": "Implement a feature in your Spring integration testing suite that logs comprehensive details of the test application context, including active profiles, property sources, and context customizers, to facilitate easier debugging and configuration verification.",
    "function_signature": "public String generateDetailedTestContextLog()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.<unknown>#getImportSelector()",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public DeferredImportSelector getImportSelector()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DeferredImportSelector getImportSelector() {\n\t\t\treturn this.importSelector;\n\t\t}",
    "query": "Revise the configuration to adopt the modern import selection approach, enhancing performance and ensuring type safety.",
    "function_signature": "public ImportStrategy resolveImportStrategy();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler#submitListenable(task)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public ListenableFuture<T> submitListenable(Callable<T> task)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic <T> ListenableFuture<T> submitListenable(Callable<T> task) {\n\t\treturn super.submitListenable(new DelegatingErrorHandlingCallable<>(task, this.errorHandler));\n\t}",
    "query": "Design a feature that handles processing of user-generated reports asynchronously, allowing other system components to attach callbacks that get triggered upon successful completion or failure of each report processing task.",
    "function_signature": "public ListenableFuture<ReportResult> processUserReport(Callable<ReportResult> reportTask)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#beforeTestMethod(testContext)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public void beforeTestMethod(TestContext testContext)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent && Boolean.TRUE.equals(\n\t\t\t\ttestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}",
    "query": "Develop a test setup routine that automatically resets and reinitializes all Mockito mocks before the execution of each test method to ensure isolation and prevent state leakage between tests.",
    "function_signature": "public void beforeTestMethod(TestContext testContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#sendRedirect(location,sc,clearBuffer)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public void sendRedirect(String location, int sc, boolean clearBuffer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void sendRedirect(String location, int sc, boolean clearBuffer) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}",
    "query": "Design a handler that redirects API clients to a maintenance page using a temporary redirect status, ensuring that any partially written response data is discarded.",
    "function_signature": "public void performMaintenanceRedirect(String maintenanceUrl, int redirectStatus, boolean discardResponse)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurers#getConfigurer(type)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type)",
    "documentation": "\t/**\n\t * Return a configurer instance for the given embedded database type.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @return the configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\treturn switch (type) {\n\t\t\t\tcase HSQL -> HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2 -> H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY -> DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t};\n\t\t}\n\t\tcatch (ClassNotFoundException | NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type + \"] is not available\", ex);\n\t\t}\n\t}",
    "query": "Create a utility that selects the proper setup procedure for an embedded database based on the user's choice, automatically handling the necessary configurations and driver validations.",
    "function_signature": "public EmbeddedDatabaseConfigurer selectDatabaseConfigurer(EmbeddedDatabaseType type)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#equals(other)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof JCacheOperationSourcePointcut that &&\n\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t}",
    "query": "Refactor the caching mechanism in your Spring application to enhance performance and ensure thread safety. Implement a component that accurately determines cache operations without relying on potentially inefficient comparison methods.",
    "function_signature": "public boolean isCacheOperationCompatible(@Nullable Object other)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.annotation.AnnotationCacheOperationSource#setPublicMethodsOnly(publicMethodsOnly)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public void setPublicMethodsOnly(boolean publicMethodsOnly)",
    "documentation": "\t/**\n\t * Set whether cacheable methods are expected to be public.\n\t * <p>The default is {@code true}.\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPublicMethodsOnly(boolean publicMethodsOnly) {\n\t\tthis.publicMethodsOnly = publicMethodsOnly;\n\t}",
    "query": "In a complex application, certain service methods that handle sensitive data are not exposed publicly but still require caching to optimize performance. How can you configure the caching system to recognize and cache these non-public methods without altering their access modifiers?",
    "function_signature": "public void setCacheMethodsPublicOnly(boolean publicMethodsOnly)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.client.match.ContentRequestMatchers#multipartData(MultiValueMap<String,expectedMap,defaultCharset)",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset)",
    "documentation": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} with a defaultCharset.\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset) {\n\t\treturn multipartData(expectedMap, defaultCharset, true);\n\t}",
    "query": "Design a test scenario that verifies the contents of a multipart HTTP request, ensuring each form field matches expected values using a specific character encoding.",
    "function_signature": "public RequestMatcher verifyMultipartContent(MultiValueMap<String, ?> expectedFields, Charset encoding)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#getCacheOperationSource()",
    "from_version": "v6.1.6",
    "to_version": "v6.2.0-M1",
    "type": "method",
    "signature": "protected JCacheOperationSource getCacheOperationSource()",
    "documentation": "\t/**\n\t * Obtain the underlying {@link JCacheOperationSource} (may be {@code null}).\n\t * To be implemented by subclasses.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected abstract JCacheOperationSource getCacheOperationSource();",
    "query": "Enhance the application's caching mechanism by implementing an efficient method to obtain the current cache operation source, ensuring improved performance and thread safety.",
    "function_signature": "protected CacheOperationSource fetchCurrentCacheOperationSource()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Enhance the messaging system to efficiently manage and track client subscriptions, ensuring optimal performance and thread safety during high-load scenarios.",
    "function_signature": "public void handleClientSubscriptions(String sessionId, String destination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Refactor the message handling component to improve destination lookup efficiency and ensure thread-safe operations in a concurrent environment.",
    "function_signature": "public String resolveDestination(String destinationName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#find(serverState,request)",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "method",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}",
    "query": "Create a method that efficiently retrieves active subscription mappings based on the current server state and specific request parameters, ensuring optimal performance and thread safety.",
    "function_signature": "public MultiValueMap<String, String> getActiveSubscriptions(ServerState serverState, FindRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Develop a service that efficiently manages user sessions and their message destinations, ensuring optimal performance and thread safety in a concurrent environment.",
    "function_signature": "public SubscriptionService initializeSubscriptionHandler()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Enhance the messaging broker's subscription handling by implementing a more efficient and secure registry management strategy.",
    "function_signature": "public SubscriptionManager configureSubscriptionManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a custom interceptor that modifies the response after the request handler execution, ensuring optimal performance and alignment with the latest Spring Framework best practices.",
    "function_signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a method to initialize the subscription system with enhanced performance and scalability, ensuring efficient management of multiple sessions and destinations.",
    "function_signature": "public void initializeSubscriptionSystem()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Refactor the interceptor configuration to efficiently handle URL patterns, ensuring enhanced performance and type safety when matching request paths.",
    "function_signature": "public PathPattern[] retrievePathPatterns()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Optimize the management of message subscriptions to enhance performance and ensure thread safety. Refactor the existing subscription handling to utilize a more efficient registry mechanism that scales better with increasing sessions and destinations.",
    "function_signature": "public void manageSubscriptionsEfficiently(SubscriptionManager manager, List<Session> sessions, List<Destination> destinations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.0-M2",
    "to_version": "v5.2.9.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Create a custom interceptor that efficiently decides whether to process incoming HTTP requests, ensuring optimal performance and enhanced security measures.",
    "function_signature": "public boolean shouldApplyInterceptor(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "method",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(",
    "query": "Design a method that initializes and manages URL patterns with improved performance and thread safety, accommodating dynamic path parsing in your web application's interceptor configuration.",
    "function_signature": "public AdvancedPatternManager initializePatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Refactor the interceptor configuration to enhance pattern matching efficiency and maintainability. Ensure that the new implementation leverages the latest path pattern handling mechanisms to improve performance and reduce potential errors.",
    "function_signature": "public PathPattern[] retrieveConfiguredPathPatterns()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Create a method to efficiently evaluate incoming HTTP requests and decide if they should be processed further based on their URL patterns. Ensure the implementation prioritizes performance and thread safety.",
    "function_signature": "public boolean shouldIntercept(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String session;",
    "query": "Refactor the messaging broker configuration to enhance thread safety and improve session management without directly accessing session identifiers.",
    "function_signature": "public String obtainSessionId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Develop a method to manage client subscriptions efficiently, ensuring thread-safe session handling and optimal resource utilization for scalable messaging applications.",
    "function_signature": "public void configureSubscription(String sessionId, String topic)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Enhance the message broker configuration to improve scalability and reliability by adopting the current best practices for managing message destinations.",
    "function_signature": "public void configureMessageDestinations()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String destination;",
    "query": "Develop a method to define and manage messaging destinations using the recommended configuration approach, ensuring improved performance and thread safety within your Spring application.",
    "function_signature": "public void configureMessagingDestination(MessagingDestinationConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Create a request interceptor that efficiently manages incoming HTTP requests, enhancing security and application responsiveness by utilizing the latest interception strategies.",
    "function_signature": "public boolean interceptRequest(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Create a thread-safe service for generating unique IDs in a messaging application, enhancing performance and reducing potential concurrency issues.",
    "function_signature": "public String generateUniqueId();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.3.18",
    "to_version": "v5.2.20.RELEASE",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Design a mechanism to efficiently manage user subscriptions, ensuring scalability and thread safety when handling multiple session identifiers and dynamic destination patterns.",
    "function_signature": "public void addUserSubscription(String sessionId, String destinationPattern)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Design a component that efficiently registers and manages user subscriptions to both specific and patterned messaging destinations, ensuring scalability and optimal handling of dynamic topic allocations.",
    "function_signature": "public void handleUserSubscriptions(String userSessionId, String messageDestination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "Design a monitoring component that periodically retrieves and logs the current number of active messaging destinations managed by the application's message broker.",
    "function_signature": "public int fetchActiveDestinationCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Design a service that initializes and manages a high volume of client subscriptions to multiple messaging channels, incorporating caching mechanisms and dynamic header-based selectors to optimize performance and resource utilization.",
    "function_signature": "public void initializeSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a mechanism that intercepts the response after a controller processes a request, allowing you to append common attributes to the model before the view is rendered.",
    "function_signature": "public void appendCommonAttributes(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean -&gt;\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Design a global error handling strategy for your reactive messaging application to uniformly manage exceptions arising from message processing across all message handlers.",
    "function_signature": "public void applyGlobalMessageErrorHandler(ErrorHandlingBean errorHandler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Create a service method that provides comprehensive details about the current messaging server's status, including active session counts, destination subscriptions, and cache configurations, to facilitate real-time monitoring and management.",
    "function_signature": "public ServerState retrieveServerStatus()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a method to retrieve all active message destination identifiers in a WebSocket-based notification system.",
    "function_signature": "public String[] getActiveDestinationIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a feature that ensures cleanup operations and custom logging are executed after every HTTP request is fully processed, handling any exceptions that may have occurred during the request lifecycle.",
    "function_signature": "public void finalizeRequestHandling(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Create a monitoring feature for a real-time chat application that allows administrators to retrieve and display all active user subscriptions to various chat rooms. This feature should enable admins to oversee user connections and manage subscriptions dynamically without disrupting ongoing communications.",
    "function_signature": "public Map<String, UserSubscription> fetchSubscriptionRegistrySnapshot()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.21.RELEASE",
    "to_version": "v5.3.20",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Implement an interceptor that logs request details for all user-related endpoints under \"/users/**\" while excluding any authentication paths, utilizing advanced URL pattern matching for optimal performance.",
    "function_signature": "@Bean\npublic HandlerInterceptor userLoggingInterceptor(String[] includePatterns, String[] excludePatterns, PathPatternParser parser) {\n    // implementation here\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.3.5",
    "to_version": "v5.3.6",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Design a custom interceptor that conditionally processes HTTP requests based on dynamic and complex URL patterns. Ensure that the interceptor efficiently distinguishes between path containers and simple path strings to optimize request handling.",
    "function_signature": "public boolean shouldProcessRequest(Object requestPath, boolean isPathContainer, PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)",
    "from_version": "v5.3.5",
    "to_version": "v5.3.6",
    "type": "method",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(",
    "query": "Implement a middleware component that selectively intercepts HTTP requests based on dynamic URL patterns, allowing for customizable pattern parsing to enhance routing flexibility in your Spring application.",
    "function_signature": "public PatternAdapter[] configureInterceptionPatterns(@Nullable String[] urlPatterns, @Nullable PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPatternString()",
    "from_version": "v5.3.5",
    "to_version": "v5.3.6",
    "type": "method",
    "signature": "public String getPatternString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}",
    "query": "Design a feature that dynamically retrieves and logs the URL patterns associated with each interceptor in your Spring application. This will help in monitoring and debugging request flows by providing clear visibility into how interceptors are mapped to specific URL patterns.",
    "function_signature": "public void logInterceptorUrlPatterns(List<ModedInterceptor> interceptors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.interceptor.<unknown>#equals(other)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof JCacheOperationSourceClassFilter that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getCacheOperationSource(), that.getCacheOperationSource())));\n\t\t}",
    "query": "Develop a caching mechanism that accurately determines whether two cache operation sources are equivalent, ensuring consistent caching behavior across different components of your application.",
    "function_signature": "public boolean validateCacheOperationSource(@Nullable Object other);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler#writeAndFlushWith(body)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {\n\t\t\tthis.bodyFlux = Flux.from(body).flatMap(Flux::from);\n\t\t\treturn Mono.empty();\n\t\t}",
    "query": "Design a reactive endpoint that streams a sequence of data buffers to the client, ensuring each buffer is flushed immediately after processing.",
    "function_signature": "public Mono<Void> streamAndFlushData(Publisher<? extends Publisher<? extends DataBuffer>> dataStream);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#read()",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public byte read()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic byte read() {\n\t\treturn this.delegate.read();\n\t}",
    "query": "Design a service that efficiently processes incoming binary data streams, allowing for precise byte-level operations within a reactive framework.",
    "function_signature": "public Mono<Void> readAndProcessByte(DataBuffer dataBuffer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.converter.AbstractSmartHttpMessageConverter#getHeaders()",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public HttpHeaders getHeaders()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}",
    "query": "Create a custom HTTP message converter that dynamically modifies response headers based on the content being processed, ensuring headers are appropriately managed during the conversion process.",
    "function_signature": "public HttpHeaders configureResponseHeaders()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#with(postProcessor)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor)",
    "documentation": "\t/**\n\t * An extension point for further initialization of {@link MockHttpServletRequest}\n\t * in ways not built directly into the {@code MockHttpServletRequestBuilder}.\n\t * Implementation of this interface can have builder-style methods themselves\n\t * and be made accessible through static factory methods.\n\t * @param postProcessor a post-processor to add\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor) {\n\t\tAssert.notNull(postProcessor, \"postProcessor is required\");\n\t\tthis.postProcessors.add(postProcessor);\n\t\treturn this;\n\t}",
    "query": "Enhance your mock HTTP request setup by integrating additional customization steps efficiently, ensuring improved performance and maintainability.",
    "function_signature": "public MockHttpServletRequestBuilder apply(RequestPostProcessor postProcessor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#writePosition(writePosition)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public DataBuffer writePosition(int writePosition)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic DataBuffer writePosition(int writePosition) {\n\t\tthis.delegate.writePosition(writePosition);\n\t\treturn this;\n\t}",
    "query": "Develop a function that enables precise manipulation of the write position within a data buffer to enhance data processing efficiency.",
    "function_signature": "public DataBuffer setBufferWritePosition(int position)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.FieldError#getRejectedValue()",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public Object getRejectedValue()",
    "documentation": "\t/**\n\t * Return the rejected field value.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Object getRejectedValue() {\n\t\treturn this.rejectedValue;\n\t}",
    "query": "Create a service method that retrieves the specific input value a user provided for a field that failed validation.",
    "function_signature": "public Object getInvalidValue(String fieldName, BindingResult bindingResult)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#write(source,offset,length)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.delegate.write(source, offset, length);\n\t\treturn this;\n\t}",
    "query": "Design a method for a high-performance data processing service that writes a specific segment of a byte array into a data buffer, allowing control over the starting point and the number of bytes to write.",
    "function_signature": "public DataBuffer write(byte[] source, int offset, int length)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.interceptor.JCacheOperationSourcePointcut#matches(method,targetClass)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}",
    "query": "Design a mechanism to efficiently determine if a specific method within a target class is eligible for caching operations, enhancing both performance and reliability.",
    "function_signature": "public boolean isCacheOperationPresent(Method method, Class<?> targetClass);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange#transformUrl(url)",
    "from_version": "v6.1.11",
    "to_version": "v6.2.0-M5",
    "type": "method",
    "signature": "public String transformUrl(String url)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String transformUrl(String url) {\n\t\treturn this.urlTransformer.apply(url);\n\t}",
    "query": "Develop a middleware component that intercepts incoming HTTP requests and adjusts their URLs to include user-specific query parameters for enhanced personalization.",
    "function_signature": "public String transformIncomingUrl(String url)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#remoteAddress(remoteAddress)",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder remoteAddress(String remoteAddress)",
    "documentation": "\t/**\n\t * Set the remote address of the request.\n\t * @param remoteAddress the remote address (IP)\n\t * @since 6.0.10\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic MockHttpServletRequestBuilder remoteAddress(String remoteAddress) {\n\t\tAssert.hasText(remoteAddress, \"'remoteAddress' must not be null or blank\");\n\t\tthis.remoteAddress = remoteAddress;\n\t\treturn this;\n\t}",
    "query": "Design a request builder that assigns the client's IP address using a type-safe and efficient approach, ensuring robustness and enhanced performance.",
    "function_signature": "public MockHttpServletRequestBuilder withClientAddress(InetAddress clientAddress)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener#getOrder()",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public int getOrder()",
    "documentation": "\t/**\n\t * Executes before {@link DependencyInjectionTestExecutionListener}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final int getOrder() {\n\t\treturn 1950;\n\t}",
    "query": "Develop a custom test execution listener that initializes Mockito mocks before Spring's dependency injection phase in your test suite.",
    "function_signature": "public int getOrder()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#setBeanFactory(beanFactory)",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public void setBeanFactory(BeanFactory beanFactory)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setBeanFactory(BeanFactory beanFactory) {\n\t\tthis.beanFactory = beanFactory;\n\t\tresetAdviceMonitor();\n\t}",
    "query": "Establish a robust initialization process for managing `BeanFactory` dependencies that optimizes performance and ensures thread safety.",
    "function_signature": "public void initializeFactory(BeanFactory factory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "class",
    "signature": "public class ExceptionHandlerMethodResolver",
    "documentation": "/**\n * Discovers {@linkplain ExceptionHandler @ExceptionHandler} methods in a given class,\n * including all of its superclasses, and helps to resolve a given {@link Exception}\n * and {@link MediaType} requested by clients to combinations supported by a given {@link Method}.\n * <p>This resolver will use the exception information declared as {@code @ExceptionHandler}\n * annotation attributes, or as a method argument as a fallback. This will throw\n * {@code IllegalStateException} instances if:\n * <ul>\n *     <li>No Exception information could be found for a method\n *     <li>An invalid {@link MediaType} has been declared as {@code @ExceptionHandler} attribute\n *     <li>Multiple handlers declare the same exception + media type mapping\n * </ul>\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 3.1\n */",
    "changetype": "stabilized",
    "source_code": "public class ExceptionHandlerMethodResolver {\n\n\t/**\n\t * A filter for selecting {@code @ExceptionHandler} methods.\n\t */\n\tprivate static final MethodFilter EXCEPTION_HANDLER_METHODS = method ->\n\t\t\tAnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);\n\n\tprivate static final ExceptionHandlerMappingInfo NO_MATCHING_EXCEPTION_HANDLER;\n\n\tstatic {\n\t\ttry {\n\t\t\tNO_MATCHING_EXCEPTION_HANDLER = new ExceptionHandlerMappingInfo(Set.of(), Set.of(),\n\t\t\t\t\tExceptionHandlerMethodResolver.class.getDeclaredMethod(\"noMatchingExceptionHandler\"));\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t}\n\t}\n\n\tprivate final Map<ExceptionMapping, ExceptionHandlerMappingInfo> mappedMethods = new HashMap<>(16);\n\n\tprivate final ConcurrentLruCache<ExceptionMapping, ExceptionHandlerMappingInfo> lookupCache = new ConcurrentLruCache<>(24,\n\t\t\tcacheKey -> getMappedMethod(cacheKey.exceptionType(), cacheKey.mediaType()));\n\n\n\t/**\n\t * A constructor that finds {@link ExceptionHandler} methods in the given type.\n\t * @param handlerType the type to introspect\n\t * @throws IllegalStateException in case of invalid or ambiguous exception mapping declarations\n\t */\n\tpublic ExceptionHandlerMethodResolver(Class<?> handlerType) {\n\t\tfor (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) {\n\t\t\tExceptionHandlerMappingInfo mappingInfo = detectExceptionMappings(method);\n\t\t\tfor (Class<? extends Throwable> exceptionType : mappingInfo.getExceptionTypes()) {\n\t\t\t\tfor (MediaType producibleType : mappingInfo.getProducibleTypes()) {\n\t\t\t\t\taddExceptionMapping(new ExceptionMapping(exceptionType, producibleType), mappingInfo);\n\t\t\t\t}\n\t\t\t\tif (mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\taddExceptionMapping(new ExceptionMapping(exceptionType, MediaType.ALL), mappingInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Extract exception mappings from the {@code @ExceptionHandler} annotation first,\n\t * and then as a fallback from the method signature itself.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate ExceptionHandlerMappingInfo detectExceptionMappings(Method method) {\n\t\tExceptionHandler exceptionHandler = readExceptionHandlerAnnotation(method);\n\t\tList<Class<? extends Throwable>> exceptions = new ArrayList<>(Arrays.asList(exceptionHandler.exception()));\n\t\tif (exceptions.isEmpty()) {\n\t\t\tfor (Class<?> paramType : method.getParameterTypes()) {\n\t\t\t\tif (Throwable.class.isAssignableFrom(paramType)) {\n\t\t\t\t\texceptions.add((Class<? extends Throwable>) paramType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exceptions.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"No exception types mapped to \" + method);\n\t\t}\n\t\tSet<MediaType> mediaTypes = new HashSet<>();\n\t\tfor (String mediaType : exceptionHandler.produces()) {\n\t\t\ttry {\n\t\t\t\tmediaTypes.add(MediaType.parseMediaType(mediaType));\n\t\t\t}\n\t\t\tcatch (InvalidMediaTypeException exc) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid media type [\" + mediaType + \"] declared on @ExceptionHandler for \" + method, exc);\n\t\t\t}\n\t\t}\n\t\treturn new ExceptionHandlerMappingInfo(Set.copyOf(exceptions), mediaTypes, method);\n\t}\n\n\tprivate ExceptionHandler readExceptionHandlerAnnotation(Method method) {\n\t\tExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class);\n\t\tAssert.state(ann != null, \"No ExceptionHandler annotation\");\n\t\treturn ann;\n\t}\n\n\tprivate void addExceptionMapping(ExceptionMapping mapping, ExceptionHandlerMappingInfo mappingInfo) {\n\t\tExceptionHandlerMappingInfo oldMapping = this.mappedMethods.put(mapping, mappingInfo);\n\t\tif (oldMapping != null && !oldMapping.getHandlerMethod().equals(mappingInfo.getHandlerMethod())) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous @ExceptionHandler method mapped for [\" +\n\t\t\t\t\tmapping + \"]: {\" + oldMapping.getHandlerMethod() + \", \" + mappingInfo.getHandlerMethod() + \"}\");\n\t\t}\n\t}\n\n\t/**\n\t * Whether the contained type has any exception mappings.\n\t */\n\tpublic boolean hasExceptionMappings() {\n\t\treturn !this.mappedMethods.isEmpty();\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic Method resolveMethod(Exception exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given Throwable.\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exception the exception\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 5.0\n\t */\n\t@Nullable\n\tpublic Method resolveMethodByThrowable(Throwable exception) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMapping(exception, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */\n\t@Nullable\n\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception type. This can be\n\t * useful if an {@link Exception} instance is not available (e.g. for tools).\n\t * <p>Uses {@link ExceptionDepthComparator} if more than one match is found.\n\t * @param exceptionType the exception type\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exceptionType, MediaType.ALL);\n\t\treturn (mappingInfo != null) ? mappingInfo.getHandlerMethod() : null;\n\t}\n\n\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (e.g. for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */\n\t@Nullable\n\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}\n\n\t/**\n\t * Return the {@link Method} mapped to the given exception type, or\n\t * {@link #NO_MATCHING_EXCEPTION_HANDLER} if none.\n\t */\n\t@Nullable\n\tprivate ExceptionHandlerMappingInfo getMappedMethod(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tList<ExceptionMapping> matches = new ArrayList<>();\n\t\tfor (ExceptionMapping mappingInfo : this.mappedMethods.keySet()) {\n\t\t\tif (mappingInfo.exceptionType().isAssignableFrom(exceptionType) && mappingInfo.mediaType().isCompatibleWith(mediaType)) {\n\t\t\t\tmatches.add(mappingInfo);\n\t\t\t}\n\t\t}\n\t\tif (!matches.isEmpty()) {\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tmatches.sort(new ExceptionMapingComparator(exceptionType, mediaType));\n\t\t\t}\n\t\t\treturn this.mappedMethods.get(matches.get(0));\n\t\t}\n\t\telse {\n\t\t\treturn NO_MATCHING_EXCEPTION_HANDLER;\n\t\t}\n\t}\n\n\t/**\n\t * For the {@link #NO_MATCHING_EXCEPTION_HANDLER} constant.\n \t */\n\t@SuppressWarnings(\"unused\")\n\tprivate void noMatchingExceptionHandler() {\n\t}\n\n\tprivate record ExceptionMapping(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ExceptionHandler{\" +\n\t\t\t\t\t\"exceptionType=\" + this.exceptionType.getCanonicalName() +\n\t\t\t\t\t\", mediaType=\" + this.mediaType +\n\t\t\t\t\t'}';\n\t\t}\n\t}\n\n\tprivate static class ExceptionMapingComparator implements Comparator<ExceptionMapping> {\n\n\t\tprivate final ExceptionDepthComparator exceptionDepthComparator;\n\n\t\tprivate final MediaType mediaType;\n\n\t\tpublic ExceptionMapingComparator(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\t\tthis.exceptionDepthComparator = new ExceptionDepthComparator(exceptionType);\n\t\t\tthis.mediaType = mediaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}\n\t}\n\n}",
    "query": "Design a robust error handling mechanism for a RESTful service that dynamically selects the appropriate response format based on the client's requested media type. Ensure that the system efficiently maps various exception types to their corresponding handler methods, considering content negotiation to deliver error details in formats like JSON or XML as specified by the client.",
    "function_signature": "public ResponseEntity<?> determineErrorResponse(Throwable exception, MediaType requestedMediaType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.<unknown>#handle(configClass,importSelector)",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector)",
    "documentation": "\t\t/**\n\t\t * Handle the specified {@link DeferredImportSelector}. If deferred import\n\t\t * selectors are being collected, this registers this instance to the list. If\n\t\t * they are being processed, the {@link DeferredImportSelector} is also processed\n\t\t * immediately according to its {@link DeferredImportSelector.Group}.\n\t\t * @param configClass the source configuration class\n\t\t * @param importSelector the selector to handle\n\t\t */",
    "changetype": "deprecated",
    "source_code": "\t\tpublic void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {\n\t\t\tDeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);\n\t\t\tif (this.deferredImportSelectors == null) {\n\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\thandler.register(holder);\n\t\t\t\thandler.processGroupImports();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.deferredImportSelectors.add(holder);\n\t\t\t}\n\t\t}",
    "query": "Optimize the handling of configuration classes by implementing a strategy that efficiently processes deferred import selectors, ensuring improved performance and better integration with the latest framework features.",
    "function_signature": "public void processDeferredImports(ConfigurationClass configClass, DeferredImportSelector importSelector)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.ServletServerHttpRequest#keySet()",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public Set<String> keySet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Set<String> keySet() {\n\t\t\tSet<String> keySet = this.keySet;\n\t\t\tif (keySet == null) {\n\t\t\t\tkeySet = new AbstractSet<>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Iterator<String> iterator() {\n\t\t\t\t\t\treturn servletRequest.getAttributeNames().asIterator();\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int size() {\n\t\t\t\t\t\treturn AttributesMap.this.size();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.keySet = keySet;\n\t\t\t}\n\t\t\treturn keySet;\n\t\t}",
    "query": "Implement a service method that retrieves all unique attribute names from an incoming HTTP request to facilitate dynamic processing and auditing without manually iterating through each attribute.",
    "function_signature": "public Set<String> extractAttributeNames(ServletServerHttpRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder#principal(principal)",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public MockHttpServletRequestBuilder principal(Principal principal)",
    "documentation": "\t/**\n\t * Set the principal of the request.\n\t * @param principal the principal\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic MockHttpServletRequestBuilder principal(Principal principal) {\n\t\tAssert.notNull(principal, \"'principal' must not be null\");\n\t\tthis.principal = principal;\n\t\treturn this;\n\t}",
    "query": "Configure a mock HTTP request to include authenticated user information using a secure and streamlined approach.",
    "function_signature": "public MockHttpServletRequestBuilder withUser(UserDetails userDetails)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.<unknown>#getAttributes()",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public Object> getAttributes()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Map<String, Object> getAttributes() {\n\t\t\treturn Collections.emptyMap();\n\t\t}",
    "query": "Develop a reactive service method that interacts with an external API and leverages contextual metadata from each response to enhance processing logic.",
    "function_signature": "public Mono<EnhancedApiResponse> fetchAndProcessWithAttributes(String apiUrl)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#appendToUsername(s)",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public void appendToUsername(String s)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void appendToUsername(String s) {\n\t\t\tif (this.username == null) {\n\t\t\t\tthis.username = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.username.append(s);\n\t\t\t}\n\t\t}",
    "query": "Create a service method that dynamically constructs a user's profile identifier by sequentially integrating various input segments, ensuring efficient handling even when certain segments are initially missing or added incrementally.",
    "function_signature": "public void integrateProfileSegment(String segment)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#clearCache()",
    "from_version": "v6.1.9",
    "to_version": "v6.2.0-M4",
    "type": "method",
    "signature": "public void clearCache()",
    "documentation": "\t/**\n\t * Clear the local resource cache, removing all cached classpath/jar structures.\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void clearCache() {\n\t\tthis.rootDirCache.clear();\n\t\tthis.jarEntryCache.clear();\n\t}",
    "query": "Create a mechanism in your Spring application that allows for the programmatic clearing of all cached resource patterns to ensure that resource loading reflects the most recent changes without requiring an application restart.",
    "function_signature": "public void clearResourceCache()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesRequestAttributes#getFacesContext()",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "protected FacesContext getFacesContext()",
    "documentation": "\t/**\n\t * Return the JSF FacesContext that this adapter operates on.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final FacesContext getFacesContext() {\n\t\treturn this.facesContext;\n\t}",
    "query": "Create a Spring-managed service that dynamically adjusts UI components by accessing the current JSF lifecycle context during each HTTP request.",
    "function_signature": "protected FacesContext retrieveCurrentContext()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.cors.CorsConfiguration#validateAllowPrivateNetwork()",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "public void validateAllowPrivateNetwork()",
    "documentation": "\t/**\n\t * Validate that when {@link #setAllowPrivateNetwork allowPrivateNetwork} is {@code true},\n\t * {@link #setAllowedOrigins allowedOrigins} does not contain the special\n\t * value {@code \"*\"} since this is insecure.\n\t * @throws IllegalArgumentException if the validation fails\n\t * @since 6.1.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void validateAllowPrivateNetwork() {\n\t\tif (this.allowPrivateNetwork == Boolean.TRUE &&\n\t\t\t\tthis.allowedOrigins != null && this.allowedOrigins.contains(ALL)) {\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"When allowPrivateNetwork is true, allowedOrigins cannot contain the special value \\\"*\\\" \" +\n\t\t\t\t\t\t\t\"as it is not recommended from a security perspective. \" +\n\t\t\t\t\t\t\t\"To allow private network access to a set of origins, list them explicitly \" +\n\t\t\t\t\t\t\t\"or consider using \\\"allowedOriginPatterns\\\" instead.\");\n\t\t}\n\t}",
    "query": "In a microservices architecture where certain services are restricted to private networks, ensure that the CORS configuration does not permit any origin wildcarding to prevent unauthorized external access.",
    "function_signature": "public void validateCorsPrivateNetworkAccess(CorsConfiguration corsConfig) throws IllegalArgumentException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.sockjs.client.SockJsClient#buildSockJsUrlInfo(url)",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "protected SockJsUrlInfo buildSockJsUrlInfo(URI url)",
    "documentation": "\t/**\n\t * Create a new {@link SockJsUrlInfo} for the current client execution.\n\t * <p>The default implementation builds a {@code SockJsUrlInfo} which\n\t * calculates a random server id and session id if necessary.\n\t * @param url the target URL\n\t * @since 6.1.3\n\t * @see SockJsUrlInfo#SockJsUrlInfo(URI)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected SockJsUrlInfo buildSockJsUrlInfo(URI url) {\n\t\treturn new SockJsUrlInfo(url);\n\t}",
    "query": "Implement a component that prepares detailed connection information for SockJS-based WebSocket clients to ensure reliable session handling.",
    "function_signature": "protected SockJsUrlInfo prepareSockJsConnectionInfo(URI connectionUri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.TagUtils#getScope(scope)",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "public int getScope(String scope)",
    "documentation": "\t/**\n\t * Determines the scope for a given input {@code String}.\n\t * <p>If the {@code String} does not match 'request', 'session',\n\t * 'page' or 'application', the method will return {@link PageContext#PAGE_SCOPE}.\n\t * @param scope the {@code String} to inspect\n\t * @return the scope found, or {@link PageContext#PAGE_SCOPE} if no scope matched\n\t * @throws IllegalArgumentException if the supplied {@code scope} is {@code null}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static int getScope(String scope) {\n\t\tAssert.notNull(scope, \"Scope to search for cannot be null\");\n\t\treturn switch (scope) {\n\t\t\tcase SCOPE_REQUEST -> PageContext.REQUEST_SCOPE;\n\t\t\tcase SCOPE_SESSION -> PageContext.SESSION_SCOPE;\n\t\t\tcase SCOPE_APPLICATION -> PageContext.APPLICATION_SCOPE;\n\t\t\tdefault -> PageContext.PAGE_SCOPE;\n\t\t};\n\t}",
    "query": "Design a method that assigns the correct scope level to a user attribute based on a provided scope name, defaulting to page-level scope when the input doesn't correspond to standard scopes.",
    "function_signature": "public int assignUserAttributeScope(String scopeName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesRequestAttributes#registerDestructionCallback(name,callback,scope)",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "public void registerDestructionCallback(String name, Runnable callback, int scope)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void registerDestructionCallback(String name, Runnable callback, int scope) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Could not register destruction callback [\" + callback + \"] for attribute '\" + name +\n\t\t\t\t\t\"' because FacesRequestAttributes does not support such callbacks\");\n\t\t}\n\t}",
    "query": "Design a feature that allows registering cleanup actions to be executed automatically when specific request-scoped attributes are removed or when the request concludes.",
    "function_signature": "public void registerAttributeCleanup(String attributeName, Runnable onDestroy, int scope)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.AbstractNestablePropertyAccessor#setValueFallbackIfPossible(value)",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "public boolean setValueFallbackIfPossible(@Nullable Object value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean setValueFallbackIfPossible(@Nullable Object value) {\n\t\t\treturn false;\n\t\t}",
    "query": "Implement a feature in your Spring application that attempts to update a nested configuration property for a user profile. If the primary property path is unavailable or inaccessible, the system should gracefully fall back to an alternative property path to ensure the configuration is updated without causing disruptions.",
    "function_signature": "public boolean updateUserConfigurationWithFallback(@Nullable Object newConfig)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesRequestAttributes#getSessionMutex()",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "public Object getSessionMutex()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object getSessionMutex() {\n\t\t// Enforce presence of a session first to allow listeners to create the mutex attribute\n\t\tExternalContext externalContext = getExternalContext();\n\t\tObject session = externalContext.getSession(true);\n\t\tObject mutex = externalContext.getSessionMap().get(WebUtils.SESSION_MUTEX_ATTRIBUTE);\n\t\tif (mutex == null) {\n\t\t\tmutex = (session != null ? session : externalContext);\n\t\t}\n\t\treturn mutex;\n\t}",
    "query": "Implement a Spring-managed bean method that updates user preferences in a JSF application, ensuring that concurrent modifications to the session are handled safely without explicit synchronization blocks.",
    "function_signature": "public void updateUserPreferences(UserPreferences preferences)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#processInjection(bean)",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "public void processInjection(Object bean)",
    "documentation": "\t/**\n\t * <em>Native</em> processing method for direct calls with an arbitrary target\n\t * instance, resolving all of its fields and methods which are annotated with\n\t * one of the supported 'resource' annotation types.\n\t * @param bean the target instance to process\n\t * @throws BeanCreationException if resource injection failed\n\t * @since 6.1.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void processInjection(Object bean) throws BeanCreationException {\n\t\tClass<?> clazz = bean.getClass();\n\t\tInjectionMetadata metadata = findResourceMetadata(clazz.getName(), clazz, null);\n\t\ttry {\n\t\t\tmetadata.inject(bean, null, null);\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\"Injection of resource dependencies failed for class [\" + clazz + \"]\", ex);\n\t\t}\n\t}",
    "query": "Design a utility method that accepts any Spring-managed bean and programmatically resolves and injects all its resource dependencies annotated with standard resource annotations. This method should handle the injection process seamlessly, ensuring that all necessary resources are properly initialized without requiring manual configuration for each bean.",
    "function_signature": "public void injectResources(Object bean)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesRequestAttributes#getExternalContext()",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "method",
    "signature": "protected ExternalContext getExternalContext()",
    "documentation": "\t/**\n\t * Return the JSF ExternalContext that this adapter operates on.\n\t * @see jakarta.faces.context.FacesContext#getExternalContext()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final ExternalContext getExternalContext() {\n\t\treturn getFacesContext().getExternalContext();\n\t}",
    "query": "Develop a Spring-managed service that retrieves and modifies request-scoped attributes by interfacing with the underlying JSF context in a JSF-integrated web application.",
    "function_signature": "public void updateRequestAttribute(String attributeName, Object value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.SCOPE_PAGE",
    "from_version": "v6.1.2",
    "to_version": "v6.1.3",
    "type": "field",
    "signature": "public String SCOPE_PAGE",
    "documentation": "\t/** Constant identifying the page scope. */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String SCOPE_PAGE = \"page\";",
    "query": "Create a controller method that processes user input from a form, ensuring the form data remains accessible only for the duration of the current page view and is not preserved beyond it.",
    "function_signature": "@Scope(\"page\")\npublic String processUserForm(@ModelAttribute UserForm form)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.MULTIPART_RELATED",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "field",
    "signature": "public MediaType MULTIPART_RELATED",
    "documentation": "\t/**\n\t * Public constant media type for {@code multipart/related}.\n\t * @since 5.2.5\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final MediaType MULTIPART_RELATED;",
    "query": "Develop a RESTful endpoint that delivers multiple interconnected resources within a single HTTP response, maintaining the relationships between each part to enhance client-side processing and reduce the number of requests.",
    "function_signature": "@GetMapping(value = \"/interconnected-data\", produces = \"multipart/related\")\npublic ResponseEntity<InterconnectedDataResponse> fetchInterconnectedData()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.support.BindStatus",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "class",
    "signature": "public class BindStatus",
    "documentation": "/**\n * Simple adapter to expose the bind status of a field or object.\n * Set as a variable both by the JSP bind tag and FreeMarker macros.\n *\n * <p>Obviously, object status representations (i.e. errors at the object level\n * rather than the field level) do not have an expression and a value but only\n * error codes and messages. For simplicity's sake and to be able to use the same\n * tags and macros, the same status class is used for both scenarios.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Darren Davison\n * @see RequestContext#getBindStatus\n * @see org.springframework.web.servlet.tags.BindTag\n * @see org.springframework.web.servlet.view.AbstractTemplateView#setExposeSpringMacroHelpers\n */",
    "changetype": "stabilized",
    "source_code": "public class BindStatus {\n\n\tprivate final RequestContext requestContext;\n\n\tprivate final String path;\n\n\tprivate final boolean htmlEscape;\n\n\t@Nullable\n\tprivate final String expression;\n\n\t@Nullable\n\tprivate final Errors errors;\n\n\tprivate final String[] errorCodes;\n\n\t@Nullable\n\tprivate String[] errorMessages;\n\n\t@Nullable\n\tprivate List<? extends ObjectError> objectErrors;\n\n\t@Nullable\n\tprivate Object value;\n\n\t@Nullable\n\tprivate Class<?> valueType;\n\n\t@Nullable\n\tprivate Object actualValue;\n\n\t@Nullable\n\tprivate PropertyEditor editor;\n\n\t@Nullable\n\tprivate BindingResult bindingResult;\n\n\n\t/**\n\t * Create a new BindStatus instance, representing a field or object status.\n\t * @param requestContext the current RequestContext\n\t * @param path the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\")\n\t * @param htmlEscape whether to HTML-escape error messages and string values\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */\n\tpublic BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {\n\t\tthis.requestContext = requestContext;\n\t\tthis.path = path;\n\t\tthis.htmlEscape = htmlEscape;\n\n\t\t// determine name of the object and property\n\t\tString beanName;\n\t\tint dotPos = path.indexOf('.');\n\t\tif (dotPos == -1) {\n\t\t\t// property not set, only the object itself\n\t\t\tbeanName = path;\n\t\t\tthis.expression = null;\n\t\t}\n\t\telse {\n\t\t\tbeanName = path.substring(0, dotPos);\n\t\t\tthis.expression = path.substring(dotPos + 1);\n\t\t}\n\n\t\tthis.errors = requestContext.getErrors(beanName, false);\n\n\t\tif (this.errors != null) {\n\t\t\t// Usual case: A BindingResult is available as request attribute.\n\t\t\t// Can determine error codes and messages for the given expression.\n\t\t\t// Can use a custom PropertyEditor, as registered by a form controller.\n\t\t\tif (this.expression != null) {\n\t\t\t\tif (\"*\".equals(this.expression)) {\n\t\t\t\t\tthis.objectErrors = this.errors.getAllErrors();\n\t\t\t\t}\n\t\t\t\telse if (this.expression.endsWith(\"*\")) {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t\tthis.value = this.errors.getFieldValue(this.expression);\n\t\t\t\t\tthis.valueType = this.errors.getFieldType(this.expression);\n\t\t\t\t\tif (this.errors instanceof BindingResult br) {\n\t\t\t\t\t\tthis.bindingResult = br;\n\t\t\t\t\t\tthis.actualValue = this.bindingResult.getRawFieldValue(this.expression);\n\t\t\t\t\t\tthis.editor = this.bindingResult.findEditor(this.expression, null);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.actualValue = this.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.objectErrors = this.errors.getGlobalErrors();\n\t\t\t}\n\t\t\tthis.errorCodes = initErrorCodes(this.objectErrors);\n\t\t}\n\n\t\telse {\n\t\t\t// No BindingResult available as request attribute:\n\t\t\t// Probably forwarded directly to a form view.\n\t\t\t// Let's do the best we can: extract a plain target if appropriate.\n\t\t\tObject target = requestContext.getModelObject(beanName);\n\t\t\tif (target == null) {\n\t\t\t\tthrow new IllegalStateException(\"Neither BindingResult nor plain target object for bean name '\" +\n\t\t\t\t\t\tbeanName + \"' available as request attribute\");\n\t\t\t}\n\t\t\tif (this.expression != null && !\"*\".equals(this.expression) && !this.expression.endsWith(\"*\")) {\n\t\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);\n\t\t\t\tthis.value = bw.getPropertyValue(this.expression);\n\t\t\t\tthis.valueType = bw.getPropertyType(this.expression);\n\t\t\t\tthis.actualValue = this.value;\n\t\t\t}\n\t\t\tthis.errorCodes = new String[0];\n\t\t\tthis.errorMessages = new String[0];\n\t\t}\n\n\t\tif (htmlEscape && this.value instanceof String text) {\n\t\t\tthis.value = HtmlUtils.htmlEscape(text);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the error codes from the ObjectError list.\n\t */\n\tprivate static String[] initErrorCodes(List<? extends ObjectError> objectErrors) {\n\t\tString[] errorCodes = new String[objectErrors.size()];\n\t\tfor (int i = 0; i < objectErrors.size(); i++) {\n\t\t\tObjectError error = objectErrors.get(i);\n\t\t\terrorCodes[i] = error.getCode();\n\t\t}\n\t\treturn errorCodes;\n\t}\n\n\n\t/**\n\t * Return the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\").\n\t */\n\tpublic String getPath() {\n\t\treturn this.path;\n\t}\n\n\t/**\n\t * Return a bind expression that can be used in HTML forms as input name\n\t * for the respective field, or {@code null} if not field-specific.\n\t * <p>Returns a bind path appropriate for resubmission, e.g. \"address.street\".\n\t * Note that the complete bind path as required by the bind tag is\n\t * \"customer.address.street\", if bound to a \"customer\" bean.\n\t */\n\t@Nullable\n\tpublic String getExpression() {\n\t\treturn this.expression;\n\t}\n\n\t/**\n\t * Return the current value of the field, i.e. either the property value\n\t * or a rejected update, or {@code null} if not field-specific.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * already was a String.\n\t */\n\t@Nullable\n\tpublic Object getValue() {\n\t\treturn this.value;\n\t}\n\n\t/**\n\t * Get the '{@code Class}' type of the field. Favor this instead of\n\t * '{@code getValue().getClass()}' since '{@code getValue()}' may\n\t * return '{@code null}'.\n\t */\n\t@Nullable\n\tpublic Class<?> getValueType() {\n\t\treturn this.valueType;\n\t}\n\n\t/**\n\t * Return the actual value of the field, i.e. the raw property value,\n\t * or {@code null} if not available.\n\t */\n\t@Nullable\n\tpublic Object getActualValue() {\n\t\treturn this.actualValue;\n\t}\n\n\t/**\n\t * Return a suitable display value for the field, i.e. the stringified\n\t * value if not null, and an empty string in case of a null value.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * was non-null: the {@code toString} result of the original value\n\t * will get HTML-escaped.\n\t */\n\tpublic String getDisplayValue() {\n\t\tif (this.value instanceof String displayValue) {\n\t\t\treturn displayValue;\n\t\t}\n\t\tif (this.value != null) {\n\t\t\treturn (this.htmlEscape ? HtmlUtils.htmlEscape(this.value.toString()) : this.value.toString());\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Return if this status represents a field or object error.\n\t */\n\tpublic boolean isError() {\n\t\treturn (this.errorCodes.length > 0);\n\t}\n\n\t/**\n\t * Return the error codes for the field or object, if any.\n\t * Returns an empty array instead of null if none.\n\t */\n\tpublic String[] getErrorCodes() {\n\t\treturn this.errorCodes;\n\t}\n\n\t/**\n\t * Return the first error codes for the field or object, if any.\n\t */\n\tpublic String getErrorCode() {\n\t\treturn (this.errorCodes.length > 0 ? this.errorCodes[0] : \"\");\n\t}\n\n\t/**\n\t * Return the resolved error messages for the field or object,\n\t * if any. Returns an empty array instead of null if none.\n\t */\n\tpublic String[] getErrorMessages() {\n\t\treturn initErrorMessages();\n\t}\n\n\t/**\n\t * Return the first error message for the field or object, if any.\n\t */\n\tpublic String getErrorMessage() {\n\t\tString[] errorMessages = initErrorMessages();\n\t\treturn (errorMessages.length > 0 ? errorMessages[0] : \"\");\n\t}\n\n\t/**\n\t * Return an error message string, concatenating all messages\n\t * separated by the given delimiter.\n\t * @param delimiter separator string, e.g. \", \" or \"<br>\"\n\t * @return the error message string\n\t */\n\tpublic String getErrorMessagesAsString(String delimiter) {\n\t\treturn StringUtils.arrayToDelimitedString(initErrorMessages(), delimiter);\n\t}\n\n\t/**\n\t * Extract the error messages from the ObjectError list.\n\t */\n\tprivate String[] initErrorMessages() throws NoSuchMessageException {\n\t\tif (this.errorMessages == null) {\n\t\t\tif (this.objectErrors != null) {\n\t\t\t\tthis.errorMessages = new String[this.objectErrors.size()];\n\t\t\t\tfor (int i = 0; i < this.objectErrors.size(); i++) {\n\t\t\t\t\tObjectError error = this.objectErrors.get(i);\n\t\t\t\t\tthis.errorMessages[i] = this.requestContext.getMessage(error, this.htmlEscape);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.errorMessages = new String[0];\n\t\t\t}\n\t\t}\n\t\treturn this.errorMessages;\n\t}\n\n\t/**\n\t * Return the Errors instance (typically a BindingResult) that this\n\t * bind status is currently associated with.\n\t * @return the current Errors instance, or {@code null} if none\n\t * @see org.springframework.validation.BindingResult\n\t */\n\t@Nullable\n\tpublic Errors getErrors() {\n\t\treturn this.errors;\n\t}\n\n\t/**\n\t * Return the PropertyEditor for the property that this bind status\n\t * is currently bound to.\n\t * @return the current PropertyEditor, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic PropertyEditor getEditor() {\n\t\treturn this.editor;\n\t}\n\n\t/**\n\t * Find a PropertyEditor for the given value class, associated with\n\t * the property that this bound status is currently bound to.\n\t * @param valueClass the value class that an editor is needed for\n\t * @return the associated PropertyEditor, or {@code null} if none\n\t */\n\t@Nullable\n\tpublic PropertyEditor findEditor(Class<?> valueClass) {\n\t\treturn (this.bindingResult != null ? this.bindingResult.findEditor(this.expression, valueClass) : null);\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"BindStatus: \");\n\t\tsb.append(\"expression=[\").append(this.expression).append(\"]; \");\n\t\tsb.append(\"value=[\").append(this.value).append(']');\n\t\tif (!ObjectUtils.isEmpty(this.errorCodes)) {\n\t\t\tsb.append(\"; errorCodes=\").append(Arrays.asList(this.errorCodes));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}",
    "query": "Design a Spring MVC controller method that retrieves comprehensive binding information for a specific form field, including its current value and any associated validation errors, ensuring that the data is safely escaped for HTML display.",
    "function_signature": "public FieldBindingInfo fetchFieldBindingDetails(RequestContext context, String fieldPath, boolean escapeHtml)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cglib.core.EmitUtils#not_equals(e,type,notEquals,customizer)",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer)",
    "documentation": "    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */",
    "changetype": "stabilized",
    "source_code": "    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }",
    "query": "How can you implement a custom inequality check in a dynamically generated class to handle complex comparison logic during runtime?",
    "function_signature": "public void implementInequalityCheck(CodeEmitter emitter, Type targetType, Label notEqualLabel, Customizer customizer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.annotation.ResponseEntityExceptionHandler#setMessageSource(messageSource)",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public void setMessageSource(MessageSource messageSource)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setMessageSource(MessageSource messageSource) {\n\t\tthis.messageSource = messageSource;\n\t}",
    "query": "Implement a global exception handler that delivers error responses localized to the user's locale, ensuring that all exception messages are sourced from an external message repository.",
    "function_signature": "public void configureLocalizedErrorHandling(MessageSource messageSource)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.hibernate5.LocalSessionFactoryBean#destroy()",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public void destroy()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void destroy() {\n\t\tif (this.sessionFactory != null) {\n\t\t\tthis.sessionFactory.close();\n\t\t}\n\t}",
    "query": "Design a cleanup process that ensures all Hibernate session resources are properly released when your Spring application context is terminated.",
    "function_signature": "public void destroySessionFactory()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.test.tools.ResourceFiles#getSingle()",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public ResourceFile getSingle()",
    "documentation": "\t/**\n\t * Return the single {@link ResourceFile} contained in the collection.\n\t * @return the single file\n\t * @throws IllegalStateException if the collection doesn't contain exactly\n\t * one file\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic ResourceFile getSingle() throws IllegalStateException {\n\t\treturn this.files.getSingle();\n\t}",
    "query": "How can you verify that a test setup contains precisely one resource file and access it for validation purposes?",
    "function_signature": "public ResourceFile fetchSingleTestResource()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.Conflict",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "class",
    "signature": "public class Conflict",
    "documentation": "\t/**\n\t * {@link HttpClientErrorException} for status HTTP 409 Conflict.\n\t * @since 5.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final class Conflict extends HttpClientErrorException {\n\n\t\tprivate Conflict(String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\t\t\tsuper(HttpStatus.CONFLICT, statusText, headers, body, charset);\n\t\t}\n\n\t\tprivate Conflict(String message, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\t\t\tsuper(message, HttpStatus.CONFLICT, statusText, headers, body, charset);\n\t\t}\n\t}",
    "query": "Design a service method that updates user information via a REST API. Ensure that if the update conflicts with existing data (resulting in an HTTP 409 status), a specific client error exception is thrown to clearly indicate the conflict scenario.",
    "function_signature": "public void updateUserProfile(UserProfile profile) throws ConflictException;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.AbstractHandlerMapping#getPathMatcher()",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * Return the {@link #setPathMatcher configured} {@code PathMatcher}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Implement a feature in your Spring MVC application that allows dynamic modification of URL pattern matching strategies at runtime, enabling different matching behaviors based on user roles or application states.",
    "function_signature": "public void updateUrlPatternMatchingStrategy(PathMatcher newPathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.AbstractNestablePropertyAccessor#getValue()",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public Object getValue()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic abstract Object getValue() throws Exception;",
    "query": "Develop a utility method that dynamically retrieves the value of a deeply nested property from a complex Java bean. The method should accept a bean instance and a property path string, efficiently navigating through multiple layers of nested objects while handling potential access issues gracefully.",
    "function_signature": "public Object extractNestedProperty(Object bean, String propertyPath) throws Exception;"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.support.JmsUtils#rollbackIfNecessary(session)",
    "from_version": "v5.3.33",
    "to_version": "v6.0.18",
    "type": "method",
    "signature": "public void rollbackIfNecessary(Session session)",
    "documentation": "\t/**\n\t * Roll back the Session if not within a JTA transaction.\n\t * @param session the JMS Session to rollback\n\t * @throws JMSException if committing failed\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static void rollbackIfNecessary(Session session) throws JMSException {\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\ttry {\n\t\t\tsession.rollback();\n\t\t}\n\t\tcatch (jakarta.jms.TransactionInProgressException | jakarta.jms.IllegalStateException ex) {\n\t\t\t// Ignore -> can only happen in case of a JTA transaction.\n\t\t}\n\t}",
    "query": "Implement a method that processes a JMS message and ensures the session is rolled back only if not part of an existing JTA transaction.",
    "function_signature": "public void processMessageWithConditionalRollback(Session session, Message message) throws JMSException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.aot.BeanInstanceSupplier#withGenerator(generator)",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingSupplier<T> generator)",
    "documentation": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses the specified\n\t * {@code generator} supplier to instantiate the underlying bean.\n\t * @param generator a {@link ThrowingSupplier} to instantiate the underlying bean\n\t * @return a new {@link BeanInstanceSupplier} instance with the specified generator\n\t * @deprecated in favor of {@link #withGenerator(ThrowingFunction)}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic BeanInstanceSupplier<T> withGenerator(ThrowingSupplier<T> generator) {\n\t\tAssert.notNull(generator, \"'generator' must not be null\");\n\t\treturn new BeanInstanceSupplier<>(this.lookup, registeredBean -> generator.get(),\n\t\t\t\tnull, this.shortcutBeanNames);\n\t}",
    "query": "Enhance your bean configuration to utilize a generator that accommodates contextual information, improving flexibility and error handling during bean instantiation.",
    "function_signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingFunction<BeanCreationContext, T> generator)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.client.ClientRequestObservationContext#getRequest()",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public ClientRequest getRequest()",
    "documentation": "\t/**\n\t * Return the immutable client request.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic @Nullable ClientRequest getRequest() {\n\t\treturn this.request;\n\t}",
    "query": "Implement a monitoring feature that captures and logs essential information from each outbound HTTP request made by your reactive web client, ensuring that the original request details remain immutable.",
    "function_signature": "public void monitorOutboundRequest(ClientRequestObservationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession#checkOnDataAvailable()",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "protected void checkOnDataAvailable()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tprotected void checkOnDataAvailable() {\n\t\t\tresumeReceiving();\n\t\t\tint size = this.pendingMessages.size();\n\t\t\tif (rsReadLogger.isTraceEnabled()) {\n\t\t\t\trsReadLogger.trace(getLogPrefix() + \"checkOnDataAvailable (\" + size + \" pending)\");\n\t\t\t}\n\t\t\tif (size > 0) {\n\t\t\t\tonDataAvailable();\n\t\t\t}\n\t\t}",
    "query": "Develop a reactive WebSocket session manager that automatically resumes message reception and triggers appropriate handling when new data becomes available.",
    "function_signature": "protected void handleDataAvailability()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.BeanRegistryAdapter#order(order)",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public Spec<T> order(int order)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Spec<T> order(int order) {\n\t\t\tthis.beanDefinition.setAttribute(AbstractBeanDefinition.ORDER_ATTRIBUTE, order);\n\t\t\treturn this;\n\t\t}",
    "query": "Provide a fluent configuration method that allows specifying the initialization order of beans to control their processing sequence within the Spring application context.",
    "function_signature": "public Spec<T> order(int order)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.Netty5DataBufferFactory#wrap(buffer)",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public Netty5DataBuffer wrap(Buffer buffer)",
    "documentation": "\t/**\n\t * Wrap the given Netty {@link Buffer} in a {@code Netty5DataBuffer}.\n\t * @param buffer the Netty buffer to wrap\n\t * @return the wrapped buffer\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic Netty5DataBuffer wrap(Buffer buffer) {\n\t\tbuffer.touch(\"Wrap buffer\");\n\t\treturn new Netty5DataBuffer(buffer, this);\n\t}",
    "query": "Develop a utility that processes incoming data streams, ensuring optimal memory management and compatibility with the latest framework improvements.",
    "function_signature": "public DataBuffer create(Buffer buffer);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterErrors#popNestedPath()",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public void popNestedPath()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void popNestedPath() throws IllegalStateException {\n\t\tthis.errors.popNestedPath();\n\t}",
    "query": "Develop a validation method for a complex organizational chart where each department's errors are isolated and properly scoped, ensuring that after validating each department, the validation context returns to the higher organizational level seamlessly.",
    "function_signature": "public void validateOrganizationalChart(OrganizationChart chart, Errors errors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.AbstractXmlApplicationContext#initBeanDefinitionReader(reader)",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader)",
    "documentation": "\t/**\n\t * Initialize the bean definition reader used for loading the bean definitions\n\t * of this context. The default implementation sets the validating flag.\n\t * <p>Can be overridden in subclasses, for example, for turning off XML validation\n\t * or using a different {@link BeanDefinitionDocumentReader} implementation.\n\t * @param reader the bean definition reader used by this context\n\t * @see XmlBeanDefinitionReader#setValidating\n\t * @see XmlBeanDefinitionReader#setDocumentReaderClass\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {\n\t\treader.setValidating(this.validating);\n\t}",
    "query": "Design a Spring XML application context that optimizes startup time by configuring the bean definition loader to bypass XML validation. Ensure that the custom context effectively disables validation without altering the default bean loading behavior.",
    "function_signature": "protected void configureBeanDefinitionReader(XmlBeanDefinitionReader reader)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getLastModifiedInternal(request,handlerMethod)",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "documentation": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}",
    "query": "Design a method that efficiently checks if a resource has been updated by computing its last modified timestamp and leveraging request validation to minimize unnecessary processing.",
    "function_signature": "protected ResponseEntity<?> evaluateLastModified(HttpServletRequest request, WebRequest webRequest)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotation(element,annotationType)",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "documentation": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}",
    "query": "Implement a utility that retrieves a consolidated configuration annotation from a given class, ensuring that any meta-annotations and inherited attributes are appropriately merged to reflect the effective settings.",
    "function_signature": "public <A extends Annotation> A resolveConsolidatedConfig(Class<?> targetClass, Class<A> configAnnotation)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer#isDeclarativeBinding()",
    "from_version": "v6.2.4",
    "to_version": "v7.0.0-M3",
    "type": "method",
    "signature": "public boolean isDeclarativeBinding()",
    "documentation": "\t/**\n\t * Return whether to bind only fields intended for binding.\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isDeclarativeBinding() {\n\t\treturn (this.declarativeBinding != null ? this.declarativeBinding : false);\n\t}",
    "query": "Your web application needs to ensure that only explicitly specified fields in form submissions are processed to enhance security and maintain data integrity. Configure the data binding mechanism to enforce this selective binding strategy.",
    "function_signature": "public boolean isSecureDeclarativeBindingEnabled()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Configure a request interceptor to apply selectively to specific URL patterns by integrating a customized path matching strategy, enhancing the precision and flexibility of request handling in your Spring MVC application.",
    "function_signature": "public void setCustomPathMatcherForInterceptor(PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Develop a feature for a live collaboration platform that manages user subscriptions to shared channels, ensuring optimal handling of simultaneous subscribe and unsubscribe actions based on varying contention strategies.",
    "function_signature": "public void manageChannelSubscription(String sessionId, String contentionType, Message<?> subscribeAction, Message<?> unsubscribeAction)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "Create a service that dynamically monitors and limits the number of active messaging endpoints to ensure optimal performance and prevent resource saturation in a real-time communication system.",
    "function_signature": "public int getActiveEndpointCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#find(serverState,request)",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "method",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}",
    "query": "Create a service method that efficiently gathers all user subscriptions for a specific messaging channel, taking into account the current server status and a detailed search criteria.",
    "function_signature": "public MultiValueMap<String, String> gatherUserSubscriptions(ServerState serverState, FindRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Design a component that efficiently manages and tracks active client subscriptions in a real-time messaging application, ensuring seamless scalability and performance.",
    "function_signature": "public void handleActiveSubscriptions(SubscriptionRegistry subscriptionRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by subclasses of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Implement an interceptor that processes requests exclusively matching \"/orders/**\" while excluding \"/orders/public/**\", leveraging Spring's advanced pattern-based request handling for optimized performance.",
    "function_signature": "@Bean\npublic HandlerInterceptor orderProcessingInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Create a feature that intercepts the response after a controller processes a request, allowing you to modify the view data dynamically based on specific request attributes.",
    "function_signature": "public void modifyViewData(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Implement a feature in a Spring WebSocket application that efficiently retrieves all active subscription paths to optimize message routing and broadcasting. Ensure your solution can handle dynamic changes in subscriptions without significant performance overhead.",
    "function_signature": "public String[] fetchActiveSubscriptionPaths()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Design a component in a real-time notification system that can fetch and display all currently connected user session identifiers to administrators for monitoring purposes.",
    "function_signature": "public String[] retrieveCurrentUserSessions()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.2.25.RELEASE",
    "to_version": "v5.3.29",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design an interceptor that can dynamically adjust its path matching strategy based on specific application requirements, allowing for flexible request handling without restarting the application.",
    "function_signature": "public PathMatcher retrieveInterceptorPathMatcher()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterValidationResult#unwrap(error,sourceType)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "public T unwrap(MessageSourceResolvable error, Class<T> sourceType)",
    "documentation": "\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}",
    "query": "Develop a method to efficiently retrieve the underlying source object from a validation error, emphasizing type safety and enhanced performance over previous implementations.",
    "function_signature": "public <T> T fetchValidationSource(ErrorDetail errorDetail, Class<T> sourceType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#param(name,values)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "public B param(String name, String... values)",
    "documentation": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic B param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn self();\n\t}",
    "query": "Create a unit test that appends multiple query parameters to a mock HTTP request, enhancing the clarity and efficiency of parameter handling in your test scenarios.",
    "function_signature": "public MockHttpServletRequestBuilder addQueryParameter(String name, String... values)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.MockReset",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "enum",
    "signature": "public enum MockReset",
    "documentation": "/**\n * Reset strategy used on a mock bean. Usually applied to a mock through the\n * {@link MockitoBean @MockitoBean} annotation but can also be directly applied\n * to any mock in the {@code ApplicationContext} using the static methods.\n *\n * @author Phillip Webb\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "changetype": "deprecated",
    "source_code": "public enum MockReset {\n\n\t/**\n\t * Reset the mock before the test method runs.\n\t */\n\tBEFORE,\n\n\t/**\n\t * Reset the mock after the test method runs.\n\t */\n\tAFTER,\n\n\t/**\n\t * Don't reset the mock.\n\t */\n\tNONE;\n\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur before each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings before() {\n\t\treturn withSettings(BEFORE);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where reset\n\t * should occur after each test method runs.\n\t * @return mock settings\n\t */\n\tpublic static MockSettings after() {\n\t\treturn withSettings(AFTER);\n\t}\n\n\t/**\n\t * Create {@link MockSettings settings} to be used with mocks where a\n\t * specific reset should occur.\n\t * @param reset the reset type\n\t * @return mock settings\n\t */\n\tpublic static MockSettings withSettings(MockReset reset) {\n\t\treturn apply(reset, Mockito.withSettings());\n\t}\n\n\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */\n\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}\n\n\t/**\n\t * Get the {@link MockReset} associated with the given mock.\n\t * @param mock the source mock\n\t * @return the reset type (never {@code null})\n\t */\n\tstatic MockReset get(Object mock) {\n\t\tMockReset reset = MockReset.NONE;\n\t\tMockingDetails mockingDetails = Mockito.mockingDetails(mock);\n\t\tif (mockingDetails.isMock()) {\n\t\t\tMockCreationSettings<?> settings = mockingDetails.getMockCreationSettings();\n\t\t\tList<InvocationListener> listeners = settings.getInvocationListeners();\n\t\t\tfor (Object listener : listeners) {\n\t\t\t\tif (listener instanceof ResetInvocationListener resetInvocationListener) {\n\t\t\t\t\treset = resetInvocationListener.getReset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reset;\n\t}\n\n\t/**\n\t * Dummy {@link InvocationListener} used to hold the {@link MockReset} value.\n\t */\n\tprivate static class ResetInvocationListener implements InvocationListener {\n\n\t\tprivate final MockReset reset;\n\n\t\tResetInvocationListener(MockReset reset) {\n\t\t\tthis.reset = reset;\n\t\t}\n\n\t\tMockReset getReset() {\n\t\t\treturn this.reset;\n\t\t}\n\n\t\t@Override\n\t\tpublic void reportInvocation(MethodInvocationReport methodInvocationReport) {\n\t\t}\n\n\t}\n\n}",
    "query": "Refactor the test configuration to enhance mock management by adopting the latest reset strategy approach, ensuring improved performance and thread safety during test executions.",
    "function_signature": "public MockSettings configureMockResetStrategy()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.docs.integration.jms.jmsreceivingasync.ExampleListener",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "class",
    "signature": "public class ExampleListener",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class ExampleListener implements MessageListener {\n\n\tpublic void onMessage(Message message) {\n\t\tif (message instanceof TextMessage textMessage) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(textMessage.getText());\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Message must be of type TextMessage\");\n\t\t}\n\t}\n}",
    "query": "Implement a method to process incoming JMS TextMessages using a contemporary Spring approach that enhances scalability and reduces boilerplate code, ensuring better integration and maintainability within your application.",
    "function_signature": "@JmsListener(destination = \"yourDestination\")\npublic void handleTextMessage(TextMessage message) {\n    // Implementation here\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.RequestEntity#post(url)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "public BodyBuilder post(URI url)",
    "documentation": "\t/**\n\t * Create an HTTP POST builder with the given url.\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static BodyBuilder post(URI url) {\n\t\treturn method(HttpMethod.POST, url);\n\t}",
    "query": "Implement a method to construct an HTTP POST request for a specified URI, utilizing a more efficient and type-safe builder to enhance request configuration and maintainability.",
    "function_signature": "public static RequestEntity.BodyBuilder createPostRequestBuilder(URI uri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterValidationResult#hashCode()",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getMethodParameter().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getArgument());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerIndex());\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getContainerKey());\n\t\treturn hashCode;\n\t}",
    "query": "Develop a method to retrieve a stable identifier for parameter validation outcomes, enhancing performance and clarity over conventional approaches.",
    "function_signature": "public int getValidationResultId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.HandlerResultAssert#isInvokedOn(controllerType,Function<T,handlerMethod)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "documentation": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}",
    "query": "Enhance your MVC test cases by ensuring that controller actions are efficiently and safely handling incoming requests. Refactor the verification process to leverage a more robust approach that improves test clarity and performance.",
    "function_signature": "public HandlerResultAssert verifyControllerAction(Class<?> controllerClass, Consumer<?> actionVerifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#handleBindException(ex,request,response,handler)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "documentation": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,",
    "query": "Design a controller method that automatically manages binding errors from form submissions, ensuring that invalid data results in a standardized HTTP 400 response without manual error handling.",
    "function_signature": "protected ModelAndView handleFormBindingErrors(BindException ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.SpelNodeImpl#generateCodeForArguments(mv,cf,executable,arguments)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments)",
    "documentation": "\t/**\n\t * Generate code that handles building the argument values for the specified\n\t * {@link Executable} (method or constructor).\n\t * <p>This method takes into account whether the method or constructor was\n\t * declared to accept varargs, and if it was then the argument values will be\n\t * appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current {@link CodeFlow}\n\t * @param executable the {@link Executable} (method or constructor) for which\n\t * arguments are being set up\n\t * @param arguments the expression nodes for the expression supplied argument\n\t * values\n\t * @since 6.2\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected static void generateCodeForArguments(",
    "query": "Develop a method responsible for assembling argument values for a given executable entity, optimizing for performance and ensuring robust type safety during expression evaluation.",
    "function_signature": "protected void assembleExecutableArguments(MethodProcessor processor, ExecutionContext context, Executable executable, ExpressionNode[] arguments)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.<unknown>#add(deferredImport)",
    "from_version": "v6.2.0-M7",
    "to_version": "v6.1.13",
    "type": "method",
    "signature": "public void add(DeferredImportSelectorHolder deferredImport)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void add(DeferredImportSelectorHolder deferredImport) {\n\t\t\tthis.deferredImports.add(deferredImport);\n\t\t}",
    "query": "Create a configuration mechanism in your Spring application that conditionally registers additional configuration classes during context initialization based on dynamic runtime criteria. This should enable modular loading of components, ensuring that certain beans are only instantiated when specific conditions are satisfied, thereby optimizing resource usage and startup time.",
    "function_signature": "public void addDeferredImport(DeferredImportSelectorHolder deferredImport)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Create a method that efficiently determines whether an HTTP request should undergo interception, optimizing pattern matching and minimizing unnecessary evaluations.",
    "function_signature": "public boolean shouldInterceptRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String destination;",
    "query": "Enhance message routing by implementing a method that securely retrieves the target path, ensuring thread-safe access and improved encapsulation.",
    "function_signature": "public String getTargetPath();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Design a custom interceptor that efficiently verifies whether incoming request URLs adhere to defined patterns, enhancing type safety and optimizing matching performance.",
    "function_signature": "public boolean isPathMatched(String requestPath, PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Enhance your Spring application's request lifecycle by implementing post-processing logic that ensures efficient resource management and robust error handling after each HTTP request.",
    "function_signature": "public void handlePostRequestCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a method to generate unique message identifiers that perform reliably under high concurrency, enhancing scalability and thread safety in the messaging system.",
    "function_signature": "public String generateUniqueMessageId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Develop a method to set the maximum number of concurrent message destinations, ensuring optimal performance and thread safety in high-throughput applications.",
    "function_signature": "public void configureMaxConcurrentDestinations(int maxDestinations)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Refactor the messaging component to retrieve the destination using a method that ensures thread safety and enhances performance over traditional approaches.",
    "function_signature": "public String resolveDestination()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Design a component that efficiently retrieves all active connection identifiers for a specific user, ensuring scalability and thread safety in a concurrent environment.",
    "function_signature": "public List<String> obtainActiveConnections(String userIdentifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Enhance the scalability and efficiency of your messaging application by setting up a modern subscription registry. Configure it with customizable cache limits and support for advanced subscription patterns to handle high concurrency scenarios effectively.",
    "function_signature": "public void configureOptimizedSubscriptionRegistry(int sessions, int destinations, int cacheSizeLimit, String specialization)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.3.7",
    "to_version": "v5.2.15.RELEASE",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Design a component that efficiently tracks and manages active WebSocket sessions and their corresponding subscriptions, ensuring scalability and thread safety under high-load conditions.",
    "function_signature": "public SubscriptionTracker initializeSubscriptionTracker()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}",
    "query": "Create a method that constructs an HTTP request with Spring's WebClient, enabling the dynamic configuration of custom metadata attributes just before the request is dispatched.",
    "function_signature": "public RequestBodySpec customizeRequestAttributes(Consumer<Map<String, Object>> attributesConsumer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate#closeContext(mergedConfig,hierarchyMode)",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}",
    "query": "Design a testing utility that efficiently releases cached application contexts, taking into account both the merged configuration settings and their hierarchical relationships.",
    "function_signature": "public void releaseCachedContext(MergedContextConfiguration config, @Nullable HierarchyMode mode)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.CHECKPOINT_ON_REFRESH_VALUE",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "field",
    "signature": "public String CHECKPOINT_ON_REFRESH_VALUE",
    "documentation": "\t/**\n\t * Recognized value for the context checkpoint property: {@value}.\n\t * @since 6.1\n\t * @see #CHECKPOINT_PROPERTY_NAME\n\t * @see org.crac.Core#checkpointRestore()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String CHECKPOINT_ON_REFRESH_VALUE = \"onRefresh\";",
    "query": "Develop a configuration method that ensures the application context saves its state automatically whenever it undergoes a refresh, enhancing the application's resilience and state management.",
    "function_signature": "public void configureCheckpointOnRefresh()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.init.ScriptUtils#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "documentation": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,",
    "query": "Enhance the efficiency of SQL script processing by implementing a method that accurately interprets script content, manages various comment formats, and reliably separates individual statements.",
    "function_signature": "public String parseSqlScript(BufferedReader reader, String commentPrefix, String statementSeparator, String blockCommentEndDelimiter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#keySet()",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public Set<String> keySet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}",
    "query": "Design a component that efficiently extracts and iterates over all distinct HTTP header names from incoming requests to apply custom validation logic.",
    "function_signature": "public Set<String> retrieveDistinctHeaderNames(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.JettyHeadersAdapter#values()",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public Collection<List<String>> values()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}",
    "query": "Create a Spring service method that collects and processes all HTTP header values from a Jetty-based incoming request, accommodating headers that may have multiple values efficiently.",
    "function_signature": "public Collection<List<String>> collectAllHeaderValues(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty4HeadersAdapter#getKey()",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public String getKey()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}",
    "query": "Design a component within a reactive Spring application that processes incoming HTTP requests by efficiently extracting and logging specific header identifiers from each request using the latest enhancements in header handling.",
    "function_signature": "public String retrieveHeaderIdentifier(ServerHttpRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.BindErrorUtils#resolve(errors)",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public String> resolve(List<E> errors)",
    "documentation": "\t/**\n\t * Shortcut for {@link #resolve(List, MessageSource, Locale)} with an empty\n\t * {@link MessageSource} that simply formats the default message, or first\n\t * error code, also prepending the field name for field errors.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(List<E> errors) {\n\t\treturn resolve(errors, defaultMessageSource, Locale.getDefault());\n\t}",
    "query": "Design a service method that takes a collection of user input errors and efficiently maps each error to its corresponding user-friendly message, ensuring that field-specific issues are clearly identified.",
    "function_signature": "public Map<MessageSourceResolvable, String> mapValidationErrors(List<MessageSourceResolvable> errors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.cache.DefaultContextCache#incrementFailureCount(key)",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public void incrementFailureCount(MergedContextConfiguration key)",
    "documentation": "\t/**\n\t * {@inheritDoc}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void incrementFailureCount(MergedContextConfiguration key) {\n\t\tthis.totalFailureCount.incrementAndGet();\n\t\tthis.failureCounts.merge(key, 1, Integer::sum);\n\t}",
    "query": "Design a mechanism within your testing framework that accurately tracks and increments the number of failed test executions for each unique test configuration. Ensure that this tracking system efficiently aggregates failure counts, facilitating better analysis and reporting of test stability across different configurations.",
    "function_signature": "public void recordTestFailure(MergedContextConfiguration config)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.beanvalidation.MethodValidationAdapter#invokeValidatorForArguments(target,method,arguments,groups)",
    "from_version": "v6.0.11",
    "to_version": "v6.1.0-M2",
    "type": "method",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForArguments(Object target, Method method, Object[] arguments, Class<?>[] groups)",
    "documentation": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments(",
    "query": "Design a service method that validates multiple input parameters against specified validation groups and aggregates all constraint violations before proceeding.",
    "function_signature": "public Set<ConstraintViolation<Object>> validateServiceMethodArgs(Object target, Method method, Object[] args, Class<?>[] groups)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.beanvalidation.MethodValidationAdapter#validateReturnValue(target,method,returnType,returnValue,groups)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic final MethodValidationResult validateReturnValue(",
    "query": "Design a component that automatically verifies the correctness of data produced by service methods by checking their outputs against defined validation rules immediately after execution.",
    "function_signature": "public ValidationOutcome verifyMethodOutput(Object serviceInstance, Method executedMethod, @Nullable MethodParameter returnType, @Nullable Object result, Class<?>[] validationGroups)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.ConfigurationClassPostProcessor#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,",
    "query": "Design a configuration mechanism that dynamically generates optimized suppliers for bean instances during the application startup phase. Ensure that the solution allows toggling between direct supplier shortcuts and more elaborate supplier generation based on specific runtime conditions.",
    "function_signature": "public CodeBlock createDynamicBeanSupplier(GenerationContext context, BeanRegistrationCode registrationCode, boolean enableShortcut);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parseTypeFilters(element,scanner,parserContext)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "protected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext) {\n\t\t// Parse exclude and include filter elements.\n\t\tClassLoader classLoader = scanner.getResourceLoader().getClassLoader();\n\t\tNodeList nodeList = element.getChildNodes();\n\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\tNode node = nodeList.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tString localName = parserContext.getDelegate().getLocalName(node);\n\t\t\t\ttry {\n\t\t\t\t\tif (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addIncludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addExcludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tparserContext.getReaderContext().warning(\n\t\t\t\t\t\t\t\"Ignoring non-present type filter class: \" + ex, parserContext.extractSource(element));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\tex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "How can you enhance your Spring application to dynamically include and exclude beans during component scanning by parsing custom XML configuration elements, leveraging the latest Spring Framework capabilities?",
    "function_signature": "protected void configureComponentScanFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.WebExchangeDataBinder#shouldConstructArgument(param)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "protected boolean shouldConstructArgument(MethodParameter param)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected boolean shouldConstructArgument(MethodParameter param) {\n\t\tClass<?> type = param.nestedIfOptional().getNestedParameterType();\n\t\treturn (super.shouldConstructArgument(param) && !Part.class.isAssignableFrom(type));\n\t}",
    "query": "Design a reactive controller component that selectively bypasses the binding process for specific types of multipart file uploads, ensuring they are handled differently from standard request parameters.",
    "function_signature": "@Override\nprotected boolean shouldConstructArgument(MethodParameter parameter) {\n    // Implementation leveraging the latest data binding enhancements\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser#createScanner(readerContext,useDefaultFilters)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {\n\t\treturn new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters,\n\t\t\t\treaderContext.getEnvironment(), readerContext.getResourceLoader());\n\t}",
    "query": "Design a method that configures a classpath scanner to include or exclude default component filters based on the provided configuration context.",
    "function_signature": "protected ClassPathBeanDefinitionScanner configureScanner(XmlReaderContext readerContext, boolean useDefaultFilters)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.<unknown>#set(key,value)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "public void set(String key, @Nullable String value)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}",
    "query": "Develop a method to efficiently manage and modify HTTP headers within a reactive client, prioritizing immutability and thread safety to enhance application performance.",
    "function_signature": "public void addHeader(String key, @Nullable String value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver#handleMissingValue(name,parameter,message)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, Message<?> message)",
    "documentation": "\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);",
    "query": "Design a custom argument resolver that ensures specific message attributes are always present during request processing. If an essential attribute is missing, the resolver should handle this scenario by enforcing appropriate exception handling.",
    "function_signature": "protected void handleMissingAttribute(String attributeName, MethodParameter parameter, Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getIncludePathPatterns()",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "public String[] getIncludePathPatterns()",
    "documentation": "\t/**\n\t * Get the include path patterns this interceptor is mapped to.\n\t * @since 6.1\n\t * @see #getExcludePathPatterns()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String[] getIncludePathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Design a feature that retrieves and logs all URL patterns an interceptor is configured to handle, enabling dynamic monitoring of request routing within the application.",
    "function_signature": "public String[] fetchConfiguredInterceptorPaths(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.<unknown>#paramSource(namedParamObject)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "public StatementSpec paramSource(Object namedParamObject)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic StatementSpec paramSource(Object namedParamObject) {\n\t\t\tthis.namedParamSource = (namedParamObject instanceof Map map ?\n\t\t\t\t\tnew MapSqlParameterSource(map) :\n\t\t\t\t\tnew SimplePropertySqlParameterSource(namedParamObject));\n\t\t\treturn this;\n\t\t}",
    "query": "Design a service method that executes a dynamic SQL update operation, allowing callers to provide parameters either as a map or as a plain Java object. Ensure that the method efficiently handles both input types without requiring separate implementations.",
    "function_signature": "public int executeDynamicUpdate(String sql, Object parameterSource)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler)",
    "from_version": "v6.0.18",
    "to_version": "v6.1.5",
    "type": "method",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping(",
    "query": "Implement a scalable WebSocket configuration that utilizes advanced scheduling to enhance message routing efficiency and resource management.",
    "function_signature": "public HandlerMapping createScalableWebSocketHandlerMapping(WebSocketHandler handler, TaskScheduler scheduler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Design a `MappedInterceptor` setup that optimizes URL path matching for better performance and utilizes the latest path parsing mechanisms without relying on manual pattern configurations.",
    "function_signature": "public void optimizeInterceptorPathMatching()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean ->\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t *\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a configuration that efficiently manages global message exception handlers, ensuring seamless integration with controller advice and improving maintainability.",
    "function_signature": "public void configureGlobalMessageExceptionHandling(GlobalExceptionHandler handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Refactor the subscription handling to implement a more efficient and thread-safe registry management strategy within your messaging broker configuration.",
    "function_signature": "public SubscriptionRegistry createSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String destination;",
    "query": "Enhance the messaging configuration to ensure efficient routing of messages by addressing current limitations in destination handling.",
    "function_signature": "public void setDestinationResolver(DestinationResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "Enhance the subscription setup to improve scalability and reduce latency. Implement a method that initializes the subscription registry using the latest configuration strategies to handle increased load efficiently.",
    "function_signature": "public void initializeSubscriptionRegistryWithOptimizedConfig()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Create a method that efficiently determines whether an interceptor should process a given HTTP request. Ensure that the implementation optimizes pattern matching and enhances scalability for handling diverse request paths.",
    "function_signature": "public boolean shouldInterceptRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Design a method to efficiently handle and track client subscriptions, ensuring scalability and thread safety in a high-concurrency messaging environment.",
    "function_signature": "public void handleClientSubscriptions(SubscriptionManager subscriptionManager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Enhance your Spring application's request processing by implementing a modern interception strategy that boosts performance and maintainability.",
    "function_signature": "public boolean interceptRequest(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Develop a component that efficiently retrieves the messaging destination, ensuring thread safety and optimal performance without directly accessing internal fields.",
    "function_signature": "public String getDestination()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.3.9",
    "to_version": "v5.2.16.RELEASE",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int sessions;",
    "query": "Create a method that retrieves the current number of active messaging sessions, ensuring thread safety and optimal performance for high-load scenarios.",
    "function_signature": "public int fetchActiveSessionCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup()",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "method",
    "signature": "public void doSetup()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "query": "In a real-time messaging application, you need to efficiently manage subscriptions for thousands of concurrent WebSocket sessions and destinations. Develop a setup process that configures the subscription registry with optimal caching and dynamic selector criteria.",
    "function_signature": "public void configureSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a WebSocket controller method that efficiently assigns a sequential identifier to each client message, ensuring thread-safe incrementation even under high load.",
    "function_signature": "public void processClientMessage(String clientId, String messageContent)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Design a service method that retrieves all active WebSocket session identifiers to monitor user connections in real-time.",
    "function_signature": "public String[] fetchActiveSessionIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Design a component that configures subscription destinations dynamically based on varying levels of subscriber contention, utilizing server state to ensure optimal destination assignment and scalability.",
    "function_signature": "public void configureDynamicSubscriptions(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Create a mechanism that selectively intercepts HTTP requests targeting certain API endpoints to enforce custom authentication logic before they reach the designated controllers. Ensure that only the specified URL patterns are processed by this interceptor, allowing other requests to proceed unaffected.",
    "function_signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "How can you ensure that specific attributes are consistently added to the model after any controller processes a request, without modifying each controller individually?",
    "function_signature": "public void enrichModelAttributes(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Design a scalable WebSocket-based chat application where users can subscribe to multiple chat rooms with varying subscription patterns. Ensure that the subscription management efficiently handles high concurrency and dynamic subscription changes without compromising performance.",
    "function_signature": "public void manageUserSubscriptions(String userId, List<String> chatRoomPatterns)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Develop a request interceptor that dynamically determines whether to process incoming HTTP requests based on runtime attributes of the `HttpServletRequest`. Ensure that your implementation efficiently leverages the latest Spring Framework features for request path evaluation.",
    "function_signature": "public boolean shouldIntercept(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Design a Spring MVC configuration that applies a custom logging interceptor exclusively to API endpoints matching `/api/**` while excluding any administrative routes under `/api/admin/**`. Ensure that the pattern matching is optimized for performance and leverages the latest path parsing capabilities provided by the framework.",
    "function_signature": "public void registerApiLoggingInterceptor(String[] includePatterns, String[] excludePatterns, HandlerInterceptor interceptor, PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.15.RELEASE",
    "to_version": "v5.3.8",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Create a feature in your real-time collaboration tool that dynamically manages and monitors user subscriptions to various channels, ensuring that updates are efficiently routed only to currently subscribed participants.",
    "function_signature": "public void manageChannelSubscriptions(User user, SubscriptionRegistry subscriptionRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#addParameter(name,values)",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public void addParameter(String name, String... values)",
    "documentation": "\t/**\n\t * Add an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given values will be added to the end of the list.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void addParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tString[] oldArr = this.parameters.get(name);\n\t\tif (oldArr != null) {\n\t\t\tString[] newArr = new String[oldArr.length + values.length];\n\t\t\tSystem.arraycopy(oldArr, 0, newArr, 0, oldArr.length);\n\t\t\tSystem.arraycopy(values, 0, newArr, oldArr.length, values.length);\n\t\t\tthis.parameters.put(name, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.parameters.put(name, values);\n\t\t}\n\t}",
    "query": "Design a method to efficiently manage multiple values for a single HTTP parameter in a mock request, enhancing thread safety and performance.",
    "function_signature": "public void setParameterValues(String name, List<String> values)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanDefinition#hasQualifier(typeName)",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public boolean hasQualifier(String typeName)",
    "documentation": "\t/**\n\t * Return whether this bean has the specified qualifier.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean hasQualifier(String typeName) {\n\t\treturn this.qualifiers.containsKey(typeName);\n\t}",
    "query": "Develop a method to verify the presence of a specific attribute within a bean, leveraging a type-safe approach to enhance performance and reliability.",
    "function_signature": "public boolean containsAttribute(Class<? extends Annotation> attributeType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.event.AbstractApplicationEventMulticaster#addApplicationListenerBean(listenerBeanName)",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public void addApplicationListenerBean(String listenerBeanName)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void addApplicationListenerBean(String listenerBeanName) {\n\t\tsynchronized (this.defaultRetriever) {\n\t\t\tthis.defaultRetriever.applicationListenerBeans.add(listenerBeanName);\n\t\t\tthis.retrieverCache.clear();\n\t\t}\n\t}",
    "query": "Optimize the event listener registration process to enhance type safety and reduce configuration overhead within your Spring application context.",
    "function_signature": "public void registerApplicationListener(ApplicationListener<?> listener)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.AdvisedSupport#equals(other)",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof MethodCacheKey &&\n\t\t\t\t\tthis.method == ((MethodCacheKey) other).method));\n\t\t}",
    "query": "Enhance the reliability of determining whether two AOP proxy configurations are identical, ensuring improved performance and thread safety in high-concurrency scenarios.",
    "function_signature": "public boolean areProxyConfigsEquivalent(@Nullable Object configA, @Nullable Object configB)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanDefinition#setDescription(description)",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public void setDescription(@Nullable String description)",
    "documentation": "\t/**\n\t * Set a human-readable description of this bean definition.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setDescription(@Nullable String description) {\n\t\tthis.description = description;\n\t}",
    "query": "Enhance a Spring bean definition by providing a clear, maintainable description using the latest best practices to improve code safety and readability.",
    "function_signature": "public void configureBeanDescription(@Nullable String description)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.ServletServerHttpRequest#getHeaders()",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public HttpHeaders getHeaders()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic HttpHeaders getHeaders() {\n\t\tif (this.headers == null) {\n\t\t\tthis.headers = new HttpHeaders();\n\n\t\t\tfor (Enumeration<?> names = this.servletRequest.getHeaderNames(); names.hasMoreElements();) {\n\t\t\t\tString headerName = (String) names.nextElement();\n\t\t\t\tfor (Enumeration<?> headerValues = this.servletRequest.getHeaders(headerName);\n\t\t\t\t\t\theaderValues.hasMoreElements();) {\n\t\t\t\t\tString headerValue = (String) headerValues.nextElement();\n\t\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// HttpServletRequest exposes some headers as properties:\n\t\t\t// we should include those if not already present\n\t\t\ttry {\n\t\t\t\tMediaType contentType = this.headers.getContentType();\n\t\t\t\tif (contentType == null) {\n\t\t\t\t\tString requestContentType = this.servletRequest.getContentType();\n\t\t\t\t\tif (StringUtils.hasLength(requestContentType)) {\n\t\t\t\t\t\tcontentType = MediaType.parseMediaType(requestContentType);\n\t\t\t\t\t\tif (contentType.isConcrete()) {\n\t\t\t\t\t\t\tthis.headers.setContentType(contentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (contentType != null && contentType.getCharset() == null) {\n\t\t\t\t\tString requestEncoding = this.servletRequest.getCharacterEncoding();\n\t\t\t\t\tif (StringUtils.hasLength(requestEncoding)) {\n\t\t\t\t\t\tCharset charSet = Charset.forName(requestEncoding);\n\t\t\t\t\t\tMap<String, String> params = new LinkedCaseInsensitiveMap<>();\n\t\t\t\t\t\tparams.putAll(contentType.getParameters());\n\t\t\t\t\t\tparams.put(\"charset\", charSet.toString());\n\t\t\t\t\t\tMediaType mediaType = new MediaType(contentType.getType(), contentType.getSubtype(), params);\n\t\t\t\t\t\tthis.headers.setContentType(mediaType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\t// Ignore: simply not exposing an invalid content type in HttpHeaders...\n\t\t\t}\n\n\t\t\tif (this.headers.getContentLength() < 0) {\n\t\t\t\tint requestContentLength = this.servletRequest.getContentLength();\n\t\t\t\tif (requestContentLength != -1) {\n\t\t\t\t\tthis.headers.setContentLength(requestContentLength);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.headers;\n\t}",
    "query": "Optimize the retrieval of HTTP headers to enhance performance and ensure thread safety within your server request handling.",
    "function_signature": "public HttpHeaders fetchOptimizedHeaders()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.CloseStatus",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "class",
    "signature": "public class CloseStatus",
    "documentation": "/**\n * Representation of WebSocket \"close\" status codes and reasons. Status codes\n * in the 1xxx range are pre-defined by the protocol.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n * @see <a href=\"https://tools.ietf.org/html/rfc6455#section-7.4.1\">\n *     RFC 6455, Section 7.4.1 \"Defined Status Codes\"</a>\n */",
    "changetype": "deprecated",
    "source_code": "public final class CloseStatus {\n\n\t/**\n\t * \"1000 indicates a normal closure, meaning that the purpose for which the connection\n\t * was established has been fulfilled.\"\n\t */\n\tpublic static final CloseStatus NORMAL = new CloseStatus(1000);\n\n\t/**\n\t * \"1001 indicates that an endpoint is \"going away\", such as a server going down or a\n\t * browser having navigated away from a page.\"\n\t */\n\tpublic static final CloseStatus GOING_AWAY = new CloseStatus(1001);\n\n\t/**\n\t * \"1002 indicates that an endpoint is terminating the connection due to a protocol\n\t * error.\"\n\t */\n\tpublic static final CloseStatus PROTOCOL_ERROR  = new CloseStatus(1002);\n\n\t/**\n\t * \"1003 indicates that an endpoint is terminating the connection because it has\n\t * received a type of data it cannot accept (e.g., an endpoint that understands only\n\t * text data MAY send this if it receives a binary message).\"\n\t */\n\tpublic static final CloseStatus NOT_ACCEPTABLE = new CloseStatus(1003);\n\n\t// 10004: Reserved.\n\t// The specific meaning might be defined in the future.\n\n\t/**\n\t * \"1005 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that no status code was actually present.\"\n\t */\n\tpublic static final CloseStatus NO_STATUS_CODE = new CloseStatus(1005);\n\n\t/**\n\t * \"1006 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that the connection was closed abnormally, e.g., without sending\n\t * or receiving a Close control frame.\"\n\t */\n\tpublic static final CloseStatus NO_CLOSE_FRAME = new CloseStatus(1006);\n\n\t/**\n\t * \"1007 indicates that an endpoint is terminating the connection because it has\n\t * received data within a message that was not consistent with the type of the message\n\t * (e.g., non-UTF-8 [RFC3629] data within a text message).\"\n\t */\n\tpublic static final CloseStatus BAD_DATA = new CloseStatus(1007);\n\n\t/**\n\t * \"1008 indicates that an endpoint is terminating the connection because it has\n\t * received a message that violates its policy. This is a generic status code that can\n\t * be returned when there is no other more suitable status code (e.g., 1003 or 1009)\n\t * or if there is a need to hide specific details about the policy.\"\n\t */\n\tpublic static final CloseStatus POLICY_VIOLATION = new CloseStatus(1008);\n\n\t/**\n\t * \"1009 indicates that an endpoint is terminating the connection because it has\n\t * received a message that is too big for it to process.\"\n\t */\n\tpublic static final CloseStatus TOO_BIG_TO_PROCESS = new CloseStatus(1009);\n\n\t/**\n\t * \"1010 indicates that an endpoint (client) is terminating the connection because it\n\t * has expected the server to negotiate one or more extension, but the server didn't\n\t * return them in the response message of the WebSocket handshake. The list of\n\t * extensions that are needed SHOULD appear in the /reason/ part of the Close frame.\n\t * Note that this status code is not used by the server, because it can fail the\n\t * WebSocket handshake instead.\"\n\t */\n\tpublic static final CloseStatus REQUIRED_EXTENSION = new CloseStatus(1010);\n\n\t/**\n\t * \"1011 indicates that a server is terminating the connection because it encountered\n\t * an unexpected condition that prevented it from fulfilling the request.\"\n\t */\n\tpublic static final CloseStatus SERVER_ERROR = new CloseStatus(1011);\n\n\t/**\n\t * \"1012 indicates that the service is restarted. A client may reconnect, and if it\n\t * chooses to do, should reconnect using a randomized delay of 5 - 30s.\"\n\t */\n\tpublic static final CloseStatus SERVICE_RESTARTED = new CloseStatus(1012);\n\n\t/**\n\t * \"1013 indicates that the service is experiencing overload. A client should only\n\t * connect to a different IP (when there are multiple for the target) or reconnect to\n\t * the same IP upon user action.\"\n\t */\n\tpublic static final CloseStatus SERVICE_OVERLOAD = new CloseStatus(1013);\n\n\t/**\n\t * \"1015 is a reserved value and MUST NOT be set as a status code in a Close control\n\t * frame by an endpoint. It is designated for use in applications expecting a status\n\t * code to indicate that the connection was closed due to a failure to perform a TLS\n\t * handshake (e.g., the server certificate can't be verified).\"\n\t */\n\tpublic static final CloseStatus TLS_HANDSHAKE_FAILURE = new CloseStatus(1015);\n\n\n\tprivate final int code;\n\n\t@Nullable\n\tprivate final String reason;\n\n\n\t/**\n\t * Create a new {@link CloseStatus} instance.\n\t * @param code the status code\n\t */\n\tpublic CloseStatus(int code) {\n\t\tthis(code, null);\n\t}\n\n\t/**\n\t * Create a new {@link CloseStatus} instance.\n\t * @param code the status code\n\t * @param reason the reason\n\t */\n\tpublic CloseStatus(int code, @Nullable String reason) {\n\t\tAssert.isTrue((code >= 1000 && code < 5000), \"Invalid status code\");\n\t\tthis.code = code;\n\t\tthis.reason = reason;\n\t}\n\n\n\t/**\n\t * Return the status code.\n\t */\n\tpublic int getCode() {\n\t\treturn this.code;\n\t}\n\n\t/**\n\t * Return the reason, or {@code null} if none.\n\t */\n\t@Nullable\n\tpublic String getReason() {\n\t\treturn this.reason;\n\t}\n\n\t/**\n\t * Create a new {@link CloseStatus} from this one with the specified reason.\n\t * @param reason the reason\n\t * @return a new {@link CloseStatus} instance\n\t */\n\tpublic CloseStatus withReason(String reason) {\n\t\tAssert.hasText(reason, \"Reason must not be empty\");\n\t\treturn new CloseStatus(this.code, reason);\n\t}\n\n\t/**\n\t * @deprecated as of 5.3 in favor of comparing codes directly\n\t */\n\t@Deprecated\n\tpublic boolean equalsCode(CloseStatus other) {\n\t\treturn (this.code == other.code);\n\t}\n\n\n\t/**\n\t * Return a constant for the given code, or create a new instance if the\n\t * code does not match or there is a reason.\n\t * @since 5.3\n\t */\n\tpublic static CloseStatus create(int code, @Nullable String reason) {\n\t\tif (!StringUtils.hasText(reason)) {\n\t\t\tswitch (code) {\n\t\t\t\tcase 1000:\n\t\t\t\t\treturn NORMAL;\n\t\t\t\tcase 1001:\n\t\t\t\t\treturn GOING_AWAY;\n\t\t\t\tcase 1002:\n\t\t\t\t\treturn PROTOCOL_ERROR;\n\t\t\t\tcase 1003:\n\t\t\t\t\treturn NOT_ACCEPTABLE;\n\t\t\t\tcase 1005:\n\t\t\t\t\treturn NO_STATUS_CODE;\n\t\t\t\tcase 1006:\n\t\t\t\t\treturn NO_CLOSE_FRAME;\n\t\t\t\tcase 1007:\n\t\t\t\t\treturn BAD_DATA;\n\t\t\t\tcase 1008:\n\t\t\t\t\treturn POLICY_VIOLATION;\n\t\t\t\tcase 1009:\n\t\t\t\t\treturn TOO_BIG_TO_PROCESS;\n\t\t\t\tcase 1010:\n\t\t\t\t\treturn REQUIRED_EXTENSION;\n\t\t\t\tcase 1011:\n\t\t\t\t\treturn SERVER_ERROR;\n\t\t\t\tcase 1012:\n\t\t\t\t\treturn SERVICE_RESTARTED;\n\t\t\t\tcase 1013:\n\t\t\t\t\treturn SERVICE_OVERLOAD;\n\t\t\t}\n\t\t}\n\t\treturn new CloseStatus(code, reason);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof CloseStatus otherStatus)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.code == otherStatus.code &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.reason, otherStatus.reason));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.code * 29 + ObjectUtils.nullSafeHashCode(this.reason);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CloseStatus[code=\" + this.code + \", reason=\" + this.reason + \"]\";\n\t}\n\n}",
    "query": "Design a method to determine if a WebSocket connection has terminated successfully by evaluating the provided status code. Ensure the implementation prioritizes performance and simplicity in the comparison logic.",
    "function_signature": "public boolean isConnectionClosedNormally(int statusCode)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.JdbcTemplate#execute(sql)",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public void execute(final String sql)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void execute(final String sql) throws DataAccessException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL statement [\" + sql + \"]\");\n\t\t}\n\n\t\t/**\n\t\t * Callback to execute the statement.\n\t\t */\n\t\tclass ExecuteStatementCallback implements StatementCallback<Object>, SqlProvider {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Object doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tstmt.execute(sql);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\texecute(new ExecuteStatementCallback(), true);\n\t}",
    "query": "Develop a method to execute SQL statements using a callback mechanism to enhance flexibility and error handling.",
    "function_signature": "public <T> T executeSql(String sql, StatementCallback<T> action)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.jpa.AbstractEntityManagerFactoryBean#getBeanClassLoader()",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public ClassLoader getBeanClassLoader()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic ClassLoader getBeanClassLoader() {\n\t\treturn this.beanClassLoader;\n\t}",
    "query": "Design a method to efficiently obtain the appropriate ClassLoader within a JPA EntityManager setup, ensuring enhanced performance and thread safety.",
    "function_signature": "public ClassLoader fetchOptimalClassLoader()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#getServerName()",
    "from_version": "v6.0.0-M3",
    "to_version": "v5.3.17",
    "type": "method",
    "signature": "public String getServerName()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getServerName() {\n\t\tString rawHostHeader = getHeader(HttpHeaders.HOST);\n\t\tString host = rawHostHeader;\n\t\tif (host != null) {\n\t\t\thost = host.trim();\n\t\t\tif (host.startsWith(\"[\")) {\n\t\t\t\tint indexOfClosingBracket = host.indexOf(']');\n\t\t\t\tAssert.state(indexOfClosingBracket > -1, () -> \"Invalid Host header: \" + rawHostHeader);\n\t\t\t\thost = host.substring(0, indexOfClosingBracket + 1);\n\t\t\t}\n\t\t\telse if (host.contains(\":\")) {\n\t\t\t\thost = host.substring(0, host.indexOf(':'));\n\t\t\t}\n\t\t\treturn host;\n\t\t}\n\n\t\t// else\n\t\treturn this.serverName;\n\t}",
    "query": "Develop a method to accurately obtain the server's hostname from a mock HTTP request, enhancing performance and reliability compared to conventional techniques.",
    "function_signature": "public String retrieveServerHostname(MockHttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#getByte(index)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public byte getByte(int index)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic byte getByte(int index) {\n\t\t\treturn this.delegate.getByte(index);\n\t\t}",
    "query": "Optimize the retrieval of a byte value at a specific index from the reactive HTTP connector, ensuring enhanced performance and thread safety by utilizing the latest recommended approach.",
    "function_signature": "public Mono<Byte> fetchByteAt(int index)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#compareTo(o)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public int compareTo(Delayed o)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int compareTo(Delayed o) {\n\t\t\treturn this.future.compareTo(o);\n\t\t}",
    "query": "Design a service that schedules background tasks to execute after a specified delay, ensuring that tasks with higher priority are executed before those with lower priority, regardless of their scheduled execution time.",
    "function_signature": "public ScheduledFuture<?> scheduleWithPriority(Runnable task, long delay, int priority);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#append(codePoint)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public void append(int codePoint)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void append(int codePoint) {\n\t\t\tthis.segments.add(new PathSegment(codePoint));\n\t\t}",
    "query": "Design a RESTful endpoint that dynamically builds a URL path by appending various Unicode characters based on client input. Ensure that each appended character is correctly integrated as a distinct segment in the path, maintaining the integrity and readability of the URL.",
    "function_signature": "public void buildDynamicPath(int unicodeCodePoint)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.ResolvableType#isAssignableFrom(types)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public boolean isAssignableFrom(ResolvableType... types)",
    "documentation": "\t\t/**\n\t\t * Return {@code true} if this bounds is assignable to all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if this bounds is assignable to all types\n\t\t */",
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType... types) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (!isAssignable(bound, type)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}",
    "query": "Develop a utility function that assesses the compatibility of multiple type hierarchies, prioritizing enhanced performance and reliability over traditional approaches.",
    "function_signature": "public boolean checkTypeCompatibility(ResolvableType... typesToEvaluate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#cookie(name,value)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}",
    "query": "Develop a method that initiates an HTTP request to an external API, ensuring a specific tracking cookie is included to maintain user analytics seamlessly.",
    "function_signature": "public RequestBodyUriSpec includeTrackingCookie(String name, String value);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.MockMvcTester#multipart()",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public MockMultipartMvcRequestBuilder multipart()",
    "documentation": "\t\t/**\n\t\t * Enable file upload support using multipart.\n\t\t * @return a {@link MockMultipartMvcRequestBuilder} with the settings\n\t\t * configured thus far\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic MockMultipartMvcRequestBuilder multipart() {\n\t\t\treturn new MockMultipartMvcRequestBuilder(this);\n\t\t}",
    "query": "Design a unit test for a REST controller endpoint that accepts user profile pictures, ensuring the multipart file upload is correctly handled and validated.",
    "function_signature": "public MockMultipartMvcRequestBuilder uploadUserProfilePicture()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.annotation.AnnotatedMethod#toString()",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}",
    "query": "Create a utility that generates a comprehensive log of all annotated methods within a specified Spring component, including their detailed signatures. This will enhance debugging by providing clear insights into method configurations and annotations.",
    "function_signature": "public String generateAnnotatedMethodsLog(Class<?> componentClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#flush()",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public void flush()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void flush() throws IOException {\n\t\t\tif (this.sendFailed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.outputMessage.flush();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.sendFailed = true;\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}",
    "query": "Develop a request handler that guarantees all response data is transmitted to the client immediately after processing, ensuring that the output stream is properly cleared and any transmission issues are handled gracefully.",
    "function_signature": "public void sendResponseAndFlush(ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#slice(index,length)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "public DataBuffer slice(int index, int length)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}",
    "query": "Enhance the data processing workflow by implementing a method that efficiently retrieves a subsection of a data buffer, ensuring optimal performance and memory management.",
    "function_signature": "public DataBuffer extractSection(int start, int length)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.DefaultResponseErrorHandler#getCharset(response)",
    "from_version": "v6.1.19",
    "to_version": "v6.2.6",
    "type": "method",
    "signature": "protected Charset getCharset(ClientHttpResponse response)",
    "documentation": "\t/**\n\t * Determine the charset of the response (for inclusion in a status exception).\n\t * @param response the response to inspect\n\t * @return the associated charset, or {@code null} if none\n\t * @since 4.3.8\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Charset getCharset(ClientHttpResponse response) {\n\t\tMediaType contentType = response.getHeaders().getContentType();\n\t\treturn (contentType != null ? contentType.getCharset() : null);\n\t}",
    "query": "Design a custom error handler that retrieves the character encoding from HTTP responses to enrich exception messages.",
    "function_signature": "protected Charset extractCharsetFromResponse(ClientHttpResponse response)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a component to handle the completion phase of web requests, ensuring efficient resource management and robust exception handling to enhance overall application stability.",
    "function_signature": "public void handleCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Throwable exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Develop a component that efficiently manages client subscriptions, ensuring thread safety and optimal resource utilization in a concurrent messaging system.",
    "function_signature": "public void registerClientSubscription(ClientSession session, String topic)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#find(serverState,request)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}",
    "query": "Create a method that efficiently retrieves active subscription details based on the server's current state and a specific request. Ensure the implementation enhances performance and reliability compared to previous approaches.",
    "function_signature": "public MultiValueMap<String, String> fetchActiveSubscriptions(ServerState serverState, FindRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean ->\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t *\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a centralized mechanism for managing exceptions in reactive message processing to enhance performance and ensure thread-safe operations.",
    "function_signature": "public void registerGlobalExceptionHandler(GlobalExceptionHandler handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Design a robust subscription management feature that efficiently handles multiple subscription requests concurrently while ensuring data integrity. Consider scalability and maintainability in your implementation.",
    "function_signature": "public void handleSubscription(String sessionId, SubscriptionDetails details)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Enhance the message broker's destination resolution to improve scalability and maintainability, addressing potential limitations in the current implementation.",
    "function_signature": "public DestinationResolver resolveDestination(String destinationName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Develop a component to manage HTTP request processing that enhances performance and ensures safer operations by adopting the latest interceptor mechanism provided by the Spring Framework.",
    "function_signature": "public boolean handleRequest(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#match(path,isPathContainer,pathMatcher)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}",
    "query": "Design a component that efficiently evaluates incoming request URLs against defined patterns, ensuring optimal performance and thread safety in a web application.",
    "function_signature": "public boolean isPathMatched(String requestPath, PathMatcher pathMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Design a method to configure a messaging system's subscription management using a robust and optimized registry solution that enhances scalability and thread safety.",
    "function_signature": "public SubscriptionManager configureSubscriptionManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.3.10",
    "to_version": "v5.2.17.RELEASE",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Design a setup mechanism that dynamically assigns destinations based on server state, optimizing for thread safety and reducing contention in high-load environments.",
    "function_signature": "public void initializeDestinationMapping(ServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String destination;",
    "query": "Design a WebSocket message handler that efficiently routes incoming messages to different processing channels based on their target endpoints.",
    "function_signature": "public void routeMessageByDestination(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Develop a feature that efficiently manages user subscriptions for real-time updates in a WebSocket communication setup.",
    "function_signature": "public SubscriptionRegistry getSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Optimize a real-time messaging application to handle high volumes of dynamic subscriptions with varying patterns and header-based selectors, ensuring efficient routing and minimal latency.",
    "function_signature": "public void registerDynamicSubscription(String sessionId, String destinationPattern, Map<String, String> selectorHeaders)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a method that fetches the list of authorized destination identifiers to enforce access control in your messaging application.",
    "function_signature": "public String[] fetchAuthorizedDestinationIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Create a Spring interceptor that dynamically retrieves and processes specific URL patterns to enhance request handling efficiency in a web application.",
    "function_signature": "public String[] retrieveConfiguredPathPatterns()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a component within your Spring WebSocket broker that assigns a unique, thread-safe identifier to each incoming message to facilitate precise tracking and management in a high-concurrency environment.",
    "function_signature": "public void assignUniqueMessageId(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Design a component that selectively retrieves and modifies the underlying request interceptor based on dynamic conditions during runtime.",
    "function_signature": "public HandlerInterceptor customizeInterceptorBasedOnCondition(String condition)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Create a mechanism to access and leverage the path matching configuration of a specific interceptor, enabling dynamic adjustment of request handling based on custom URL patterns.",
    "function_signature": "public PathMatcher retrieveConfiguredPathMatcher(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a Spring component that selectively processes incoming HTTP requests based on dynamic path patterns. Ensure that the component efficiently determines applicability by leveraging the latest enhancements in request path matching, allowing for streamlined inclusion and exclusion logic without manual path evaluations.",
    "function_signature": "public boolean shouldHandleRequest(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.9.RELEASE",
    "to_version": "v5.3.0-RC1",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "Develop a Spring service that retrieves and exposes the current number of active message destinations managed by your application's messaging broker.",
    "function_signature": "public int getActiveDestinationCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int destinations;",
    "query": "Design a Spring service method that monitors and limits the number of active messaging channels to enhance application scalability and prevent resource exhaustion.",
    "function_signature": "public void enforceChannelLimit(int maxChannels)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a service method that identifies and retrieves messaging destinations based on specific contention scenarios, such as having no active subscribers or targeting existing destination overlaps. This method should efficiently handle different system states to ensure optimal message routing.",
    "function_signature": "public Destination findDestinationByContention(String contentionType);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Design a method to orchestrate client subscription workflows in a messaging system, allowing dynamic handling of subscribe and unsubscribe actions while supporting configurable contention strategies and session management.",
    "function_signature": "public void orchestrateSubscriptionWorkflow(SubscriptionWorkflowContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#find(serverState,request)",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "method",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}",
    "query": "Design a feature for a real-time chat application that efficiently retrieves all active user subscriptions for a given chat room based on the current server state and specific query parameters.",
    "function_signature": "public MultiValueMap<String, String> getActiveUserSubscriptions(ServerState serverState, FindRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPatternString()",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "method",
    "signature": "public String getPatternString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}",
    "query": "Design a monitoring component that logs the specific URL patterns each interceptor is applied to within your Spring MVC application. Ensure that the component dynamically retrieves and displays these patterns without hardcoding them.",
    "function_signature": "public void logInterceptorPatterns(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String destination;",
    "query": "Design a component that intercepts incoming WebSocket messages and logs their specific routing destinations to facilitate monitoring and debugging.",
    "function_signature": "public void logMessageDestination(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "stabilized",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Design a feature in your Spring MVC application that conditionally applies logging only to specific API endpoints while excluding others, ensuring that the logging mechanism is efficiently managed based on URL patterns.",
    "function_signature": "public void configureSelectiveLoggingInterceptor(String[] includePaths, String[] excludePaths, HandlerInterceptor loggingInterceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a feature that appends standardized metadata to the response model after a controller has handled a request, ensuring consistency across multiple endpoints without modifying each controller individually.",
    "function_signature": "public void appendStandardMetadata(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Develop a component that manages real-time client subscriptions to multiple messaging destinations, ensuring efficient handling of both specific and wildcard subscription patterns while maintaining optimal performance under high load.",
    "function_signature": "public void configureSubscriptionManager(int maxCacheSize, SubscriptionPatternHandler patternHandler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerUnregister(serverState,request,blackhole)",
    "from_version": "v5.2.20.RELEASE",
    "to_version": "v5.3.19",
    "type": "method",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}",
    "query": "Develop a service method to efficiently manage the lifecycle of user subscriptions in a live streaming platform. The method should handle registering new subscriptions, unregistering existing ones, and ensure that subscription queries are processed without impacting the system's responsiveness during high concurrency.",
    "function_signature": "public void manageSubscriptionLifecycle(ServerState serverState, SubscriptionRequest request, Blackhole blackhole)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.jsf.el.logger",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "field",
    "signature": "protected Log logger",
    "documentation": "\t/** Logger available to subclasses. */",
    "changetype": "stabilized",
    "source_code": "\tprotected final Log logger = LogFactory.getLog(getClass());",
    "query": "Enhance the base controller by overriding its method to log incoming requests and outgoing responses using the inherited logging facility.",
    "function_signature": "@Override\npublic Response processRequest(RequestData requestData);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.support.converter.MarshallingMessageConverter#marshalToMessage(object,session,marshaller,targetType)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "protected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)",
    "documentation": "\t/**\n\t * Template method that allows for custom message marshalling.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS session\n\t * @param marshaller the marshaller to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)",
    "query": "Design a method within your JMS messaging service that transforms complex Java objects into specialized JMS message types, ensuring the serialization process accommodates custom formats beyond standard text or byte messages.",
    "function_signature": "protected Message convertObjectToCustomMessage(Object payload, Session session, Marshaller marshaller, MessageType targetType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.ProxyFactoryBean#setAdvisorAdapterRegistry(advisorAdapterRegistry)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry)",
    "documentation": "\t/**\n\t * Specify the AdvisorAdapterRegistry to use.\n\t * Default is the global AdvisorAdapterRegistry.\n\t * @see org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) {\n\t\tthis.advisorAdapterRegistry = advisorAdapterRegistry;\n\t}",
    "query": "How can you customize the processing of AOP advisors in your Spring application to handle specialized adaptation logic?",
    "function_signature": "public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.KEY_TYPE_ATTRIBUTE",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "field",
    "signature": "public String KEY_TYPE_ATTRIBUTE",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static final String KEY_TYPE_ATTRIBUTE = \"key-type\";",
    "query": "Design a custom XML parser for Spring that allows developers to specify the type of keys used in a map property within bean definitions, ensuring type safety and reducing configuration errors.",
    "function_signature": "public void parseMapWithCustomKeyType(Element element, ParserContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletResponse#setOutputStreamAccessAllowed(outputStreamAccessAllowed)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "public void setOutputStreamAccessAllowed(boolean outputStreamAccessAllowed)",
    "documentation": "\t/**\n\t * Set whether {@link #getOutputStream()} access is allowed.\n\t * <p>Default is {@code true}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setOutputStreamAccessAllowed(boolean outputStreamAccessAllowed) {\n\t\tthis.outputStreamAccessAllowed = outputStreamAccessAllowed;\n\t}",
    "query": "Create a unit test for a Spring MVC controller that conditionally restricts access to the HTTP response's output stream based on specific criteria, ensuring that unauthorized access attempts are properly handled.",
    "function_signature": "public void configureResponseOutputStreamAccess(boolean outputStreamAccessAllowed)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.support.PeriodicTrigger#equals(other)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "public boolean equals(@Nullable Object other)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof PeriodicTrigger otherTrigger)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this.fixedRate == otherTrigger.fixedRate && this.initialDelay == otherTrigger.initialDelay &&\n\t\t\t\tthis.period == otherTrigger.period);\n\t}",
    "query": "Implement a component that manages periodic data synchronization tasks, ensuring that identical synchronization schedules are not registered multiple times.",
    "function_signature": "public boolean registerDataSyncTask(String taskName, long initialDelay, long syncInterval)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleMissingPathVariable(ex,headers,status,request)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "protected ResponseEntity<Object> handleMissingPathVariable(MissingPathVariableException ex, HttpHeaders headers, HttpStatus status, WebRequest request)",
    "documentation": "\t/**\n\t * Customize the response for MissingPathVariableException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} instance\n\t * @since 4.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingPathVariable(",
    "query": "In a RESTful service, ensure that clients receive a clear and structured error message when they omit a necessary path variable in their request URLs.",
    "function_signature": "protected ResponseEntity<Object> handleMissingPathVariable(MissingPathVariableException ex, HttpHeaders headers, HttpStatus status, WebRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.TOO_BIG_TO_PROCESS",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "field",
    "signature": "public CloseStatus TOO_BIG_TO_PROCESS",
    "documentation": "\t/**\n\t * \"1009 indicates that an endpoint is terminating the connection because it has\n\t * received a message that is too big for it to process.\"\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final CloseStatus TOO_BIG_TO_PROCESS = new CloseStatus(1009);",
    "query": "Design a WebSocket handler that gracefully closes client connections when incoming messages exceed the processing limit, ensuring the client is informed of the reason for termination.",
    "function_signature": "public CloseStatus handleMessageTooLarge(WebSocketSession session, WebSocketMessage<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,",
    "query": "Design a mechanism within your application that conditionally injects varying service implementations based on runtime criteria, ensuring accurate resolution among multiple candidates and supporting custom type conversions without manual bean specification.",
    "function_signature": "public Object injectConditionalService(DependencyDescriptor descriptor, @Nullable String requestingBean, @Nullable Set<String> candidateBeans, @Nullable TypeConverter converter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder#createServletRequest(servletContext)",
    "from_version": "v5.2.19.RELEASE",
    "to_version": "v6.0.0-M1",
    "type": "method",
    "signature": "protected MockHttpServletRequest createServletRequest(ServletContext servletContext)",
    "documentation": "\t/**\n\t * Create a new {@link MockMultipartHttpServletRequest} based on the\n\t * supplied {@code ServletContext} and the {@code MockMultipartFiles}\n\t * added to this builder.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected final MockHttpServletRequest createServletRequest(ServletContext servletContext) {\n\t\tMockMultipartHttpServletRequest request = new MockMultipartHttpServletRequest(servletContext);\n\t\tCharset defaultCharset = (request.getCharacterEncoding() != null ?\n\t\t\t\tCharset.forName(request.getCharacterEncoding()) : StandardCharsets.UTF_8);\n\n\t\tthis.files.forEach(request::addFile);\n\t\tthis.parts.values().stream().flatMap(Collection::stream).forEach(part -> {\n\t\t\trequest.addPart(part);\n\t\t\ttry {\n\t\t\t\tString name = part.getName();\n\t\t\t\tString filename = part.getSubmittedFileName();\n\t\t\t\tInputStream is = part.getInputStream();\n\t\t\t\tif (filename != null) {\n\t\t\t\t\trequest.addFile(new MockMultipartFile(name, filename, part.getContentType(), is));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInputStreamReader reader = new InputStreamReader(is, getCharsetOrDefault(part, defaultCharset));\n\t\t\t\t\tString value = FileCopyUtils.copyToString(reader);\n\t\t\t\t\trequest.addParameter(part.getName(), value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to read content for part \" + part.getName(), ex);\n\t\t\t}\n\t\t});\n\n\t\treturn request;\n\t}",
    "query": "How can you efficiently simulate a multipart file upload within your Spring MVC test environment, ensuring that both files and form parameters are accurately represented in the mock request?",
    "function_signature": "protected MockHttpServletRequest prepareMultipartRequest(ServletContext servletContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendPongMessage(message)",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "protected void sendPongMessage(PongMessage message)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void sendPongMessage(PongMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPong(message.getPayload(), callback));\n\t}",
    "query": "Implement a WebSocket endpoint that automatically responds to incoming ping messages with appropriate pong replies to ensure the connection remains active.",
    "function_signature": "protected void respondWithPong(PongMessage message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.NameResolver",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "interface",
    "signature": "public interface NameResolver",
    "documentation": "\t/**\n\t * Strategy to determine the name of the value to bind to a method parameter.\n\t * Supported on constructor parameters with {@link #construct constructor\n\t * binding} which performs lookups via {@link ValueResolver#resolveValue}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic interface NameResolver {\n\n\t\t/**\n\t\t * Return the name to use for the given method parameter, or {@code null}\n\t\t * if unresolved. For constructor parameters, the name is determined via\n\t\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} if\n\t\t * unresolved.\n\t\t */\n\t\t@Nullable\n\t\tString resolveName(MethodParameter parameter);\n\n\t}",
    "query": "Design a feature that dynamically determines the appropriate names for constructor parameters to enable flexible binding of external data sources, particularly when parameter names are not explicitly defined or are obfuscated.",
    "function_signature": "public void bindParameters(Object target, MethodParameter parameter, ParameterNameResolver resolver)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#read()",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "public byte read()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic byte read() {\n\t\t\treturn this.delegate.read();\n\t\t}",
    "query": "Design a Spring reactive service that processes incoming HTTP responses at the byte level, enabling fine-grained handling of binary data streams for real-time applications.",
    "function_signature": "public byte readByteStream()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setPhase(phase)",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "public void setPhase(int phase)",
    "documentation": "\t/**\n\t * Specify the lifecycle phase for pausing and resuming this executor.\n\t * The default is {@link #DEFAULT_PHASE}.\n\t * @since 6.1\n\t * @see SmartLifecycle#getPhase()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setPhase(int phase) {\n\t\tthis.phase = phase;\n\t}",
    "query": "Design a component that manages a thread pool executor, ensuring it pauses and resumes operations in coordination with other lifecycle-managed beans during application startup and shutdown. The executor should participate in the application's lifecycle phases to maintain proper initialization and termination order.",
    "function_signature": "public void configureExecutorLifecycle(int lifecyclePhase);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty4HeadersAdapter#putAll(String,map)",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this.headers::set);\n\t}",
    "query": "Create a Spring service method that efficiently updates multiple HTTP headers for a response using a provided map of header names to their corresponding values.",
    "function_signature": "public void addAllResponseHeaders(Map<String, List<String>> headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.DataBinder#construct(valueResolver)",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "public void construct(ValueResolver valueResolver)",
    "documentation": "\t/**\n\t * Create the target with constructor injection of values. It is expected that\n\t * {@link #setTargetType(ResolvableType)} was previously called and that\n\t * {@link #getTarget()} is {@code null}.\n\t * <p>Uses a public, no-arg constructor if available in the target object type,\n\t * also supporting a \"primary constructor\" approach for data classes as follows:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as\n\t * well as runtime-retained parameter names in the bytecode, associating\n\t * input values with constructor arguments by name. If no such constructor is\n\t * found, the default constructor will be used (even if not public), assuming\n\t * subsequent bean property bindings through setter methods.\n\t * <p>After the call, use {@link #getBindingResult()} to check for failures\n\t * to bind to, and/or validate constructor arguments. If there are no errors,\n\t * the target is set, and {@link #doBind(MutablePropertyValues)} can be used\n\t * for further initialization via setters.\n\t * @param valueResolver to resolve constructor argument values with\n\t * @throws BeanInstantiationException in case of constructor failure\n\t * @since 6.1\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final void construct(ValueResolver valueResolver) {\n\t\tAssert.state(this.target == null, \"Target instance already available\");\n\t\tAssert.state(this.targetType != null, \"Target type not set\");\n\n\t\tthis.target = createObject(this.targetType, \"\", valueResolver);\n\n\t\tif (!getBindingResult().hasErrors()) {\n\t\t\tthis.bindingResult = null;\n\t\t\tif (this.typeConverter != null) {\n\t\t\t\tthis.typeConverter.registerCustomEditors(getPropertyAccessor());\n\t\t\t}\n\t\t}\n\t}",
    "query": "Develop a method that initializes a domain object by injecting its dependencies through its constructor, ensuring that constructor parameters are resolved by name and handling any binding validation errors effectively.",
    "function_signature": "public void initializeDomainObject(ValueResolver resolver);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.ModuleResource#hashCode()",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\treturn this.module.hashCode() * 31 + this.path.hashCode();\n\t}",
    "query": "Implement a service that assigns unique hash values to module resources to enable efficient lookup and comparison within hash-based collections.",
    "function_signature": "public int assignResourceHashCode(Resource resource)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession#sendPingMessage(message)",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "protected void sendPingMessage(PingMessage message)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void sendPingMessage(PingMessage message) throws IOException {\n\t\tuseSession((session, callback) -> session.sendPing(message.getPayload(), callback));\n\t}",
    "query": "Design a WebSocket service that maintains active connections by periodically verifying their health. Implement a method responsible for sending periodic signals to ensure clients are still connected and responsive.",
    "function_signature": "public void initiateConnectionHeartbeat(PingMessage heartbeatMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.interceptor.PLACEHOLDER_TARGET_CLASS_NAME",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "field",
    "signature": "public String PLACEHOLDER_TARGET_CLASS_NAME",
    "documentation": "\t/**\n\t * The {@code $[targetClassName]} placeholder.\n\t * Replaced with the fully-qualified name of the {@code Class}\n\t * of the method invocation target.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static final String PLACEHOLDER_TARGET_CLASS_NAME = \"$[targetClassName]\";",
    "query": "Design a service that automatically injects the fully-qualified name of the class handling a request into log messages, ensuring that each log entry clearly identifies its originating class without manual intervention.",
    "function_signature": "public void configureClassNameInjector(Logger logger)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.simple.<unknown>#query(mappedClass)",
    "from_version": "v6.0.12",
    "to_version": "v6.1.0-M5",
    "type": "method",
    "signature": "public MappedQuerySpec<T> query(Class<T> mappedClass)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic <T> MappedQuerySpec<T> query(Class<T> mappedClass) {\n\t\t\tRowMapper<?> rowMapper = rowMapperCache.computeIfAbsent(mappedClass, key ->\n\t\t\t\t\tBeanUtils.isSimpleProperty(mappedClass) ? new SingleColumnRowMapper<>(mappedClass) :\n\t\t\t\t\t\t\tnew SimplePropertyRowMapper<>(mappedClass));\n\t\t\treturn query((RowMapper<T>) rowMapper);\n\t\t}",
    "query": "Design a repository method that efficiently retrieves records from a database and maps each row to a specified domain model. Ensure that the method can seamlessly handle both simple scalar types and complex objects without manual mapper configuration.",
    "function_signature": "public <T> MappedQuerySpec<T> fetchEntities(Class<T> entityType);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.messaging.WebSocketStompClient#setOutboundMessageSizeLimit(outboundMessageSizeLimit)",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit)",
    "documentation": "\t/**\n\t * Configure the maximum size allowed for outbound STOMP message.\n\t * If STOMP message's size exceeds {@link WebSocketStompClient#outboundMessageSizeLimit},\n\t * STOMP message is split into multiple frames.\n\t * <p>By default this is not set in which case each STOMP message are not split.\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setOutboundMessageSizeLimit(Integer outboundMessageSizeLimit) {\n\t\tthis.outboundMessageSizeLimit = outboundMessageSizeLimit;\n\t}",
    "query": "How can a financial trading platform efficiently manage and transmit large volumes of real-time transaction data without overloading the network or clients?",
    "function_signature": "public void configureTransactionDataSizeLimit(Integer maxDataSize)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.WebHttpHandlerBuilder#hasSessionManager()",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public boolean hasSessionManager()",
    "documentation": "\t/**\n\t * Whether a {@code WebSessionManager} is configured or not, either detected from an\n\t * {@code ApplicationContext} or explicitly configured via {@link #sessionManager}.\n\t * @since 5.0.9\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean hasSessionManager() {\n\t\treturn (this.sessionManager != null);\n\t}",
    "query": "Design a mechanism to verify the presence and configuration of session management in your web application, ensuring optimal performance and enhanced security without relying on outdated verification techniques.",
    "function_signature": "public void ensureOptimalSessionManagement(Configuration config)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#remove(key)",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public V remove(Object key)",
    "documentation": null,
    "changetype": "signature",
    "source_code": "\tpublic V remove(Object key) {\n\t\treturn adaptValue(this.targetMap.remove(key));\n\t}",
    "query": "Create a service that manages user preferences stored in a centralized repository. When a user opts to delete a specific preference, ensure that the removal process efficiently handles the underlying data transformation and resource cleanup.",
    "function_signature": "public V deleteUserPreference(Object preferenceKey)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#value()",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public int value()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int value() {\n\t\t\treturn this.port;\n\t\t}",
    "query": "Implement a component that dynamically retrieves the active server port to configure dependent services at runtime.",
    "function_signature": "public int retrieveActivePort()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#connect(method,uri,ClientHttpRequest,requestCallback)",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,",
    "query": "Enhance the reactive HTTP client setup to leverage improved request configuration mechanisms, ensuring better performance and streamlined request handling.",
    "function_signature": "public Mono<ClientHttpResponse> initiateConnection(HttpMethod method, URI uri,\n        Consumer<? super ClientHttpRequest> requestCustomizer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.<unknown>#setEnvironment(environment)",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public void setEnvironment(Environment environment)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setEnvironment(Environment environment) {\n\t\tif (!(environment instanceof ConfigurableEnvironment configurableEnvironment)) {\n\t\t\tthrow new IllegalArgumentException(\"Environment must be a ConfigurableEnvironment\");\n\t\t}\n\t\tthis.environment = configurableEnvironment;\n\t}",
    "query": "Design a test configuration that allows injecting custom property sources into the application context before any test executes, ensuring that these properties can be modified programmatically during test setup.",
    "function_signature": "public void configureCustomTestEnvironment(Environment environment)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.<unknown>#getOrder()",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public int getOrder()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int getOrder() {\n\t\t\treturn Ordered.HIGHEST_PRECEDENCE;\n\t\t}",
    "query": "Design a testing component that prioritizes certain bean overrides to ensure they are applied before others during the Spring application context initialization.",
    "function_signature": "public int getOrder();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.config.JmsListenerEndpointRegistrar#setContainerFactoryBeanName(containerFactoryBeanName)",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public void setContainerFactoryBeanName(String containerFactoryBeanName)",
    "documentation": "\t/**\n\t * Set the bean name of the {@link JmsListenerContainerFactory} to use in case\n\t * a {@link JmsListenerEndpoint} is registered with a {@code null} container factory.\n\t * Alternatively, the container factory instance can be registered directly:\n\t * see {@link #setContainerFactory(JmsListenerContainerFactory)}.\n\t * @see #setBeanFactory\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setContainerFactoryBeanName(String containerFactoryBeanName) {\n\t\tthis.containerFactoryBeanName = containerFactoryBeanName;\n\t}",
    "query": "Enhance the JMS listener configuration by specifying a dedicated container factory instance to improve type safety and optimize resource management.",
    "function_signature": "public void configureContainerFactory(JmsListenerContainerFactory containerFactory)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.io.buffer.JettyDataBuffer#toString()",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn String.format(\"JettyDataBuffer (r: %d, w: %d, c: %d)\",\n\t\t\t\treadPosition(), writePosition(), capacity());\n\t}",
    "query": "Develop a monitoring tool that captures and logs the current state of data buffers in real-time, providing insights into read and write positions as well as buffer capacity during high-load operations.",
    "function_signature": "public String captureBufferState(DataBuffer buffer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper",
    "from_version": "v6.1.13",
    "to_version": "v6.2.0-RC1",
    "type": "class",
    "signature": "public class ReflectionHelper",
    "documentation": "/**\n * Utility methods used by the reflection resolver code to discover the appropriate\n * methods/constructors and fields that should be used in expressions.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public abstract class ReflectionHelper {\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>The supplied type converter allows for matches to take into account that a type\n\t * may be transformed into a different type by the converter.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return an {@code ArgumentsMatchInfo} object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArguments(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),\n\t\t\t\t\"Expected argument types and supplied argument types should be lists of the same size\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\t\tfor (int i = 0; i < expectedArgTypes.size() && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\t// The user may supply null - and that will be ok unless a primitive is expected\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!expectedArg.equals(suppliedArg)) {\n\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */\n\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>The supplied type converter allows for matches to take into account that a type\n\t * may be transformed into a different type by the converter.\n\t * <p>This variant of {@link #compareArguments(List, List, TypeConverter)} also allows\n\t * for a varargs match.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return an {@code ArgumentsMatchInfo} object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArgumentsVarargs(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),\n\t\t\t\t\"Expected arguments must at least include one array (the varargs parameter)\");\n\t\tAssert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),\n\t\t\t\t\"Final expected argument should be array type (the varargs parameter)\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\n\t\t// Check up until the varargs argument:\n\n\t\t// Deal with the arguments up to 'expected number' - 1 (that is everything but the varargs argument)\n\t\tint argCountUpToVarargs = expectedArgTypes.size() - 1;\n\t\tfor (int i = 0; i < argCountUpToVarargs && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!expectedArg.equals(suppliedArg)) {\n\t\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If already confirmed it cannot be a match, then return\n\t\tif (match == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (suppliedArgTypes.size() == expectedArgTypes.size() &&\n\t\t\t\texpectedArgTypes.get(expectedArgTypes.size() - 1).equals(\n\t\t\t\t\t\tsuppliedArgTypes.get(suppliedArgTypes.size() - 1))) {\n\t\t\t// Special case: there is one parameter left and it is an array and it matches the varargs\n\t\t\t// expected argument - that is a match, the caller has already built the array. Proceed with it.\n\t\t}\n\t\telse {\n\t\t\t// Now... we have the final argument in the method we are checking as a match and we have 0\n\t\t\t// or more other arguments left to pass to it.\n\t\t\tTypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1);\n\t\t\tTypeDescriptor componentTypeDesc = varargsDesc.getElementTypeDescriptor();\n\t\t\tAssert.state(componentTypeDesc != null, \"Component type must not be null for a varargs array\");\n\t\t\tClass<?> varargsComponentType = componentTypeDesc.getType();\n\n\t\t\t// All remaining parameters must be of this type or convertible to this type\n\t\t\tfor (int i = expectedArgTypes.size() - 1; i < suppliedArgTypes.size(); i++) {\n\t\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\t\tif (suppliedArg == null) {\n\t\t\t\t\tif (varargsComponentType.isPrimitive()) {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (varargsComponentType != suppliedArg.getType()) {\n\t\t\t\t\t\tif (ClassUtils.isAssignable(varargsComponentType, suppliedArg.getType())) {\n\t\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsComponentType))) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link Method}.\n\t * <p>If the supplied method is a varargs method, the final parameter type must be an\n\t * array whose component type should be used as the conversion target for extraneous\n\t * arguments. For example, if the parameter types are <code>{Integer, String[]}</code>\n\t * and the input arguments are <code>{Integer, boolean, float}</code>, then both the\n\t * {@code boolean} and the {@code float} must be converted to strings.\n\t * <p>This method does <strong>not</strong> repackage the arguments into a form suitable\n\t * for the varargs invocation: a subsequent call to\n\t * {@link #setupArgumentsForVarargsInvocation(Class[], Object...)} is required for that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param method the target {@code Method}\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws SpelEvaluationException if a problem occurs during conversion\n\t */\n\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n\t\t\tthrows SpelEvaluationException {\n\n\t\tInteger varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null);\n\t\treturn convertArguments(converter, arguments, method, varargsPosition);\n\t}\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link Executable}, taking the varargs position into account.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param executable the target {@code Method} or {@code Constructor}\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t */\n\tstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,\n\t\t\t@Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition);\n\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam);\n\t\t\tTypeDescriptor componentTypeDesc = targetType.getElementTypeDescriptor();\n\t\t\tAssert.state(componentTypeDesc != null, \"Component type must not be null for a varargs array\");\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (componentTypeDesc.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is assignable to the varargs component type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to convert\n\t\t\t\t// a String containing a comma would result in the String being split and repackaged in an\n\t\t\t\t// array when it should be used as-is. Similarly, if the argument is an array that is\n\t\t\t\t// assignable to the varargs array type, there is no need to convert it. However, if the\n\t\t\t\t// argument is a java.util.List, we let the TypeConverter convert the list to an array.\n\t\t\t\telse if (!sourceType.isAssignableTo(componentTypeDesc) ||\n\t\t\t\t\t\t(sourceType.isArray() && !sourceType.isAssignableTo(targetType)) ||\n\t\t\t\t\t\t(argument instanceof List)) {\n\n\t\t\t\t\tTypeDescriptor targetTypeToUse =\n\t\t\t\t\t\t\t(sourceType.isArray() || argument instanceof List ? targetType : componentTypeDesc);\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetTypeToUse);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs component type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was the correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs component type.\n\t\t\telse {\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, componentTypeDesc);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link MethodHandle}, taking the varargs position into account.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param methodHandle the target {@code MethodHandle}\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */\n\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tMethodType methodHandleType = methodHandle.type();\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleType.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleType.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tClass<?> varargsArrayClass = methodHandleType.lastParameterType();\n\t\t\t// We use the wrapper type for a primitive varargs array, since we eventually\n\t\t\t// need an Object array in order to invoke the MethodHandle in\n\t\t\t// FunctionReference#executeFunctionViaMethodHandle().\n\t\t\tClass<?> varargsComponentClass = ClassUtils.resolvePrimitiveIfNecessary(varargsArrayClass.componentType());\n\t\t\tTypeDescriptor varargsArrayType = TypeDescriptor.array(TypeDescriptor.valueOf(varargsComponentClass));\n\t\t\tAssert.state(varargsArrayType != null, \"Array type must not be null for a varargs array\");\n\t\t\tTypeDescriptor varargsComponentType = varargsArrayType.getElementTypeDescriptor();\n\t\t\tAssert.state(varargsComponentType != null, \"Component type must not be null for a varargs array\");\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (varargsComponentType.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is assignable to the varargs component type, there is no need to\n\t\t\t\t// convert it. For example, using StringToArrayConverter to convert a String containing a\n\t\t\t\t// comma would result in the String being split and repackaged in an array when it should\n\t\t\t\t// be used as-is. Similarly, if the argument is an array that is assignable to the varargs\n\t\t\t\t// array type, there is no need to convert it. However, if the argument is a java.util.List,\n\t\t\t\t// we let the TypeConverter convert the list to an array.\n\t\t\t\telse if (!sourceType.isAssignableTo(varargsComponentType) ||\n\t\t\t\t\t\t(sourceType.isArray() && !sourceType.isAssignableTo(varargsArrayType)) ||\n\t\t\t\t\t\t(argument instanceof List)) {\n\n\t\t\t\t\tTypeDescriptor targetTypeToUse =\n\t\t\t\t\t\t\t(sourceType.isArray() || argument instanceof List ? varargsArrayType : varargsComponentType);\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetTypeToUse);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs component type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was the correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., an Object array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted as explained in the comments above.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs component type.\n\t\t\telse {\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, varargsComponentType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Check if the supplied value is the first entry in the array represented by the possibleArray value.\n\t * @param value the value to check for in the array\n\t * @param possibleArray an array object that may have the supplied value as the first element\n\t * @return true if the supplied value is the first entry in the array\n\t */\n\tprivate static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {\n\t\tif (possibleArray == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = possibleArray.getClass();\n\t\tif (!type.isArray() || Array.getLength(possibleArray) == 0 ||\n\t\t\t\t!ClassUtils.isAssignableValue(type.componentType(), value)) {\n\t\t\treturn false;\n\t\t}\n\t\tObject arrayValue = Array.get(possibleArray, 0);\n\t\treturn (type.componentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value);\n\t}\n\n\t/**\n\t * Package up the supplied {@code args} so that they correctly match what is\n\t * expected in {@code requiredParameterTypes}.\n\t * <p>For example, if {@code requiredParameterTypes} is {@code (int, String[])}\n\t * because the second parameter was declared as {@code String...}, then if\n\t * {@code args} is {@code [1, \"a\", \"b\"]} it must be repackaged as\n\t * {@code [1, new String[] {\"a\", \"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be set up for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been performed\n\t */\n\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\tAssert.notEmpty(requiredParameterTypes, \"Required parameter types array must not be empty\");\n\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tClass<?> lastRequiredParameterType = requiredParameterTypes[parameterCount - 1];\n\t\tAssert.isTrue(lastRequiredParameterType.isArray(),\n\t\t\t\t\"The last required parameter type must be an array to support varargs invocation\");\n\n\t\tint argumentCount = args.length;\n\t\tObject lastArgument = (argumentCount > 0 ? args[argumentCount - 1] : null);\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != argumentCount || !lastRequiredParameterType.isInstance(lastArgument)) {\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = lastRequiredParameterType.componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\n\t\treturn args;\n\t}\n\n\n\t/**\n\t * Arguments match kinds.\n\t */\n\tenum ArgumentsMatchKind {\n\n\t\t/** An exact match is where the parameter types exactly match what the method/constructor is expecting. */\n\t\tEXACT,\n\n\t\t/** A close match is where the parameter types either exactly match or are assignment-compatible. */\n\t\tCLOSE,\n\n\t\t/** A conversion match is where the type converter must be used to transform some of the parameter types. */\n\t\tREQUIRES_CONVERSION\n\t}\n\n\n\t/**\n\t * An instance of {@code ArgumentsMatchInfo} describes what kind of match was achieved\n\t * between two sets of arguments - the set that a method/constructor is expecting\n\t * and the set that is being supplied at the point of invocation.\n\t *\n\t * @param kind the kind of match that was achieved\n\t */\n\trecord ArgumentsMatchInfo(ArgumentsMatchKind kind) {\n\n\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}\n\n\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}\n\n\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ArgumentsMatchInfo: \" + this.kind;\n\t\t}\n\t}\n\n}",
    "query": "Implement a utility method that efficiently matches and converts method arguments using Spring's advanced type conversion framework, ensuring enhanced performance and type safety in expression evaluations.",
    "function_signature": "public static ArgumentsMatchInfo evaluateArgumentsMatch(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> providedArgTypes, TypeConverter typeConverter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setPathMatcher(pathMatcher)",
    "from_version": "v5.2.0.M2",
    "to_version": "v5.2.0.M3",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Set the PathMatcher implementation to use for matching destinations\n\t * against configured destination patterns.\n\t * <p>By default, {@link AntPathMatcher} is used with separator set to \".\".\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tAssert.notNull(pathMatcher, \"PathMatcher must not be null\");\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Enhance your message handling setup by configuring a more efficient and thread-safe strategy for destination pattern matching, thereby improving overall performance and maintainability.",
    "function_signature": "public void configureDestinationPatternMatching(DestinationPatternConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#getPathMatcher()",
    "from_version": "v5.2.0.M2",
    "to_version": "v5.2.0.M3",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * Return the PathMatcher implementation to use for matching destinations.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design a message handler that utilizes an optimized pattern matching mechanism to improve destination matching performance and enhance overall usability.",
    "function_signature": "public PatternMatcher getDestinationMatcher()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#getDestination(message)",
    "from_version": "v5.2.0.M2",
    "to_version": "v5.2.0.M3",
    "type": "method",
    "signature": "protected String getDestination(Message<?> message)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tprotected String getDestination(Message<?> message) {\n\t\treturn (String) message.getHeaders().get(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER);\n\t}",
    "query": "Design a method to efficiently determine the messaging destination from a given message object, enhancing type safety and performance compared to previous retrieval techniques.",
    "function_signature": "protected String resolveDestination(Message<?> message)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#setRouteMatcher(routeMatcher)",
    "from_version": "v5.2.0.M2",
    "to_version": "v5.2.0.M3",
    "type": "method",
    "signature": "public void setRouteMatcher(RouteMatcher routeMatcher)",
    "documentation": "\t/**\n\t * Set the {@code RouteMatcher} to use for mapping messages to handlers\n\t * based on the route patterns they're configured with.\n\t * <p>By default, {@link SimpleRouteMatcher} is used, backed by\n\t * {@link AntPathMatcher} with \".\" as separator. For greater\n\t * efficiency consider using the {@code PathPatternRouteMatcher} from\n\t * {@code spring-web} instead.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setRouteMatcher(RouteMatcher routeMatcher) {\n\t\tAssert.notNull(routeMatcher, \"RouteMatcher must not be null\");\n\t\tthis.routeMatcher = routeMatcher;\n\t}",
    "query": "Enhance your reactive messaging application to efficiently handle a large number of complex route patterns, ensuring high performance and scalability.",
    "function_signature": "public void configureHighPerformanceRouteMatcher(RouteMatcher routeMatcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#getRouteMatcher()",
    "from_version": "v5.2.0.M2",
    "to_version": "v5.2.0.M3",
    "type": "method",
    "signature": "public RouteMatcher getRouteMatcher()",
    "documentation": "\t/**\n\t * Return the {@code RouteMatcher} used to map messages to handlers.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic RouteMatcher getRouteMatcher() {\n\t\treturn this.routeMatcher;\n\t}",
    "query": "Develop a reactive messaging component that dynamically directs incoming messages to the appropriate handlers based on customizable routing rules.",
    "function_signature": "public Mono<Void> dispatchReactiveMessages()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.ServerState",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "class",
    "signature": "public class ServerState",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}",
    "query": "Design a component that efficiently handles active user sessions and manages destination subscriptions, ensuring thread safety and optimal resource utilization in your messaging infrastructure.",
    "function_signature": "public void setupOptimizedSubscriptionRegistry(SubscriptionRegistryConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PathPattern[] includePatterns;\n\n\t@Nullable\n\tprivate final PathPattern[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\t@Nullable\n\tprivate static PathPattern[] initPatterns(\n\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\treturn null;\n\t\t}\n\t\tparser = (parser != null ? parser : PathPatternParser.defaultInstance);\n\t\treturn Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchPattern(Object path, boolean isPathContainer, PathPattern pattern) {\n\t\treturn (isPathContainer ?\n\t\t\t\tpattern.matches((PathContainer) path) :\n\t\t\t\tthis.pathMatcher.match(pattern.getPatternString(), (String) path));\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n}",
    "query": "Enhance your application's request handling by configuring an interceptor that selectively applies to specific URL patterns, ensuring optimal performance and maintainability.",
    "function_signature": "public void configureCustomInterceptors(InterceptorRegistry registry) {\n    // Implementation here\n}"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Enhance your interceptor configuration by adopting a more robust retrieval approach to improve thread safety and maintainability within your Spring application.",
    "function_signature": "public Optional<HandlerInterceptor> fetchInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Implement a method responsible for post-processing HTTP requests and responses, ensuring enhanced performance and thread safety compared to previous approaches.",
    "function_signature": "public void afterRequestProcessing(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Design a component that efficiently handles client subscriptions, ensuring scalability and thread safety without relying on direct field access.",
    "function_signature": "public SubscriptionRegistry obtainSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Optimize interceptor configuration by adopting pattern objects to enhance matching performance and type safety.",
    "function_signature": "public PathPattern[] getPathPatternMatchers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Optimize the message broker configuration to enhance performance and ensure thread safety. Refactor the existing setup to utilize the latest recommended practices for managing destination counts.",
    "function_signature": "public void configureMessageBrokerWithOptimizedDestinations()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a request interceptor that efficiently determines its applicability by leveraging the latest path resolution techniques, ensuring improved performance and enhanced safety.",
    "function_signature": "public boolean isApplicable(PathResolvedRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a callback mechanism to execute custom logic after processing HTTP requests, ensuring improved performance and enhanced error handling.",
    "function_signature": "public void onRequestCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Throwable exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.0-RC2",
    "to_version": "v5.2.10.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Refactor the message broker configuration to utilize the latest destination prefix handling for improved flexibility and performance.",
    "function_signature": "public void setDestinationPrefixes(String... prefixes)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.util.TestContextResourceUtils#convertToClasspathResourcePaths(clazz,preservePlaceholders,paths)",
    "from_version": "v5.2.0.RC1",
    "to_version": "v5.2.0.RC2",
    "type": "method",
    "signature": "public String[] convertToClasspathResourcePaths(Class<?> clazz, boolean preservePlaceholders, String... paths)",
    "documentation": "\t/**\n\t * Convert the supplied paths to classpath resource paths.\n\t *\n\t * <p>For each of the supplied paths:\n\t * <ul>\n\t * <li>A plain path &mdash; for example, {@code \"context.xml\"} &mdash; will\n\t * be treated as a classpath resource that is relative to the package in\n\t * which the specified class is defined. Such a path will be prepended with\n\t * the {@code classpath:} prefix and the path to the package for the class.\n\t * <li>A path starting with a slash will be treated as an absolute path\n\t * within the classpath, for example: {@code \"/org/example/schema.sql\"}.\n\t * Such a path will be prepended with the {@code classpath:} prefix.\n\t * <li>A path which is already prefixed with a URL protocol (e.g.,\n\t * {@code classpath:}, {@code file:}, {@code http:}, etc.) will not have its\n\t * protocol modified.\n\t * </ul>\n\t * <p>Each path will then be {@linkplain StringUtils#cleanPath cleaned},\n\t * unless the {@code preservePlaceholders} flag is {@code true} and the path\n\t * contains one or more placeholders in the form <code>${placeholder.name}</code>.\n\t * @param clazz the class with which the paths are associated\n\t * @param preservePlaceholders {@code true} if placeholders should be preserved\n\t * @param paths the paths to be converted\n\t * @return a new array of converted resource paths\n\t * @since 5.2\n\t * @see #convertToResources\n\t * @see ResourceUtils#CLASSPATH_URL_PREFIX\n\t * @see ResourceUtils#FILE_URL_PREFIX\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static String[] convertToClasspathResourcePaths(Class<?> clazz, boolean preservePlaceholders, String... paths) {\n\t\tString[] convertedPaths = new String[paths.length];\n\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\tString path = paths[i];\n\n\t\t\t// Absolute path\n\t\t\tif (path.startsWith(SLASH)) {\n\t\t\t\tconvertedPaths[i] = ResourceUtils.CLASSPATH_URL_PREFIX + path;\n\t\t\t}\n\t\t\t// Relative path\n\t\t\telse if (!ResourcePatternUtils.isUrl(path)) {\n\t\t\t\tconvertedPaths[i] = ResourceUtils.CLASSPATH_URL_PREFIX + SLASH +\n\t\t\t\t\t\tClassUtils.classPackageAsResourcePath(clazz) + SLASH + path;\n\t\t\t}\n\t\t\t// URL\n\t\t\telse {\n\t\t\t\tconvertedPaths[i] = path;\n\t\t\t}\n\n\t\t\tif (!(preservePlaceholders && PLACEHOLDER_PATTERN.matcher(convertedPaths[i]).matches())) {\n\t\t\t\tconvertedPaths[i] = StringUtils.cleanPath(convertedPaths[i]);\n\t\t\t}\n\t\t}\n\t\treturn convertedPaths;\n\t}",
    "query": "Design a Spring-based testing utility that processes a variety of resource file paths for a given test class. The utility should handle absolute paths, relative paths based on the test class's package, and paths already prefixed with a URL protocol. Additionally, it should offer the option to retain placeholder variables within the paths without altering them.\n\nImplement a method that accepts the test class, a flag indicating whether to preserve placeholders, and a list of resource paths. The method should return the processed classpath resource paths accordingly.",
    "function_signature": "public String[] prepareTestResourcePaths(Class<?> testClass, boolean retainPlaceholders, String... resourcePaths)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#toByteBuffer(index,length)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}",
    "query": "Create a reactive Spring service that handles streaming HTTP responses and efficiently extracts a specific segment of bytes for real-time data processing.",
    "function_signature": "public ByteBuffer extractSegment(int index, int length)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.support.CronTrigger#resumeFixedExecution(expression,resumptionTimestamp)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public CronTrigger resumeFixedExecution(String expression, Instant resumptionTimestamp)",
    "documentation": "\t/**\n\t * Create a {@link CronTrigger} for fixed execution, to be rescheduled\n\t * after every task based on the last scheduled time.\n\t * <p>This variant makes up for missed trigger firings if the associated task\n\t * has taken too long, scheduling a task for every original trigger firing.\n\t * Such follow-up tasks may execute late but will never be skipped.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param resumptionTimestamp the timestamp to resume from (the last-known\n\t * scheduled timestamp), with every trigger in-between immediately firing\n\t * to make up for every execution that would have happened in the meantime\n\t * @since 6.1.3\n\t * @see #forFixedExecution\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static CronTrigger resumeFixedExecution(String expression, Instant resumptionTimestamp) {\n\t\treturn new CronTrigger(expression) {\n\t\t\t@Override\n\t\t\tprotected Instant determineLatestTimestamp(TriggerContext triggerContext) {\n\t\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\t\treturn (scheduled != null ? scheduled : super.determineLatestTimestamp(triggerContext));\n\t\t\t}\n\t\t\t@Override\n\t\t\tInstant determineInitialTimestamp(TriggerContext triggerContext) {\n\t\t\t\treturn resumptionTimestamp;\n\t\t\t}\n\t\t};\n\t}",
    "query": "Implement a scheduler that, upon recovery from downtime, replays all missed executions based on a predefined cron schedule starting from the last known execution time.",
    "function_signature": "public CronTrigger resumeTaskSchedule(String cronExpression, Instant lastExecutionTimestamp)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty5HeadersAdapter#setValue(value)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public List<String> setValue(List<String> value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tList<String> previousValues = getValue();\n\t\t\theaders.set(this.key, value);\n\t\t\treturn previousValues;\n\t\t}",
    "query": "Implement a feature that updates all entries of a specific HTTP header with a new collection of values, ensuring that the previous set of values is returned for auditing or logging purposes.",
    "function_signature": "public List<String> updateHttpHeaderValues(String headerName, List<String> newValues)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.<unknown>#uri(Function<UriBuilder,uriFunction)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.builder()));\n\t\t}",
    "query": "Implement a service method that interacts with an external payment gateway, allowing dynamic construction of request URIs based on varying transaction parameters to ensure flexibility and maintainability.",
    "function_signature": "public RequestBodySpec configurePaymentEndpoint(Function<UriBuilder, URI> uriCustomizer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#validateIfApplicable(binder,parameter)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "documentation": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}",
    "query": "Optimize the validation process for model attributes by implementing the recommended validation technique, ensuring better performance and scalability.",
    "function_signature": "protected void optimizeModelValidation(WebDataBinder binder, MethodParameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.ast.Selection#isNullSafe()",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public boolean isNullSafe()",
    "documentation": "\t/**\n\t * Does this node represent a null-safe selection operation?\n\t * @since 6.1.6\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final boolean isNullSafe() {\n\t\treturn this.nullSafe;\n\t}",
    "query": "Develop a component that processes dynamic expressions to safely navigate nested properties without throwing exceptions when encountering null references.",
    "function_signature": "public EvaluationResult processSafelyNavigatedExpression(String expression, EvaluationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#convertToReference(character)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public String convertToReference(char character)",
    "documentation": "\t/**\n\t * Return the reference mapped to the given character, or {@code null} if none found.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String convertToReference(char character) {\n\t\treturn convertToReference(character, WebUtils.DEFAULT_CHARACTER_ENCODING);\n\t}",
    "query": "Create a utility method that accepts a single character and returns its corresponding HTML entity reference when applicable. Ensure that the method gracefully handles characters without predefined references.",
    "function_signature": "public String resolveHtmlEntity(char character)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.support.Netty5HeadersAdapter#values()",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "public Collection<List<String>> values()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Collection<List<String>> values() {\n\t\tList<List<String>> result = new ArrayList<>(this.headers.size());\n\t\tforEach((key, value) -> result.add(value));\n\t\treturn result;\n\t}",
    "query": "Create a feature that aggregates every value for each HTTP header in incoming requests to perform comprehensive analytics. The solution should efficiently handle headers with multiple entries, ensuring that no values are omitted during the aggregation process.",
    "function_signature": "public Collection<List<String>> aggregateHeaderValues(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.codec.xml.Jaxb2XmlEncoder#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "method",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,",
    "query": "Create a reactive service method that serializes a given object into XML format and streams the resulting data buffers to the client, ensuring compatibility with various MIME types and supporting additional serialization hints.",
    "function_signature": "protected Flux<DataBuffer> serializeToXml(Object payload, DataBufferFactory bufferFactory, ResolvableType targetType, @Nullable MimeType mimeType, @Nullable Map<String, Object> serializationHints)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.NameResolver",
    "from_version": "v6.0.21",
    "to_version": "v6.1.8",
    "type": "interface",
    "signature": "public interface NameResolver",
    "documentation": "\t/**\n\t * Strategy to determine the name of the value to bind to a method parameter.\n\t * Supported on constructor parameters with {@link #construct constructor binding}\n\t * which performs lookups via {@link ValueResolver#resolveValue}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic interface NameResolver {\n\n\t\t/**\n\t\t * Return the name to use for the given method parameter, or {@code null}\n\t\t * if unresolved. For constructor parameters, the name is determined via\n\t\t * {@link org.springframework.core.DefaultParameterNameDiscoverer} if unresolved.\n\t\t */\n\t\t@Nullable\n\t\tString resolveName(MethodParameter parameter);\n\t}",
    "query": "Develop a component that dynamically assigns binding names to constructor parameters during dependency injection, ensuring accurate parameter mapping even when explicit names aren't provided.",
    "function_signature": "public String resolveParameterName(MethodParameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor#getParameterName()",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public String getParameterName()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String getParameterName() {\n\t\t\treturn this.parameterName;\n\t\t}",
    "query": "Create a utility that efficiently determines the identifier associated with a model attribute in a Spring MVC controller, enhancing type safety and performance.",
    "function_signature": "public String resolveAttributeIdentifier(MethodParameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.JettyHeadersAdapter",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "class",
    "signature": "public class JettyHeadersAdapter",
    "documentation": "/**\n * {@code MultiValueMap} implementation for wrapping Jetty HTTP headers.\n *\n * <p>There is a duplicate of this class in the server package!\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.3\n */",
    "changetype": "stabilized",
    "source_code": "public final class JettyHeadersAdapter implements MultiValueMap<String, String> {\n\n\tprivate final HttpFields headers;\n\n\tprivate static final String IMMUTABLE_HEADER_ERROR = \"Immutable headers\";\n\n\n\t/**\n\t * Creates a new {@code JettyHeadersAdapter} based on the given\n\t * {@code HttpFields} instance.\n\t * @param headers the {@code HttpFields} to base this adapter on\n\t */\n\tpublic JettyHeadersAdapter(HttpFields headers) {\n\t\tAssert.notNull(headers, \"Headers must not be null\");\n\t\tthis.headers = headers;\n\t}\n\n\n\t@Override\n\tpublic String getFirst(String key) {\n\t\treturn this.headers.get(key);\n\t}\n\n\t@Override\n\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}\n\n\t@Override\n\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}\n\n\t@Override\n\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}\n\n\t@Override\n\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}\n\n\t@Override\n\tpublic Map<String, String> toSingleValueMap() {\n\t\tMap<String, String> singleValueMap = CollectionUtils.newLinkedHashMap(this.headers.size());\n\t\tIterator<HttpField> iterator = this.headers.iterator();\n\t\titerator.forEachRemaining(field -> {\n\t\t\tif (!singleValueMap.containsKey(field.getName())) {\n\t\t\t\tsingleValueMap.put(field.getName(), field.getValue());\n\t\t\t}\n\t\t});\n\t\treturn singleValueMap;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.headers.getFieldNamesCollection().size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn (this.headers.size() == 0);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn (key instanceof String headerName && this.headers.contains(headerName));\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> get(Object key) {\n\t\tif (containsKey(key)) {\n\t\t\treturn this.headers.getValuesList((String) key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}\n\n\t@Nullable\n\t@Override\n\tpublic List<String> remove(Object key) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tif (key instanceof String name) {\n\t\t\tList<String> oldValues = get(key);\n\t\t\tmutableHttpFields.remove(name);\n\t\t\treturn oldValues;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}\n\n\t@Override\n\tpublic Set<String> keySet() {\n\t\treturn new HeaderNames();\n\t}\n\n\t@Override\n\tpublic Collection<List<String>> values() {\n\t\treturn this.headers.getFieldNamesCollection().stream()\n\t\t\t\t.map(this.headers::getValuesList).toList();\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn HttpHeaders.formatHeaders(this);\n\t}\n\n\n\tprivate class EntryIterator implements Iterator<Entry<String, List<String>>> {\n\n\t\tprivate final Iterator<String> names = headers.getFieldNamesCollection().iterator();\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.names.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<String, List<String>> next() {\n\t\t\treturn new HeaderEntry(this.names.next());\n\t\t}\n\t}\n\n\n\tprivate class HeaderEntry implements Entry<String, List<String>> {\n\n\t\tprivate final String key;\n\n\t\tHeaderEntry(String key) {\n\t\t\tthis.key = key;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getValue() {\n\t\t\treturn headers.getValuesList(this.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> setValue(List<String> value) {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tList<String> previousValues = headers.getValuesList(this.key);\n\t\t\tmutableHttpFields.put(this.key, value);\n\t\t\treturn previousValues;\n\t\t}\n\t}\n\n\n\tprivate class HeaderNames extends AbstractSet<String> {\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn headers.getFieldNamesCollection().size();\n\t\t}\n\t}\n\n\n\tprivate final class HeaderNamesIterator implements Iterator<String> {\n\n\t\tprivate final Iterator<String> iterator;\n\n\t\t@Nullable\n\t\tprivate String currentName;\n\n\t\tprivate HeaderNamesIterator(Iterator<String> iterator) {\n\t\t\tthis.iterator = iterator;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn this.iterator.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic String next() {\n\t\t\tthis.currentName = this.iterator.next();\n\t\t\treturn this.currentName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tif (!(headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t\t}\n\t\t\tif (this.currentName == null) {\n\t\t\t\tthrow new IllegalStateException(\"No current Header in iterator\");\n\t\t\t}\n\t\t\tif (!headers.contains(this.currentName)) {\n\t\t\t\tthrow new IllegalStateException(\"Header not present: \" + this.currentName);\n\t\t\t}\n\t\t\tmutableHttpFields.remove(this.currentName);\n\t\t}\n\t}\n\n}",
    "query": "Imagine you're developing a Spring-based web service that requires seamless integration and manipulation of Jetty's HTTP headers. Design a method that bridges Jetty's `HttpFields` with Spring's `MultiValueMap`, enabling efficient and flexible header operations within your application.",
    "function_signature": "public MultiValueMap<String, String> createHeadersAdapter(HttpFields httpFields)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.JettyHeadersAdapter#putAll(String,map)",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}",
    "query": "Design a service that aggregates user preferences from various sources and applies them as HTTP headers in outgoing requests, ensuring all headers are set efficiently in a single operation.",
    "function_signature": "public void applyUserPreferencesHeaders(Map<String, List<String>> preferences)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.beanvalidation.MethodValidationAdapter#compare(result1,result2)",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}",
    "query": "Design a feature that systematically ranks validation outcomes of method parameters to present a coherent and prioritized error report to API consumers.",
    "function_signature": "public int prioritizeParameterValidation(ParameterValidationResult firstResult, ParameterValidationResult secondResult)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.JettyHeadersAdapter#clear()",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public void clear()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void clear() {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.clear();\n\t}",
    "query": "Design a method that removes all existing HTTP headers from a request, ensuring that the operation only proceeds if the headers are modifiable, to prevent unintended side effects.",
    "function_signature": "public void clearAllHeaders(HttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.JettyHeadersAdapter#entrySet()",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public List<String>>> entrySet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn new AbstractSet<>() {\n\t\t\t@Override\n\t\t\tpublic Iterator<Entry<String, List<String>>> iterator() {\n\t\t\t\treturn new EntryIterator();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn headers.size();\n\t\t\t}\n\t\t};\n\t}",
    "query": "Design a Spring service method that efficiently aggregates and processes multiple HTTP header values, allowing for easy iteration and manipulation of header entries.",
    "function_signature": "public Set<Map.Entry<String, List<String>>> aggregateHttpHeaders()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.config.YamlProcessor#isGlobalTagAllowed(tag)",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public boolean isGlobalTagAllowed(Tag tag)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isGlobalTagAllowed(Tag tag) {\n\t\t\treturn supportedTypes.contains(tag.getClassName());\n\t\t}",
    "query": "Implement a validation process that restricts the usage of specific YAML tags across your Spring applications configuration files, ensuring only approved global tags are utilized.",
    "function_signature": "public boolean isTagGloballyPermitted(Tag tag)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.JettyHeadersAdapter#iterator()",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public Iterator<String> iterator()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Iterator<String> iterator() {\n\t\t\treturn new HeaderNamesIterator(headers.getFieldNamesCollection().iterator());\n\t\t}",
    "query": "Create a service that processes each HTTP header name from a Jetty client response individually for auditing purposes, ensuring minimal memory usage by handling headers in a streamed manner.",
    "function_signature": "public Iterator<String> streamHeaderNamesForAudit()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.JettyHeadersAdapter#containsValue(value)",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public boolean containsValue(Object value)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean containsValue(Object value) {\n\t\treturn (value instanceof String searchString &&\n\t\t\t\tthis.headers.stream().anyMatch(field -> field.contains(searchString)));\n\t}",
    "query": "Design a service method that determines whether incoming HTTP requests contain a specific value within their headers. Leverage the latest Spring Framework enhancements to perform this check efficiently without manually iterating through each header.",
    "function_signature": "public boolean hasHeaderValue(HttpHeaders headers, String value)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.junit.jupiter.SpringExtension#getApplicationContext(context)",
    "from_version": "v6.0.10",
    "to_version": "v6.1.0-M1",
    "type": "method",
    "signature": "public ApplicationContext getApplicationContext(ExtensionContext context)",
    "documentation": "\t/**\n\t * Get the {@link ApplicationContext} associated with the supplied {@code ExtensionContext}.\n\t * @param context the current {@code ExtensionContext} (never {@code null})\n\t * @return the application context\n\t * @throws IllegalStateException if an error occurs while retrieving the application context\n\t * @see org.springframework.test.context.TestContext#getApplicationContext()\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static ApplicationContext getApplicationContext(ExtensionContext context) {\n\t\treturn getTestContextManager(context).getTestContext().getApplicationContext();\n\t}",
    "query": "Create a test helper function that accesses the Spring application context within a JUnit 5 extension to facilitate bean retrieval during integration testing.",
    "function_signature": "public ApplicationContext obtainApplicationContext(ExtensionContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.AbstractRegexpMethodPointcut#toString()",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String toString() {\n\t\treturn getClass().getName() + \": patterns \" + ObjectUtils.nullSafeToString(this.patterns) +\n\t\t\t\t\", excluded patterns \" + ObjectUtils.nullSafeToString(this.excludedPatterns);\n\t}",
    "query": "Implement a method that provides a clear and efficient summary of the current method interception patterns, enhancing maintainability and performance.",
    "function_signature": "public String getInterceptionPatternsSummary()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.reactive.server.<unknown>#viewResolvers(consumer)",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public DefaultControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic DefaultControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer) {\n\t\tthis.configurer.viewResolversConsumer = consumer;\n\t\treturn this;\n\t}",
    "query": "Enhance your controller configuration by implementing a modern approach to manage view resolutions, ensuring better performance and type safety.",
    "function_signature": "public DefaultControllerSpec setViewResolvers(ViewResolverConfigurer configurer)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.DataSourceUtils#applyTransactionTimeout(stmt,dataSource)",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public void applyTransactionTimeout(Statement stmt, @Nullable DataSource dataSource)",
    "documentation": "\t/**\n\t * Apply the current transaction timeout, if any,\n\t * to the given JDBC Statement object.\n\t * @param stmt the JDBC Statement object\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.Statement#setQueryTimeout\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static void applyTransactionTimeout(Statement stmt, @Nullable DataSource dataSource) throws SQLException {\n\t\tapplyTimeout(stmt, dataSource, -1);\n\t}",
    "query": "Enhance your database operations by implementing a mechanism that efficiently manages transaction durations, ensuring optimal resource utilization and improved safety during statement executions.",
    "function_signature": "public void configureOptimalTransactionTimeout(Statement stmt, DataSource dataSource) throws SQLException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.client.RestTemplate#patchForObject(url,request,responseType,Map<String,uriVariables)",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,",
    "query": "Design a method to perform a partial update to a resource at a given endpoint, ensuring non-blocking execution and enhanced scalability for high-load applications.",
    "function_signature": "public <T> Mono<T> updateResourcePartially(String endpoint, @Nullable Object updatePayload, Class<T> responseType);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mock.web.MockHttpServletRequest#setPathInfo(pathInfo)",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public void setPathInfo(@Nullable String pathInfo)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathInfo(@Nullable String pathInfo) {\n\t\tthis.pathInfo = pathInfo;\n\t}",
    "query": "Create a unit test for a Spring MVC controller that accurately simulates varying servlet paths, ensuring optimal request handling and thread safety.",
    "function_signature": "public void configureServletPath(@Nullable String servletPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.support.AbstractApplicationContext#refresh()",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public void refresh()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\tStartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");\n\n\t\t\t// Prepare this context for refreshing.\n\t\t\tprepareRefresh();\n\n\t\t\t// Tell the subclass to refresh the internal bean factory.\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t// Prepare the bean factory for use in this context.\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t\t\tStartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");\n\t\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// Register bean processors that intercept bean creation.\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\t\t\t\tbeanPostProcess.end();\n\n\t\t\t\t// Initialize message source for this context.\n\t\t\t\tinitMessageSource();\n\n\t\t\t\t// Initialize event multicaster for this context.\n\t\t\t\tinitApplicationEventMulticaster();\n\n\t\t\t\t// Initialize other special beans in specific context subclasses.\n\t\t\t\tonRefresh();\n\n\t\t\t\t// Check for listener beans and register them.\n\t\t\t\tregisterListeners();\n\n\t\t\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t\t\t// Last step: publish corresponding event.\n\t\t\t\tfinishRefresh();\n\t\t\t}\n\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\t\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t\t\t}\n\n\t\t\t\t// Destroy already created singletons to avoid dangling resources.\n\t\t\t\tdestroyBeans();\n\n\t\t\t\t// Reset 'active' flag.\n\t\t\t\tcancelRefresh(ex);\n\n\t\t\t\t// Propagate exception to caller.\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tfinally {\n\t\t\t\t// Reset common introspection caches in Spring's core, since we\n\t\t\t\t// might not ever need metadata for singleton beans anymore...\n\t\t\t\tresetCommonCaches();\n\t\t\t\tcontextRefresh.end();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Improve the initialization process of your Spring application context to enhance performance and ensure thread safety during startup. Implement a method that sets up the necessary bean factories and post-processors without relying on outdated context refresh mechanisms.",
    "function_signature": "public void initializeApplicationContext(ConfigurableApplicationContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanFactory#isSingleton(name)",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public boolean isSingleton(String name)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean isSingleton(String name) throws NoSuchBeanDefinitionException {\n\t\tString beanName = transformedBeanName(name);\n\n\t\tObject beanInstance = getSingleton(beanName, false);\n\t\tif (beanInstance != null) {\n\t\t\tif (beanInstance instanceof FactoryBean<?> factoryBean) {\n\t\t\t\treturn (BeanFactoryUtils.isFactoryDereference(name) || factoryBean.isSingleton());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn !BeanFactoryUtils.isFactoryDereference(name);\n\t\t\t}\n\t\t}\n\n\t\t// No singleton instance found -> check bean definition.\n\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn parentBeanFactory.isSingleton(originalBeanName(name));\n\t\t}\n\n\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\n\t\t// In case of FactoryBean, return singleton status of created object if not a dereference.\n\t\tif (mbd.isSingleton()) {\n\t\t\tif (isFactoryBean(beanName, mbd)) {\n\t\t\t\tif (BeanFactoryUtils.isFactoryDereference(name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tFactoryBean<?> factoryBean = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\treturn factoryBean.isSingleton();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn !BeanFactoryUtils.isFactoryDereference(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}",
    "query": "Design a utility that determines whether a specified bean within the application context maintains a single shared instance. Ensure the approach optimizes performance and adheres to the latest best practices for thread safety and resource management.",
    "function_signature": "public boolean verifyBeanSingleton(String beanIdentifier)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.core.ResolvableType#forMethodParameter(method,parameterIndex,implementationClass)",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass)",
    "documentation": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} parameter with a\n\t * given implementation. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation class.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}",
    "query": "Create a utility function that accurately determines the generic type of a method's parameter, ensuring enhanced type safety and improved performance by utilizing the most efficient approach available in the current framework version.",
    "function_signature": "public ResolvableType resolveParameterType(MethodParameter methodParameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#build()",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "method",
    "signature": "public HttpServiceProxyFactory build()",
    "documentation": "\t\t/**\n\t\t * Build the {@link HttpServiceProxyFactory} instance.\n\t\t */",
    "changetype": "deprecated",
    "source_code": "\t\tpublic HttpServiceProxyFactory build() {\n\t\t\tAssert.notNull(this.clientAdapter, \"HttpClientAdapter is required\");\n\n\t\t\treturn new HttpServiceProxyFactory(\n\t\t\t\t\tthis.clientAdapter, initArgumentResolvers(),\n\t\t\t\t\tthis.embeddedValueResolver, this.reactiveAdapterRegistry,\n\t\t\t\t\t(this.blockTimeout != null ? this.blockTimeout : Duration.ofSeconds(5)));\n\t\t}",
    "query": "Develop a method to configure and instantiate an HTTP service proxy factory using the recommended configuration mechanism for better performance and thread safety.",
    "function_signature": "public HttpServiceProxyFactory configureHttpServiceProxyFactory()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.PROPS_ELEMENT",
    "from_version": "v6.0.0-RC4",
    "to_version": "v5.3.24",
    "type": "field",
    "signature": "public String PROPS_ELEMENT",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static final String PROPS_ELEMENT = \"props\";",
    "query": "Enhance the bean configuration to optimize property management, ensuring improved maintainability and type safety.",
    "function_signature": "public void configureAdvancedPropertySources()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Optimize your web application's request handling by updating the interceptor configuration to leverage enhanced asynchronous processing capabilities.",
    "function_signature": "public AsyncHandlerInterceptor retrieveAsyncInterceptor()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(lookupPath,pathMatcher)",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a function to assess whether an interceptor is applicable to the incoming HTTP request, optimizing for thread safety and streamlined request handling.",
    "function_signature": "public boolean isInterceptorApplicable(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Refactor the interceptor configuration to optimize URL path matching, ensuring that the application leverages the most efficient parsing mechanisms available for handling request paths.",
    "function_signature": "public void configurePathHandling(RequestPathHandler handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#preHandle(request,response,handler)",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "query": "Develop a component that efficiently manages the initial processing of HTTP requests, enhancing performance and ensuring robust handling of each request lifecycle.",
    "function_signature": "public boolean handleInitialRequest(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Design a method to obtain the URI patterns linked to a specific interceptor, emphasizing enhanced type safety and performance efficiency.",
    "function_signature": "public PathPattern[] retrieveUriPatterns(Interceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Design a custom interceptor that determines its applicability based on the resolved request path, leveraging advanced path matching for improved performance and maintainability.",
    "function_signature": "public boolean isApplicable(PathContainer requestPath)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Develop a component that executes supplementary operations after a controller has processed a request, prioritizing improved performance and ensuring thread safety within a Spring MVC application.",
    "function_signature": "public void handlePostControllerExecution(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#afterCompletion(request,response,handler,ex)",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a callback method to handle post-processing of HTTP requests, enhancing reliability and reducing latency compared to prior implementations.",
    "function_signature": "public void handlePostRequestCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Throwable exception)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PathPattern[] includePatterns;\n\n\t@Nullable\n\tprivate final PathPattern[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\t@Nullable\n\tprivate static PathPattern[] initPatterns(\n\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\treturn null;\n\t\t}\n\t\tparser = (parser != null ? parser : PathPatternParser.defaultInstance);\n\t\treturn Arrays.stream(patterns).map(parser::parse).toArray(PathPattern[]::new);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean matchPattern(Object path, boolean isPathContainer, PathPattern pattern) {\n\t\treturn (isPathContainer ?\n\t\t\t\tpattern.matches((PathContainer) path) :\n\t\t\t\tthis.pathMatcher.match(pattern.getPatternString(), (String) path));\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (pathMatcher.match(pattern.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n}",
    "query": "Enhance your application's request handling performance by configuring interceptors with advanced path pattern matching. Develop a method that registers a `HandlerInterceptor` using the latest pattern parsing techniques to specify inclusion and exclusion paths effectively.",
    "function_signature": "public void registerInterceptor(InterceptorRegistry registry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathMatcher()",
    "from_version": "v5.3.0-M1",
    "to_version": "v5.2.8.RELEASE",
    "type": "method",
    "signature": "public PathMatcher getPathMatcher()",
    "documentation": "\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}",
    "query": "Design a method that customizes the strategy for matching URL patterns in your web application's request handling. Ensure that the approach you choose enhances performance and maintains thread safety without relying on outdated configuration techniques.",
    "function_signature": "public void configureUrlPatternMatcher(CustomPathMatcher matcher)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.format.datetime.standard.DurationFormatterUtils#parse(value,style,unit)",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "documentation": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return a duration\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> parseIso8601(value);\n\t\t\tcase SIMPLE -> parseSimple(value, unit);\n\t\t\tcase COMPOSITE -> parseComposite(value);\n\t\t};\n\t}",
    "query": "Develop a method that efficiently transforms a formatted duration string into a `Duration` object, ensuring enhanced performance and type safety without relying on legacy parsing mechanisms.",
    "function_signature": "public Duration convertDuration(String durationString)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod(handlerMethod,exception)",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)",
    "documentation": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod(",
    "query": "Implement a feature in your Spring MVC application that intelligently locates and invokes the most suitable exception handling method based on where an exception was thrown within a controller, ensuring that both controller-specific and global exception handlers are seamlessly integrated.",
    "function_signature": "protected ServletInvocableHandlerMethod locateAppropriateExceptionHandler(@Nullable HandlerMethod originatingMethod, Exception thrownException)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter#getContentTypeResolver()",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public RequestedContentTypeResolver getContentTypeResolver()",
    "documentation": "\t/**\n\t * Return the configured {@link RequestedContentTypeResolver}.\n\t * @since 6.2\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic RequestedContentTypeResolver getContentTypeResolver() {\n\t\treturn this.contentTypeResolver;\n\t}",
    "query": "Optimize how your application determines the client's preferred content type by leveraging Spring's advanced content negotiation features, ensuring better performance and flexibility.",
    "function_signature": "public ContentNegotiationManager configureContentNegotiationManager()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.AsyncServerResponse",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "interface",
    "signature": "public interface AsyncServerResponse",
    "documentation": "/**\n * Asynchronous subtype of {@link ServerResponse} that exposes the future\n * response.\n *\n * @author Arjen Poutsma\n * @since 5.3.2\n * @see ServerResponse#async(Object)\n */",
    "changetype": "deprecated",
    "source_code": "public interface AsyncServerResponse extends ServerResponse {\n\n\t/**\n\t * Blocks indefinitely until the future response is obtained.\n\t */\n\tServerResponse block();\n\n\n\t// Static creation methods\n\n\t/**\n\t * Create a {@code AsyncServerResponse} with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse) {\n\t\treturn createInternal(asyncResponse, null);\n\t}\n\n\t/**\n\t * Create a (built) response with the given asynchronous response.\n\t * Parameter {@code asyncResponse} can be a\n\t * {@link CompletableFuture CompletableFuture&lt;ServerResponse&gt;} or\n\t * {@link Publisher Publisher&lt;ServerResponse&gt;} (or any\n\t * asynchronous producer of a single {@code ServerResponse} that can be\n\t * adapted via the {@link ReactiveAdapterRegistry}).\n\t * @param asyncResponse a {@code CompletableFuture<ServerResponse>} or\n\t * {@code Publisher<ServerResponse>}\n\t * @param timeout maximum time period to wait for before timing out\n\t * @return the asynchronous response\n\t */\n\tstatic AsyncServerResponse create(Object asyncResponse, Duration timeout) {\n\t\treturn createInternal(asyncResponse, timeout);\n\t}\n\n\tprivate static AsyncServerResponse createInternal(Object asyncResponse, @Nullable Duration timeout) {\n\t\tAssert.notNull(asyncResponse, \"AsyncResponse must not be null\");\n\n\t\tCompletableFuture<ServerResponse> futureResponse = toCompletableFuture(asyncResponse);\n\t\tif (futureResponse.isDone() &&\n\t\t\t\t!futureResponse.isCancelled() &&\n\t\t\t\t!futureResponse.isCompletedExceptionally()) {\n\n\t\t\ttry {\n\t\t\t\tServerResponse completedResponse = futureResponse.get();\n\t\t\t\treturn new CompletedAsyncServerResponse(completedResponse);\n\t\t\t}\n\t\t\tcatch (InterruptedException | ExecutionException ignored) {\n\t\t\t\t// fall through to use DefaultAsyncServerResponse\n\t\t\t}\n\t\t}\n\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static CompletableFuture<ServerResponse> toCompletableFuture(Object obj) {\n\t\tif (obj instanceof CompletableFuture<?> futureResponse) {\n\t\t\treturn (CompletableFuture<ServerResponse>) futureResponse;\n\t\t}\n\t\telse if (DefaultAsyncServerResponse.reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\treturn (CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}\n\n}",
    "query": "Design a request handler that efficiently manages asynchronous operations without hindering application performance. Ensure the solution leverages non-blocking mechanisms to maintain high throughput and responsiveness, especially under heavy concurrent access.",
    "function_signature": "public Mono<ServerResponse> processAsyncRequest(ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}",
    "query": "Design a Spring controller method that accepts various asynchronous data types and ensures responses are delivered within a configurable time frame. The implementation should automatically adapt to CompletableFuture and reactive stream publishers without manual type checking.",
    "function_signature": "public AsyncServerResponse processAsyncData(Object asyncData, @Nullable Duration responseTimeout)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.HttpServiceProxyFactory#builder(clientAdapter)",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public Builder builder(HttpClientAdapter clientAdapter)",
    "documentation": "\t/**\n\t * Return a builder that's initialized with the given client.\n\t * @deprecated in favor of {@link #builderFor(HttpExchangeAdapter)};\n\t * to be removed in 6.2.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static Builder builder(HttpClientAdapter clientAdapter) {\n\t\treturn new Builder().exchangeAdapter(clientAdapter.asReactorExchangeAdapter());\n\t}",
    "query": "Design a factory method to generate service proxies that utilize a customizable HTTP exchange mechanism for enhanced reactive communication.",
    "function_signature": "public ServiceProxyFactory createServiceProxyFactory(HttpExchangeAdapter exchangeAdapter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.framework.AdvisedSupport#removeInterface(intf)",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public boolean removeInterface(Class<?> intf)",
    "documentation": "\t/**\n\t * Remove a proxied interface.\n\t * <p>Does nothing if the given interface isn't proxied.\n\t * @param intf the interface to remove from the proxy\n\t * @return {@code true} if the interface was removed; {@code false}\n\t * if the interface was not found and hence could not be removed\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean removeInterface(Class<?> intf) {\n\t\treturn this.interfaces.remove(intf);\n\t}",
    "query": "Design a feature that allows dynamic adjustment of a proxy's implemented interfaces, ensuring optimal performance and type safety. This enhancement should provide a more reliable and user-friendly approach to managing proxy interfaces.",
    "function_signature": "public void updateProxyInterfaces(Class<?>... interfaces)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.expression.spel.support.ReflectionHelper#isCloseMatch()",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public boolean isCloseMatch()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}",
    "query": "Design a utility function that intelligently selects and invokes the most appropriate overloaded method from a service class based on dynamic runtime arguments, ensuring compatibility even when exact parameter types aren't provided.",
    "function_signature": "public Object invokeClosestMatchingMethod(String methodName, Object... args)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#portString()",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public String portString()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String portString() {\n\t\t\tif (port() == null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn port().toString();\n\t\t\t}\n\t\t}",
    "query": "Create a utility function that efficiently obtains the server port in string format, ensuring enhanced performance and null safety compared to earlier implementations.",
    "function_signature": "public String retrieveServerPort()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.server.adapter.DefaultServerWebExchange#getApplicationContext()",
    "from_version": "v6.2.0-RC1",
    "to_version": "v6.1.14",
    "type": "method",
    "signature": "public ApplicationContext getApplicationContext()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}",
    "query": "Develop a component that efficiently retrieves the application context from a web exchange, ensuring improved performance and type safety during reactive request processing.",
    "function_signature": "public Optional<ApplicationContext> obtainApplicationContext(ServerWebExchange exchange)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.context.annotation.<unknown>#getBeanName()",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public String getBeanName()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}",
    "query": "Develop a Spring-managed service that, during its initialization phase, accesses and logs its own unique identifier from the application context.",
    "function_signature": "public String retrieveServiceIdentifier()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.connection.DelegatingConnectionFactory#createContext(sessionMode)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public JMSContext createContext(int sessionMode)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic JMSContext createContext(int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(sessionMode);\n\t}",
    "query": "Develop a component that establishes a JMS context with customizable session settings to enhance message processing flexibility.",
    "function_signature": "public JMSContext initializeJmsContext(int sessionMode)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#addQualifierType(qualifierType)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public void addQualifierType(Class<? extends Annotation> qualifierType)",
    "documentation": "\t/**\n\t * Register the given type to be used as a qualifier when autowiring.\n\t * <p>This identifies qualifier annotations for direct use (on fields,\n\t * method parameters and constructor parameters) as well as meta\n\t * annotations that in turn identify actual qualifier annotations.\n\t * <p>This implementation only supports annotations as qualifier types.\n\t * The default is Spring's {@link Qualifier} annotation which serves\n\t * as a qualifier for direct use and also as a meta annotation.\n\t * @param qualifierType the annotation type to register\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void addQualifierType(Class<? extends Annotation> qualifierType) {\n\t\tthis.qualifierTypes.add(qualifierType);\n\t}",
    "query": "Configure the application to support a specialized annotation that serves as a qualifier for autowiring specific bean implementations.",
    "function_signature": "public void registerCustomBeanQualifier(Class<? extends Annotation> qualifierAnnotation)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.connection.SingleConnectionFactory#onException(ex)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public void onException(JMSException ex)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void onException(JMSException ex) {\n\t\t\t// Iterate over temporary copy in order to avoid ConcurrentModificationException,\n\t\t\t// since listener invocations may in turn trigger registration of listeners...\n\t\t\tSet<ExceptionListener> copy;\n\t\t\tsynchronized (connectionMonitor) {\n\t\t\t\tcopy = new LinkedHashSet<>(this.delegates);\n\t\t\t}\n\t\t\tfor (ExceptionListener listener : copy) {\n\t\t\t\tlistener.onException(ex);\n\t\t\t}\n\t\t}",
    "query": "Design a robust messaging component that maintains a single JMS connection and efficiently propagates any connection-related exceptions to multiple monitoring services to ensure system reliability.",
    "function_signature": "public void setupMessagingExceptionHandler(ExceptionListener handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#setResourceLoader(resourceLoader)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public void setResourceLoader(@Nullable ResourceLoader resourceLoader)",
    "documentation": "\t/**\n\t * Set the ResourceLoader to use for resource locations.\n\t * If specifying a ResourcePatternResolver, the bean definition reader\n\t * will be capable of resolving resource patterns to Resource arrays.\n\t * <p>Default is PathMatchingResourcePatternResolver, also capable of\n\t * resource pattern resolving through the ResourcePatternResolver interface.\n\t * <p>Setting this to {@code null} suggests that absolute resource loading\n\t * is not available for this bean definition reader.\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setResourceLoader(@Nullable ResourceLoader resourceLoader) {\n\t\tthis.resourceLoader = resourceLoader;\n\t}",
    "query": "Design a configuration setup that enables your Spring application to seamlessly load and process multiple bean definition files matching specific naming patterns from diverse resource directories.",
    "function_signature": "public void initializeBeanDefinitions(ResourceLoader resourceLoader)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader#getRegistry()",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public BeanDefinitionRegistry getRegistry()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic final BeanDefinitionRegistry getRegistry() {\n\t\treturn this.registry;\n\t}",
    "query": "Develop a feature that allows dynamic registration of additional beans during the application context initialization, enabling configurations to adapt based on external parameters or conditions.",
    "function_signature": "public BeanDefinitionRegistry getBeanDefinitionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler#handleMessageInternal(message,lookupDestination)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "protected void handleMessageInternal(Message<?> message, String lookupDestination)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}",
    "query": "Develop a messaging component that intelligently routes incoming messages to the appropriate handlers based on dynamic destination lookups. Ensure that the component efficiently resolves the best matching handler, handles ambiguous mappings gracefully, and provides clear logging for tracing message handling decisions.",
    "function_signature": "protected void routeIncomingMessage(Message<?> message, String lookupDestination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jms.listener.DefaultMessageListenerContainer#getIdleConsumerLimit()",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public int getIdleConsumerLimit()",
    "documentation": "\t/**\n\t * Return the limit for the number of idle consumers.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic final int getIdleConsumerLimit() {\n\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\treturn this.idleConsumerLimit;\n\t\t}\n\t}",
    "query": "Configure a JMS listener to automatically adjust its resource usage by retrieving the current maximum number of idle consumers, ensuring optimal performance during fluctuating traffic conditions.",
    "function_signature": "public int obtainIdleConsumerThreshold()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.socket.adapter.UndertowWebSocketSession#close(status)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public Mono<Void> close(CloseStatus status)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Mono<Void> close(CloseStatus status) {\n\t\tCloseMessage cm = new CloseMessage(status.getCode(), status.getReason());\n\t\tif (!getDelegate().isCloseFrameSent()) {\n\t\t\tWebSockets.sendClose(cm, getDelegate(), null);\n\t\t}\n\t\treturn Mono.empty();\n\t}",
    "query": "Design a reactive WebSocket service that automatically terminates client connections with a custom status when a predefined server-side event occurs.",
    "function_signature": "public Mono<Void> terminateClientSession(CloseStatus status)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.StaticListableBeanFactory#findAnnotationOnBean(beanName,annotationType)",
    "from_version": "v6.0.4",
    "to_version": "v6.0.5",
    "type": "method",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "query": "Design a service method that retrieves specific metadata annotations from a designated Spring bean by its identifier. This functionality is essential for dynamically processing beans based on their annotated configurations without manually inspecting each bean's class.",
    "function_signature": "public <A extends Annotation> A getBeanMetadataAnnotation(String beanIdentifier, Class<A> annotationClass);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.<unknown>#trackOverrideInstance(mock,trackingBeanRegistry)",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "protected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tprotected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry) {\n\t\tgetMockitoBeans(trackingBeanRegistry).add(mock);\n\t}",
    "query": "Develop a testing utility that automatically registers and monitors overridden mock beans within the SingletonBeanRegistry to maintain consistent bean management during integration tests.",
    "function_signature": "protected void registerOverriddenMock(Object mock, SingletonBeanRegistry beanRegistry)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#resolve(resolutionContext)",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public String resolve(PartResolutionContext resolutionContext)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String resolve(PartResolutionContext resolutionContext) {\n\t\t\tString resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\n\t\t\tString value = resolveRecursively(resolutionContext, resolvedKey);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse if (this.defaultParts != null) {\n\t\t\t\treturn Part.resolveAll(this.defaultParts, resolutionContext);\n\t\t\t}\n\t\t\treturn resolutionContext.handleUnresolvablePlaceholder(resolvedKey, text());\n\t\t}",
    "query": "Design a utility method that constructs dynamic file paths by integrating multiple path segments based on the current execution context. Ensure that the method gracefully handles scenarios where certain segments may be undefined or require default values.",
    "function_signature": "public String buildDynamicPath(PartResolutionContext resolutionContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.annotation.AsyncResult#forExecutionException(ex)",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public ListenableFuture<V> forExecutionException(Throwable ex)",
    "documentation": "\t/**\n\t * Create a new async result which exposes the given exception as an\n\t * {@link ExecutionException} from {@link Future#get()}.\n\t * @param ex the exception to expose (either an pre-built {@link ExecutionException}\n\t * or a cause to be wrapped in an {@link ExecutionException})\n\t * @since 4.2\n\t * @see ExecutionException\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic static <V> ListenableFuture<V> forExecutionException(Throwable ex) {\n\t\treturn new AsyncResult<>(null, ex);\n\t}",
    "query": "Improve the handling of asynchronous exceptions by implementing a method that encapsulates exceptions in a way that ensures better integration with modern concurrency utilities.",
    "function_signature": "public CompletableFuture<V> handleAsyncException(Throwable ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.request.AbstractMockHttpServletRequestBuilder#uri(uriTemplate,uriVariables)",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public B uri(String uriTemplate, Object... uriVariables)",
    "documentation": "\t/**\n\t * Specify the URI for the request using a URI template and URI variables.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic B uri(String uriTemplate, Object... uriVariables) {\n\t\treturn updateUri(initUri(uriTemplate, uriVariables), uriTemplate);\n\t}",
    "query": "Design a unit test for a REST endpoint that requires constructing URLs with dynamic path variables.",
    "function_signature": "public void testEndpointWithDynamicUri(String uriTemplate, Object... uriVariables)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor#getAdvice()",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public Advice getAdvice()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Advice getAdvice() {\n\t\tAdvice advice = this.advice;\n\t\tif (advice != null) {\n\t\t\treturn advice;\n\t\t}\n\n\t\tAssert.state(this.adviceBeanName != null, \"'adviceBeanName' must be specified\");\n\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to resolve 'adviceBeanName'\");\n\n\t\tif (this.beanFactory.isSingleton(this.adviceBeanName)) {\n\t\t\t// Rely on singleton semantics provided by the factory.\n\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\tthis.advice = advice;\n\t\t\treturn advice;\n\t\t}\n\t\telse {\n\t\t\t// No singleton guarantees from the factory -> let's lock locally but\n\t\t\t// reuse the factory's singleton lock, just in case a lazy dependency\n\t\t\t// of our advice bean happens to trigger the singleton lock implicitly...\n\t\t\tsynchronized (this.adviceMonitor) {\n\t\t\t\tadvice = this.advice;\n\t\t\t\tif (advice == null) {\n\t\t\t\t\tadvice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);\n\t\t\t\t\tthis.advice = advice;\n\t\t\t\t}\n\t\t\t\treturn advice;\n\t\t\t}\n\t\t}\n\t}",
    "query": "Enhance the aspect configuration to improve efficiency and ensure thread-safe retrieval of advice instances by utilizing the recommended strategy for managing advice beans within the Spring application context.",
    "function_signature": "public Advice retrieveOptimizedAdvice();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.reactive.JettyClientHttpConnector#writableByteBuffers()",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public ByteBufferIterator writableByteBuffers()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic ByteBufferIterator writableByteBuffers() {\n\t\t\tByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();\n\t\t\treturn new JettyByteBufferIterator(delegateIterator, this.chunk);\n\t\t}",
    "query": "Optimize the handling of writable byte buffers in your reactive HTTP client to enhance performance and ensure thread safety.",
    "function_signature": "public BufferWriter optimizeWritableBuffers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.server.reactive.<unknown>#getAttributes()",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public String> getAttributes()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Map<String, String> getAttributes() {\n\t\t\treturn Collections.emptyMap();\n\t\t}",
    "query": "Create a reactive REST endpoint that customizes its processing logic based on metadata associated with each incoming HTTP request, ensuring that the metadata is efficiently retrieved and utilized during request handling.",
    "function_signature": "public Mono<ResponseEntity<String>> customizeResponseBasedOnRequestAttributes(ServerRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#flagPlaceholderAsVisited(placeholder)",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public void flagPlaceholderAsVisited(String placeholder)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void flagPlaceholderAsVisited(String placeholder) {\n\t\t\tif (this.visitedPlaceholders == null) {\n\t\t\t\tthis.visitedPlaceholders = new HashSet<>(4);\n\t\t\t}\n\t\t\tif (!this.visitedPlaceholders.add(placeholder)) {\n\t\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\t\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\n\t\t\t}\n\t\t}",
    "query": "Implement a service that resolves dynamic configuration placeholders, ensuring that each placeholder is processed only once to prevent circular dependencies during resolution.",
    "function_signature": "public void markPlaceholderAsVisited(String placeholder)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#scheme()",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public String scheme()",
    "documentation": "\t\t/**\n\t\t * A URLs scheme is an ASCII string that identifies the type of URL and\n\t\t * can be used to dispatch a URL for further processing after parsing.\n\t\t * It is initially the empty string.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic String scheme() {\n\t\t\treturn this.scheme;\n\t\t}",
    "query": "Design a service that dynamically routes incoming HTTP requests based on the protocol specified in their URLs, ensuring that each request is processed by the appropriate handler corresponding to its scheme.",
    "function_signature": "public String determineRequestScheme(URI requestUri)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.web.servlet.assertj.MockMvcTester#multipart()",
    "from_version": "v6.1.16",
    "to_version": "v6.2.1",
    "type": "method",
    "signature": "public MockMultipartMvcRequestBuilder multipart()",
    "documentation": "\t\t/**\n\t\t * Enable file upload support using multipart.\n\t\t * @return a {@link MockMultipartMvcRequestBuilder} with the settings\n\t\t * configured thus far\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic MockMultipartMvcRequestBuilder multipart() {\n\t\t\treturn new MockMultipartMvcRequestBuilder(this);\n\t\t}",
    "query": "Ensure your application's API can handle file uploads by writing a test that simulates a client submitting a multipart form containing a user avatar image.",
    "function_signature": "public void verifyUserAvatarUploadProcessing()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.bean.override.mockito.MockitoTestExecutionListener",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "class",
    "signature": "public class MockitoTestExecutionListener",
    "documentation": "/**\n * {@code TestExecutionListener} that enables {@link MockitoBean @MockitoBean} and\n * {@link MockitoSpyBean @MockitoSpyBean} support. Also triggers\n * {@link MockitoAnnotations#openMocks(Object)} when any Mockito annotations are\n * used, primarily to support {@link Captor @Captor} annotations.\n *\n * <p>The automatic reset support for {@code @MockBean} and {@code @SpyBean} is\n * handled by the {@link MockitoResetTestExecutionListener}.\n *\n * @author Simon Basl\n * @author Phillip Webb\n * @author Andy Wilkinson\n * @author Moritz Halbritter\n * @since 6.2\n * @see MockitoResetTestExecutionListener\n */",
    "changetype": "stabilized",
    "source_code": "public class MockitoTestExecutionListener extends AbstractTestExecutionListener {\n\n\tprivate static final String MOCKS_ATTRIBUTE_NAME = MockitoTestExecutionListener.class.getName() + \".mocks\";\n\n\tstatic final boolean mockitoPresent = ClassUtils.isPresent(\"org.mockito.MockSettings\",\n\t\t\tMockitoTestExecutionListener.class.getClassLoader());\n\n\n\t/**\n\t * Executes before {@link DependencyInjectionTestExecutionListener}.\n\t */\n\t@Override\n\tpublic final int getOrder() {\n\t\treturn 1950;\n\t}\n\n\t@Override\n\tpublic void prepareTestInstance(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent && Boolean.TRUE.equals(\n\t\t\t\ttestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tcloseMocks(testContext);\n\t\t\tinitMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterTestClass(TestContext testContext) throws Exception {\n\t\tif (mockitoPresent) {\n\t\t\tcloseMocks(testContext);\n\t\t}\n\t}\n\n\tprivate void initMocks(TestContext testContext) {\n\t\tif (hasMockitoAnnotations(testContext)) {\n\t\t\tObject testInstance = testContext.getTestInstance();\n\t\t\ttestContext.setAttribute(MOCKS_ATTRIBUTE_NAME, MockitoAnnotations.openMocks(testInstance));\n\t\t}\n\t}\n\n\tprivate void closeMocks(TestContext testContext) throws Exception {\n\t\tObject mocks = testContext.getAttribute(MOCKS_ATTRIBUTE_NAME);\n\t\tif (mocks instanceof AutoCloseable closeable) {\n\t\t\tcloseable.close();\n\t\t}\n\t}\n\n\tprivate boolean hasMockitoAnnotations(TestContext testContext) {\n\t\tMockitoAnnotationCollector collector = new MockitoAnnotationCollector();\n\t\tReflectionUtils.doWithFields(testContext.getTestClass(), collector);\n\t\treturn collector.hasAnnotations();\n\t}\n\n\n\t/**\n\t * {@link FieldCallback} that collects Mockito annotations.\n\t */\n\tprivate static final class MockitoAnnotationCollector implements FieldCallback {\n\n\t\tprivate final Set<Annotation> annotations = new LinkedHashSet<>();\n\n\t\t@Override\n\t\tpublic void doWith(Field field) throws IllegalArgumentException {\n\t\t\tfor (Annotation annotation : field.getAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getPackageName().startsWith(\"org.mockito\")) {\n\t\t\t\t\tthis.annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasAnnotations() {\n\t\t\treturn !this.annotations.isEmpty();\n\t\t}\n\n\t}\n\n}",
    "query": "Develop a Spring Boot test method that injects a mock of a service and uses a captor to verify the arguments passed during a method invocation, ensuring that the mocks are correctly initialized and managed throughout the test lifecycle.",
    "function_signature": "@Test\nvoid shouldCaptureServiceMethodArguments(@MockBean MyService myService, @Captor ArgumentCaptor<MyArgument> captor);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#append(s)",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public void append(String s)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void append(String s) {\n\t\t\tthis.segment = null;\n\t\t\tif (this.builder == null) {\n\t\t\t\tthis.builder = new StringBuilder(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.builder.append(s);\n\t\t\t}\n\t\t}",
    "query": "Develop a feature that incrementally builds a customizable response message by appending various user-generated content segments in a thread-safe manner.",
    "function_signature": "public void constructResponseMessage(String initialMessage, List<String> contentSegments)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.support.<unknown>#setLoadTimeWeaver(loadTimeWeaver)",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {\n\t\t// no-op\n\t}",
    "query": "Configure your Spring test context to support dynamic class instrumentation, enabling advanced aspect-oriented programming features during integration testing.",
    "function_signature": "public void enableDynamicInstrumentation(LoadTimeWeaver loadTimeWeaver);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\tthis.cacheOperationSource.hasCacheOperation(method, targetClass));\n\t}",
    "query": "Design a mechanism that intercepts service layer methods and determines at runtime whether each method should utilize caching, based on its method signature and the class it belongs to.",
    "function_signature": "public boolean shouldApplyCaching(Method method, Class<?> targetClass)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#setErrorResponseInterceptors(interceptors)",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)",
    "documentation": "\t/**\n\t * Configure a list of {@link ErrorResponse.Interceptor}'s to apply when\n\t * rendering an RFC 7807 {@link org.springframework.http.ProblemDetail}\n\t * error response.\n\t * @param interceptors the handlers to use\n\t * @since 6.2\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors) {\n\t\tthis.errorResponseInterceptors.clear();\n\t\tthis.errorResponseInterceptors.addAll(interceptors);\n\t}",
    "query": "Implement a global mechanism in your Spring MVC application that allows for the customization and additional processing of all RFC 7807-compliant error responses, ensuring consistent error handling across your APIs.",
    "function_signature": "public void configureErrorResponseInterceptors(List<ErrorResponse.Interceptor> interceptors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#parse(input)",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public Ipv6Address parse(String input)",
    "documentation": "\t\t/**\n\t\t * The IPv6 parser takes a scalar value string input and then runs these steps. They return failure or an IPv6 address.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic static Ipv6Address parse(String input) {\n\t\t\t// Let address be a new IPv6 address whose IPv6 pieces are all 0.\n\t\t\tint[] address = new int[8];\n\t\t\t// Let pieceIndex be 0.\n\t\t\tint pieceIndex = 0;\n\t\t\t// Let compress be null.\n\t\t\tInteger compress = null;\n\t\t\t// Let pointer be a pointer for input.\n\t\t\tint pointer = 0;\n\t\t\tint inputLength = input.length();\n\t\t\tint c = (inputLength > 0) ? input.codePointAt(0) : EOF;\n\t\t\t// If c is U+003A (:), then:\n\t\t\tif (c == ':') {\n\t\t\t\t// If remaining does not start with U+003A (:), IPv6-invalid-compression validation error, return failure.\n\t\t\t\tif (inputLength > 1 && input.codePointAt(1) != ':') {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address begins with improper compression.\");\n\t\t\t\t}\n\t\t\t\t// Increase pointer by 2.\n\t\t\t\tpointer += 2;\n\t\t\t\t// Increase pieceIndex by 1 and then set compress to pieceIndex.\n\t\t\t\tpieceIndex++;\n\t\t\t\tcompress = pieceIndex;\n\t\t\t}\n\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t// While c is not the EOF code point:\n\t\t\twhile (c != EOF) {\n\t\t\t\t// If pieceIndex is 8, IPv6-too-many-pieces validation error, return failure.\n\t\t\t\tif (pieceIndex == 8) {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address contains more than 8 pieces.\");\n\t\t\t\t}\n\t\t\t\t// If c is U+003A (:), then:\n\t\t\t\tif (c == ':') {\n\t\t\t\t\t// If compress is non-null, IPv6-multiple-compression validation error, return failure.\n\t\t\t\t\tif (compress != null) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address is compressed in more than one spot.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Increase pointer and pieceIndex by 1, set compress to pieceIndex, and then continue.\n\t\t\t\t\tpointer++;\n\t\t\t\t\tpieceIndex++;\n\t\t\t\t\tcompress = pieceIndex;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Let value and length be 0.\n\t\t\t\tint value = 0;\n\t\t\t\tint length = 0;\n\t\t\t\t// While length is less than 4 and c is an ASCII hex digit, set value to value  0x10 + c interpreted as hexadecimal number, and increase pointer and length by 1.\n\t\t\t\twhile (length < 4 && isAsciiHexDigit(c)) {\n\t\t\t\t\tint cHex = Character.digit(c, 16);\n\t\t\t\t\tvalue = (value * 0x10) + cHex;\n\t\t\t\t\tpointer++;\n\t\t\t\t\tlength++;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t}\n\t\t\t\t// If c is U+002E (.), then:\n\t\t\t\tif (c == '.') {\n\t\t\t\t\t// If length is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\tif (length == 0) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part is empty.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Decrease pointer by length.\n\t\t\t\t\tpointer -= length;\n\t\t\t\t\t// If pieceIndex is greater than 6, IPv4-in-IPv6-too-many-pieces validation error, return failure.\n\t\t\t\t\tif (pieceIndex > 6) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv6 address has more than 6 pieces.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Let numbersSeen be 0.\n\t\t\t\t\tint numbersSeen = 0;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t// While c is not the EOF code point:\n\t\t\t\t\twhile (c != EOF) {\n\t\t\t\t\t\t// Let ipv4Piece be null.\n\t\t\t\t\t\tInteger ipv4Piece = null;\n\t\t\t\t\t\t// If numbersSeen is greater than 0, then:\n\t\t\t\t\t\tif (numbersSeen > 0) {\n\t\t\t\t\t\t\t// If c is a U+002E (.) and numbersSeen is less than 4, then increase pointer by 1.\n\t\t\t\t\t\t\tif (c =='.' && numbersSeen < 4) {\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: \" +\n\t\t\t\t\t\t\t\t\t\t\"IPv4 part is empty or contains a non-ASCII digit.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If c is not an ASCII digit, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\tif (!isAsciiDigit(c)) {\n\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part contains a non-ASCII digit.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// While c is an ASCII digit:\n\t\t\t\t\t\twhile (isAsciiDigit(c)) {\n\t\t\t\t\t\t\t// Let number be c interpreted as decimal number.\n\t\t\t\t\t\t\tint number = Character.digit(c, 10);\n\t\t\t\t\t\t\t// If ipv4Piece is null, then set ipv4Piece to number.\n\t\t\t\t\t\t\tif (ipv4Piece == null) {\n\t\t\t\t\t\t\t\tipv4Piece = number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, if ipv4Piece is 0, IPv4-in-IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\t\t\telse if (ipv4Piece == 0) {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part contains a non-ASCII digit.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, set ipv4Piece to ipv4Piece  10 + number.\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tipv4Piece = ipv4Piece * 10 + number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// If ipv4Piece is greater than 255, IPv4-in-IPv6-out-of-range-part validation error, return failure.\n\t\t\t\t\t\t\tif (ipv4Piece > 255) {\n\t\t\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 part exceeds 255.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Increase pointer by 1.\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Set address[pieceIndex] to address[pieceIndex]  0x100 + ipv4Piece.\n\t\t\t\t\t\taddress[pieceIndex] = address[pieceIndex] * 0x100 + (ipv4Piece != null ? ipv4Piece : 0);\n\t\t\t\t\t\t// Increase numbersSeen by 1.\n\t\t\t\t\t\tnumbersSeen++;\n\t\t\t\t\t\t// If numbersSeen is 2 or 4, then increase pieceIndex by 1.\n\t\t\t\t\t\tif (numbersSeen == 2 || numbersSeen == 4) {\n\t\t\t\t\t\t\tpieceIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t}\n\t\t\t\t\t// If numbersSeen is not 4, IPv4-in-IPv6-too-few-parts validation error, return failure.\n\t\t\t\t\tif (numbersSeen != 4) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address with IPv4 address syntax: IPv4 address contains too few parts.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Break.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Otherwise, if c is U+003A (:):\n\t\t\t\telse if (c == ':') {\n\t\t\t\t\t// Increase pointer by 1.\n\t\t\t\t\tpointer++;\n\t\t\t\t\tc = (pointer < inputLength) ? input.codePointAt(pointer) : EOF;\n\t\t\t\t\t// If c is the EOF code point, IPv6-invalid-code-point validation error, return failure.\n\t\t\t\t\tif (c == EOF) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address unexpectedly ends.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, if c is not the EOF code point, IPv6-invalid-code-point validation error, return failure.\n\t\t\t\telse if (c != EOF) {\n\t\t\t\t\tthrow new InvalidUrlException(\"IPv6 address contains \\\"\" + Character.toString(c) + \"\\\", which is neither an ASCII hex digit nor a ':'.\");\n\t\t\t\t}\n\t\t\t\t// Set address[pieceIndex] to value.\n\t\t\t\taddress[pieceIndex] = value;\n\t\t\t\t// Increase pieceIndex by 1.\n\t\t\t\tpieceIndex++;\n\t\t\t}\n\t\t\t// If compress is non-null, then:\n\t\t\tif (compress != null) {\n\t\t\t\t// Let swaps be pieceIndex  compress.\n\t\t\t\tint swaps = pieceIndex - compress;\n\t\t\t\t// Set pieceIndex to 7.\n\t\t\t\tpieceIndex = 7;\n\t\t\t\t// While pieceIndex is not 0 and swaps is greater than 0, swap address[pieceIndex] with address[compress + swaps  1], and then decrease both pieceIndex and swaps by 1.\n\t\t\t\twhile (pieceIndex != 0 && swaps > 0) {\n\t\t\t\t\tint tmp = address[pieceIndex];\n\t\t\t\t\taddress[pieceIndex] = address[compress + swaps - 1];\n\t\t\t\t\taddress[compress + swaps - 1] = tmp;\n\t\t\t\t\tpieceIndex--;\n\t\t\t\t\tswaps--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, if compress is null and pieceIndex is not 8, IPv6-too-few-pieces validation error, return failure.\n\t\t\telse if (compress == null && pieceIndex != 8) {\n\t\t\t\tthrow new InvalidUrlException(\"An uncompressed IPv6 address contains fewer than 8 pieces.\");\n\t\t\t}\n\t\t\t// Return address.\n\t\t\treturn new Ipv6Address(address);\n\t\t}",
    "query": "Implement a REST endpoint in your Spring application that receives a string representing an IPv6 address from the client, validates its correctness, and converts it into a structured object for internal processing. Ensure that invalid inputs are properly handled and informative error messages are returned.",
    "function_signature": "public Ipv6Address processIpv6Input(String ipv6Input)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.FieldError#hashCode()",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public int hashCode()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic int hashCode() {\n\t\tint hashCode = super.hashCode();\n\t\thashCode = 29 * hashCode + getField().hashCode();\n\t\thashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(getRejectedValue());\n\t\thashCode = 29 * hashCode + (isBindingFailure() ? 1 : 0);\n\t\treturn hashCode;\n\t}",
    "query": "Design a feature that aggregates and identifies unique validation issues from user input across multiple forms, ensuring that each distinct error is processed only once regardless of how many times it occurs.",
    "function_signature": "public Set<FieldError> collectUniqueValidationErrors(BindingResult bindingResult)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler#isDone()",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public boolean isDone()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic boolean isDone() {\n\t\t\treturn this.future.isDone();\n\t\t}",
    "query": "In a web application, ensure that a batch of scheduled data processing jobs has fully completed before sending a summary report to the user. The system should efficiently verify the completion status of each asynchronous task without blocking the main execution thread.",
    "function_signature": "public boolean verifyAllProcessingJobsCompleted()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.test.context.web.WebMergedContextConfiguration#toString()",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public String toString()",
    "documentation": "\t/**\n\t * Provide a String representation of the {@linkplain #getTestClass() test class},\n\t * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},\n\t * {@linkplain #getContextInitializerClasses() context initializer classes},\n\t * {@linkplain #getActiveProfiles() active profiles},\n\t * {@linkplain #getPropertySourceDescriptors() property source descriptors},\n\t * {@linkplain #getPropertySourceProperties() property source properties},\n\t * {@linkplain #getContextCustomizers() context customizers},\n\t * {@linkplain #getResourceBasePath() resource base path}, the name of the\n\t * {@link #getContextLoader() ContextLoader}, and the\n\t * {@linkplain #getParent() parent configuration}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\treturn new ToStringCreator(this, new DefaultToStringStyler(new SimpleValueStyler()))\n\t\t\t\t.append(\"testClass\", getTestClass())\n\t\t\t\t.append(\"locations\", getLocations())\n\t\t\t\t.append(\"classes\", getClasses())\n\t\t\t\t.append(\"contextInitializerClasses\", getContextInitializerClasses())\n\t\t\t\t.append(\"activeProfiles\", getActiveProfiles())\n\t\t\t\t.append(\"propertySourceDescriptors\", getPropertySourceDescriptors())\n\t\t\t\t.append(\"propertySourceProperties\", getPropertySourceProperties())\n\t\t\t\t.append(\"contextCustomizers\", getContextCustomizers())\n\t\t\t\t.append(\"resourceBasePath\", getResourceBasePath())\n\t\t\t\t.append(\"contextLoader\", (getContextLoader() != null ? getContextLoader().getClass() : null))\n\t\t\t\t.append(\"parent\", getParent())\n\t\t\t\t.toString();\n\t}",
    "query": "Design a testing utility for your Spring web application that captures and logs all aspects of the test context configuration, including active profiles and context initializers, to streamline debugging and configuration audits.",
    "function_signature": "public String captureTestContextConfiguration()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#port()",
    "from_version": "v6.1.7",
    "to_version": "v6.2.0-M2",
    "type": "method",
    "signature": "public Port port()",
    "documentation": "\t\t/**\n\t\t * A URLs port is either null, a string representing a 16-bit unsigned integer  that identifies a networking\n\t\t * port, or a string containing a uri template . It is initially {@code null}.\n\t\t */",
    "changetype": "stabilized",
    "source_code": "\t\tpublic Port port() {\n\t\t\treturn this.port;\n\t\t}",
    "query": "Create a REST controller method that processes incoming HTTP requests by retrieving and utilizing the port information from the request URL. Ensure that the method gracefully handles cases where the port is undefined or specified using a URI template.",
    "function_signature": "public Port retrieveRequestPort(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.util.<unknown>#spliterator()",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "public Spliterator<List<V>> spliterator()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic Spliterator<List<V>> spliterator() {\n\t\t\treturn new UnmodifiableValueSpliterator<>(this.delegate.spliterator());\n\t\t}",
    "query": "Design a service method that efficiently handles large batches of related entities by enabling parallel processing of grouped data collections.",
    "function_signature": "public Spliterator<List<Entity>> streamGroupedEntities()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.datasource.DataSourceUtils#doReleaseConnection(con,dataSource)",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "public void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource)",
    "documentation": "\t/**\n\t * Actually close the given Connection, obtained from the given DataSource.\n\t * Same as {@link #releaseConnection}, but throwing the original SQLException.\n\t * <p>Directly accessed by {@link TransactionAwareDataSourceProxy}.\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see #doGetConnection\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) throws SQLException {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (dataSource != null) {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, con)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdoCloseConnection(con, dataSource);\n\t}",
    "query": "Design a method that ensures JDBC connections retrieved from a `DataSource` are properly released. The implementation must account for transactional contexts, preventing the accidental closure of connections managed by ongoing transactions.",
    "function_signature": "public void releaseJdbcConnection(@Nullable Connection connection, @Nullable DataSource dataSource) throws SQLException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aot.generate.DefaultMethodReference#toString()",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "public String toString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String toString() {\n\t\tString methodName = this.method.name;\n\t\tif (isStatic()) {\n\t\t\treturn this.declaringClass + \"::\" + methodName;\n\t\t}\n\t\telse {\n\t\t\treturn ((this.declaringClass != null) ?\n\t\t\t\t\t\"<\" + this.declaringClass + \">\" : \"<instance>\") + \"::\" + methodName;\n\t\t}\n\t}",
    "query": "Create a service that logs concise identifiers for method references used within your Spring application, accurately distinguishing between static and instance methods.",
    "function_signature": "public String generateMethodIdentifier(Object methodReference);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Create a method within your messaging service that exposes the subscription management component, allowing dynamic addition and removal of client subscriptions to support scalable real-time communications.",
    "function_signature": "public SubscriptionRegistry getSubscriptionRegistry()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.WebUtils#getTempDir(servletContext)",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "public File getTempDir(ServletContext servletContext)",
    "documentation": "\t/**\n\t * Return the temporary directory for the current web application,\n\t * as provided by the servlet container.\n\t * @param servletContext the servlet context of the web application\n\t * @return the File representing the temporary directory\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic static File getTempDir(ServletContext servletContext) {\n\t\tAssert.notNull(servletContext, \"ServletContext must not be null\");\n\t\treturn (File) servletContext.getAttribute(TEMP_DIR_CONTEXT_ATTRIBUTE);\n\t}",
    "query": "Create a utility method to retrieve the web application's temporary storage directory for handling transient files during request processing.",
    "function_signature": "public File retrieveTemporaryStorage(ServletContext servletContext)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.reactive.function.server.<unknown>#writeToInternal(exchange,context)",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "protected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tprotected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context) {\n\t\t\treturn this.inserter.insert(exchange.getResponse(), new BodyInserter.Context() {\n\t\t\t\t@Override\n\t\t\t\tpublic List<HttpMessageWriter<?>> messageWriters() {\n\t\t\t\t\treturn context.messageWriters();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Optional<ServerHttpRequest> serverRequest() {\n\t\t\t\t\treturn Optional.of(exchange.getRequest());\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Map<String, Object> hints() {\n\t\t\t\t\thints.put(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix());\n\t\t\t\t\treturn hints;\n\t\t\t\t}\n\t\t\t});\n\t\t}",
    "query": "Create a server-side component in a reactive Spring application that intercepts and processes HTTP responses internally, allowing for additional context-aware modifications before the response is sent to the client.",
    "function_signature": "protected Mono<Void> interceptAndProcessResponse(ServerWebExchange exchange, Context context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.scheduling.support.CronSequenceGenerator#next(date)",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "public Date next(Date date)",
    "documentation": "\t/**\n\t * Get the next {@link Date} in the sequence matching the Cron pattern and\n\t * after the value provided. The return value will have a whole number of\n\t * seconds, and will be after the input value.\n\t * @param date a seed value\n\t * @return the next value matching the pattern\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Date next(Date date) {\n\t\t/*\n\t\tThe plan:\n\n\t\t1 Start with whole second (rounding up if necessary)\n\n\t\t2 If seconds match move on, otherwise find the next match:\n\t\t2.1 If next match is in the next minute then roll forwards\n\n\t\t3 If minute matches move on, otherwise find the next match\n\t\t3.1 If next match is in the next hour then roll forwards\n\t\t3.2 Reset the seconds and go to 2\n\n\t\t4 If hour matches move on, otherwise find the next match\n\t\t4.1 If next match is in the next day then roll forwards,\n\t\t4.2 Reset the minutes and seconds and go to 2\n\t\t*/\n\n\t\tCalendar calendar = new GregorianCalendar();\n\t\tcalendar.setTimeZone(this.timeZone);\n\t\tcalendar.setTime(date);\n\n\t\t// First, just reset the milliseconds and try to calculate from there...\n\t\tcalendar.set(Calendar.MILLISECOND, 0);\n\t\tlong originalTimestamp = calendar.getTimeInMillis();\n\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\n\t\tif (calendar.getTimeInMillis() == originalTimestamp) {\n\t\t\t// We arrived at the original timestamp - round up to the next whole second and try again...\n\t\t\tcalendar.add(Calendar.SECOND, 1);\n\t\t\tdoNext(calendar, calendar.get(Calendar.YEAR));\n\t\t}\n\n\t\treturn calendar.getTime();\n\t}",
    "query": "Design a service method that, given a specific point in time and a cron expression, determines the subsequent execution time for a scheduled task. Ensure the solution efficiently calculates the next valid timestamp based on the cron pattern.",
    "function_signature": "public Date calculateNextExecutionTime(Date currentTime, String cronExpression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "class",
    "signature": "public class BeanDefinitionParserDelegate",
    "documentation": "/**\n * Stateful delegate class used to parse XML bean definitions.\n * Intended for use by both the main parser and any extension\n * {@link BeanDefinitionParser BeanDefinitionParsers} or\n * {@link BeanDefinitionDecorator BeanDefinitionDecorators}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @author Mark Fisher\n * @author Gary Russell\n * @since 2.0\n * @see ParserContext\n * @see DefaultBeanDefinitionDocumentReader\n */",
    "changetype": "stabilized",
    "source_code": "public class BeanDefinitionParserDelegate {\n\n\tpublic static final String BEANS_NAMESPACE_URI = \"http://www.springframework.org/schema/beans\";\n\n\tpublic static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = \",; \";\n\n\t/**\n\t * Value of a T/F attribute that represents true.\n\t * Anything else represents false.\n\t */\n\tpublic static final String TRUE_VALUE = \"true\";\n\n\tpublic static final String FALSE_VALUE = \"false\";\n\n\tpublic static final String DEFAULT_VALUE = \"default\";\n\n\tpublic static final String DESCRIPTION_ELEMENT = \"description\";\n\n\tpublic static final String AUTOWIRE_NO_VALUE = \"no\";\n\n\tpublic static final String AUTOWIRE_BY_NAME_VALUE = \"byName\";\n\n\tpublic static final String AUTOWIRE_BY_TYPE_VALUE = \"byType\";\n\n\tpublic static final String AUTOWIRE_CONSTRUCTOR_VALUE = \"constructor\";\n\n\tpublic static final String AUTOWIRE_AUTODETECT_VALUE = \"autodetect\";\n\n\tpublic static final String NAME_ATTRIBUTE = \"name\";\n\n\tpublic static final String BEAN_ELEMENT = \"bean\";\n\n\tpublic static final String META_ELEMENT = \"meta\";\n\n\tpublic static final String ID_ATTRIBUTE = \"id\";\n\n\tpublic static final String PARENT_ATTRIBUTE = \"parent\";\n\n\tpublic static final String CLASS_ATTRIBUTE = \"class\";\n\n\tpublic static final String ABSTRACT_ATTRIBUTE = \"abstract\";\n\n\tpublic static final String SCOPE_ATTRIBUTE = \"scope\";\n\n\tprivate static final String SINGLETON_ATTRIBUTE = \"singleton\";\n\n\tpublic static final String LAZY_INIT_ATTRIBUTE = \"lazy-init\";\n\n\tpublic static final String AUTOWIRE_ATTRIBUTE = \"autowire\";\n\n\tpublic static final String AUTOWIRE_CANDIDATE_ATTRIBUTE = \"autowire-candidate\";\n\n\tpublic static final String PRIMARY_ATTRIBUTE = \"primary\";\n\n\tpublic static final String DEPENDS_ON_ATTRIBUTE = \"depends-on\";\n\n\tpublic static final String INIT_METHOD_ATTRIBUTE = \"init-method\";\n\n\tpublic static final String DESTROY_METHOD_ATTRIBUTE = \"destroy-method\";\n\n\tpublic static final String FACTORY_METHOD_ATTRIBUTE = \"factory-method\";\n\n\tpublic static final String FACTORY_BEAN_ATTRIBUTE = \"factory-bean\";\n\n\tpublic static final String CONSTRUCTOR_ARG_ELEMENT = \"constructor-arg\";\n\n\tpublic static final String INDEX_ATTRIBUTE = \"index\";\n\n\tpublic static final String TYPE_ATTRIBUTE = \"type\";\n\n\tpublic static final String VALUE_TYPE_ATTRIBUTE = \"value-type\";\n\n\tpublic static final String KEY_TYPE_ATTRIBUTE = \"key-type\";\n\n\tpublic static final String PROPERTY_ELEMENT = \"property\";\n\n\tpublic static final String REF_ATTRIBUTE = \"ref\";\n\n\tpublic static final String VALUE_ATTRIBUTE = \"value\";\n\n\tpublic static final String LOOKUP_METHOD_ELEMENT = \"lookup-method\";\n\n\tpublic static final String REPLACED_METHOD_ELEMENT = \"replaced-method\";\n\n\tpublic static final String REPLACER_ATTRIBUTE = \"replacer\";\n\n\tpublic static final String ARG_TYPE_ELEMENT = \"arg-type\";\n\n\tpublic static final String ARG_TYPE_MATCH_ATTRIBUTE = \"match\";\n\n\tpublic static final String REF_ELEMENT = \"ref\";\n\n\tpublic static final String IDREF_ELEMENT = \"idref\";\n\n\tpublic static final String BEAN_REF_ATTRIBUTE = \"bean\";\n\n\tpublic static final String PARENT_REF_ATTRIBUTE = \"parent\";\n\n\tpublic static final String VALUE_ELEMENT = \"value\";\n\n\tpublic static final String NULL_ELEMENT = \"null\";\n\n\tpublic static final String ARRAY_ELEMENT = \"array\";\n\n\tpublic static final String LIST_ELEMENT = \"list\";\n\n\tpublic static final String SET_ELEMENT = \"set\";\n\n\tpublic static final String MAP_ELEMENT = \"map\";\n\n\tpublic static final String ENTRY_ELEMENT = \"entry\";\n\n\tpublic static final String KEY_ELEMENT = \"key\";\n\n\tpublic static final String KEY_ATTRIBUTE = \"key\";\n\n\tpublic static final String KEY_REF_ATTRIBUTE = \"key-ref\";\n\n\tpublic static final String VALUE_REF_ATTRIBUTE = \"value-ref\";\n\n\tpublic static final String PROPS_ELEMENT = \"props\";\n\n\tpublic static final String PROP_ELEMENT = \"prop\";\n\n\tpublic static final String MERGE_ATTRIBUTE = \"merge\";\n\n\tpublic static final String QUALIFIER_ELEMENT = \"qualifier\";\n\n\tpublic static final String QUALIFIER_ATTRIBUTE_ELEMENT = \"attribute\";\n\n\tpublic static final String DEFAULT_LAZY_INIT_ATTRIBUTE = \"default-lazy-init\";\n\n\tpublic static final String DEFAULT_MERGE_ATTRIBUTE = \"default-merge\";\n\n\tpublic static final String DEFAULT_AUTOWIRE_ATTRIBUTE = \"default-autowire\";\n\n\tpublic static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = \"default-autowire-candidates\";\n\n\tpublic static final String DEFAULT_INIT_METHOD_ATTRIBUTE = \"default-init-method\";\n\n\tpublic static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = \"default-destroy-method\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final XmlReaderContext readerContext;\n\n\tprivate final DocumentDefaultsDefinition defaults = new DocumentDefaultsDefinition();\n\n\tprivate final ParseState parseState = new ParseState();\n\n\t/**\n\t * Stores all used bean names so we can enforce uniqueness on a per\n\t * beans-element basis. Duplicate bean ids/names may not exist within the\n\t * same level of beans element nesting, but may be duplicated across levels.\n\t */\n\tprivate final Set<String> usedNames = new HashSet<>();\n\n\n\t/**\n\t * Create a new BeanDefinitionParserDelegate associated with the supplied\n\t * {@link XmlReaderContext}.\n\t */\n\tpublic BeanDefinitionParserDelegate(XmlReaderContext readerContext) {\n\t\tAssert.notNull(readerContext, \"XmlReaderContext must not be null\");\n\t\tthis.readerContext = readerContext;\n\t}\n\n\n\t/**\n\t * Get the {@link XmlReaderContext} associated with this helper instance.\n\t */\n\tpublic final XmlReaderContext getReaderContext() {\n\t\treturn this.readerContext;\n\t}\n\n\t/**\n\t * Invoke the {@link org.springframework.beans.factory.parsing.SourceExtractor}\n\t * to pull the source metadata from the supplied {@link Element}.\n\t */\n\t@Nullable\n\tprotected Object extractSource(Element ele) {\n\t\treturn this.readerContext.extractSource(ele);\n\t}\n\n\t/**\n\t * Report an error with the given message for the given source element.\n\t */\n\tprotected void error(String message, Node source) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot());\n\t}\n\n\t/**\n\t * Report an error with the given message for the given source element.\n\t */\n\tprotected void error(String message, Element source) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot());\n\t}\n\n\t/**\n\t * Report an error with the given message for the given source element.\n\t */\n\tprotected void error(String message, Element source, Throwable cause) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot(), cause);\n\t}\n\n\n\t/**\n\t * Initialize the default settings assuming a {@code null} parent delegate.\n\t */\n\tpublic void initDefaults(Element root) {\n\t\tinitDefaults(root, null);\n\t}\n\n\t/**\n\t * Initialize the default lazy-init, autowire, dependency check settings,\n\t * init-method, destroy-method and merge settings. Support nested 'beans'\n\t * element use cases by falling back to the given parent in case the\n\t * defaults are not explicitly set locally.\n\t * @see #populateDefaults(DocumentDefaultsDefinition, DocumentDefaultsDefinition, org.w3c.dom.Element)\n\t * @see #getDefaults()\n\t */\n\tpublic void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) {\n\t\tpopulateDefaults(this.defaults, (parent != null ? parent.defaults : null), root);\n\t\tthis.readerContext.fireDefaultsRegistered(this.defaults);\n\t}\n\n\t/**\n\t * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,\n\t * autowire, dependency check settings, init-method, destroy-method and merge settings.\n\t * Support nested 'beans' element use cases by falling back to {@code parentDefaults}\n\t * in case the defaults are not explicitly set locally.\n\t * @param defaults the defaults to populate\n\t * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to\n\t * @param root the root element of the current bean definition document (or nested beans element)\n\t */\n\tprotected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) {\n\t\tString lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tlazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setLazyInit(lazyInit);\n\n\t\tString merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);\n\t\tif (isDefaultValue(merge)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tmerge = (parentDefaults != null ? parentDefaults.getMerge() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setMerge(merge);\n\n\t\tString autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowire)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to 'no'.\n\t\t\tautowire = (parentDefaults != null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);\n\t\t}\n\t\tdefaults.setAutowire(autowire);\n\n\t\tif (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {\n\t\t\tdefaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setInitMethod(parentDefaults.getInitMethod());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setDestroyMethod(parentDefaults.getDestroyMethod());\n\t\t}\n\n\t\tdefaults.setSource(this.readerContext.extractSource(root));\n\t}\n\n\t/**\n\t * Return the defaults definition object.\n\t */\n\tpublic DocumentDefaultsDefinition getDefaults() {\n\t\treturn this.defaults;\n\t}\n\n\t/**\n\t * Return the default settings for bean definitions as indicated within\n\t * the attributes of the top-level {@code <beans/>} element.\n\t */\n\tpublic BeanDefinitionDefaults getBeanDefinitionDefaults() {\n\t\tBeanDefinitionDefaults bdd = new BeanDefinitionDefaults();\n\t\tbdd.setLazyInit(TRUE_VALUE.equalsIgnoreCase(this.defaults.getLazyInit()));\n\t\tbdd.setAutowireMode(getAutowireMode(DEFAULT_VALUE));\n\t\tbdd.setInitMethodName(this.defaults.getInitMethod());\n\t\tbdd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\treturn bdd;\n\t}\n\n\t/**\n\t * Return any patterns provided in the 'default-autowire-candidates'\n\t * attribute of the top-level {@code <beans/>} element.\n\t */\n\t@Nullable\n\tpublic String[] getAutowireCandidatePatterns() {\n\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\treturn (candidatePattern != null ? StringUtils.commaDelimitedListToStringArray(candidatePattern) : null);\n\t}\n\n\n\t/**\n\t * Parses the supplied {@code <bean>} element. May return {@code null}\n\t * if there were errors during parse. Errors are reported to the\n\t * {@link org.springframework.beans.factory.parsing.ProblemReporter}.\n\t */\n\t@Nullable\n\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {\n\t\treturn parseBeanDefinitionElement(ele, null);\n\t}\n\n\t/**\n\t * Parses the supplied {@code <bean>} element. May return {@code null}\n\t * if there were errors during parse. Errors are reported to the\n\t * {@link org.springframework.beans.factory.parsing.ProblemReporter}.\n\t */\n\t@Nullable\n\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n\t\tList<String> aliases = new ArrayList<>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\t\tif (beanDefinition != null) {\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// Register an alias for the plain bean class name, if still possible,\n\t\t\t\t\t\t// if the generator returned the class name plus a suffix.\n\t\t\t\t\t\t// This is expected for Spring 1.2/2.0 backwards compatibility.\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n\t\t\t\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validate that the specified bean name and aliases have not been used already\n\t * within the current level of beans element nesting.\n\t */\n\tprotected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {\n\t\tString foundName = null;\n\n\t\tif (StringUtils.hasText(beanName) && this.usedNames.contains(beanName)) {\n\t\t\tfoundName = beanName;\n\t\t}\n\t\tif (foundName == null) {\n\t\t\tfoundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);\n\t\t}\n\t\tif (foundName != null) {\n\t\t\terror(\"Bean name '\" + foundName + \"' is already used in this <beans> element\", beanElement);\n\t\t}\n\n\t\tthis.usedNames.add(beanName);\n\t\tthis.usedNames.addAll(aliases);\n\t}\n\n\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */\n\t@Nullable\n\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\tparseMetaElements(ele, bd);\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */\n\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}\n\n\t/**\n\t * Create a bean definition for the given class name and parent name.\n\t * @param className the name of the bean class\n\t * @param parentName the name of the bean's parent bean\n\t * @return the newly created bean definition\n\t * @throws ClassNotFoundException if bean class resolution was attempted but failed\n\t */\n\tprotected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\treturn BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\tparentName, className, this.readerContext.getBeanClassLoader());\n\t}\n\n\t/**\n\t * Parse the meta elements underneath the given element, if any.\n\t */\n\tpublic void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {\n\t\tNodeList nl = ele.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\tElement metaElement = (Element) node;\n\t\t\t\tString key = metaElement.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\tString value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);\n\t\t\t\tattribute.setSource(extractSource(metaElement));\n\t\t\t\tattributeAccessor.addMetadataAttribute(attribute);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse the given autowire attribute value into\n\t * {@link AbstractBeanDefinition} autowire constants.\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic int getAutowireMode(String attrValue) {\n\t\tString attr = attrValue;\n\t\tif (isDefaultValue(attr)) {\n\t\t\tattr = this.defaults.getAutowire();\n\t\t}\n\t\tint autowire = AbstractBeanDefinition.AUTOWIRE_NO;\n\t\tif (AUTOWIRE_BY_NAME_VALUE.equals(attr)) {\n\t\t\tautowire = AbstractBeanDefinition.AUTOWIRE_BY_NAME;\n\t\t}\n\t\telse if (AUTOWIRE_BY_TYPE_VALUE.equals(attr)) {\n\t\t\tautowire = AbstractBeanDefinition.AUTOWIRE_BY_TYPE;\n\t\t}\n\t\telse if (AUTOWIRE_CONSTRUCTOR_VALUE.equals(attr)) {\n\t\t\tautowire = AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR;\n\t\t}\n\t\telse if (AUTOWIRE_AUTODETECT_VALUE.equals(attr)) {\n\t\t\tautowire = AbstractBeanDefinition.AUTOWIRE_AUTODETECT;\n\t\t}\n\t\t// Else leave default value.\n\t\treturn autowire;\n\t}\n\n\t/**\n\t * Parse constructor-arg sub-elements of the given bean element.\n\t */\n\tpublic void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n\t\t\t\tparseConstructorArgElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse property sub-elements of the given bean element.\n\t */\n\tpublic void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n\t\t\t\tparsePropertyElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse qualifier sub-elements of the given bean element.\n\t */\n\tpublic void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ELEMENT)) {\n\t\t\t\tparseQualifierElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse lookup-override sub-elements of the given bean element.\n\t */\n\tpublic void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {\n\t\t\t\tElement ele = (Element) node;\n\t\t\t\tString methodName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString beanRef = ele.getAttribute(BEAN_ELEMENT);\n\t\t\t\tLookupOverride override = new LookupOverride(methodName, beanRef);\n\t\t\t\toverride.setSource(extractSource(ele));\n\t\t\t\toverrides.addOverride(override);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse replaced-method sub-elements of the given bean element.\n\t */\n\tpublic void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {\n\t\t\t\tElement replacedMethodEle = (Element) node;\n\t\t\t\tString name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n\t\t\t\tReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n\t\t\t\t// Look for arg-type match elements.\n\t\t\t\tList<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n\t\t\t\tfor (Element argTypeEle : argTypeEles) {\n\t\t\t\t\tString match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n\t\t\t\t\tmatch = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));\n\t\t\t\t\tif (StringUtils.hasText(match)) {\n\t\t\t\t\t\treplaceOverride.addTypeIdentifier(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treplaceOverride.setSource(extractSource(replacedMethodEle));\n\t\t\t\toverrides.addOverride(replaceOverride);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse a constructor-arg element.\n\t */\n\tpublic void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n\t\tString indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n\t\tString typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (StringUtils.hasLength(indexAttr)) {\n\t\t\ttry {\n\t\t\t\tint index = Integer.parseInt(indexAttr);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\terror(\"'index' cannot be lower than 0\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry(index));\n\t\t\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\t\t\tif (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {\n\t\t\t\t\t\t\terror(\"Ambiguous constructor-arg entries for index \" + index, ele);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tthis.parseState.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\terror(\"Attribute 'index' of tag 'constructor-arg' must be an integer\", ele);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry());\n\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t}\n\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.parseState.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse a property element.\n\t */\n\tpublic void parsePropertyElement(Element ele, BeanDefinition bd) {\n\t\tString propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(propertyName)) {\n\t\t\terror(\"Tag 'property' must have a 'name' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new PropertyEntry(propertyName));\n\t\ttry {\n\t\t\tif (bd.getPropertyValues().contains(propertyName)) {\n\t\t\t\terror(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject val = parsePropertyValue(ele, bd, propertyName);\n\t\t\tPropertyValue pv = new PropertyValue(propertyName, val);\n\t\t\tparseMetaElements(ele, pv);\n\t\t\tpv.setSource(extractSource(ele));\n\t\t\tbd.getPropertyValues().addPropertyValue(pv);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}\n\n\t/**\n\t * Parse a qualifier element.\n\t */\n\tpublic void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {\n\t\tString typeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(typeName)) {\n\t\t\terror(\"Tag 'qualifier' must have a 'type' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new QualifierEntry(typeName));\n\t\ttry {\n\t\t\tAutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);\n\t\t\tqualifier.setSource(extractSource(ele));\n\t\t\tString value = ele.getAttribute(VALUE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasLength(value)) {\n\t\t\t\tqualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);\n\t\t\t}\n\t\t\tNodeList nl = ele.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {\n\t\t\t\t\tElement attributeEle = (Element) node;\n\t\t\t\t\tString attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\t\tString attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\t\tif (StringUtils.hasLength(attributeName) && StringUtils.hasLength(attributeValue)) {\n\t\t\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);\n\t\t\t\t\t\tattribute.setSource(extractSource(attributeEle));\n\t\t\t\t\t\tqualifier.addMetadataAttribute(attribute);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\terror(\"Qualifier 'attribute' tag must have a 'name' and 'value'\", attributeEle);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbd.addQualifier(qualifier);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}\n\n\t/**\n\t * Get the value of a property element. May be a list etc.\n\t * Also used for constructor arguments, \"propertyName\" being null in this case.\n\t */\n\t@Nullable\n\tpublic Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n\t\tString elementName = (propertyName != null ?\n\t\t\t\t\"<property> element for property '\" + propertyName + \"'\" :\n\t\t\t\t\"<constructor-arg> element\");\n\n\t\t// Should only have one child element: ref, value, list, etc.\n\t\tNodeList nl = ele.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element currentElement && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&\n\t\t\t\t\t!nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(elementName + \" must not contain more than one sub-element\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = currentElement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n\t\tboolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\t\tif ((hasRefAttribute && hasValueAttribute) ||\n\t\t\t\t((hasRefAttribute || hasValueAttribute) && subElement != null)) {\n\t\t\terror(elementName +\n\t\t\t\t\t\" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n\t\t}\n\n\t\tif (hasRefAttribute) {\n\t\t\tString refName = ele.getAttribute(REF_ATTRIBUTE);\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(elementName + \" contains empty 'ref' attribute\", ele);\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (hasValueAttribute) {\n\t\t\tTypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\treturn valueHolder;\n\t\t}\n\t\telse if (subElement != null) {\n\t\t\treturn parsePropertySubElement(subElement, bd);\n\t\t}\n\t\telse {\n\t\t\t// Neither child element nor \"ref\" or \"value\" attribute found.\n\t\t\terror(elementName + \" must specify a ref or value\", ele);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t */\n\t@Nullable\n\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n\t\treturn parsePropertySubElement(ele, bd, null);\n\t}\n\n\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t * @param defaultValueType the default type (class name) for any\n\t * {@code <value>} tag that might be created\n\t */\n\t@Nullable\n\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {\n\t\tif (!isDefaultNamespace(ele)) {\n\t\t\treturn parseNestedCustomElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t\tBeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n\t\t\tif (nestedBd != null) {\n\t\t\t\tnestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n\t\t\t}\n\t\t\treturn nestedBd;\n\t\t}\n\t\telse if (nodeNameEquals(ele, REF_ELEMENT)) {\n\t\t\t// A generic reference to any name of any bean.\n\t\t\tString refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n\t\t\tboolean toParent = false;\n\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t// A reference to the id of another bean in a parent context.\n\t\t\t\trefName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n\t\t\t\ttoParent = true;\n\t\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t\terror(\"'bean' or 'parent' is required for <ref> element\", ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(\"<ref> element contains empty target attribute\", ele);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n\t\t\treturn parseIdRefElement(ele);\n\t\t}\n\t\telse if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n\t\t\treturn parseValueElement(ele, defaultValueType);\n\t\t}\n\t\telse if (nodeNameEquals(ele, NULL_ELEMENT)) {\n\t\t\t// It's a distinguished null value. Let's wrap it in a TypedStringValue\n\t\t\t// object in order to preserve the source location.\n\t\t\tTypedStringValue nullHolder = new TypedStringValue(null);\n\t\t\tnullHolder.setSource(extractSource(ele));\n\t\t\treturn nullHolder;\n\t\t}\n\t\telse if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n\t\t\treturn parseArrayElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, LIST_ELEMENT)) {\n\t\t\treturn parseListElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, SET_ELEMENT)) {\n\t\t\treturn parseSetElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, MAP_ELEMENT)) {\n\t\t\treturn parseMapElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n\t\t\treturn parsePropsElement(ele);\n\t\t}\n\t\telse {\n\t\t\terror(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return a typed String value Object for the given 'idref' element.\n\t */\n\t@Nullable\n\tpublic Object parseIdRefElement(Element ele) {\n\t\t// A generic reference to any name of any bean.\n\t\tString refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\terror(\"'bean' is required for <idref> element\", ele);\n\t\t\treturn null;\n\t\t}\n\t\tif (!StringUtils.hasText(refName)) {\n\t\t\terror(\"<idref> element contains empty target attribute\", ele);\n\t\t\treturn null;\n\t\t}\n\t\tRuntimeBeanNameReference ref = new RuntimeBeanNameReference(refName);\n\t\tref.setSource(extractSource(ele));\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Return a typed String value Object for the given value element.\n\t */\n\tpublic Object parseValueElement(Element ele, @Nullable String defaultTypeName) {\n\t\t// It's a literal value.\n\t\tString value = DomUtils.getTextValue(ele);\n\t\tString specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString typeName = specifiedTypeName;\n\t\tif (!StringUtils.hasText(typeName)) {\n\t\t\ttypeName = defaultTypeName;\n\t\t}\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, typeName);\n\t\t\ttypedValue.setSource(extractSource(ele));\n\t\t\ttypedValue.setSpecifiedTypeName(specifiedTypeName);\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + typeName + \"] not found for <value> element\", ele, ex);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */\n\tprotected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\tClassLoader classLoader = this.readerContext.getBeanClassLoader();\n\t\tTypedStringValue typedValue;\n\t\tif (!StringUtils.hasText(targetTypeName)) {\n\t\t\ttypedValue = new TypedStringValue(value);\n\t\t}\n\t\telse if (classLoader != null) {\n\t\t\tClass<?> targetType = ClassUtils.forName(targetTypeName, classLoader);\n\t\t\ttypedValue = new TypedStringValue(value, targetType);\n\t\t}\n\t\telse {\n\t\t\ttypedValue = new TypedStringValue(value, targetTypeName);\n\t\t}\n\t\treturn typedValue;\n\t}\n\n\t/**\n\t * Parse an array element.\n\t */\n\tpublic Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {\n\t\tString elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = arrayEle.getChildNodes();\n\t\tManagedArray target = new ManagedArray(elementType, nl.getLength());\n\t\ttarget.setSource(extractSource(arrayEle));\n\t\ttarget.setElementTypeName(elementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(arrayEle));\n\t\tparseCollectionElements(nl, target, bd, elementType);\n\t\treturn target;\n\t}\n\n\t/**\n\t * Parse a list element.\n\t */\n\tpublic List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedList<Object> target = new ManagedList<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}\n\n\t/**\n\t * Parse a set element.\n\t */\n\tpublic Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedSet<Object> target = new ManagedSet<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}\n\n\tprotected void parseCollectionElements(\n\t\t\tNodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType) {\n\n\t\tfor (int i = 0; i < elementNodes.getLength(); i++) {\n\t\t\tNode node = elementNodes.item(i);\n\t\t\tif (node instanceof Element currentElement && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {\n\t\t\t\ttarget.add(parsePropertySubElement(currentElement, bd, defaultElementType));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parse a map element.\n\t */\n\tpublic Map<Object, Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {\n\t\tString defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);\n\t\tString defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\n\t\tList<Element> entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);\n\t\tManagedMap<Object, Object> map = new ManagedMap<>(entryEles.size());\n\t\tmap.setSource(extractSource(mapEle));\n\t\tmap.setKeyTypeName(defaultKeyType);\n\t\tmap.setValueTypeName(defaultValueType);\n\t\tmap.setMergeEnabled(parseMergeAttribute(mapEle));\n\n\t\tfor (Element entryEle : entryEles) {\n\t\t\t// Should only have one value child element: ref, value, list, etc.\n\t\t\t// Optionally, there might be a key child element.\n\t\t\tNodeList entrySubNodes = entryEle.getChildNodes();\n\t\t\tElement keyEle = null;\n\t\t\tElement valueEle = null;\n\t\t\tfor (int j = 0; j < entrySubNodes.getLength(); j++) {\n\t\t\t\tNode node = entrySubNodes.item(j);\n\t\t\t\tif (node instanceof Element candidateEle) {\n\t\t\t\t\tif (nodeNameEquals(candidateEle, KEY_ELEMENT)) {\n\t\t\t\t\t\tif (keyEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element is only allowed to contain one <key> sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tkeyEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Child element is what we're looking for.\n\t\t\t\t\t\tif (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {\n\t\t\t\t\t\t\t// the element is a <description> -> ignore it\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (valueEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element must not contain more than one value sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvalueEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extract key from attribute or sub-element.\n\t\t\tObject key = null;\n\t\t\tboolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);\n\t\t\tboolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);\n\t\t\tif ((hasKeyAttribute && hasKeyRefAttribute) ||\n\t\t\t\t\t(hasKeyAttribute || hasKeyRefAttribute) && keyEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"a 'key' attribute OR a 'key-ref' attribute OR a <key> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif (hasKeyAttribute) {\n\t\t\t\tkey = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);\n\t\t\t}\n\t\t\telse if (hasKeyRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'key-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tkey = ref;\n\t\t\t}\n\t\t\telse if (keyEle != null) {\n\t\t\t\tkey = parseKeyElement(keyEle, bd, defaultKeyType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a key\", entryEle);\n\t\t\t}\n\n\t\t\t// Extract value from attribute or sub-element.\n\t\t\tObject value = null;\n\t\t\tboolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);\n\t\t\tboolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\tboolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\tif ((hasValueAttribute && hasValueRefAttribute) ||\n\t\t\t\t\t(hasValueAttribute || hasValueRefAttribute) && valueEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"'value' attribute OR 'value-ref' attribute OR <value> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif ((hasValueTypeAttribute && hasValueRefAttribute) ||\n\t\t\t\t(hasValueTypeAttribute && !hasValueAttribute) ||\n\t\t\t\t\t(hasValueTypeAttribute && valueEle != null)) {\n\t\t\t\terror(\"<entry> element is only allowed to contain a 'value-type' \" +\n\t\t\t\t\t\t\"attribute when it has a 'value' attribute\", entryEle);\n\t\t\t}\n\t\t\tif (hasValueAttribute) {\n\t\t\t\tString valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(valueType)) {\n\t\t\t\t\tvalueType = defaultValueType;\n\t\t\t\t}\n\t\t\t\tvalue = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);\n\t\t\t}\n\t\t\telse if (hasValueRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'value-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tvalue = ref;\n\t\t\t}\n\t\t\telse if (valueEle != null) {\n\t\t\t\tvalue = parsePropertySubElement(valueEle, bd, defaultValueType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a value\", entryEle);\n\t\t\t}\n\n\t\t\t// Add final key and value to the Map.\n\t\t\tmap.put(key, value);\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */\n\tprotected final Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle) {\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, defaultTypeName);\n\t\t\ttypedValue.setSource(extractSource(entryEle));\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + defaultTypeName + \"] not found for Map key/value type\", entryEle, ex);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a key sub-element of a map element.\n\t */\n\t@Nullable\n\tprotected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName) {\n\t\tNodeList nl = keyEle.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element currentElement) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(\"<key> element must not contain more than one value sub-element\", keyEle);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = currentElement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (subElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsePropertySubElement(subElement, bd, defaultKeyTypeName);\n\t}\n\n\t/**\n\t * Parse a props element.\n\t */\n\tpublic Properties parsePropsElement(Element propsEle) {\n\t\tManagedProperties props = new ManagedProperties();\n\t\tprops.setSource(extractSource(propsEle));\n\t\tprops.setMergeEnabled(parseMergeAttribute(propsEle));\n\n\t\tList<Element> propEles = DomUtils.getChildElementsByTagName(propsEle, PROP_ELEMENT);\n\t\tfor (Element propEle : propEles) {\n\t\t\tString key = propEle.getAttribute(KEY_ATTRIBUTE);\n\t\t\t// Trim the text value to avoid unwanted whitespace\n\t\t\t// caused by typical XML formatting.\n\t\t\tString value = DomUtils.getTextValue(propEle).trim();\n\t\t\tTypedStringValue keyHolder = new TypedStringValue(key);\n\t\t\tkeyHolder.setSource(extractSource(propEle));\n\t\t\tTypedStringValue valueHolder = new TypedStringValue(value);\n\t\t\tvalueHolder.setSource(extractSource(propEle));\n\t\t\tprops.put(keyHolder, valueHolder);\n\t\t}\n\n\t\treturn props;\n\t}\n\n\t/**\n\t * Parse the merge attribute of a collection element, if any.\n\t */\n\tpublic boolean parseMergeAttribute(Element collectionElement) {\n\t\tString value = collectionElement.getAttribute(MERGE_ATTRIBUTE);\n\t\tif (isDefaultValue(value)) {\n\t\t\tvalue = this.defaults.getMerge();\n\t\t}\n\t\treturn TRUE_VALUE.equals(value);\n\t}\n\n\t/**\n\t * Parse a custom element (outside the default namespace).\n\t * @param ele the element to parse\n\t * @return the resulting bean definition\n\t */\n\t@Nullable\n\tpublic BeanDefinition parseCustomElement(Element ele) {\n\t\treturn parseCustomElement(ele, null);\n\t}\n\n\t/**\n\t * Parse a custom element (outside the default namespace).\n\t * @param ele the element to parse\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the resulting bean definition\n\t */\n\t@Nullable\n\tpublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\tif (namespaceUri == null) {\n\t\t\treturn null;\n\t\t}\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}\n\n\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @return the decorated bean definition\n\t */\n\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {\n\t\treturn decorateBeanDefinitionIfRequired(ele, originalDef, null);\n\t}\n\n\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */\n\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n\t\t\tElement ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tBeanDefinitionHolder finalDefinition = originalDef;\n\n\t\t// Decorate based on custom attributes first.\n\t\tNamedNodeMap attributes = ele.getAttributes();\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tNode node = attributes.item(i);\n\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t}\n\n\t\t// Decorate based on custom nested elements.\n\t\tNodeList children = ele.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode node = children.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t\t}\n\t\t}\n\t\treturn finalDefinition;\n\t}\n\n\t/**\n\t * Decorate the given bean definition through a namespace handler,\n\t * if applicable.\n\t * @param node the current child node\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */\n\tpublic BeanDefinitionHolder decorateIfRequired(\n\t\t\tNode node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tString namespaceUri = getNamespaceURI(node);\n\t\tif (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {\n\t\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\t\tif (handler != null) {\n\t\t\t\tBeanDefinitionHolder decorated =\n\t\t\t\t\t\thandler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));\n\t\t\t\tif (decorated != null) {\n\t\t\t\t\treturn decorated;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (namespaceUri.startsWith(\"http://www.springframework.org/schema/\")) {\n\t\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A custom namespace, not to be handled by Spring - maybe \"xml:...\".\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No Spring NamespaceHandler found for XML schema namespace [\" + namespaceUri + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn originalDef;\n\t}\n\n\t@Nullable\n\tprivate BeanDefinitionHolder parseNestedCustomElement(Element ele, @Nullable BeanDefinition containingBd) {\n\t\tBeanDefinition innerDefinition = parseCustomElement(ele, containingBd);\n\t\tif (innerDefinition == null) {\n\t\t\terror(\"Incorrect usage of element '\" + ele.getNodeName() + \"' in a nested manner. \" +\n\t\t\t\t\t\"This tag cannot be used nested inside <property>.\", ele);\n\t\t\treturn null;\n\t\t}\n\t\tString id = ele.getNodeName() + BeanDefinitionReaderUtils.GENERATED_BEAN_NAME_SEPARATOR +\n\t\t\t\tObjectUtils.getIdentityHexString(innerDefinition);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Using generated bean name [\" + id +\n\t\t\t\t\t\"] for nested custom element '\" + ele.getNodeName() + \"'\");\n\t\t}\n\t\treturn new BeanDefinitionHolder(innerDefinition, id);\n\t}\n\n\n\t/**\n\t * Get the namespace URI for the supplied node.\n\t * <p>The default implementation uses {@link Node#getNamespaceURI}.\n\t * Subclasses may override the default implementation to provide a\n\t * different namespace identification mechanism.\n\t * @param node the node\n\t */\n\t@Nullable\n\tpublic String getNamespaceURI(Node node) {\n\t\treturn node.getNamespaceURI();\n\t}\n\n\t/**\n\t * Get the local name for the supplied {@link Node}.\n\t * <p>The default implementation calls {@link Node#getLocalName}.\n\t * Subclasses may override the default implementation to provide a\n\t * different mechanism for getting the local name.\n\t * @param node the {@code Node}\n\t */\n\tpublic String getLocalName(Node node) {\n\t\treturn node.getLocalName();\n\t}\n\n\t/**\n\t * Determine whether the name of the supplied node is equal to the supplied name.\n\t * <p>The default implementation checks the supplied desired name against both\n\t * {@link Node#getNodeName()} and {@link Node#getLocalName()}.\n\t * <p>Subclasses may override the default implementation to provide a different\n\t * mechanism for comparing node names.\n\t * @param node the node to compare\n\t * @param desiredName the name to check for\n\t */\n\tpublic boolean nodeNameEquals(Node node, String desiredName) {\n\t\treturn desiredName.equals(node.getNodeName()) || desiredName.equals(getLocalName(node));\n\t}\n\n\t/**\n\t * Determine whether the given URI indicates the default namespace.\n\t */\n\tpublic boolean isDefaultNamespace(@Nullable String namespaceUri) {\n\t\treturn !StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri);\n\t}\n\n\t/**\n\t * Determine whether the given node indicates the default namespace.\n\t */\n\tpublic boolean isDefaultNamespace(Node node) {\n\t\treturn isDefaultNamespace(getNamespaceURI(node));\n\t}\n\n\tprivate boolean isDefaultValue(String value) {\n\t\treturn !StringUtils.hasLength(value) || DEFAULT_VALUE.equals(value);\n\t}\n\n\tprivate boolean isCandidateElement(Node node) {\n\t\treturn (node instanceof Element && (isDefaultNamespace(node) || !isDefaultNamespace(node.getParentNode())));\n\t}\n\n}",
    "query": "Design a custom XML configuration parser that delegates the handling of specialized bean elements to a dedicated component, ensuring efficient parsing and registration of complex bean definitions within your Spring application.",
    "function_signature": "public BeanDefinitionHolder parseCustomBeanElement(Element element, ParsingDelegate delegate)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.rsocket.<unknown>#rsocketClient()",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "method",
    "signature": "public RSocketClient rsocketClient()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic RSocketClient rsocketClient() {\n\t\treturn this.rsocketClient;\n\t}",
    "query": "Design a service component that requires establishing a reactive client to manage real-time, bidirectional communication channels with external systems efficiently.",
    "function_signature": "public RSocketClient createReactiveConnection()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.http.client.PartBuilder",
    "from_version": "v5.2.23.RELEASE",
    "to_version": "v6.0.8",
    "type": "interface",
    "signature": "public interface PartBuilder",
    "documentation": "\t/**\n\t * Builder that allows for further customization of part headers.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic interface PartBuilder {\n\n\t\t/**\n\t\t * Set the {@linkplain MediaType media type} of the part.\n\t\t * @param contentType the content type\n\t\t * @since 5.2\n\t\t * @see HttpHeaders#setContentType(MediaType)\n\t\t */\n\t\tPartBuilder contentType(MediaType contentType);\n\n\t\t/**\n\t\t * Set the filename parameter for a file part. This should not be\n\t\t * necessary with {@link org.springframework.core.io.Resource Resource}\n\t\t * based parts that expose a filename but may be useful for\n\t\t * {@link Publisher} parts.\n\t\t * @param filename the filename to set on the Content-Disposition\n\t\t * @since 5.2\n\t\t */\n\t\tPartBuilder filename(String filename);\n\n\t\t/**\n\t\t * Add part header values.\n\t\t * @param headerName the part header name\n\t\t * @param headerValues the part header value(s)\n\t\t * @return this builder\n\t\t * @see HttpHeaders#addAll(String, List)\n\t\t */\n\t\tPartBuilder header(String headerName, String... headerValues);\n\n\t\t/**\n\t\t * Manipulate the part headers through the given consumer.\n\t\t * @param headersConsumer consumer to manipulate the part headers with\n\t\t * @return this builder\n\t\t */\n\t\tPartBuilder headers(Consumer<HttpHeaders> headersConsumer);\n\t}",
    "query": "How can you implement a method to add a multipart file with custom headers, allowing dynamic configuration of the part's media type and filename?",
    "function_signature": "public void addMultipartFile(String partName, Resource file, Consumer<HttpHeaders> headersCustomizer);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#registerSubscriptions(sessionId,destination)",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "method",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}",
    "query": "Design a feature for a real-time collaborative application where users can dynamically subscribe to various data streams based on their roles and permissions. Ensure that the subscription handling efficiently manages both specific and pattern-based destinations to accommodate scalable and flexible communication channels.",
    "function_signature": "public void manageUserSubscriptions(String userSessionId, String topicDestination)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.findDestination",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "field",
    "signature": "public String findDestination",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String findDestination;",
    "query": "Design a method within a messaging service that efficiently determines the appropriate routing path for incoming WebSocket messages by leveraging the latest destination resolution enhancements in the Spring Framework.",
    "function_signature": "public String resolveRoutingPath(Message<?> incomingMessage)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a method that sets up the message broker with a specific array of destination identifiers to streamline message routing for subscribed clients.",
    "function_signature": "public void configureBrokerDestinationIds(String[] destinationIds)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessionIds",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "field",
    "signature": "public String[] sessionIds",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String[] sessionIds;",
    "query": "Develop a feature that dispatches a real-time alert to all currently connected WebSocket clients, ensuring each active session receives the update promptly.",
    "function_signature": "public void dispatchAlertToAllSessions(String alertMessage, String[] sessionIds)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.uniqueIdGenerator",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "field",
    "signature": "public AtomicInteger uniqueIdGenerator",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic AtomicInteger uniqueIdGenerator;",
    "query": "Design a message broadcasting service that assigns a unique, thread-safe identifier to each outgoing message to track delivery status efficiently.",
    "function_signature": "public void broadcastMessage(String content, int uniqueId)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Implement a feature that fetches and processes all path patterns associated with a specific interceptor to dynamically adjust its behavior.",
    "function_signature": "public void processInterceptorPathPatterns(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.registry",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "field",
    "signature": "public DefaultSubscriptionRegistry registry",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic DefaultSubscriptionRegistry registry;",
    "query": "Develop a service that can monitor and manage active WebSocket subscriptions dynamically, allowing for real-time updates and scalability.",
    "function_signature": "public SubscriptionRegistry getSubscriptionRegistry();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic int sessions;",
    "query": "Develop a monitoring tool that offers real-time visibility into the number of active client connections within your messaging infrastructure, allowing administrators to track and analyze usage trends effectively.",
    "function_signature": "public int getCurrentActiveSessions();"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPatternString()",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "method",
    "signature": "public String getPatternString()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}",
    "query": "Design a feature that records and analyzes the URL patterns associated with each interceptor in your Spring MVC application to enhance monitoring and debugging capabilities.",
    "function_signature": "public void analyzeInterceptorPatterns(MappedInterceptor interceptor)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.2.16.RELEASE",
    "to_version": "v5.3.10",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "How can you implement a service method that dynamically selects a messaging destination based on subscriber presence or specific routing criteria to enhance the efficiency of a WebSocket communication system?",
    "function_signature": "public String selectMessagingDestination(DestinationSelectionCriteria criteria)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.WebExchangeBindException#getSuppressedFields()",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public String[] getSuppressedFields()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getSuppressedFields() {\n\t\treturn this.bindingResult.getSuppressedFields();\n\t}",
    "query": "Design a solution to capture and manage all critical validation errors in a reactive web application, ensuring thread-safe operations and optimal resource utilization.",
    "function_signature": "public List<String> retrieveValidationErrors()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.context.request.FacesWebRequest#checkNotModified(lastModifiedTimestamp)",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public boolean checkNotModified(long lastModifiedTimestamp)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic boolean checkNotModified(long lastModifiedTimestamp) {\n\t\treturn false;\n\t}",
    "query": "Develop a method to assess whether the content has changed since the client's last request by considering both ETag and the last modified timestamp, enhancing cache validation mechanisms.",
    "function_signature": "public boolean isContentModified(String etag, long lastModifiedTimestamp)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.socket.WebSocketHttpHeaders#entrySet()",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public List<String>>> entrySet()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic Set<Entry<String, List<String>>> entrySet() {\n\t\treturn this.headers.entrySet();\n\t}",
    "query": "Design a method that efficiently aggregates all key-value pairs from a WebSocket connection's header information to facilitate comprehensive logging and analysis.",
    "function_signature": "public Set<Map.Entry<String, List<String>>> aggregateWebSocketHeaderEntries(WebSocketHttpHeaders headers)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.cache.concurrent.ConcurrentMapCache#retrieve(key,valueLoader)",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn CompletableFuture.supplyAsync(() ->\n\t\t\t\t(T) fromStoreValue(this.store.computeIfAbsent(key, k -> toStoreValue(valueLoader.get().join()))));\n\t}",
    "query": "Design an asynchronous caching method that ensures non-blocking data retrieval and enhances thread safety, thereby improving overall application performance and developer experience.",
    "function_signature": "public CompletableFuture<T> fetchAsync(Object key, Supplier<CompletableFuture<T>> valueProvider);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet#getDate(columnLabel,cal)",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public Date getDate(String columnLabel, Calendar cal)",
    "documentation": "\t/**\n\t * @see java.sql.ResultSet#getDate(String, Calendar)\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic @Nullable Date getDate(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getDate(findColumn(columnLabel), cal);\n\t}",
    "query": "Refactor the data retrieval logic to enhance type safety and leverage modern date-time APIs. Implement a method that extracts the date value from the specified column without relying on legacy date representations.",
    "function_signature": "public LocalDate retrieveLocalDate(String columnLabel)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.validation.method.ParameterErrors#getGlobalErrorCount()",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public int getGlobalErrorCount()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic int getGlobalErrorCount() {\n\t\treturn this.errors.getGlobalErrorCount();\n\t}",
    "query": "Create a method that efficiently retrieves the total number of global validation errors from a form submission, ensuring optimal performance and thread safety.",
    "function_signature": "public int countGlobalValidationErrors(BindingResult bindingResult)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.util.<unknown>#get(i)",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public String get(int i)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String get(int i) {\n\t\t\treturn this.segments.get(i).segment();\n\t\t}",
    "query": "Create a utility method that efficiently retrieves a segment from a collection based on its position. Ensure the method emphasizes type safety and optimal performance when accessing elements by their index.",
    "function_signature": "public String fetchSegmentAt(int index)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.bind.support.WebExchangeBindException#getObjectName()",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public String getObjectName()",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic String getObjectName() {\n\t\treturn this.bindingResult.getObjectName();\n\t}",
    "query": "Develop a method to retrieve the identifier of the bound object within a reactive web exchange, ensuring enhanced performance and type safety.",
    "function_signature": "public Optional<String> fetchBoundObjectId(WebExchangeContext context)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jndi.support.SimpleJndiBeanFactory#getBean(name)",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public Object getBean(String name)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic Object getBean(String name) throws BeansException {\n\t\treturn getBean(name, Object.class);\n\t}",
    "query": "Design a service that efficiently retrieves a specific component by its identifier while ensuring type safety and reducing runtime casting errors.",
    "function_signature": "public <T> T fetchComponent(String id, Class<T> componentType)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.orm.hibernate5.HibernateTemplate#isCacheQueries()",
    "from_version": "v7.0.0-M4",
    "to_version": "v6.1.20",
    "type": "method",
    "signature": "public boolean isCacheQueries()",
    "documentation": "\t/**\n\t * Return whether to cache all queries executed by this template.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isCacheQueries() {\n\t\treturn this.cacheQueries;\n\t}",
    "query": "Design a repository method that checks whether your application's data access layer is configured to reuse previously executed database queries, thereby improving performance.",
    "function_signature": "public boolean isQueryReuseEnabled()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinations",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "field",
    "signature": "public int destinations",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int destinations;",
    "query": "Design a method to configure and manage message destinations efficiently, ensuring scalability and maintainability in high-throughput Spring applications.",
    "function_signature": "public void initializeMessageDestinationManager(MessageDestinationManager manager)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int sessions;",
    "query": "Refactor the session management component to enhance performance and ensure thread safety when handling a large number of concurrent user connections.",
    "function_signature": "public int fetchActiveSessionCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.FindRequest",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "class",
    "signature": "public class FindRequest",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}",
    "query": "Craft a method to efficiently locate messaging destinations, enhancing performance and thread safety by utilizing the latest Spring messaging utilities.",
    "function_signature": "public DestinationResolver resolveDestination(String destinationName)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#initPatterns(patterns,parser)",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "method",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(",
    "query": "Design a method to efficiently set up pattern adapters utilizing an up-to-date parsing mechanism, ensuring better performance and maintainability.",
    "function_signature": "public PatternAdapter[] configurePatternAdapters(String[] patterns, PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "class",
    "signature": "public class DefaultSubscriptionRegistryBenchmark",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "public class DefaultSubscriptionRegistryBenchmark {\n\n\t@State(Scope.Benchmark)\n\tpublic static class ServerState {\n\t\t@Param(\"1000\")\n\t\tpublic int sessions;\n\n\t\t@Param(\"10\")\n\t\tpublic int destinations;\n\n\t\t@Param({\"0\", \"1024\"})\n\t\tint cacheSizeLimit;\n\n\t\t@Param({\"none\", \"patternSubscriptions\", \"selectorHeaders\"})\n\t\tString specialization;\n\n\t\tpublic DefaultSubscriptionRegistry registry;\n\n\t\tpublic String[] destinationIds;\n\n\t\tpublic String[] sessionIds;\n\n\t\tpublic AtomicInteger uniqueIdGenerator;\n\n\t\tpublic Message<?> findMessage;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup() {\n\t\t\tthis.findMessage = MessageBuilder.createMessage(\"\",  SimpMessageHeaderAccessor.create().getMessageHeaders());\n\t\t\tthis.uniqueIdGenerator = new AtomicInteger();\n\n\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n\t\t\tthis.registry.setCacheLimit(this.cacheSizeLimit);\n\t\t\tthis.registry.setSelectorHeaderName(\"selectorHeaders\".equals(this.specialization) ? \"someSelector\" : null);\n\n\t\t\tthis.destinationIds = IntStream.range(0, this.destinations)\n\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tthis.sessionIds = IntStream.range(0, this.sessions)\n\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n\t\t\t\t\t.toArray(String[]::new);\n\n\t\t\tfor (String sessionId : this.sessionIds) {\n\t\t\t\tfor (String destinationId : this.destinationIds) {\n\t\t\t\t\tregisterSubscriptions(sessionId, destinationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}\n\n\t@State(Scope.Thread)\n\tpublic static class FindRequest {\n\t\t@Param({\"none\", \"noSubscribers\", \"sameDestination\"})\n\t\tString contention;\n\n\t\tpublic String destination;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Benchmark\n\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}\n\n\t@Benchmark\n\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}\n\n\tpublic static Message<?> subscribeMessage(String sessionId, String subscriptionId, String dest) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.SUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\taccessor.setDestination(dest);\n\t\taccessor.setNativeHeader(\"someSelector\", \"true\");\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n\n\tpublic static Message<?> unsubscribeMessage(String sessionId, String subscriptionId) {\n\t\tSimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create(SimpMessageType.UNSUBSCRIBE);\n\t\taccessor.setSessionId(sessionId);\n\t\taccessor.setSubscriptionId(subscriptionId);\n\t\treturn MessageBuilder.createMessage(\"\", accessor.getMessageHeaders());\n\t}\n}",
    "query": "Design a benchmarking method to evaluate the efficiency of managing client subscriptions in a Spring application, ensuring optimal performance and thread safety with the latest subscription handling mechanism.",
    "function_signature": "public void evaluateSubscriptionPerformance(SubscriptionManager subscriptionManager, BenchmarkConfig config)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a method to efficiently obtain the current messaging destination identifiers, ensuring thread safety and enhancing immutability for better application performance.",
    "function_signature": "public List<String> fetchCurrentDestinationIdentifiers()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a component that executes cleanup operations after a request has been fully processed, ensuring better resource management and error handling.",
    "function_signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destination",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "field",
    "signature": "public String destination",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String destination;",
    "query": "Develop a configuration method that sets up a reliable and efficient strategy for managing message routing, minimizing potential concurrency issues and enhancing overall system performance.",
    "function_signature": "public void configureMessageRoutingStrategy(RoutingStrategy strategy)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.handler.annotation.reactive.MessageMappingMessageHandler#registerMessagingAdvice(bean)",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "method",
    "signature": "public void registerMessagingAdvice(MessagingAdviceBean bean)",
    "documentation": "\t/**\n\t * Use this method to register a {@link MessagingAdviceBean} that may contain\n\t * globally applicable\n\t * {@link org.springframework.messaging.handler.annotation.MessageExceptionHandler @MessageExceptionHandler}\n\t * methods.\n\t * <p>Note: spring-messaging does not depend on spring-web and therefore it\n\t * is not possible to explicitly support the registration of a\n\t * {@code @ControllerAdvice} bean. You can use the following adapter code\n\t * to register {@code @ControllerAdvice} beans here:\n\t * <pre>\n\t * ControllerAdviceBean.findAnnotatedBeans(context).forEach(bean -&gt;\n\t *         messageHandler.registerMessagingAdvice(new ControllerAdviceWrapper(bean));\n\t *\n\t * public class ControllerAdviceWrapper implements MessagingAdviceBean {\n\t *     private final ControllerAdviceBean delegate;\n\t *     // delegate all methods\n\t * }\n\t * </pre>\n\t * @param bean the bean to check for {@code @MessageExceptionHandler} methods\n\t * @since 5.3.5\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void registerMessagingAdvice(MessagingAdviceBean bean) {\n\t\tClass<?> type = bean.getBeanType();\n\t\tif (type != null) {\n\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "query": "Design a method to efficiently manage global message exception handling, enhancing performance and maintainability within your reactive messaging setup.",
    "function_signature": "public void configureGlobalExceptionHandler(ControllerAdviceWrapper advice)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor",
    "from_version": "v5.3.20",
    "to_version": "v5.2.22.RELEASE",
    "type": "class",
    "signature": "public class MappedInterceptor",
    "documentation": "/**\n * Wraps a {@link HandlerInterceptor} and uses URL patterns to determine whether\n * it applies to a given request.\n *\n * <p>Pattern matching can be done with {@link PathMatcher} or with parsed\n * {@link PathPattern}. The syntax is largely the same with the latter being more\n * tailored for web usage and more efficient. The choice is driven by the\n * presence of a {@link UrlPathHelper#resolveAndCacheLookupPath resolved}\n * {@code String} lookupPath or a {@link ServletRequestPathUtils#parseAndCache\n * parsed} {@code RequestPath} which in turn depends on the\n * {@link HandlerMapping} that matched the current request.\n *\n * <p>{@code MappedInterceptor} is supported by sub-classes of\n * {@link org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n * AbstractHandlerMethodMapping} which detect beans of type\n * {@code MappedInterceptor} and also check if interceptors directly registered\n * with it are of this type.\n *\n * @author Keith Donald\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @since 3.0\n */",
    "changetype": "deprecated",
    "source_code": "public final class MappedInterceptor implements HandlerInterceptor {\n\n\tprivate static PathMatcher defaultPathMatcher = new AntPathMatcher();\n\n\n\t@Nullable\n\tprivate final PatternAdapter[] includePatterns;\n\n\t@Nullable\n\tprivate final PatternAdapter[] excludePatterns;\n\n\tprivate PathMatcher pathMatcher = defaultPathMatcher;\n\n\tprivate final HandlerInterceptor interceptor;\n\n\n\t/**\n\t * Create an instance with the given include and exclude patterns along with\n\t * the target interceptor for the mappings.\n\t * @param includePatterns patterns to which requests must match, or null to\n\t * match all paths\n\t * @param excludePatterns patterns to which requests must not match\n\t * @param interceptor the target interceptor\n\t * @param parser a parser to use to pre-parse patterns into {@link PathPattern};\n\t * when not provided, {@link PathPatternParser#defaultInstance} is used.\n\t * @since 5.3\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor, @Nullable PathPatternParser parser) {\n\n\t\tthis.includePatterns = PatternAdapter.initPatterns(includePatterns, parser);\n\t\tthis.excludePatterns = PatternAdapter.initPatterns(excludePatterns, parser);\n\t\tthis.interceptor = interceptor;\n\t}\n\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with include patterns only.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, HandlerInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * without a provided parser.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tHandlerInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, interceptor, null);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, WebRequestInterceptor interceptor) {\n\t\tthis(includePatterns, null, interceptor);\n\t}\n\n\t/**\n\t * Variant of\n\t * {@link #MappedInterceptor(String[], String[], HandlerInterceptor, PathPatternParser)}\n\t * with a {@link WebRequestInterceptor} as the target.\n\t */\n\tpublic MappedInterceptor(@Nullable String[] includePatterns, @Nullable String[] excludePatterns,\n\t\t\tWebRequestInterceptor interceptor) {\n\n\t\tthis(includePatterns, excludePatterns, new WebRequestHandlerInterceptorAdapter(interceptor));\n\t}\n\n\n\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */\n\t@Nullable\n\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PatternAdapter::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}\n\n\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */\n\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}\n\n\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * The {@link #setPathMatcher(PathMatcher) configured} PathMatcher.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */\n\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (adapter.match(path, isPathContainer, this.pathMatcher)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */\n\t@Deprecated\n\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t// HandlerInterceptor delegation\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}\n\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}\n\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}\n\n\n\t/**\n\t * Contains both the parsed {@link PathPattern} and the raw String pattern,\n\t * and uses the former when the cached path is {@link PathContainer} or the\n\t * latter otherwise. If the pattern cannot be parsed due to unsupported\n\t * syntax, then {@link PathMatcher} is used for all requests.\n\t * @since 5.3.6\n\t */\n\tprivate static class PatternAdapter {\n\n\t\tprivate final String patternString;\n\n\t\t@Nullable\n\t\tprivate final PathPattern pathPattern;\n\n\n\t\tpublic PatternAdapter(String pattern, @Nullable PathPatternParser parser) {\n\t\t\tthis.patternString = pattern;\n\t\t\tthis.pathPattern = initPathPattern(pattern, parser);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static PathPattern initPathPattern(String pattern, @Nullable PathPatternParser parser) {\n\t\t\ttry {\n\t\t\t\treturn (parser != null ? parser : PathPatternParser.defaultInstance).parse(pattern);\n\t\t\t}\n\t\t\tcatch (PatternParseException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic String getPatternString() {\n\t\t\treturn this.patternString;\n\t\t}\n\n\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}\n\n\t\t@Nullable\n\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}\n\t}\n\n}",
    "query": "Optimize the interceptor application logic to ensure it efficiently determines applicability for each incoming HTTP request, enhancing both performance and thread safety.",
    "function_signature": "public boolean shouldApplyInterceptor(HttpServletRequest request);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.AbstractHandlerMapping#getDefaultHandler()",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public Object getDefaultHandler()",
    "documentation": "\t/**\n\t * Return the default handler for this handler mapping,\n\t * or {@code null} if none.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic Object getDefaultHandler() {\n\t\treturn this.defaultHandler;\n\t}",
    "query": "Implement a fallback mechanism in your Spring MVC application that gracefully handles undefined routes by directing them to a custom error controller. Ensure that this default handler seamlessly integrates without disrupting existing handler mappings.",
    "function_signature": "public Object determineFallbackHandler(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#extractSource(ele)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "protected Object extractSource(Element ele)",
    "documentation": "\t/**\n\t * Invoke the {@link org.springframework.beans.factory.parsing.SourceExtractor}\n\t * to pull the source metadata from the supplied {@link Element}.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected Object extractSource(Element ele) {\n\t\treturn getReaderContext().extractSource(ele);\n\t}",
    "query": "Develop a component that reads XML-based bean configurations and retrieves the origin metadata of each bean definition to assist in tracing configuration issues.",
    "function_signature": "protected Object retrieveBeanDefinitionOrigin(Element beanElement)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.jdbc.core.JdbcTemplate#queryForStream(psc,pss,rowMapper)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper)",
    "documentation": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (e.g. through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,",
    "query": "Design a service method that efficiently streams user activity logs from the database for real-time processing, ensuring that resources are properly managed and the application remains responsive even with large datasets.",
    "function_signature": "public Stream<UserActivity> streamUserActivityLogs(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss, RowMapper<UserActivity> rowMapper)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.resource.ResourceHttpRequestHandler#setCorsConfiguration(corsConfiguration)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public void setCorsConfiguration(CorsConfiguration corsConfiguration)",
    "documentation": "\t/**\n\t * Specify the CORS configuration for resources served by this handler.\n\t * <p>By default this is not set in which allows cross-origin requests.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setCorsConfiguration(CorsConfiguration corsConfiguration) {\n\t\tthis.corsConfiguration = corsConfiguration;\n\t}",
    "query": "How can you enhance the security of your application's static resources by defining specific cross-origin access rules?",
    "function_signature": "public void applyResourceCorsSettings(CorsConfiguration corsConfig)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.aot.<unknown>#generateSetBeanInstanceSupplierCode(generationContext,beanRegistrationCode,instanceSupplierCode,postProcessors)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public CodeBlock generateSetBeanInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, CodeBlock instanceSupplierCode,\n\t\t\tList<MethodReference> postProcessors)",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic CodeBlock generateSetBeanInstanceSupplierCode(",
    "query": "Design a component that programmatically establishes customized suppliers for bean instances during the applications initialization, ensuring that a series of post-processing steps are integrated seamlessly into the bean registration workflow.",
    "function_signature": "public CodeBlock configureBeanInstanceSupplier(GenerationContext context, BeanRegistrationCode registration, CodeBlock supplierCode, List<MethodReference> postProcessors)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.aspectj.annotation.<unknown>#getAspectName()",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public String getAspectName()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic String getAspectName() {\n\t\treturn this.aspectName;\n\t}",
    "query": "How can you create an aspect that automatically includes its own identifier in every log entry it generates for service layer methods?",
    "function_signature": "public void includeAspectIdentifierInLogs(ProceedingJoinPoint joinPoint) throws Throwable"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding(allowBeanDefinitionOverriding)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding)",
    "documentation": "\t/**\n\t * Set whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * If not, an exception will be thrown. This also applies to overriding aliases.\n\t * <p>Default is \"true\".\n\t * @see #registerBeanDefinition\n\t */",
    "changetype": "stabilized",
    "source_code": "\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n\t\tthis.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;\n\t}",
    "query": "Implement a configuration that ensures your Spring application context throws an exception upon detecting any attempts to redefine existing bean definitions, thereby preventing accidental bean overrides during application startup.",
    "function_signature": "public void configureBeanDefinitionOverriding(boolean allowOverriding)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.service.invoker.AbstractNamedValueArgumentResolver#createNamedValueInfo(parameter)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter)",
    "documentation": "\t/**\n\t * Return information about the request value, or {@code null} if the\n\t * parameter does not represent a request value of interest.\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);",
    "query": "Design a mechanism within your Spring application that intelligently interprets and binds custom annotations on controller method parameters, ensuring each annotated parameter is processed with specific metadata extracted at runtime.",
    "function_signature": "protected NamedValueInfo resolveCustomAnnotationInfo(MethodParameter parameter)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.aop.aspectj.AspectJExpressionPointcut#isRuntime()",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "public boolean isRuntime()",
    "documentation": null,
    "changetype": "stabilized",
    "source_code": "\tpublic boolean isRuntime() {\n\t\treturn obtainPointcutExpression().mayNeedDynamicTest();\n\t}",
    "query": "Design a service method that evaluates whether aspect-oriented pointcut expressions necessitate dynamic runtime checks for enhanced flexibility in application behavior.",
    "function_signature": "public boolean requiresDynamicPointcutEvaluation(String pointcutExpression)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.mail.javamail.MimeMessageHelper#validateAddresses(addresses)",
    "from_version": "v5.3.23",
    "to_version": "v6.0.0-RC1",
    "type": "method",
    "signature": "protected void validateAddresses(InternetAddress[] addresses)",
    "documentation": "\t/**\n\t * Validate all given mail addresses.\n\t * <p>The default implementation simply delegates to {@link #validateAddress}\n\t * for each address.\n\t * @param addresses the addresses to validate\n\t * @throws AddressException if validation failed\n\t * @see #validateAddress(InternetAddress)\n\t */",
    "changetype": "stabilized",
    "source_code": "\tprotected void validateAddresses(InternetAddress[] addresses) throws AddressException {\n\t\tfor (InternetAddress address : addresses) {\n\t\t\tvalidateAddress(address);\n\t\t}\n\t}",
    "query": "Design a method within your email dispatch service that efficiently verifies multiple recipient email addresses to ensure they adhere to standard formatting before sending out the email.",
    "function_signature": "protected void verifyEmailRecipients(InternetAddress[] recipients) throws AddressException"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#setPathMatcher(pathMatcher)",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "method",
    "signature": "public void setPathMatcher(PathMatcher pathMatcher)",
    "documentation": "\t/**\n\t * Configure the PathMatcher to use to match URL paths with against include\n\t * and exclude patterns.\n\t * <p>This is an advanced property that should be used only when a\n\t * customized {@link AntPathMatcher} or a custom PathMatcher is required.\n\t * <p>By default this is {@link AntPathMatcher}.\n\t * <p><strong>Note:</strong> Setting {@code PathMatcher} enforces use of\n\t * String pattern matching even when a\n\t * {@link ServletRequestPathUtils#parseAndCache parsed} {@code RequestPath}\n\t * is available.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tthis.pathMatcher = pathMatcher;\n\t}",
    "query": "Enhance your request handling by configuring a component to utilize Spring's modern path pattern parsing for more efficient and reliable URL matching.",
    "function_signature": "public void setPathPatternParser(PathPatternParser parser)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.sessions",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "field",
    "signature": "public int sessions",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic int sessions;",
    "query": "Design a method to retrieve the current number of active messaging sessions in a thread-safe and efficient manner, enhancing maintainability and performance.",
    "function_signature": "public int getActiveSessionCount()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.destinationIds",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "field",
    "signature": "public String[] destinationIds",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String[] destinationIds;",
    "query": "Design a method that retrieves the active destination identifiers managed by the messaging broker, ensuring thread safety and enhanced performance over previous implementations.",
    "function_signature": "public List<String> fetchActiveDestinationIds()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#matches(request)",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "method",
    "signature": "public boolean matches(HttpServletRequest request)",
    "documentation": "\t/**\n\t * Check whether this interceptor is mapped to the request.\n\t * <p>The request mapping path is expected to have been resolved externally.\n\t * See also class-level Javadoc.\n\t * @param request the request to match to\n\t * @return {@code true} if the interceptor should be applied to the request\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic boolean matches(HttpServletRequest request) {\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\t\tboolean isPathContainer = (path instanceof PathContainer);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PathPattern pattern : this.excludePatterns) {\n\t\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PathPattern pattern : this.includePatterns) {\n\t\t\tif (matchPattern(path, isPathContainer, pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "query": "Enhance the interceptor configuration to evaluate incoming HTTP requests for applicability, ensuring improved performance and more precise path handling.",
    "function_signature": "public boolean isInterceptorApplicable(HttpServletRequest request)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.Requests",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "class",
    "signature": "public class Requests",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic static class Requests {\n\t\t@Param({\"none\", \"sameDestination\", \"sameSession\"})\n\t\tString contention;\n\n\t\tpublic String session;\n\n\t\tpublic Message<?> subscribe;\n\n\t\tpublic String findDestination;\n\n\t\tpublic Message<?> unsubscribe;\n\n\t\t@Setup(Level.Trial)\n\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.incrementAndGet();\n\n\t\t\tif (\"sameDestination\".equals(this.contention)) {\n\t\t\t\tthis.findDestination = serverState.destinationIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.findDestination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t}\n\n\t\t\tif (\"sameSession\".equals(this.contention)) {\n\t\t\t\tthis.session = serverState.sessionIds[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.session = serverState.sessionIds[uniqueNumber % serverState.sessionIds.length];\n\t\t\t}\n\n\t\t\tString subscription = String.valueOf(uniqueNumber);\n\t\t\tString subscribeDestination = \"patternSubscriptions\".equals(serverState.specialization) ?\n\t\t\t\t\t\"/**/\" + this.findDestination : this.findDestination;\n\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, subscribeDestination);\n\n\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n\t\t}\n\t}",
    "query": "Implement a subscription management feature that enhances performance and ensures thread-safe handling of client destinations in a messaging broker.",
    "function_signature": "public void manageClientSubscriptions(String sessionId, String destination);"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryBenchmark#doSetup(serverState)",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "method",
    "signature": "public void doSetup(ServerState serverState)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic void doSetup(ServerState serverState) {\n\t\t\tswitch (this.contention) {\n\t\t\t\tcase \"noSubscribers\":\n\t\t\t\t\tthis.destination = \"someDestination_withNoSubscribers_\" + serverState.uniqueIdGenerator.incrementAndGet();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sameDestination\":\n\t\t\t\t\tthis.destination = serverState.destinationIds[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"none\":\n\t\t\t\t\tint uniqueNumber = serverState.uniqueIdGenerator.getAndIncrement();\n\t\t\t\t\tthis.destination = serverState.destinationIds[uniqueNumber % serverState.destinationIds.length];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}",
    "query": "Design a method to configure the subscription registry that enhances thread safety and scalability when handling diverse server states, ensuring efficient destination management without the complexities of the previous implementation.",
    "function_signature": "public void configureSubscriptionRegistry(EnhancedServerState serverState)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#postHandle(request,response,handler,modelAndView)",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "method",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,",
    "query": "Design a component to process HTTP responses after the main handler execution, ensuring improved performance and thread safety by utilizing the framework's latest interception mechanisms.",
    "function_signature": "public void handleAfterExecution(HttpServletRequest request, HttpServletResponse response, Object handler)"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.messaging.simp.broker.session",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "field",
    "signature": "public String session",
    "documentation": null,
    "changetype": "deprecated",
    "source_code": "\t\tpublic String session;",
    "query": "Create a utility method that efficiently retrieves the current messaging session identifier, ensuring optimal performance and thread safety.",
    "function_signature": "public String fetchCurrentMessagingSessionId()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getPathPatterns()",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "method",
    "signature": "public String[] getPathPatterns()",
    "documentation": "\t/**\n\t * Return the patterns this interceptor is mapped to.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic String[] getPathPatterns() {\n\t\treturn (!ObjectUtils.isEmpty(this.includePatterns) ?\n\t\t\t\tArrays.stream(this.includePatterns).map(PathPattern::getPatternString).toArray(String[]::new) :\n\t\t\t\tnull);\n\t}",
    "query": "Enhance the interceptor configuration by retrieving its mapped path patterns using a type-safe and efficient approach provided by the latest framework utilities.",
    "function_signature": "public PathPattern[] retrieveMappedPathPatterns()"
  },
  {
    "library": "spring-framework",
    "name": "org.springframework.web.servlet.handler.MappedInterceptor#getInterceptor()",
    "from_version": "v5.3.2",
    "to_version": "v5.2.12.RELEASE",
    "type": "method",
    "signature": "public HandlerInterceptor getInterceptor()",
    "documentation": "\t/**\n\t * The target {@link HandlerInterceptor} to invoke in case of a match.\n\t */",
    "changetype": "deprecated",
    "source_code": "\tpublic HandlerInterceptor getInterceptor() {\n\t\treturn this.interceptor;\n\t}",
    "query": "Improve the efficiency of your web application's request handling by implementing a method that retrieves the active interceptor, ensuring better performance and easier maintenance.",
    "function_signature": "public HandlerInterceptor fetchActiveInterceptor()"
  }
]